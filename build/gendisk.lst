ARM GAS  /tmp/ccN45wj6.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"gendisk.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./block/gendisk.c"
  20              		.section	.rodata.__gendisk_alloc.str1.4,"aMS",%progbits,1
  21              		.align	2
  22              	.LC0:
  23 0000 73642563 		.ascii	"sd%c\000"
  23      00
  24              		.section	.text.__gendisk_alloc,"ax",%progbits
  25              		.align	1
  26              		.global	__gendisk_alloc
  27              		.syntax unified
  28              		.thumb
  29              		.thumb_func
  31              	__gendisk_alloc:
  32              	.LVL0:
  33              	.LFB960:
   1:./block/gendisk.c **** #include <linux/blkdev.h>
   2:./block/gendisk.c **** #include <linux/mutex.h>
   3:./block/gendisk.c **** #include <linux/slab.h>
   4:./block/gendisk.c **** #include <linux/errno.h>
   5:./block/gendisk.c **** #include <linux/sprintf.h>
   6:./block/gendisk.c **** 
   7:./block/gendisk.c **** static char number = 'a';
   8:./block/gendisk.c **** static uint8_t blk_dev_major = 254;
   9:./block/gendisk.c **** struct gendisk *__gendisk_alloc(int major,int minors)
  10:./block/gendisk.c **** {
  34              		.loc 1 10 1 view -0
  35              		.cfi_startproc
  36              		@ args = 0, pretend = 0, frame = 0
  37              		@ frame_needed = 0, uses_anonymous_args = 0
  38              		.loc 1 10 1 is_stmt 0 view .LVU1
  39 0000 70B5     		push	{r4, r5, r6, lr}
  40              	.LCFI0:
  41              		.cfi_def_cfa_offset 16
  42              		.cfi_offset 4, -16
  43              		.cfi_offset 5, -12
  44              		.cfi_offset 6, -8
  45              		.cfi_offset 14, -4
  46 0002 0546     		mov	r5, r0
  47 0004 0E46     		mov	r6, r1
ARM GAS  /tmp/ccN45wj6.s 			page 2


  11:./block/gendisk.c ****     struct gendisk *disk;
  48              		.loc 1 11 5 is_stmt 1 view .LVU2
  12:./block/gendisk.c ****     disk = kmalloc(sizeof(struct gendisk), GFP_KERNEL);
  49              		.loc 1 12 5 view .LVU3
  50              	.LVL1:
  51              	.LBB8:
  52              	.LBI8:
  53              		.file 2 "./include/linux/slab.h"
   1:./include/linux/slab.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/slab.h **** /*
   3:./include/linux/slab.h ****  * Written by Mark Hemment, 1996 (markhe@nextd.demon.co.uk).
   4:./include/linux/slab.h ****  *
   5:./include/linux/slab.h ****  * (C) SGI 2006, Christoph Lameter
   6:./include/linux/slab.h ****  * 	Cleaned up and restructured to ease the addition of alternative
   7:./include/linux/slab.h ****  * 	implementations of SLAB allocators.
   8:./include/linux/slab.h ****  * (C) Linux Foundation 2008-2013
   9:./include/linux/slab.h ****  *      Unified interface for all slab allocators
  10:./include/linux/slab.h ****  */
  11:./include/linux/slab.h **** 
  12:./include/linux/slab.h **** #ifndef _LINUX_SLAB_H
  13:./include/linux/slab.h **** #define	_LINUX_SLAB_H
  14:./include/linux/slab.h **** 
  15:./include/linux/slab.h **** #include <linux/cache.h>
  16:./include/linux/slab.h **** #include <linux/overflow.h>
  17:./include/linux/slab.h **** #include <linux/types.h>
  18:./include/linux/slab.h **** #include <linux/raid/pq.h>
  19:./include/linux/slab.h **** #include <linux/gfp_types.h>
  20:./include/linux/slab.h **** #include <linux/numa.h>
  21:./include/linux/slab.h **** #include <linux/reciprocal_div.h>
  22:./include/linux/slab.h **** #include <linux/spinlock.h>
  23:./include/linux/slab.h **** 
  24:./include/linux/slab.h **** enum _slab_flag_bits {
  25:./include/linux/slab.h **** 	_SLAB_CONSISTENCY_CHECKS,
  26:./include/linux/slab.h **** 	_SLAB_RED_ZONE,
  27:./include/linux/slab.h **** 	_SLAB_POISON,
  28:./include/linux/slab.h **** 	_SLAB_KMALLOC,
  29:./include/linux/slab.h **** 	_SLAB_HWCACHE_ALIGN,
  30:./include/linux/slab.h **** 	_SLAB_CACHE_DMA,
  31:./include/linux/slab.h **** 	_SLAB_CACHE_DMA32,
  32:./include/linux/slab.h **** 	_SLAB_STORE_USER,
  33:./include/linux/slab.h **** 	_SLAB_PANIC,
  34:./include/linux/slab.h **** 	_SLAB_TYPESAFE_BY_RCU,
  35:./include/linux/slab.h **** 	_SLAB_TRACE,
  36:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
  37:./include/linux/slab.h **** 	_SLAB_DEBUG_OBJECTS,
  38:./include/linux/slab.h **** #endif
  39:./include/linux/slab.h **** 	_SLAB_NOLEAKTRACE,
  40:./include/linux/slab.h **** 	_SLAB_NO_MERGE,
  41:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
  42:./include/linux/slab.h **** 	_SLAB_FAILSLAB,
  43:./include/linux/slab.h **** #endif
  44:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
  45:./include/linux/slab.h **** 	_SLAB_ACCOUNT,
  46:./include/linux/slab.h **** #endif
  47:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
  48:./include/linux/slab.h **** 	_SLAB_KASAN,
  49:./include/linux/slab.h **** #endif
ARM GAS  /tmp/ccN45wj6.s 			page 3


  50:./include/linux/slab.h **** 	_SLAB_NO_USER_FLAGS,
  51:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
  52:./include/linux/slab.h **** 	_SLAB_SKIP_KFENCE,
  53:./include/linux/slab.h **** #endif
  54:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
  55:./include/linux/slab.h **** 	_SLAB_RECLAIM_ACCOUNT,
  56:./include/linux/slab.h **** #endif
  57:./include/linux/slab.h **** 	_SLAB_OBJECT_POISON,
  58:./include/linux/slab.h **** 	_SLAB_CMPXCHG_DOUBLE,
  59:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
  60:./include/linux/slab.h **** 	_SLAB_NO_OBJ_EXT,
  61:./include/linux/slab.h **** #endif
  62:./include/linux/slab.h **** 	_SLAB_FLAGS_LAST_BIT
  63:./include/linux/slab.h **** };
  64:./include/linux/slab.h **** 
  65:./include/linux/slab.h **** 
  66:./include/linux/slab.h **** 
  67:./include/linux/slab.h **** #define __SLAB_FLAG_BIT(nr)	((slab_flags_t __force)(1U << (nr)))
  68:./include/linux/slab.h **** #define __SLAB_FLAG_UNUSED	((slab_flags_t __force)(0U))
  69:./include/linux/slab.h **** 
  70:./include/linux/slab.h **** /*
  71:./include/linux/slab.h ****  * Flags to pass to kmem_cache_create().
  72:./include/linux/slab.h ****  * The ones marked DEBUG need CONFIG_SLUB_DEBUG enabled, otherwise are no-op
  73:./include/linux/slab.h ****  */
  74:./include/linux/slab.h **** /* DEBUG: Perform (expensive) checks on alloc/free */
  75:./include/linux/slab.h **** #define SLAB_CONSISTENCY_CHECKS	__SLAB_FLAG_BIT(_SLAB_CONSISTENCY_CHECKS)
  76:./include/linux/slab.h **** /* DEBUG: Red zone objs in a cache */
  77:./include/linux/slab.h **** #define SLAB_RED_ZONE		__SLAB_FLAG_BIT(_SLAB_RED_ZONE)
  78:./include/linux/slab.h **** /* DEBUG: Poison objects */
  79:./include/linux/slab.h **** #define SLAB_POISON		__SLAB_FLAG_BIT(_SLAB_POISON)
  80:./include/linux/slab.h **** /* Indicate a kmalloc slab */
  81:./include/linux/slab.h **** #define SLAB_KMALLOC		__SLAB_FLAG_BIT(_SLAB_KMALLOC)
  82:./include/linux/slab.h **** /**
  83:./include/linux/slab.h ****  * define SLAB_HWCACHE_ALIGN - Align objects on cache line boundaries.
  84:./include/linux/slab.h ****  *
  85:./include/linux/slab.h ****  * Sufficiently large objects are aligned on cache line boundary. For object
  86:./include/linux/slab.h ****  * size smaller than a half of cache line size, the alignment is on the half of
  87:./include/linux/slab.h ****  * cache line size. In general, if object size is smaller than 1/2^n of cache
  88:./include/linux/slab.h ****  * line size, the alignment is adjusted to 1/2^n.
  89:./include/linux/slab.h ****  *
  90:./include/linux/slab.h ****  * If explicit alignment is also requested by the respective
  91:./include/linux/slab.h ****  * &struct kmem_cache_args field, the greater of both is alignments is applied.
  92:./include/linux/slab.h ****  */
  93:./include/linux/slab.h **** #define SLAB_HWCACHE_ALIGN	__SLAB_FLAG_BIT(_SLAB_HWCACHE_ALIGN)
  94:./include/linux/slab.h **** /* Use GFP_DMA memory */
  95:./include/linux/slab.h **** #define SLAB_CACHE_DMA		__SLAB_FLAG_BIT(_SLAB_CACHE_DMA)
  96:./include/linux/slab.h **** /* Use GFP_DMA32 memory */
  97:./include/linux/slab.h **** #define SLAB_CACHE_DMA32	__SLAB_FLAG_BIT(_SLAB_CACHE_DMA32)
  98:./include/linux/slab.h **** /* DEBUG: Store the last owner for bug hunting */
  99:./include/linux/slab.h **** #define SLAB_STORE_USER		__SLAB_FLAG_BIT(_SLAB_STORE_USER)
 100:./include/linux/slab.h **** /* Panic if kmem_cache_create() fails */
 101:./include/linux/slab.h **** #define SLAB_PANIC		__SLAB_FLAG_BIT(_SLAB_PANIC)
 102:./include/linux/slab.h **** /**
 103:./include/linux/slab.h ****  * define SLAB_TYPESAFE_BY_RCU - **WARNING** READ THIS!
 104:./include/linux/slab.h ****  *
 105:./include/linux/slab.h ****  * This delays freeing the SLAB page by a grace period, it does _NOT_
 106:./include/linux/slab.h ****  * delay object freeing. This means that if you do kmem_cache_free()
ARM GAS  /tmp/ccN45wj6.s 			page 4


 107:./include/linux/slab.h ****  * that memory location is free to be reused at any time. Thus it may
 108:./include/linux/slab.h ****  * be possible to see another object there in the same RCU grace period.
 109:./include/linux/slab.h ****  *
 110:./include/linux/slab.h ****  * This feature only ensures the memory location backing the object
 111:./include/linux/slab.h ****  * stays valid, the trick to using this is relying on an independent
 112:./include/linux/slab.h ****  * object validation pass. Something like:
 113:./include/linux/slab.h ****  *
 114:./include/linux/slab.h ****  * ::
 115:./include/linux/slab.h ****  *
 116:./include/linux/slab.h ****  *  begin:
 117:./include/linux/slab.h ****  *   rcu_read_lock();
 118:./include/linux/slab.h ****  *   obj = lockless_lookup(key);
 119:./include/linux/slab.h ****  *   if (obj) {
 120:./include/linux/slab.h ****  *     if (!try_get_ref(obj)) // might fail for free objects
 121:./include/linux/slab.h ****  *       rcu_read_unlock();
 122:./include/linux/slab.h ****  *       goto begin;
 123:./include/linux/slab.h ****  *
 124:./include/linux/slab.h ****  *     if (obj->key != key) { // not the object we expected
 125:./include/linux/slab.h ****  *       put_ref(obj);
 126:./include/linux/slab.h ****  *       rcu_read_unlock();
 127:./include/linux/slab.h ****  *       goto begin;
 128:./include/linux/slab.h ****  *     }
 129:./include/linux/slab.h ****  *   }
 130:./include/linux/slab.h ****  *  rcu_read_unlock();
 131:./include/linux/slab.h ****  *
 132:./include/linux/slab.h ****  * This is useful if we need to approach a kernel structure obliquely,
 133:./include/linux/slab.h ****  * from its address obtained without the usual locking. We can lock
 134:./include/linux/slab.h ****  * the structure to stabilize it and check it's still at the given address,
 135:./include/linux/slab.h ****  * only if we can be sure that the memory has not been meanwhile reused
 136:./include/linux/slab.h ****  * for some other kind of object (which our subsystem's lock might corrupt).
 137:./include/linux/slab.h ****  *
 138:./include/linux/slab.h ****  * rcu_read_lock before reading the address, then rcu_read_unlock after
 139:./include/linux/slab.h ****  * taking the spinlock within the structure expected at that address.
 140:./include/linux/slab.h ****  *
 141:./include/linux/slab.h ****  * Note that it is not possible to acquire a lock within a structure
 142:./include/linux/slab.h ****  * allocated with SLAB_TYPESAFE_BY_RCU without first acquiring a reference
 143:./include/linux/slab.h ****  * as described above.  The reason is that SLAB_TYPESAFE_BY_RCU pages
 144:./include/linux/slab.h ****  * are not zeroed before being given to the slab, which means that any
 145:./include/linux/slab.h ****  * locks must be initialized after each and every kmem_struct_alloc().
 146:./include/linux/slab.h ****  * Alternatively, make the ctor passed to kmem_cache_create() initialize
 147:./include/linux/slab.h ****  * the locks at page-allocation time, as is done in __i915_request_ctor(),
 148:./include/linux/slab.h ****  * sighand_ctor(), and anon_vma_ctor().  Such a ctor permits readers
 149:./include/linux/slab.h ****  * to safely acquire those ctor-initialized locks under rcu_read_lock()
 150:./include/linux/slab.h ****  * protection.
 151:./include/linux/slab.h ****  *
 152:./include/linux/slab.h ****  * Note that SLAB_TYPESAFE_BY_RCU was originally named SLAB_DESTROY_BY_RCU.
 153:./include/linux/slab.h ****  */
 154:./include/linux/slab.h **** #define SLAB_TYPESAFE_BY_RCU	__SLAB_FLAG_BIT(_SLAB_TYPESAFE_BY_RCU)
 155:./include/linux/slab.h **** /* Trace allocations and frees */
 156:./include/linux/slab.h **** #define SLAB_TRACE		__SLAB_FLAG_BIT(_SLAB_TRACE)
 157:./include/linux/slab.h **** 
 158:./include/linux/slab.h **** /* Flag to prevent checks on free */
 159:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
 160:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_BIT(_SLAB_DEBUG_OBJECTS)
 161:./include/linux/slab.h **** #else
 162:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_UNUSED
 163:./include/linux/slab.h **** #endif
ARM GAS  /tmp/ccN45wj6.s 			page 5


 164:./include/linux/slab.h **** 
 165:./include/linux/slab.h **** /* Avoid kmemleak tracing */
 166:./include/linux/slab.h **** #define SLAB_NOLEAKTRACE	__SLAB_FLAG_BIT(_SLAB_NOLEAKTRACE)
 167:./include/linux/slab.h **** 
 168:./include/linux/slab.h **** /*
 169:./include/linux/slab.h ****  * Prevent merging with compatible kmem caches. This flag should be used
 170:./include/linux/slab.h ****  * cautiously. Valid use cases:
 171:./include/linux/slab.h ****  *
 172:./include/linux/slab.h ****  * - caches created for self-tests (e.g. kunit)
 173:./include/linux/slab.h ****  * - general caches created and used by a subsystem, only when a
 174:./include/linux/slab.h ****  *   (subsystem-specific) debug option is enabled
 175:./include/linux/slab.h ****  * - performance critical caches, should be very rare and consulted with slab
 176:./include/linux/slab.h ****  *   maintainers, and not used together with CONFIG_SLUB_TINY
 177:./include/linux/slab.h ****  */
 178:./include/linux/slab.h **** #define SLAB_NO_MERGE		__SLAB_FLAG_BIT(_SLAB_NO_MERGE)
 179:./include/linux/slab.h **** 
 180:./include/linux/slab.h **** /* Fault injection mark */
 181:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
 182:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_BIT(_SLAB_FAILSLAB)
 183:./include/linux/slab.h **** #else
 184:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_UNUSED
 185:./include/linux/slab.h **** #endif
 186:./include/linux/slab.h **** /**
 187:./include/linux/slab.h ****  * define SLAB_ACCOUNT - Account allocations to memcg.
 188:./include/linux/slab.h ****  *
 189:./include/linux/slab.h ****  * All object allocations from this cache will be memcg accounted, regardless of
 190:./include/linux/slab.h ****  * __GFP_ACCOUNT being or not being passed to individual allocations.
 191:./include/linux/slab.h ****  */
 192:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
 193:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_BIT(_SLAB_ACCOUNT)
 194:./include/linux/slab.h **** #else
 195:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_UNUSED
 196:./include/linux/slab.h **** #endif
 197:./include/linux/slab.h **** 
 198:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
 199:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_BIT(_SLAB_KASAN)
 200:./include/linux/slab.h **** #else
 201:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_UNUSED
 202:./include/linux/slab.h **** #endif
 203:./include/linux/slab.h **** 
 204:./include/linux/slab.h **** /*
 205:./include/linux/slab.h ****  * Ignore user specified debugging flags.
 206:./include/linux/slab.h ****  * Intended for caches created for self-tests so they have only flags
 207:./include/linux/slab.h ****  * specified in the code and other flags are ignored.
 208:./include/linux/slab.h ****  */
 209:./include/linux/slab.h **** #define SLAB_NO_USER_FLAGS	__SLAB_FLAG_BIT(_SLAB_NO_USER_FLAGS)
 210:./include/linux/slab.h **** 
 211:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
 212:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_BIT(_SLAB_SKIP_KFENCE)
 213:./include/linux/slab.h **** #else
 214:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_UNUSED
 215:./include/linux/slab.h **** #endif
 216:./include/linux/slab.h **** 
 217:./include/linux/slab.h **** /* The following flags affect the page allocator grouping pages by mobility */
 218:./include/linux/slab.h **** /**
 219:./include/linux/slab.h ****  * define SLAB_RECLAIM_ACCOUNT - Objects are reclaimable.
 220:./include/linux/slab.h ****  *
ARM GAS  /tmp/ccN45wj6.s 			page 6


 221:./include/linux/slab.h ****  * Use this flag for caches that have an associated shrinker. As a result, slab
 222:./include/linux/slab.h ****  * pages are allocated with __GFP_RECLAIMABLE, which affects grouping pages by
 223:./include/linux/slab.h ****  * mobility, and are accounted in SReclaimable counter in /proc/meminfo
 224:./include/linux/slab.h ****  */
 225:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
 226:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_BIT(_SLAB_RECLAIM_ACCOUNT)
 227:./include/linux/slab.h **** #else
 228:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_UNUSED
 229:./include/linux/slab.h **** #endif
 230:./include/linux/slab.h **** #define SLAB_TEMPORARY		SLAB_RECLAIM_ACCOUNT	/* Objects are short-lived */
 231:./include/linux/slab.h **** 
 232:./include/linux/slab.h **** /* Slab created using create_boot_cache */
 233:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
 234:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_BIT(_SLAB_NO_OBJ_EXT)
 235:./include/linux/slab.h **** #else
 236:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_UNUSED
 237:./include/linux/slab.h **** #endif
 238:./include/linux/slab.h **** 
 239:./include/linux/slab.h **** /*
 240:./include/linux/slab.h ****  * freeptr_t represents a SLUB freelist pointer, which might be encoded
 241:./include/linux/slab.h ****  * and not dereferenceable if CONFIG_SLAB_FREELIST_HARDENED is enabled.
 242:./include/linux/slab.h ****  */
 243:./include/linux/slab.h **** typedef struct { unsigned long v; } freeptr_t;
 244:./include/linux/slab.h **** 
 245:./include/linux/slab.h **** /*
 246:./include/linux/slab.h ****  * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.
 247:./include/linux/slab.h ****  *
 248:./include/linux/slab.h ****  * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault.
 249:./include/linux/slab.h ****  *
 250:./include/linux/slab.h ****  * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.
 251:./include/linux/slab.h ****  * Both make kfree a no-op.
 252:./include/linux/slab.h ****  */
 253:./include/linux/slab.h **** #define ZERO_SIZE_PTR ((void *)16)
 254:./include/linux/slab.h **** 
 255:./include/linux/slab.h **** #define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) <= \
 256:./include/linux/slab.h **** 				(unsigned long)ZERO_SIZE_PTR)
 257:./include/linux/slab.h **** 
 258:./include/linux/slab.h **** 
 259:./include/linux/slab.h **** 
 260:./include/linux/slab.h **** 
 261:./include/linux/slab.h **** 
 262:./include/linux/slab.h **** #ifdef CONFIG_SLUB_CPU_PARTIAL
 263:./include/linux/slab.h **** #define slub_percpu_partial(c)			((c)->partial)
 264:./include/linux/slab.h **** 
 265:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)		\
 266:./include/linux/slab.h **** ({						\
 267:./include/linux/slab.h **** 	slub_percpu_partial(c) = (p)->next;	\
 268:./include/linux/slab.h **** })
 269:./include/linux/slab.h **** 
 270:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	READ_ONCE(slub_percpu_partial(c))
 271:./include/linux/slab.h **** #else
 272:./include/linux/slab.h **** #define slub_percpu_partial(c)			NULL
 273:./include/linux/slab.h **** 
 274:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)
 275:./include/linux/slab.h **** 
 276:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	NULL
 277:./include/linux/slab.h **** 
ARM GAS  /tmp/ccN45wj6.s 			page 7


 278:./include/linux/slab.h **** 
 279:./include/linux/slab.h **** #endif // CONFIG_SLUB_CPU_PARTIAL
 280:./include/linux/slab.h **** 
 281:./include/linux/slab.h **** /*
 282:./include/linux/slab.h **** 	* Word size structure that can be atomically updated or read and that
 283:./include/linux/slab.h **** 	* contains both the order and the number of objects that a slab of the
 284:./include/linux/slab.h **** 	* given order would contain.
 285:./include/linux/slab.h **** 	*/				
 286:./include/linux/slab.h **** struct kmem_cache_order_objects {
 287:./include/linux/slab.h **** 	unsigned int x;
 288:./include/linux/slab.h **** };
 289:./include/linux/slab.h **** 
 290:./include/linux/slab.h **** struct kmem_cache_node {
 291:./include/linux/slab.h **** 	spinlock_t list_lock;
 292:./include/linux/slab.h **** 	unsigned long nr_partial;
 293:./include/linux/slab.h **** 	struct list_head partial;
 294:./include/linux/slab.h **** #ifdef CONFIG_SLUB_DEBUG
 295:./include/linux/slab.h **** 	atomic_long_t nr_slabs;
 296:./include/linux/slab.h **** 	atomic_long_t total_objects;
 297:./include/linux/slab.h **** 	struct list_head full;
 298:./include/linux/slab.h **** #endif
 299:./include/linux/slab.h **** };
 300:./include/linux/slab.h **** 
 301:./include/linux/slab.h **** struct kmem_cache {
 302:./include/linux/slab.h **** 	#ifndef CONFIG_SLUB_TINY
 303:./include/linux/slab.h **** 	//	struct kmem_cache_cpu __percpu *cpu_slab;
 304:./include/linux/slab.h **** 	#endif
 305:./include/linux/slab.h **** 		/* Used for retrieving partial slabs, etc. */
 306:./include/linux/slab.h **** 		slab_flags_t flags;
 307:./include/linux/slab.h **** 		unsigned long min_partial;
 308:./include/linux/slab.h **** 		unsigned int size;		/* Object size including metadata */
 309:./include/linux/slab.h **** 		unsigned int object_size;	/* Object size without metadata */
 310:./include/linux/slab.h **** 		struct reciprocal_value reciprocal_size;
 311:./include/linux/slab.h **** 		unsigned int offset;		/* Free pointer offset */
 312:./include/linux/slab.h **** 	#ifdef CONFIG_SLUB_CPU_PARTIAL
 313:./include/linux/slab.h **** 		/* Number of per cpu partial objects to keep around */
 314:./include/linux/slab.h **** 		unsigned int cpu_partial;
 315:./include/linux/slab.h **** 		/* Number of per cpu partial slabs to keep around */
 316:./include/linux/slab.h **** 		unsigned int cpu_partial_slabs;
 317:./include/linux/slab.h **** 	#endif
 318:./include/linux/slab.h **** 		struct kmem_cache_order_objects oo;
 319:./include/linux/slab.h **** 	
 320:./include/linux/slab.h **** 		/* Allocation and freeing of slabs */
 321:./include/linux/slab.h **** 		struct kmem_cache_order_objects min;
 322:./include/linux/slab.h **** 		gfp_t allocflags;		/* gfp flags to use on each alloc */
 323:./include/linux/slab.h **** 		int refcount;			/* Refcount for slab cache destroy */
 324:./include/linux/slab.h **** 		void (*ctor)(void *object);	/* Object constructor */
 325:./include/linux/slab.h **** 		unsigned int inuse;		/* Offset to metadata */
 326:./include/linux/slab.h **** 		unsigned int align;		/* Alignment */
 327:./include/linux/slab.h **** 		unsigned int red_left_pad;	/* Left redzone padding size */
 328:./include/linux/slab.h **** 		const char *name;		/* Name (only for display!) */
 329:./include/linux/slab.h **** 		struct list_head list;		/* List of slab caches */
 330:./include/linux/slab.h **** 	#ifdef CONFIG_SYSFS
 331:./include/linux/slab.h **** 		struct kobject kobj;		/* For sysfs */
 332:./include/linux/slab.h **** 	#endif
 333:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_HARDENED
 334:./include/linux/slab.h **** 		unsigned long random;
ARM GAS  /tmp/ccN45wj6.s 			page 8


 335:./include/linux/slab.h **** 	#endif
 336:./include/linux/slab.h **** 	
 337:./include/linux/slab.h **** 	#ifdef CONFIG_NUMA
 338:./include/linux/slab.h **** 		/*
 339:./include/linux/slab.h **** 			* Defragmentation by allocating from a remote node.
 340:./include/linux/slab.h **** 			*/
 341:./include/linux/slab.h **** 		unsigned int remote_node_defrag_ratio;
 342:./include/linux/slab.h **** 	#endif
 343:./include/linux/slab.h **** 	
 344:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_RANDOM
 345:./include/linux/slab.h **** 		unsigned int *random_seq;
 346:./include/linux/slab.h **** 	#endif
 347:./include/linux/slab.h **** 	
 348:./include/linux/slab.h **** 	#ifdef CONFIG_KASAN_GENERIC
 349:./include/linux/slab.h **** 		struct kasan_cache kasan_info;
 350:./include/linux/slab.h **** 	#endif
 351:./include/linux/slab.h **** 	
 352:./include/linux/slab.h **** 	#ifdef CONFIG_HARDENED_USERCOPY
 353:./include/linux/slab.h **** 		unsigned int useroffset;	/* Usercopy region offset */
 354:./include/linux/slab.h **** 		unsigned int usersize;		/* Usercopy region size */
 355:./include/linux/slab.h **** 	#endif
 356:./include/linux/slab.h **** 	
 357:./include/linux/slab.h **** 		struct kmem_cache_node *node[MAX_NUMNODES];
 358:./include/linux/slab.h **** 	};
 359:./include/linux/slab.h **** 					
 360:./include/linux/slab.h **** 
 361:./include/linux/slab.h **** 
 362:./include/linux/slab.h **** 
 363:./include/linux/slab.h **** 
 364:./include/linux/slab.h **** #define KMALLOC_WAIT 1
 365:./include/linux/slab.h **** 
 366:./include/linux/slab.h **** 
 367:./include/linux/slab.h **** extern void* __smalloc__(u32 size, gfp_t flags);
 368:./include/linux/slab.h **** extern void  __sfree__(void* addr);
 369:./include/linux/slab.h **** 
 370:./include/linux/slab.h **** 
 371:./include/linux/slab.h **** static void inline *vmalloc(unsigned long size){
 372:./include/linux/slab.h **** 	return __smalloc__(size,GFP_TRANSHUGE_LIGHT);
 373:./include/linux/slab.h **** }
 374:./include/linux/slab.h **** 
 375:./include/linux/slab.h **** static void inline vfree(void *addr){
 376:./include/linux/slab.h **** 	__sfree__(addr);
 377:./include/linux/slab.h **** }
 378:./include/linux/slab.h **** 
 379:./include/linux/slab.h **** static void inline *kmalloc(size_t size, gfp_t flags){
  54              		.loc 2 379 21 view .LVU4
  55              	.LBB9:
 380:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
  56              		.loc 2 380 2 view .LVU5
  57              		.loc 2 380 9 is_stmt 0 view .LVU6
  58 0006 4FF44C61 		mov	r1, #3264
  59              	.LVL2:
  60              		.loc 2 380 9 view .LVU7
  61 000a 7420     		movs	r0, #116
  62              	.LVL3:
  63              		.loc 2 380 9 view .LVU8
  64 000c FFF7FEFF 		bl	__smalloc__
ARM GAS  /tmp/ccN45wj6.s 			page 9


  65              	.LVL4:
  66              		.loc 2 380 9 view .LVU9
  67              	.LBE9:
  68              	.LBE8:
  13:./block/gendisk.c ****     if (!disk) return -ENOMEM;
  69              		.loc 1 13 5 is_stmt 1 view .LVU10
  70              		.loc 1 13 8 is_stmt 0 view .LVU11
  71 0010 F0B1     		cbz	r0, .L4
  72 0012 0446     		mov	r4, r0
  14:./block/gendisk.c ****     
  15:./block/gendisk.c ****     if(major == 0){
  73              		.loc 1 15 5 is_stmt 1 view .LVU12
  74              		.loc 1 15 7 is_stmt 0 view .LVU13
  75 0014 2DB9     		cbnz	r5, .L3
  16:./block/gendisk.c ****         blk_dev_major++;   
  76              		.loc 1 16 9 is_stmt 1 view .LVU14
  77              		.loc 1 16 22 is_stmt 0 view .LVU15
  78 0016 104A     		ldr	r2, .L6
  79 0018 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
  80 001a 0133     		adds	r3, r3, #1
  81 001c DBB2     		uxtb	r3, r3
  82 001e 1370     		strb	r3, [r2]
  17:./block/gendisk.c ****         disk->major = blk_dev_major;
  83              		.loc 1 17 9 is_stmt 1 view .LVU16
  84              		.loc 1 17 21 is_stmt 0 view .LVU17
  85 0020 0360     		str	r3, [r0]
  86              	.L3:
  18:./block/gendisk.c ****     }
  19:./block/gendisk.c **** 
  20:./block/gendisk.c ****     disk->major = major;
  87              		.loc 1 20 5 is_stmt 1 view .LVU18
  88              		.loc 1 20 17 is_stmt 0 view .LVU19
  89 0022 2560     		str	r5, [r4]
  21:./block/gendisk.c ****     disk->first_minor = 0;
  90              		.loc 1 21 5 is_stmt 1 view .LVU20
  91              		.loc 1 21 23 is_stmt 0 view .LVU21
  92 0024 0025     		movs	r5, #0
  93              	.LVL5:
  94              		.loc 1 21 23 view .LVU22
  95 0026 6560     		str	r5, [r4, #4]
  22:./block/gendisk.c ****     disk->minors = minors;
  96              		.loc 1 22 5 is_stmt 1 view .LVU23
  97              		.loc 1 22 18 is_stmt 0 view .LVU24
  98 0028 A660     		str	r6, [r4, #8]
  23:./block/gendisk.c **** 
  24:./block/gendisk.c ****     snprintf(disk->disk_name, DISK_NAME_LEN, "sd%c",number);
  99              		.loc 1 24 5 is_stmt 1 view .LVU25
 100 002a 0C4E     		ldr	r6, .L6+4
 101              	.LVL6:
 102              		.loc 1 24 5 is_stmt 0 view .LVU26
 103 002c 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 104 002e 0C4A     		ldr	r2, .L6+8
 105 0030 2021     		movs	r1, #32
 106 0032 04F10C00 		add	r0, r4, #12
 107              	.LVL7:
 108              		.loc 1 24 5 view .LVU27
 109 0036 FFF7FEFF 		bl	snprintf
ARM GAS  /tmp/ccN45wj6.s 			page 10


 110              	.LVL8:
  25:./block/gendisk.c ****     number++;
 111              		.loc 1 25 5 is_stmt 1 view .LVU28
 112              		.loc 1 25 11 is_stmt 0 view .LVU29
 113 003a 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 114 003c 0133     		adds	r3, r3, #1
 115 003e 3370     		strb	r3, [r6]
  26:./block/gendisk.c ****     disk->flags = 0;
 116              		.loc 1 26 5 is_stmt 1 view .LVU30
 117              		.loc 1 26 17 is_stmt 0 view .LVU31
 118 0040 A564     		str	r5, [r4, #72]
  27:./block/gendisk.c ****     disk->state &= GD_NEED_PART_SCAN;
 119              		.loc 1 27 5 is_stmt 1 view .LVU32
 120              		.loc 1 27 17 is_stmt 0 view .LVU33
 121 0042 E564     		str	r5, [r4, #76]
  28:./block/gendisk.c ****     disk->state &= GD_NATIVE_CAPACITY;
 122              		.loc 1 28 5 is_stmt 1 view .LVU34
  29:./block/gendisk.c ****     mutex_init(&disk->open_mutex);
 123              		.loc 1 29 5 view .LVU35
  30:./block/gendisk.c **** 
  31:./block/gendisk.c ****     disk->open_partitions = 0;
 124              		.loc 1 31 5 view .LVU36
 125              		.loc 1 31 27 is_stmt 0 view .LVU37
 126 0044 2566     		str	r5, [r4, #96]
  32:./block/gendisk.c ****     disk->diskseq = 0;
 127              		.loc 1 32 5 is_stmt 1 view .LVU38
 128              		.loc 1 32 19 is_stmt 0 view .LVU39
 129 0046 A566     		str	r5, [r4, #104]
  33:./block/gendisk.c ****     disk->open_mode = BLK_OPEN_READ;
 130              		.loc 1 33 5 is_stmt 1 view .LVU40
 131              		.loc 1 33 21 is_stmt 0 view .LVU41
 132 0048 0123     		movs	r3, #1
 133 004a E366     		str	r3, [r4, #108]
  34:./block/gendisk.c ****     return disk;
 134              		.loc 1 34 5 is_stmt 1 view .LVU42
 135              	.LVL9:
 136              	.L1:
  35:./block/gendisk.c **** }
 137              		.loc 1 35 1 is_stmt 0 view .LVU43
 138 004c 2046     		mov	r0, r4
 139 004e 70BD     		pop	{r4, r5, r6, pc}
 140              	.LVL10:
 141              	.L4:
  13:./block/gendisk.c ****     
 142              		.loc 1 13 23 discriminator 1 view .LVU44
 143 0050 6FF00B04 		mvn	r4, #11
 144 0054 FAE7     		b	.L1
 145              	.L7:
 146 0056 00BF     		.align	2
 147              	.L6:
 148 0058 00000000 		.word	blk_dev_major
 149 005c 00000000 		.word	number
 150 0060 00000000 		.word	.LC0
 151              		.cfi_endproc
 152              	.LFE960:
 154              		.section	.text.__put_disk,"ax",%progbits
 155              		.align	1
ARM GAS  /tmp/ccN45wj6.s 			page 11


 156              		.global	__put_disk
 157              		.syntax unified
 158              		.thumb
 159              		.thumb_func
 161              	__put_disk:
 162              	.LVL11:
 163              	.LFB961:
  36:./block/gendisk.c **** 
  37:./block/gendisk.c **** void __put_disk(struct gendisk *disk){
 164              		.loc 1 37 38 is_stmt 1 view -0
 165              		.cfi_startproc
 166              		@ args = 0, pretend = 0, frame = 0
 167              		@ frame_needed = 0, uses_anonymous_args = 0
 168              		.loc 1 37 38 is_stmt 0 view .LVU46
 169 0000 08B5     		push	{r3, lr}
 170              	.LCFI1:
 171              		.cfi_def_cfa_offset 8
 172              		.cfi_offset 3, -8
 173              		.cfi_offset 14, -4
  38:./block/gendisk.c ****     kfree(disk);   
 174              		.loc 1 38 5 is_stmt 1 view .LVU47
 175              	.LVL12:
 176              	.LBB10:
 177              	.LBI10:
 381:./include/linux/slab.h **** }
 382:./include/linux/slab.h **** 
 383:./include/linux/slab.h **** static void inline kfree(const void *ptr){
 178              		.loc 2 383 20 view .LVU48
 179              	.LBB11:
 384:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 180              		.loc 2 384 2 view .LVU49
 181 0002 FFF7FEFF 		bl	__sfree__
 182              	.LVL13:
 183              		.loc 2 384 2 is_stmt 0 view .LVU50
 184              	.LBE11:
 185              	.LBE10:
  39:./block/gendisk.c **** }...
 186              		.loc 1 39 1 view .LVU51
 187 0006 08BD     		pop	{r3, pc}
 188              		.cfi_endproc
 189              	.LFE961:
 191              		.section	.data.blk_dev_major,"aw"
 194              	blk_dev_major:
 195 0000 FE       		.byte	-2
 196              		.section	.data.number,"aw"
 199              	number:
 200 0000 61       		.byte	97
 201              		.text
 202              	.Letext0:
 203              		.file 3 "./include/asm-generic/int-l64.h"
 204              		.file 4 "./include/asm-generic/posix_types.h"
 205              		.file 5 "./include/uapi/linux/types.h"
 206              		.file 6 "./include/linux/types.h"
 207              		.file 7 "./include/linux/time64.h"
 208              		.file 8 "./arch/arm_m/include/asm/spinlock.h"
 209              		.file 9 "./include/linux/spinlock_types_raw.h"
 210              		.file 10 "./include/linux/spinlock_types.h"
ARM GAS  /tmp/ccN45wj6.s 			page 12


 211              		.file 11 "./include/linux/mutex.h"
 212              		.file 12 "./include/linux/errseq.h"
 213              		.file 13 "./include/linux/rbtree_types.h"
 214              		.file 14 "./include/linux/uidgid_types.h"
 215              		.file 15 "./include/linux/projid.h"
 216              		.file 16 "./include/linux/fs.h"
 217              		.file 17 "./include/linux/mnt_idmapping.h"
 218              		.file 18 "./include/linux/uio.h"
 219              		.file 19 "./include/linux/wait.h"
 220              		.file 20 "./include/linux/xarray.h"
 221              		.file 21 "./include/linux/lockref.h"
 222              		.file 22 "./include/linux/dcache.h"
 223              		.file 23 "./include/linux/migrate_mode.h"
 224              		.file 24 "./include/linux/path.h"
 225              		.file 25 "./include/linux/reciprocal_div.h"
 226              		.file 26 "./include/linux/mm_type.h"
 227              		.file 27 "./include/linux/statfs.h"
 228              		.file 28 "./include/linux/stat.h"
 229              		.file 29 "./include/linux/bvec.h"
 230              		.file 30 "./include/linux/gfp_types.h"
 231              		.file 31 "./include/linux/blk_types.h"
 232              		.file 32 "./include/linux/rw_hint.h"
 233              		.file 33 "./include/linux/blkdev.h"
 234              		.file 34 "./include/linux/bio.h"
 235              		.file 35 "./include/linux/mempool_super_haper.h"
 236              		.file 36 "./include/linux/mempool.h"
 237              		.file 37 "./include/linux/lockdep_types.h"
 238              		.file 38 "./include/linux/workqueue_types.h"
 239              		.file 39 "./include/linux/blk-mq.h"
 240              		.file 40 "./include/uapi/linux/pr.h"
 241              		.file 41 "./include/linux/pr.h"
 242              		.file 42 "./include/linux/hdreg.h"
 243              		.file 43 "./include/linux/sprintf.h"
ARM GAS  /tmp/ccN45wj6.s 			page 13


DEFINED SYMBOLS
                            *ABS*:00000000 gendisk.c
     /tmp/ccN45wj6.s:21     .rodata.__gendisk_alloc.str1.4:00000000 $d
     /tmp/ccN45wj6.s:25     .text.__gendisk_alloc:00000000 $t
     /tmp/ccN45wj6.s:31     .text.__gendisk_alloc:00000000 __gendisk_alloc
     /tmp/ccN45wj6.s:148    .text.__gendisk_alloc:00000058 $d
     /tmp/ccN45wj6.s:194    .data.blk_dev_major:00000000 blk_dev_major
     /tmp/ccN45wj6.s:199    .data.number:00000000 number
     /tmp/ccN45wj6.s:155    .text.__put_disk:00000000 $t
     /tmp/ccN45wj6.s:161    .text.__put_disk:00000000 __put_disk

UNDEFINED SYMBOLS
__smalloc__
snprintf
__sfree__
