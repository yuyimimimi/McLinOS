ARM GAS  /tmp/cc2wwjO4.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"stm32f4_gpio.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./drivers/gpio/stm32f4_gpio.c"
  20              		.section	.text.GPIO_SetAF,"ax",%progbits
  21              		.align	1
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	GPIO_SetAF:
  27              	.LVL0:
  28              	.LFB1037:
   1:./drivers/gpio/stm32f4_gpio.c **** #include <linux/kernel.h>
   2:./drivers/gpio/stm32f4_gpio.c **** #include <linux/uaccess.h>
   3:./drivers/gpio/stm32f4_gpio.c **** #include <linux/fs.h>
   4:./drivers/gpio/stm32f4_gpio.c **** #include <linux/init.h>
   5:./drivers/gpio/stm32f4_gpio.c **** #include <linux/slab.h>
   6:./drivers/gpio/stm32f4_gpio.c **** #include <linux/device.h>
   7:./drivers/gpio/stm32f4_gpio.c **** #include <linux/gpio/gpio.h>
   8:./drivers/gpio/stm32f4_gpio.c **** 
   9:./drivers/gpio/stm32f4_gpio.c **** typedef enum {
  10:./drivers/gpio/stm32f4_gpio.c ****     DISABLE = 0, 
  11:./drivers/gpio/stm32f4_gpio.c ****     ENABLE = !DISABLE
  12:./drivers/gpio/stm32f4_gpio.c **** } FunctionalState;
  13:./drivers/gpio/stm32f4_gpio.c **** 
  14:./drivers/gpio/stm32f4_gpio.c **** // 寄存器地址定义
  15:./drivers/gpio/stm32f4_gpio.c **** #define PERIPH_BASE           (0x40000000UL)
  16:./drivers/gpio/stm32f4_gpio.c **** #define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000UL)
  17:./drivers/gpio/stm32f4_gpio.c **** 
  18:./drivers/gpio/stm32f4_gpio.c **** #define GPIOA_BASE            (AHB1PERIPH_BASE + 0x0000UL)
  19:./drivers/gpio/stm32f4_gpio.c **** #define GPIOB_BASE            (AHB1PERIPH_BASE + 0x0400UL)
  20:./drivers/gpio/stm32f4_gpio.c **** #define GPIOC_BASE            (AHB1PERIPH_BASE + 0x0800UL)
  21:./drivers/gpio/stm32f4_gpio.c **** #define GPIOD_BASE            (AHB1PERIPH_BASE + 0x0C00UL)
  22:./drivers/gpio/stm32f4_gpio.c **** #define GPIOE_BASE            (AHB1PERIPH_BASE + 0x1000UL)
  23:./drivers/gpio/stm32f4_gpio.c **** #define GPIOF_BASE            (AHB1PERIPH_BASE + 0x1400UL)
  24:./drivers/gpio/stm32f4_gpio.c **** #define GPIOG_BASE            (AHB1PERIPH_BASE + 0x1800UL)
  25:./drivers/gpio/stm32f4_gpio.c **** #define GPIOH_BASE            (AHB1PERIPH_BASE + 0x1C00UL)
  26:./drivers/gpio/stm32f4_gpio.c **** #define GPIOI_BASE            (AHB1PERIPH_BASE + 0x2000UL)
  27:./drivers/gpio/stm32f4_gpio.c **** #define GPIOJ_BASE            (AHB1PERIPH_BASE + 0x2400UL)
  28:./drivers/gpio/stm32f4_gpio.c **** #define GPIOK_BASE            (AHB1PERIPH_BASE + 0x2800UL)
  29:./drivers/gpio/stm32f4_gpio.c **** 
  30:./drivers/gpio/stm32f4_gpio.c **** #define RCC_BASE              (AHB1PERIPH_BASE + 0x3800UL)
ARM GAS  /tmp/cc2wwjO4.s 			page 2


  31:./drivers/gpio/stm32f4_gpio.c **** 
  32:./drivers/gpio/stm32f4_gpio.c **** // GPIO 寄存器结构体
  33:./drivers/gpio/stm32f4_gpio.c **** typedef struct {
  34:./drivers/gpio/stm32f4_gpio.c ****     volatile uint32_t MODER;    // 模式寄存器
  35:./drivers/gpio/stm32f4_gpio.c ****     volatile uint32_t OTYPER;   // 输出类型寄存器
  36:./drivers/gpio/stm32f4_gpio.c ****     volatile uint32_t OSPEEDR;  // 输出速度寄存器
  37:./drivers/gpio/stm32f4_gpio.c ****     volatile uint32_t PUPDR;    // 上拉/下拉寄存器
  38:./drivers/gpio/stm32f4_gpio.c ****     volatile uint32_t IDR;      // 输入数据寄存器
  39:./drivers/gpio/stm32f4_gpio.c ****     volatile uint32_t ODR;      // 输出数据寄存器
  40:./drivers/gpio/stm32f4_gpio.c ****     volatile uint32_t BSRR;     // 置位/复位寄存器
  41:./drivers/gpio/stm32f4_gpio.c ****     volatile uint32_t LCKR;     // 锁定寄存器
  42:./drivers/gpio/stm32f4_gpio.c ****     volatile uint32_t AFR[2];   // 复用功能寄存器
  43:./drivers/gpio/stm32f4_gpio.c **** } GPIO_TypeDef;
  44:./drivers/gpio/stm32f4_gpio.c **** 
  45:./drivers/gpio/stm32f4_gpio.c **** // RCC 寄存器
  46:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1ENR           (*((volatile uint32_t *)(RCC_BASE + 0x30)))
  47:./drivers/gpio/stm32f4_gpio.c **** 
  48:./drivers/gpio/stm32f4_gpio.c **** // GPIO 指针定义
  49:./drivers/gpio/stm32f4_gpio.c **** #define GPIOA                 ((GPIO_TypeDef *)GPIOA_BASE)
  50:./drivers/gpio/stm32f4_gpio.c **** #define GPIOB                 ((GPIO_TypeDef *)GPIOB_BASE)
  51:./drivers/gpio/stm32f4_gpio.c **** #define GPIOC                 ((GPIO_TypeDef *)GPIOC_BASE)
  52:./drivers/gpio/stm32f4_gpio.c **** #define GPIOD                 ((GPIO_TypeDef *)GPIOD_BASE)
  53:./drivers/gpio/stm32f4_gpio.c **** #define GPIOE                 ((GPIO_TypeDef *)GPIOE_BASE)
  54:./drivers/gpio/stm32f4_gpio.c **** #define GPIOF                 ((GPIO_TypeDef *)GPIOF_BASE)
  55:./drivers/gpio/stm32f4_gpio.c **** #define GPIOG                 ((GPIO_TypeDef *)GPIOG_BASE)
  56:./drivers/gpio/stm32f4_gpio.c **** #define GPIOH                 ((GPIO_TypeDef *)GPIOH_BASE)
  57:./drivers/gpio/stm32f4_gpio.c **** #define GPIOI                 ((GPIO_TypeDef *)GPIOI_BASE)
  58:./drivers/gpio/stm32f4_gpio.c **** #define GPIOJ                 ((GPIO_TypeDef *)GPIOJ_BASE)
  59:./drivers/gpio/stm32f4_gpio.c **** #define GPIOK                 ((GPIO_TypeDef *)GPIOK_BASE)
  60:./drivers/gpio/stm32f4_gpio.c **** 
  61:./drivers/gpio/stm32f4_gpio.c **** // GPIO 引脚定义
  62:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_0            (0x0001)
  63:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_1            (0x0002)
  64:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_2            (0x0004)
  65:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_3            (0x0008)
  66:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_4            (0x0010)
  67:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_5            (0x0020)
  68:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_6            (0x0040)
  69:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_7            (0x0080)
  70:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_8            (0x0100)
  71:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_9            (0x0200)
  72:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_10           (0x0400)
  73:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_11           (0x0800)
  74:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_12           (0x1000)
  75:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_13           (0x2000)
  76:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_14           (0x4000)
  77:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Pin_15           (0x8000)
  78:./drivers/gpio/stm32f4_gpio.c **** 
  79:./drivers/gpio/stm32f4_gpio.c **** // GPIO 模式定义
  80:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Mode_IN          (0x00)  // 输入模式
  81:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Mode_OUT         (0x01)  // 输出模式
  82:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Mode_AF          (0x02)  // 复用功能模式
  83:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Mode_AN          (0x03)  // 模拟模式
  84:./drivers/gpio/stm32f4_gpio.c **** 
  85:./drivers/gpio/stm32f4_gpio.c **** // 输出类型定义
  86:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_OType_PP         (0x00)  // 推挽输出
  87:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_OType_OD         (0x01)  // 开漏输出
ARM GAS  /tmp/cc2wwjO4.s 			page 3


  88:./drivers/gpio/stm32f4_gpio.c **** 
  89:./drivers/gpio/stm32f4_gpio.c **** // 上拉/下拉定义
  90:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_PuPd_NOPULL      (0x00)  // 无上拉下拉
  91:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_PuPd_UP          (0x01)  // 上拉
  92:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_PuPd_DOWN        (0x02)  // 下拉
  93:./drivers/gpio/stm32f4_gpio.c **** 
  94:./drivers/gpio/stm32f4_gpio.c **** // 速度定义
  95:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Speed_2MHz       (0x00)  // 低速
  96:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Speed_25MHz      (0x01)  // 中速
  97:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Speed_50MHz      (0x02)  // 高速
  98:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_Speed_100MHz     (0x03)  // 超高速
  99:./drivers/gpio/stm32f4_gpio.c **** 
 100:./drivers/gpio/stm32f4_gpio.c **** // RCC AHB1 外设时钟使能
 101:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOA  (0x00000001)
 102:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOB  (0x00000002)
 103:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOC  (0x00000004)
 104:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOD  (0x00000008)
 105:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOE  (0x00000010)
 106:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOF  (0x00000020)
 107:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOG  (0x00000040)
 108:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOH  (0x00000080)
 109:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOI  (0x00000100)
 110:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOJ  (0x00000200)
 111:./drivers/gpio/stm32f4_gpio.c **** #define RCC_AHB1Periph_GPIOK  (0x00000400)
 112:./drivers/gpio/stm32f4_gpio.c **** 
 113:./drivers/gpio/stm32f4_gpio.c **** // 新增的复用功能定义
 114:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF0              (0x0)
 115:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF1              (0x1)
 116:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF2              (0x2)
 117:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF3              (0x3)
 118:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF4              (0x4)
 119:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF5              (0x5)
 120:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF6              (0x6)
 121:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF7              (0x7)
 122:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF8              (0x8)
 123:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF9              (0x9)
 124:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF10             (0xA)
 125:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF11             (0xB)
 126:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF12             (0xC)
 127:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF13             (0xD)
 128:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF14             (0xE)
 129:./drivers/gpio/stm32f4_gpio.c **** #define GPIO_AF15             (0xF)
 130:./drivers/gpio/stm32f4_gpio.c **** 
 131:./drivers/gpio/stm32f4_gpio.c **** 
 132:./drivers/gpio/stm32f4_gpio.c **** // GPIO 初始化结构体
 133:./drivers/gpio/stm32f4_gpio.c **** typedef struct {
 134:./drivers/gpio/stm32f4_gpio.c ****     uint16_t GPIO_Pin;
 135:./drivers/gpio/stm32f4_gpio.c ****     uint16_t GPIO_Mode;
 136:./drivers/gpio/stm32f4_gpio.c ****     uint16_t GPIO_Speed;
 137:./drivers/gpio/stm32f4_gpio.c ****     uint16_t GPIO_OType;
 138:./drivers/gpio/stm32f4_gpio.c ****     uint16_t GPIO_PuPd;
 139:./drivers/gpio/stm32f4_gpio.c ****     uint8_t GPIO_AF;    
 140:./drivers/gpio/stm32f4_gpio.c **** } GPIO_InitTypeDef;
 141:./drivers/gpio/stm32f4_gpio.c **** 
 142:./drivers/gpio/stm32f4_gpio.c **** // 设备结构体
 143:./drivers/gpio/stm32f4_gpio.c **** static struct gpio_device {
 144:./drivers/gpio/stm32f4_gpio.c ****     uint16_t gpio_number;
ARM GAS  /tmp/cc2wwjO4.s 			page 4


 145:./drivers/gpio/stm32f4_gpio.c ****     GPIO_TypeDef *gpio_type;
 146:./drivers/gpio/stm32f4_gpio.c ****     GPIO_InitTypeDef GPIO_InitStructure;
 147:./drivers/gpio/stm32f4_gpio.c **** };
 148:./drivers/gpio/stm32f4_gpio.c **** 
 149:./drivers/gpio/stm32f4_gpio.c **** 
 150:./drivers/gpio/stm32f4_gpio.c **** void print_gpio_number(uint16_t pin) {
 151:./drivers/gpio/stm32f4_gpio.c ****     static const char prefix[] = "export gpio: GPIO_Pin_";
 152:./drivers/gpio/stm32f4_gpio.c ****     static const char suffix[] = "\n\r";
 153:./drivers/gpio/stm32f4_gpio.c ****     if(pin >= GPIO_Pin_0 && pin <= GPIO_Pin_15) {
 154:./drivers/gpio/stm32f4_gpio.c ****         // 计算引脚号(0-15)
 155:./drivers/gpio/stm32f4_gpio.c ****         uint8_t pin_num = 0;
 156:./drivers/gpio/stm32f4_gpio.c ****         while(pin >>= 1) { pin_num++; }
 157:./drivers/gpio/stm32f4_gpio.c ****         char buf[5] = {0}; // 最大存储"15"+null
 158:./drivers/gpio/stm32f4_gpio.c ****         if(pin_num < 10) {
 159:./drivers/gpio/stm32f4_gpio.c ****             buf[0] = '0' + pin_num;
 160:./drivers/gpio/stm32f4_gpio.c ****         } else {
 161:./drivers/gpio/stm32f4_gpio.c ****             buf[0] = '1';
 162:./drivers/gpio/stm32f4_gpio.c ****             buf[1] = '0' + (pin_num - 10);
 163:./drivers/gpio/stm32f4_gpio.c ****         }       
 164:./drivers/gpio/stm32f4_gpio.c ****         printk("%s%s%s", prefix, buf, suffix);
 165:./drivers/gpio/stm32f4_gpio.c ****     } else {
 166:./drivers/gpio/stm32f4_gpio.c ****         printk("error pin number: %d%s", pin, suffix);
 167:./drivers/gpio/stm32f4_gpio.c ****     }
 168:./drivers/gpio/stm32f4_gpio.c **** }
 169:./drivers/gpio/stm32f4_gpio.c **** 
 170:./drivers/gpio/stm32f4_gpio.c **** void print_gpio_type(GPIO_TypeDef *type) {
 171:./drivers/gpio/stm32f4_gpio.c ****     static const char prefix[] = "gpio type is :GPIO";
 172:./drivers/gpio/stm32f4_gpio.c ****     static const char suffix[] = "\n\r";
 173:./drivers/gpio/stm32f4_gpio.c ****     
 174:./drivers/gpio/stm32f4_gpio.c ****     if(type >= GPIOA && type <= GPIOK) {
 175:./drivers/gpio/stm32f4_gpio.c ****         char port = 'A' + ((uint32_t)type - (uint32_t)GPIOA) / 0x400;
 176:./drivers/gpio/stm32f4_gpio.c ****         printk("%s%c%s", prefix, port, suffix);
 177:./drivers/gpio/stm32f4_gpio.c ****     } else {
 178:./drivers/gpio/stm32f4_gpio.c ****         printk("error gpio type%s", suffix);
 179:./drivers/gpio/stm32f4_gpio.c ****     }
 180:./drivers/gpio/stm32f4_gpio.c **** }
 181:./drivers/gpio/stm32f4_gpio.c **** 
 182:./drivers/gpio/stm32f4_gpio.c **** 
 183:./drivers/gpio/stm32f4_gpio.c **** 
 184:./drivers/gpio/stm32f4_gpio.c **** 
 185:./drivers/gpio/stm32f4_gpio.c **** // 设置引脚复用功能
 186:./drivers/gpio/stm32f4_gpio.c **** static void GPIO_SetAF(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint8_t AF) {
  29              		.loc 1 186 76 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
 187:./drivers/gpio/stm32f4_gpio.c ****     uint32_t pinpos = 0;
  34              		.loc 1 187 5 view .LVU1
 188:./drivers/gpio/stm32f4_gpio.c ****     while((GPIO_Pin >> pinpos) != 1) { pinpos++; }
  35              		.loc 1 188 5 view .LVU2
 187:./drivers/gpio/stm32f4_gpio.c ****     uint32_t pinpos = 0;
  36              		.loc 1 187 14 is_stmt 0 view .LVU3
  37 0000 0023     		movs	r3, #0
  38              		.loc 1 188 10 view .LVU4
  39 0002 00E0     		b	.L2
  40              	.LVL1:
ARM GAS  /tmp/cc2wwjO4.s 			page 5


  41              	.L3:
  42              		.loc 1 188 40 is_stmt 1 discriminator 2 view .LVU5
  43              		.loc 1 188 46 is_stmt 0 discriminator 2 view .LVU6
  44 0004 0133     		adds	r3, r3, #1
  45              	.LVL2:
  46              	.L2:
  47              		.loc 1 188 32 is_stmt 1 discriminator 1 view .LVU7
  48              		.loc 1 188 21 is_stmt 0 discriminator 1 view .LVU8
  49 0006 41FA03FC 		asr	ip, r1, r3
  50              		.loc 1 188 32 discriminator 1 view .LVU9
  51 000a BCF1010F 		cmp	ip, #1
  52 000e F9D1     		bne	.L3
 189:./drivers/gpio/stm32f4_gpio.c ****     
 190:./drivers/gpio/stm32f4_gpio.c ****     if(pinpos < 8) {
  53              		.loc 1 190 5 is_stmt 1 view .LVU10
  54              		.loc 1 190 7 is_stmt 0 view .LVU11
  55 0010 072B     		cmp	r3, #7
  56 0012 0ED8     		bhi	.L4
 191:./drivers/gpio/stm32f4_gpio.c ****         GPIOx->AFR[0] &= ~(0xF << (pinpos * 4));
  57              		.loc 1 191 9 is_stmt 1 view .LVU12
  58              		.loc 1 191 19 is_stmt 0 view .LVU13
  59 0014 016A     		ldr	r1, [r0, #32]
  60              	.LVL3:
  61              		.loc 1 191 43 view .LVU14
  62 0016 9B00     		lsls	r3, r3, #2
  63              	.LVL4:
  64              		.loc 1 191 32 view .LVU15
  65 0018 4FF00F0C 		mov	ip, #15
  66 001c 0CFA03FC 		lsl	ip, ip, r3
  67              		.loc 1 191 23 view .LVU16
  68 0020 21EA0C01 		bic	r1, r1, ip
  69 0024 0162     		str	r1, [r0, #32]
 192:./drivers/gpio/stm32f4_gpio.c ****         GPIOx->AFR[0] |= (AF << (pinpos * 4));
  70              		.loc 1 192 9 is_stmt 1 view .LVU17
  71              		.loc 1 192 19 is_stmt 0 view .LVU18
  72 0026 016A     		ldr	r1, [r0, #32]
  73              		.loc 1 192 30 view .LVU19
  74 0028 02FA03F3 		lsl	r3, r2, r3
  75              		.loc 1 192 23 view .LVU20
  76 002c 0B43     		orrs	r3, r3, r1
  77 002e 0362     		str	r3, [r0, #32]
  78 0030 7047     		bx	lr
  79              	.LVL5:
  80              	.L4:
 193:./drivers/gpio/stm32f4_gpio.c ****     } else {
 194:./drivers/gpio/stm32f4_gpio.c ****         GPIOx->AFR[1] &= ~(0xF << ((pinpos-8) * 4));
  81              		.loc 1 194 9 is_stmt 1 view .LVU21
  82              		.loc 1 194 19 is_stmt 0 view .LVU22
  83 0032 416A     		ldr	r1, [r0, #36]
  84              	.LVL6:
  85              		.loc 1 194 43 view .LVU23
  86 0034 083B     		subs	r3, r3, #8
  87              	.LVL7:
  88              		.loc 1 194 47 view .LVU24
  89 0036 9B00     		lsls	r3, r3, #2
  90              	.LVL8:
  91              		.loc 1 194 32 view .LVU25
ARM GAS  /tmp/cc2wwjO4.s 			page 6


  92 0038 4FF00F0C 		mov	ip, #15
  93 003c 0CFA03FC 		lsl	ip, ip, r3
  94              		.loc 1 194 23 view .LVU26
  95 0040 21EA0C01 		bic	r1, r1, ip
  96 0044 4162     		str	r1, [r0, #36]
 195:./drivers/gpio/stm32f4_gpio.c ****         GPIOx->AFR[1] |= (AF << ((pinpos-8) * 4));
  97              		.loc 1 195 9 is_stmt 1 view .LVU27
  98              		.loc 1 195 19 is_stmt 0 view .LVU28
  99 0046 416A     		ldr	r1, [r0, #36]
 100              		.loc 1 195 30 view .LVU29
 101 0048 9A40     		lsls	r2, r2, r3
 102              	.LVL9:
 103              		.loc 1 195 23 view .LVU30
 104 004a 0A43     		orrs	r2, r2, r1
 105 004c 4262     		str	r2, [r0, #36]
 196:./drivers/gpio/stm32f4_gpio.c ****     }
 197:./drivers/gpio/stm32f4_gpio.c **** }
 106              		.loc 1 197 1 view .LVU31
 107 004e 7047     		bx	lr
 108              		.cfi_endproc
 109              	.LFE1037:
 111              		.section	.text.GPIO_Init,"ax",%progbits
 112              		.align	1
 113              		.syntax unified
 114              		.thumb
 115              		.thumb_func
 117              	GPIO_Init:
 118              	.LVL10:
 119              	.LFB1038:
 198:./drivers/gpio/stm32f4_gpio.c **** 
 199:./drivers/gpio/stm32f4_gpio.c **** static void GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_InitStruct) {
 120              		.loc 1 199 79 is_stmt 1 view -0
 121              		.cfi_startproc
 122              		@ args = 0, pretend = 0, frame = 0
 123              		@ frame_needed = 0, uses_anonymous_args = 0
 124              		.loc 1 199 79 is_stmt 0 view .LVU33
 125 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 126              	.LCFI0:
 127              		.cfi_def_cfa_offset 24
 128              		.cfi_offset 3, -24
 129              		.cfi_offset 4, -20
 130              		.cfi_offset 5, -16
 131              		.cfi_offset 6, -12
 132              		.cfi_offset 7, -8
 133              		.cfi_offset 14, -4
 134 0002 0546     		mov	r5, r0
 135 0004 0E46     		mov	r6, r1
 200:./drivers/gpio/stm32f4_gpio.c ****     uint32_t pinpos, pos, currentpin;
 136              		.loc 1 200 5 is_stmt 1 view .LVU34
 201:./drivers/gpio/stm32f4_gpio.c ****     
 202:./drivers/gpio/stm32f4_gpio.c ****     for(pinpos = 0; pinpos < 16; pinpos++) {
 137              		.loc 1 202 5 view .LVU35
 138              	.LVL11:
 139              		.loc 1 202 16 is_stmt 0 view .LVU36
 140 0006 0024     		movs	r4, #0
 141              		.loc 1 202 5 view .LVU37
 142 0008 0CE0     		b	.L7
ARM GAS  /tmp/cc2wwjO4.s 			page 7


 143              	.LVL12:
 144              	.L9:
 203:./drivers/gpio/stm32f4_gpio.c ****         pos = (0x1 << pinpos);
 204:./drivers/gpio/stm32f4_gpio.c ****         currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 205:./drivers/gpio/stm32f4_gpio.c ****         
 206:./drivers/gpio/stm32f4_gpio.c ****         if(currentpin == pos) {
 207:./drivers/gpio/stm32f4_gpio.c ****             // 配置模式
 208:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->MODER &= ~(0x3 << (pinpos * 2));
 209:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->MODER |= (GPIO_InitStruct->GPIO_Mode << (pinpos * 2));
 210:./drivers/gpio/stm32f4_gpio.c ****             
 211:./drivers/gpio/stm32f4_gpio.c ****             // 如果是复用模式或输出模式，配置其他参数
 212:./drivers/gpio/stm32f4_gpio.c ****             if(GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT || 
 213:./drivers/gpio/stm32f4_gpio.c ****                GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF) {
 214:./drivers/gpio/stm32f4_gpio.c ****                 // 配置输出类型
 215:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OTYPER &= ~(0x1 << pinpos);
 216:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OTYPER |= (GPIO_InitStruct->GPIO_OType << pinpos);
 217:./drivers/gpio/stm32f4_gpio.c ****                 
 218:./drivers/gpio/stm32f4_gpio.c ****                 // 配置速度
 219:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OSPEEDR &= ~(0x3 << (pinpos * 2));
 220:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OSPEEDR |= (GPIO_InitStruct->GPIO_Speed << (pinpos * 2));
 221:./drivers/gpio/stm32f4_gpio.c ****             }
 222:./drivers/gpio/stm32f4_gpio.c ****             
 223:./drivers/gpio/stm32f4_gpio.c ****             // 配置上拉/下拉
 224:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->PUPDR &= ~(0x3 << (pinpos * 2));
 145              		.loc 1 224 13 is_stmt 1 view .LVU38
 146              		.loc 1 224 18 is_stmt 0 view .LVU39
 147 000a EA68     		ldr	r2, [r5, #12]
 148              		.loc 1 224 26 view .LVU40
 149 000c 1040     		ands	r0, r0, r2
 150 000e E860     		str	r0, [r5, #12]
 225:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->PUPDR |= (GPIO_InitStruct->GPIO_PuPd << (pinpos * 2));
 151              		.loc 1 225 13 is_stmt 1 view .LVU41
 152              		.loc 1 225 18 is_stmt 0 view .LVU42
 153 0010 EA68     		ldr	r2, [r5, #12]
 154              		.loc 1 225 45 view .LVU43
 155 0012 3089     		ldrh	r0, [r6, #8]
 156              		.loc 1 225 57 view .LVU44
 157 0014 00FA01F1 		lsl	r1, r0, r1
 158              		.loc 1 225 26 view .LVU45
 159 0018 0A43     		orrs	r2, r2, r1
 160 001a EA60     		str	r2, [r5, #12]
 226:./drivers/gpio/stm32f4_gpio.c ****             
 227:./drivers/gpio/stm32f4_gpio.c ****             // 如果是复用模式，配置复用功能
 228:./drivers/gpio/stm32f4_gpio.c ****             if(GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF) {
 161              		.loc 1 228 13 is_stmt 1 view .LVU46
 162              		.loc 1 228 31 is_stmt 0 view .LVU47
 163 001c 7288     		ldrh	r2, [r6, #2]
 164              		.loc 1 228 15 view .LVU48
 165 001e 022A     		cmp	r2, #2
 166 0020 2FD0     		beq	.L12
 167              	.LVL13:
 168              	.L8:
 202:./drivers/gpio/stm32f4_gpio.c ****         pos = (0x1 << pinpos);
 169              		.loc 1 202 40 is_stmt 1 discriminator 2 view .LVU49
 170 0022 0134     		adds	r4, r4, #1
 171              	.LVL14:
 172              	.L7:
ARM GAS  /tmp/cc2wwjO4.s 			page 8


 202:./drivers/gpio/stm32f4_gpio.c ****         pos = (0x1 << pinpos);
 173              		.loc 1 202 28 discriminator 1 view .LVU50
 174 0024 0F2C     		cmp	r4, #15
 175 0026 32D8     		bhi	.L13
 203:./drivers/gpio/stm32f4_gpio.c ****         currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 176              		.loc 1 203 9 view .LVU51
 203:./drivers/gpio/stm32f4_gpio.c ****         currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 177              		.loc 1 203 20 is_stmt 0 view .LVU52
 178 0028 0123     		movs	r3, #1
 179 002a A340     		lsls	r3, r3, r4
 180              	.LVL15:
 204:./drivers/gpio/stm32f4_gpio.c ****         
 181              		.loc 1 204 9 is_stmt 1 view .LVU53
 204:./drivers/gpio/stm32f4_gpio.c ****         
 182              		.loc 1 204 38 is_stmt 0 view .LVU54
 183 002c 3288     		ldrh	r2, [r6]
 184              	.LVL16:
 206:./drivers/gpio/stm32f4_gpio.c ****             // 配置模式
 185              		.loc 1 206 9 is_stmt 1 view .LVU55
 206:./drivers/gpio/stm32f4_gpio.c ****             // 配置模式
 186              		.loc 1 206 11 is_stmt 0 view .LVU56
 187 002e 33EA0202 		bics	r2, r3, r2
 188              	.LVL17:
 206:./drivers/gpio/stm32f4_gpio.c ****             // 配置模式
 189              		.loc 1 206 11 view .LVU57
 190 0032 F6D1     		bne	.L8
 208:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->MODER |= (GPIO_InitStruct->GPIO_Mode << (pinpos * 2));
 191              		.loc 1 208 13 is_stmt 1 view .LVU58
 208:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->MODER |= (GPIO_InitStruct->GPIO_Mode << (pinpos * 2));
 192              		.loc 1 208 18 is_stmt 0 view .LVU59
 193 0034 2F68     		ldr	r7, [r5]
 208:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->MODER |= (GPIO_InitStruct->GPIO_Mode << (pinpos * 2));
 194              		.loc 1 208 46 view .LVU60
 195 0036 6100     		lsls	r1, r4, #1
 208:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->MODER |= (GPIO_InitStruct->GPIO_Mode << (pinpos * 2));
 196              		.loc 1 208 35 view .LVU61
 197 0038 0322     		movs	r2, #3
 198 003a 8A40     		lsls	r2, r2, r1
 208:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->MODER |= (GPIO_InitStruct->GPIO_Mode << (pinpos * 2));
 199              		.loc 1 208 29 view .LVU62
 200 003c D043     		mvns	r0, r2
 208:./drivers/gpio/stm32f4_gpio.c ****             GPIOx->MODER |= (GPIO_InitStruct->GPIO_Mode << (pinpos * 2));
 201              		.loc 1 208 26 view .LVU63
 202 003e 27EA0202 		bic	r2, r7, r2
 203 0042 2A60     		str	r2, [r5]
 204              	.LVL18:
 209:./drivers/gpio/stm32f4_gpio.c ****             
 205              		.loc 1 209 13 is_stmt 1 view .LVU64
 209:./drivers/gpio/stm32f4_gpio.c ****             
 206              		.loc 1 209 18 is_stmt 0 view .LVU65
 207 0044 2A68     		ldr	r2, [r5]
 209:./drivers/gpio/stm32f4_gpio.c ****             
 208              		.loc 1 209 45 view .LVU66
 209 0046 B6F802C0 		ldrh	ip, [r6, #2]
 209:./drivers/gpio/stm32f4_gpio.c ****             
 210              		.loc 1 209 57 view .LVU67
 211 004a 0CFA01FC 		lsl	ip, ip, r1
ARM GAS  /tmp/cc2wwjO4.s 			page 9


 209:./drivers/gpio/stm32f4_gpio.c ****             
 212              		.loc 1 209 26 view .LVU68
 213 004e 42EA0C02 		orr	r2, r2, ip
 214 0052 2A60     		str	r2, [r5]
 212:./drivers/gpio/stm32f4_gpio.c ****                GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF) {
 215              		.loc 1 212 13 is_stmt 1 view .LVU69
 212:./drivers/gpio/stm32f4_gpio.c ****                GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF) {
 216              		.loc 1 212 31 is_stmt 0 view .LVU70
 217 0054 7288     		ldrh	r2, [r6, #2]
 212:./drivers/gpio/stm32f4_gpio.c ****                GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF) {
 218              		.loc 1 212 60 view .LVU71
 219 0056 013A     		subs	r2, r2, #1
 220 0058 92B2     		uxth	r2, r2
 212:./drivers/gpio/stm32f4_gpio.c ****                GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF) {
 221              		.loc 1 212 15 view .LVU72
 222 005a 012A     		cmp	r2, #1
 223 005c D5D8     		bhi	.L9
 215:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OTYPER |= (GPIO_InitStruct->GPIO_OType << pinpos);
 224              		.loc 1 215 17 is_stmt 1 view .LVU73
 215:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OTYPER |= (GPIO_InitStruct->GPIO_OType << pinpos);
 225              		.loc 1 215 22 is_stmt 0 view .LVU74
 226 005e 6A68     		ldr	r2, [r5, #4]
 215:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OTYPER |= (GPIO_InitStruct->GPIO_OType << pinpos);
 227              		.loc 1 215 31 view .LVU75
 228 0060 22EA0302 		bic	r2, r2, r3
 229 0064 6A60     		str	r2, [r5, #4]
 216:./drivers/gpio/stm32f4_gpio.c ****                 
 230              		.loc 1 216 17 is_stmt 1 view .LVU76
 216:./drivers/gpio/stm32f4_gpio.c ****                 
 231              		.loc 1 216 22 is_stmt 0 view .LVU77
 232 0066 6A68     		ldr	r2, [r5, #4]
 216:./drivers/gpio/stm32f4_gpio.c ****                 
 233              		.loc 1 216 50 view .LVU78
 234 0068 F788     		ldrh	r7, [r6, #6]
 216:./drivers/gpio/stm32f4_gpio.c ****                 
 235              		.loc 1 216 63 view .LVU79
 236 006a A740     		lsls	r7, r7, r4
 216:./drivers/gpio/stm32f4_gpio.c ****                 
 237              		.loc 1 216 31 view .LVU80
 238 006c 3A43     		orrs	r2, r2, r7
 239 006e 6A60     		str	r2, [r5, #4]
 219:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OSPEEDR |= (GPIO_InitStruct->GPIO_Speed << (pinpos * 2));
 240              		.loc 1 219 17 is_stmt 1 view .LVU81
 219:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OSPEEDR |= (GPIO_InitStruct->GPIO_Speed << (pinpos * 2));
 241              		.loc 1 219 22 is_stmt 0 view .LVU82
 242 0070 AA68     		ldr	r2, [r5, #8]
 219:./drivers/gpio/stm32f4_gpio.c ****                 GPIOx->OSPEEDR |= (GPIO_InitStruct->GPIO_Speed << (pinpos * 2));
 243              		.loc 1 219 32 view .LVU83
 244 0072 0240     		ands	r2, r2, r0
 245 0074 AA60     		str	r2, [r5, #8]
 220:./drivers/gpio/stm32f4_gpio.c ****             }
 246              		.loc 1 220 17 is_stmt 1 view .LVU84
 220:./drivers/gpio/stm32f4_gpio.c ****             }
 247              		.loc 1 220 22 is_stmt 0 view .LVU85
 248 0076 AA68     		ldr	r2, [r5, #8]
 220:./drivers/gpio/stm32f4_gpio.c ****             }
 249              		.loc 1 220 51 view .LVU86
ARM GAS  /tmp/cc2wwjO4.s 			page 10


 250 0078 B788     		ldrh	r7, [r6, #4]
 220:./drivers/gpio/stm32f4_gpio.c ****             }
 251              		.loc 1 220 64 view .LVU87
 252 007a 8F40     		lsls	r7, r7, r1
 220:./drivers/gpio/stm32f4_gpio.c ****             }
 253              		.loc 1 220 32 view .LVU88
 254 007c 3A43     		orrs	r2, r2, r7
 255 007e AA60     		str	r2, [r5, #8]
 256 0080 C3E7     		b	.L9
 257              	.L12:
 229:./drivers/gpio/stm32f4_gpio.c ****                 GPIO_SetAF(GPIOx, pos, GPIO_InitStruct->GPIO_AF);
 258              		.loc 1 229 17 is_stmt 1 view .LVU89
 259 0082 B27A     		ldrb	r2, [r6, #10]	@ zero_extendqisi2
 260 0084 99B2     		uxth	r1, r3
 261 0086 2846     		mov	r0, r5
 262 0088 FFF7FEFF 		bl	GPIO_SetAF
 263              	.LVL19:
 264              		.loc 1 229 17 is_stmt 0 view .LVU90
 265 008c C9E7     		b	.L8
 266              	.LVL20:
 267              	.L13:
 230:./drivers/gpio/stm32f4_gpio.c ****             }
 231:./drivers/gpio/stm32f4_gpio.c ****         }
 232:./drivers/gpio/stm32f4_gpio.c ****     }
 233:./drivers/gpio/stm32f4_gpio.c **** }
 268              		.loc 1 233 1 view .LVU91
 269 008e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 270              		.loc 1 233 1 view .LVU92
 271              		.cfi_endproc
 272              	.LFE1038:
 274              		.section	.text.GPIO_SetBits,"ax",%progbits
 275              		.align	1
 276              		.syntax unified
 277              		.thumb
 278              		.thumb_func
 280              	GPIO_SetBits:
 281              	.LVL21:
 282              	.LFB1039:
 234:./drivers/gpio/stm32f4_gpio.c **** 
 235:./drivers/gpio/stm32f4_gpio.c **** // 设置GPIO引脚
 236:./drivers/gpio/stm32f4_gpio.c **** static void GPIO_SetBits(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) {
 283              		.loc 1 236 66 is_stmt 1 view -0
 284              		.cfi_startproc
 285              		@ args = 0, pretend = 0, frame = 0
 286              		@ frame_needed = 0, uses_anonymous_args = 0
 287              		@ link register save eliminated.
 237:./drivers/gpio/stm32f4_gpio.c ****     GPIOx->BSRR = GPIO_Pin;
 288              		.loc 1 237 5 view .LVU94
 289              		.loc 1 237 17 is_stmt 0 view .LVU95
 290 0000 8161     		str	r1, [r0, #24]
 238:./drivers/gpio/stm32f4_gpio.c **** }
 291              		.loc 1 238 1 view .LVU96
 292 0002 7047     		bx	lr
 293              		.cfi_endproc
 294              	.LFE1039:
 296              		.section	.text.GPIO_ResetBits,"ax",%progbits
 297              		.align	1
ARM GAS  /tmp/cc2wwjO4.s 			page 11


 298              		.syntax unified
 299              		.thumb
 300              		.thumb_func
 302              	GPIO_ResetBits:
 303              	.LVL22:
 304              	.LFB1040:
 239:./drivers/gpio/stm32f4_gpio.c **** 
 240:./drivers/gpio/stm32f4_gpio.c **** // 复位GPIO引脚
 241:./drivers/gpio/stm32f4_gpio.c **** static void GPIO_ResetBits(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) {
 305              		.loc 1 241 68 is_stmt 1 view -0
 306              		.cfi_startproc
 307              		@ args = 0, pretend = 0, frame = 0
 308              		@ frame_needed = 0, uses_anonymous_args = 0
 309              		@ link register save eliminated.
 242:./drivers/gpio/stm32f4_gpio.c ****     GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 310              		.loc 1 242 5 view .LVU98
 311              		.loc 1 242 38 is_stmt 0 view .LVU99
 312 0000 0904     		lsls	r1, r1, #16
 313              	.LVL23:
 314              		.loc 1 242 17 view .LVU100
 315 0002 8161     		str	r1, [r0, #24]
 243:./drivers/gpio/stm32f4_gpio.c **** }
 316              		.loc 1 243 1 view .LVU101
 317 0004 7047     		bx	lr
 318              		.cfi_endproc
 319              	.LFE1040:
 321              		.section	.text.GPIO_ReadInputDataBit,"ax",%progbits
 322              		.align	1
 323              		.syntax unified
 324              		.thumb
 325              		.thumb_func
 327              	GPIO_ReadInputDataBit:
 328              	.LVL24:
 329              	.LFB1041:
 244:./drivers/gpio/stm32f4_gpio.c **** 
 245:./drivers/gpio/stm32f4_gpio.c **** // 读取输入数据位
 246:./drivers/gpio/stm32f4_gpio.c **** static uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) {
 330              		.loc 1 246 78 is_stmt 1 view -0
 331              		.cfi_startproc
 332              		@ args = 0, pretend = 0, frame = 0
 333              		@ frame_needed = 0, uses_anonymous_args = 0
 334              		@ link register save eliminated.
 247:./drivers/gpio/stm32f4_gpio.c ****     return ((GPIOx->IDR & GPIO_Pin) != 0) ? 1 : 0;
 335              		.loc 1 247 5 view .LVU103
 336              		.loc 1 247 19 is_stmt 0 view .LVU104
 337 0000 0369     		ldr	r3, [r0, #16]
 338              		.loc 1 247 47 view .LVU105
 339 0002 1942     		tst	r1, r3
 248:./drivers/gpio/stm32f4_gpio.c **** }
 340              		.loc 1 248 1 view .LVU106
 341 0004 14BF     		ite	ne
 342 0006 0120     		movne	r0, #1
 343              	.LVL25:
 344              		.loc 1 248 1 view .LVU107
 345 0008 0020     		moveq	r0, #0
 346 000a 7047     		bx	lr
 347              		.cfi_endproc
ARM GAS  /tmp/cc2wwjO4.s 			page 12


 348              	.LFE1041:
 350              		.section	.text.RCC_AHB1PeriphClockCmd,"ax",%progbits
 351              		.align	1
 352              		.syntax unified
 353              		.thumb
 354              		.thumb_func
 356              	RCC_AHB1PeriphClockCmd:
 357              	.LVL26:
 358              	.LFB1042:
 249:./drivers/gpio/stm32f4_gpio.c **** 
 250:./drivers/gpio/stm32f4_gpio.c **** // 使能GPIO时钟
 251:./drivers/gpio/stm32f4_gpio.c **** static void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, uint8_t NewState) {
 359              		.loc 1 251 79 is_stmt 1 view -0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 0
 362              		@ frame_needed = 0, uses_anonymous_args = 0
 363              		@ link register save eliminated.
 252:./drivers/gpio/stm32f4_gpio.c ****     if(NewState!= DISABLE) {
 364              		.loc 1 252 5 view .LVU109
 365              		.loc 1 252 7 is_stmt 0 view .LVU110
 366 0000 31B1     		cbz	r1, .L18
 253:./drivers/gpio/stm32f4_gpio.c ****         RCC_AHB1ENR |= RCC_AHB1Periph;
 367              		.loc 1 253 9 is_stmt 1 view .LVU111
 368 0002 074A     		ldr	r2, .L20
 369 0004 D2F83038 		ldr	r3, [r2, #2096]
 370              		.loc 1 253 21 is_stmt 0 view .LVU112
 371 0008 0343     		orrs	r3, r3, r0
 372 000a C2F83038 		str	r3, [r2, #2096]
 373 000e 7047     		bx	lr
 374              	.L18:
 254:./drivers/gpio/stm32f4_gpio.c ****     } else {
 255:./drivers/gpio/stm32f4_gpio.c ****         RCC_AHB1ENR &= ~RCC_AHB1Periph;
 375              		.loc 1 255 9 is_stmt 1 view .LVU113
 376 0010 034A     		ldr	r2, .L20
 377 0012 D2F83038 		ldr	r3, [r2, #2096]
 378              		.loc 1 255 21 is_stmt 0 view .LVU114
 379 0016 23EA0003 		bic	r3, r3, r0
 380 001a C2F83038 		str	r3, [r2, #2096]
 256:./drivers/gpio/stm32f4_gpio.c ****     }
 257:./drivers/gpio/stm32f4_gpio.c **** }
 381              		.loc 1 257 1 view .LVU115
 382 001e 7047     		bx	lr
 383              	.L21:
 384              		.align	2
 385              	.L20:
 386 0020 00300240 		.word	1073885184
 387              		.cfi_endproc
 388              	.LFE1042:
 390              		.section	.text.get_gpio_number,"ax",%progbits
 391              		.align	1
 392              		.syntax unified
 393              		.thumb
 394              		.thumb_func
 396              	get_gpio_number:
 397              	.LVL27:
 398              	.LFB1043:
 258:./drivers/gpio/stm32f4_gpio.c **** 
ARM GAS  /tmp/cc2wwjO4.s 			page 13


 259:./drivers/gpio/stm32f4_gpio.c **** // 获取GPIO编号
 260:./drivers/gpio/stm32f4_gpio.c **** static uint16_t gpio_pins[16] = {
 261:./drivers/gpio/stm32f4_gpio.c ****     GPIO_Pin_0, GPIO_Pin_1, GPIO_Pin_2, GPIO_Pin_3,
 262:./drivers/gpio/stm32f4_gpio.c ****     GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_7,
 263:./drivers/gpio/stm32f4_gpio.c ****     GPIO_Pin_8, GPIO_Pin_9, GPIO_Pin_10, GPIO_Pin_11,
 264:./drivers/gpio/stm32f4_gpio.c ****     GPIO_Pin_12, GPIO_Pin_13, GPIO_Pin_14, GPIO_Pin_15
 265:./drivers/gpio/stm32f4_gpio.c **** };
 266:./drivers/gpio/stm32f4_gpio.c **** 
 267:./drivers/gpio/stm32f4_gpio.c **** static uint16_t get_gpio_number(uint16_t pin) {
 399              		.loc 1 267 47 is_stmt 1 view -0
 400              		.cfi_startproc
 401              		@ args = 0, pretend = 0, frame = 0
 402              		@ frame_needed = 0, uses_anonymous_args = 0
 403              		@ link register save eliminated.
 268:./drivers/gpio/stm32f4_gpio.c ****     int i = pin % 16;
 404              		.loc 1 268 5 view .LVU117
 405              		.loc 1 268 9 is_stmt 0 view .LVU118
 406 0000 00F00F00 		and	r0, r0, #15
 407              	.LVL28:
 269:./drivers/gpio/stm32f4_gpio.c ****     return gpio_pins[i];
 408              		.loc 1 269 5 is_stmt 1 view .LVU119
 270:./drivers/gpio/stm32f4_gpio.c **** }
 409              		.loc 1 270 1 is_stmt 0 view .LVU120
 410 0004 014B     		ldr	r3, .L23
 411 0006 33F81000 		ldrh	r0, [r3, r0, lsl #1]
 412              	.LVL29:
 413              		.loc 1 270 1 view .LVU121
 414 000a 7047     		bx	lr
 415              	.L24:
 416              		.align	2
 417              	.L23:
 418 000c 00000000 		.word	gpio_pins
 419              		.cfi_endproc
 420              	.LFE1043:
 422              		.section	.text.get_gpio_type,"ax",%progbits
 423              		.align	1
 424              		.syntax unified
 425              		.thumb
 426              		.thumb_func
 428              	get_gpio_type:
 429              	.LVL30:
 430              	.LFB1044:
 271:./drivers/gpio/stm32f4_gpio.c **** 
 272:./drivers/gpio/stm32f4_gpio.c **** // 获取GPIO类型
 273:./drivers/gpio/stm32f4_gpio.c **** static GPIO_TypeDef* gpio_Types[11] = {
 274:./drivers/gpio/stm32f4_gpio.c ****     GPIOA, GPIOB, GPIOC, GPIOD,
 275:./drivers/gpio/stm32f4_gpio.c ****     GPIOE, GPIOF, GPIOG, GPIOH,
 276:./drivers/gpio/stm32f4_gpio.c ****     GPIOI, GPIOJ, GPIOK
 277:./drivers/gpio/stm32f4_gpio.c **** };
 278:./drivers/gpio/stm32f4_gpio.c **** 
 279:./drivers/gpio/stm32f4_gpio.c **** static GPIO_TypeDef *get_gpio_type(uint16_t pin) {
 431              		.loc 1 279 50 is_stmt 1 view -0
 432              		.cfi_startproc
 433              		@ args = 0, pretend = 0, frame = 0
 434              		@ frame_needed = 0, uses_anonymous_args = 0
 435              		@ link register save eliminated.
 280:./drivers/gpio/stm32f4_gpio.c ****     int i = pin / 16;
ARM GAS  /tmp/cc2wwjO4.s 			page 14


 436              		.loc 1 280 5 view .LVU123
 437              		.loc 1 280 17 is_stmt 0 view .LVU124
 438 0000 0309     		lsrs	r3, r0, #4
 439              	.LVL31:
 281:./drivers/gpio/stm32f4_gpio.c ****     if(i < 11) {
 440              		.loc 1 281 5 is_stmt 1 view .LVU125
 441              		.loc 1 281 7 is_stmt 0 view .LVU126
 442 0002 AF28     		cmp	r0, #175
 443 0004 03D8     		bhi	.L27
 282:./drivers/gpio/stm32f4_gpio.c ****         return gpio_Types[i];
 444              		.loc 1 282 9 is_stmt 1 view .LVU127
 445              		.loc 1 282 26 is_stmt 0 view .LVU128
 446 0006 034A     		ldr	r2, .L28
 447 0008 52F82300 		ldr	r0, [r2, r3, lsl #2]
 448              	.LVL32:
 449              		.loc 1 282 26 view .LVU129
 450 000c 7047     		bx	lr
 451              	.LVL33:
 452              	.L27:
 283:./drivers/gpio/stm32f4_gpio.c ****     }
 284:./drivers/gpio/stm32f4_gpio.c ****     else return NULL;
 453              		.loc 1 284 17 view .LVU130
 454 000e 0020     		movs	r0, #0
 455              	.LVL34:
 285:./drivers/gpio/stm32f4_gpio.c **** }
 456              		.loc 1 285 1 view .LVU131
 457 0010 7047     		bx	lr
 458              	.L29:
 459 0012 00BF     		.align	2
 460              	.L28:
 461 0014 00000000 		.word	gpio_Types
 462              		.cfi_endproc
 463              	.LFE1044:
 465              		.section	.text.Get_APB_RCC_Source,"ax",%progbits
 466              		.align	1
 467              		.syntax unified
 468              		.thumb
 469              		.thumb_func
 471              	Get_APB_RCC_Source:
 472              	.LVL35:
 473              	.LFB1045:
 286:./drivers/gpio/stm32f4_gpio.c **** 
 287:./drivers/gpio/stm32f4_gpio.c **** // 获取RCC时钟源
 288:./drivers/gpio/stm32f4_gpio.c **** static uint32_t Get_APB_RCC_Source(GPIO_TypeDef *type) {
 474              		.loc 1 288 56 is_stmt 1 view -0
 475              		.cfi_startproc
 476              		@ args = 0, pretend = 0, frame = 0
 477              		@ frame_needed = 0, uses_anonymous_args = 0
 478              		@ link register save eliminated.
 289:./drivers/gpio/stm32f4_gpio.c ****     if(type == GPIOA)      return RCC_AHB1Periph_GPIOA;
 479              		.loc 1 289 5 view .LVU133
 480              		.loc 1 289 7 is_stmt 0 view .LVU134
 481 0000 234B     		ldr	r3, .L43
 482 0002 9842     		cmp	r0, r3
 483 0004 2AD0     		beq	.L32
 290:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOB) return RCC_AHB1Periph_GPIOB;
 484              		.loc 1 290 10 is_stmt 1 view .LVU135
ARM GAS  /tmp/cc2wwjO4.s 			page 15


 485              		.loc 1 290 12 is_stmt 0 view .LVU136
 486 0006 03F58063 		add	r3, r3, #1024
 487 000a 9842     		cmp	r0, r3
 488 000c 28D0     		beq	.L33
 291:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOC) return RCC_AHB1Periph_GPIOC;
 489              		.loc 1 291 10 is_stmt 1 view .LVU137
 490              		.loc 1 291 12 is_stmt 0 view .LVU138
 491 000e 03F58063 		add	r3, r3, #1024
 492 0012 9842     		cmp	r0, r3
 493 0014 26D0     		beq	.L34
 292:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOD) return RCC_AHB1Periph_GPIOD;
 494              		.loc 1 292 10 is_stmt 1 view .LVU139
 495              		.loc 1 292 12 is_stmt 0 view .LVU140
 496 0016 03F58063 		add	r3, r3, #1024
 497 001a 9842     		cmp	r0, r3
 498 001c 24D0     		beq	.L35
 293:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOE) return RCC_AHB1Periph_GPIOE;
 499              		.loc 1 293 10 is_stmt 1 view .LVU141
 500              		.loc 1 293 12 is_stmt 0 view .LVU142
 501 001e 03F58063 		add	r3, r3, #1024
 502 0022 9842     		cmp	r0, r3
 503 0024 22D0     		beq	.L36
 294:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOF) return RCC_AHB1Periph_GPIOF;
 504              		.loc 1 294 10 is_stmt 1 view .LVU143
 505              		.loc 1 294 12 is_stmt 0 view .LVU144
 506 0026 03F58063 		add	r3, r3, #1024
 507 002a 9842     		cmp	r0, r3
 508 002c 20D0     		beq	.L37
 295:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOG) return RCC_AHB1Periph_GPIOG;
 509              		.loc 1 295 10 is_stmt 1 view .LVU145
 510              		.loc 1 295 12 is_stmt 0 view .LVU146
 511 002e 03F58063 		add	r3, r3, #1024
 512 0032 9842     		cmp	r0, r3
 513 0034 1ED0     		beq	.L38
 296:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOH) return RCC_AHB1Periph_GPIOH;
 514              		.loc 1 296 10 is_stmt 1 view .LVU147
 515              		.loc 1 296 12 is_stmt 0 view .LVU148
 516 0036 03F58063 		add	r3, r3, #1024
 517 003a 9842     		cmp	r0, r3
 518 003c 1CD0     		beq	.L39
 297:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOI) return RCC_AHB1Periph_GPIOI;
 519              		.loc 1 297 10 is_stmt 1 view .LVU149
 520              		.loc 1 297 12 is_stmt 0 view .LVU150
 521 003e 03F58063 		add	r3, r3, #1024
 522 0042 9842     		cmp	r0, r3
 523 0044 1AD0     		beq	.L40
 298:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOJ) return RCC_AHB1Periph_GPIOJ;
 524              		.loc 1 298 10 is_stmt 1 view .LVU151
 525              		.loc 1 298 12 is_stmt 0 view .LVU152
 526 0046 03F58063 		add	r3, r3, #1024
 527 004a 9842     		cmp	r0, r3
 528 004c 19D0     		beq	.L41
 299:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOK) return RCC_AHB1Periph_GPIOK;
 529              		.loc 1 299 10 is_stmt 1 view .LVU153
 530              		.loc 1 299 12 is_stmt 0 view .LVU154
 531 004e 03F58063 		add	r3, r3, #1024
 532 0052 9842     		cmp	r0, r3
ARM GAS  /tmp/cc2wwjO4.s 			page 16


 533 0054 18D0     		beq	.L42
 300:./drivers/gpio/stm32f4_gpio.c ****     return 0xffffffff;
 534              		.loc 1 300 12 view .LVU155
 535 0056 4FF0FF30 		mov	r0, #-1
 536              	.LVL36:
 537              		.loc 1 300 12 view .LVU156
 538 005a 7047     		bx	lr
 539              	.LVL37:
 540              	.L32:
 289:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOB) return RCC_AHB1Periph_GPIOB;
 541              		.loc 1 289 35 discriminator 1 view .LVU157
 542 005c 0120     		movs	r0, #1
 543              	.LVL38:
 289:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOB) return RCC_AHB1Periph_GPIOB;
 544              		.loc 1 289 35 discriminator 1 view .LVU158
 545 005e 7047     		bx	lr
 546              	.LVL39:
 547              	.L33:
 290:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOC) return RCC_AHB1Periph_GPIOC;
 548              		.loc 1 290 35 discriminator 1 view .LVU159
 549 0060 0220     		movs	r0, #2
 550              	.LVL40:
 290:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOC) return RCC_AHB1Periph_GPIOC;
 551              		.loc 1 290 35 discriminator 1 view .LVU160
 552 0062 7047     		bx	lr
 553              	.LVL41:
 554              	.L34:
 291:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOD) return RCC_AHB1Periph_GPIOD;
 555              		.loc 1 291 35 discriminator 1 view .LVU161
 556 0064 0420     		movs	r0, #4
 557              	.LVL42:
 291:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOD) return RCC_AHB1Periph_GPIOD;
 558              		.loc 1 291 35 discriminator 1 view .LVU162
 559 0066 7047     		bx	lr
 560              	.LVL43:
 561              	.L35:
 292:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOE) return RCC_AHB1Periph_GPIOE;
 562              		.loc 1 292 35 discriminator 1 view .LVU163
 563 0068 0820     		movs	r0, #8
 564              	.LVL44:
 292:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOE) return RCC_AHB1Periph_GPIOE;
 565              		.loc 1 292 35 discriminator 1 view .LVU164
 566 006a 7047     		bx	lr
 567              	.LVL45:
 568              	.L36:
 293:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOF) return RCC_AHB1Periph_GPIOF;
 569              		.loc 1 293 35 discriminator 1 view .LVU165
 570 006c 1020     		movs	r0, #16
 571              	.LVL46:
 293:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOF) return RCC_AHB1Periph_GPIOF;
 572              		.loc 1 293 35 discriminator 1 view .LVU166
 573 006e 7047     		bx	lr
 574              	.LVL47:
 575              	.L37:
 294:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOG) return RCC_AHB1Periph_GPIOG;
 576              		.loc 1 294 35 discriminator 1 view .LVU167
 577 0070 2020     		movs	r0, #32
ARM GAS  /tmp/cc2wwjO4.s 			page 17


 578              	.LVL48:
 294:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOG) return RCC_AHB1Periph_GPIOG;
 579              		.loc 1 294 35 discriminator 1 view .LVU168
 580 0072 7047     		bx	lr
 581              	.LVL49:
 582              	.L38:
 295:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOH) return RCC_AHB1Periph_GPIOH;
 583              		.loc 1 295 35 discriminator 1 view .LVU169
 584 0074 4020     		movs	r0, #64
 585              	.LVL50:
 295:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOH) return RCC_AHB1Periph_GPIOH;
 586              		.loc 1 295 35 discriminator 1 view .LVU170
 587 0076 7047     		bx	lr
 588              	.LVL51:
 589              	.L39:
 296:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOI) return RCC_AHB1Periph_GPIOI;
 590              		.loc 1 296 35 discriminator 1 view .LVU171
 591 0078 8020     		movs	r0, #128
 592              	.LVL52:
 296:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOI) return RCC_AHB1Periph_GPIOI;
 593              		.loc 1 296 35 discriminator 1 view .LVU172
 594 007a 7047     		bx	lr
 595              	.LVL53:
 596              	.L40:
 297:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOJ) return RCC_AHB1Periph_GPIOJ;
 597              		.loc 1 297 35 discriminator 1 view .LVU173
 598 007c 4FF48070 		mov	r0, #256
 599              	.LVL54:
 297:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOJ) return RCC_AHB1Periph_GPIOJ;
 600              		.loc 1 297 35 discriminator 1 view .LVU174
 601 0080 7047     		bx	lr
 602              	.LVL55:
 603              	.L41:
 298:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOK) return RCC_AHB1Periph_GPIOK;
 604              		.loc 1 298 35 discriminator 1 view .LVU175
 605 0082 4FF40070 		mov	r0, #512
 606              	.LVL56:
 298:./drivers/gpio/stm32f4_gpio.c ****     else if(type == GPIOK) return RCC_AHB1Periph_GPIOK;
 607              		.loc 1 298 35 discriminator 1 view .LVU176
 608 0086 7047     		bx	lr
 609              	.LVL57:
 610              	.L42:
 299:./drivers/gpio/stm32f4_gpio.c ****     return 0xffffffff;
 611              		.loc 1 299 35 discriminator 1 view .LVU177
 612 0088 4FF48060 		mov	r0, #1024
 613              	.LVL58:
 301:./drivers/gpio/stm32f4_gpio.c **** }
 614              		.loc 1 301 1 view .LVU178
 615 008c 7047     		bx	lr
 616              	.L44:
 617 008e 00BF     		.align	2
 618              	.L43:
 619 0090 00000240 		.word	1073872896
 620              		.cfi_endproc
 621              	.LFE1045:
 623              		.section	.text.GPIO_GetAF,"ax",%progbits
 624              		.align	1
ARM GAS  /tmp/cc2wwjO4.s 			page 18


 625              		.syntax unified
 626              		.thumb
 627              		.thumb_func
 629              	GPIO_GetAF:
 630              	.LVL59:
 631              	.LFB1046:
 302:./drivers/gpio/stm32f4_gpio.c **** 
 303:./drivers/gpio/stm32f4_gpio.c **** 
 304:./drivers/gpio/stm32f4_gpio.c **** // 获取引脚当前复用功能
 305:./drivers/gpio/stm32f4_gpio.c **** static uint8_t GPIO_GetAF(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) {
 632              		.loc 1 305 67 is_stmt 1 view -0
 633              		.cfi_startproc
 634              		@ args = 0, pretend = 0, frame = 0
 635              		@ frame_needed = 0, uses_anonymous_args = 0
 636              		@ link register save eliminated.
 306:./drivers/gpio/stm32f4_gpio.c ****     uint32_t pinpos = 0;
 637              		.loc 1 306 5 view .LVU180
 307:./drivers/gpio/stm32f4_gpio.c ****     while((GPIO_Pin >> pinpos) != 1) { pinpos++; }
 638              		.loc 1 307 5 view .LVU181
 306:./drivers/gpio/stm32f4_gpio.c ****     uint32_t pinpos = 0;
 639              		.loc 1 306 14 is_stmt 0 view .LVU182
 640 0000 0023     		movs	r3, #0
 641              		.loc 1 307 10 view .LVU183
 642 0002 00E0     		b	.L46
 643              	.LVL60:
 644              	.L47:
 645              		.loc 1 307 40 is_stmt 1 discriminator 2 view .LVU184
 646              		.loc 1 307 46 is_stmt 0 discriminator 2 view .LVU185
 647 0004 0133     		adds	r3, r3, #1
 648              	.LVL61:
 649              	.L46:
 650              		.loc 1 307 32 is_stmt 1 discriminator 1 view .LVU186
 651              		.loc 1 307 21 is_stmt 0 discriminator 1 view .LVU187
 652 0006 41FA03F2 		asr	r2, r1, r3
 653              		.loc 1 307 32 discriminator 1 view .LVU188
 654 000a 012A     		cmp	r2, #1
 655 000c FAD1     		bne	.L47
 308:./drivers/gpio/stm32f4_gpio.c ****     
 309:./drivers/gpio/stm32f4_gpio.c ****     if(pinpos < 8) {
 656              		.loc 1 309 5 is_stmt 1 view .LVU189
 657              		.loc 1 309 7 is_stmt 0 view .LVU190
 658 000e 072B     		cmp	r3, #7
 659 0010 05D8     		bhi	.L48
 310:./drivers/gpio/stm32f4_gpio.c ****         return (GPIOx->AFR[0] >> (pinpos * 4)) & 0xF;
 660              		.loc 1 310 9 is_stmt 1 view .LVU191
 661              		.loc 1 310 27 is_stmt 0 view .LVU192
 662 0012 006A     		ldr	r0, [r0, #32]
 663              	.LVL62:
 664              		.loc 1 310 42 view .LVU193
 665 0014 9B00     		lsls	r3, r3, #2
 666              	.LVL63:
 667              		.loc 1 310 31 view .LVU194
 668 0016 D840     		lsrs	r0, r0, r3
 669              		.loc 1 310 48 view .LVU195
 670 0018 00F00F00 		and	r0, r0, #15
 671 001c 7047     		bx	lr
 672              	.LVL64:
ARM GAS  /tmp/cc2wwjO4.s 			page 19


 673              	.L48:
 311:./drivers/gpio/stm32f4_gpio.c ****     } else {
 312:./drivers/gpio/stm32f4_gpio.c ****         return (GPIOx->AFR[1] >> ((pinpos-8) * 4)) & 0xF;
 674              		.loc 1 312 9 is_stmt 1 view .LVU196
 675              		.loc 1 312 27 is_stmt 0 view .LVU197
 676 001e 406A     		ldr	r0, [r0, #36]
 677              	.LVL65:
 678              		.loc 1 312 42 view .LVU198
 679 0020 083B     		subs	r3, r3, #8
 680              	.LVL66:
 681              		.loc 1 312 46 view .LVU199
 682 0022 9B00     		lsls	r3, r3, #2
 683              	.LVL67:
 684              		.loc 1 312 31 view .LVU200
 685 0024 D840     		lsrs	r0, r0, r3
 686              		.loc 1 312 52 view .LVU201
 687 0026 00F00F00 		and	r0, r0, #15
 313:./drivers/gpio/stm32f4_gpio.c ****     }
 314:./drivers/gpio/stm32f4_gpio.c **** }
 688              		.loc 1 314 1 view .LVU202
 689 002a 7047     		bx	lr
 690              		.cfi_endproc
 691              	.LFE1046:
 693              		.section	.rodata.gpio_write.str1.4,"aMS",%progbits,1
 694              		.align	2
 695              	.LC0:
 696 0000 706C6561 		.ascii	"please use ioctl to set pin number first\012\015\000"
 696      73652075 
 696      73652069 
 696      6F63746C 
 696      20746F20 
 697 002b 00       		.align	2
 698              	.LC1:
 699 002c 6572726F 		.ascii	"error input\012\015\000"
 699      7220696E 
 699      7075740A 
 699      0D00
 700              		.section	.text.gpio_write,"ax",%progbits
 701              		.align	1
 702              		.syntax unified
 703              		.thumb
 704              		.thumb_func
 706              	gpio_write:
 707              	.LVL68:
 708              	.LFB1048:
 315:./drivers/gpio/stm32f4_gpio.c **** 
 316:./drivers/gpio/stm32f4_gpio.c **** 
 317:./drivers/gpio/stm32f4_gpio.c **** 
 318:./drivers/gpio/stm32f4_gpio.c **** // 文件操作函数
 319:./drivers/gpio/stm32f4_gpio.c **** static int gpio_open(struct inode *inode, struct file *file) {
 320:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = kmalloc(sizeof(struct gpio_device), GFP_KERNEL);
 321:./drivers/gpio/stm32f4_gpio.c ****     if(device == NULL) return -ENOMEM;
 322:./drivers/gpio/stm32f4_gpio.c ****     device->gpio_number = 0xffff;
 323:./drivers/gpio/stm32f4_gpio.c ****     device->gpio_type = NULL;
 324:./drivers/gpio/stm32f4_gpio.c ****     file->private_data = device;
 325:./drivers/gpio/stm32f4_gpio.c ****     printk("open gpios device\n\r");
 326:./drivers/gpio/stm32f4_gpio.c ****     return 0;
ARM GAS  /tmp/cc2wwjO4.s 			page 20


 327:./drivers/gpio/stm32f4_gpio.c **** }
 328:./drivers/gpio/stm32f4_gpio.c **** 
 329:./drivers/gpio/stm32f4_gpio.c **** static int gpio_write(struct file *file, const char __user *buf, size_t len, loff_t *offset) {
 709              		.loc 1 329 94 is_stmt 1 view -0
 710              		.cfi_startproc
 711              		@ args = 0, pretend = 0, frame = 0
 712              		@ frame_needed = 0, uses_anonymous_args = 0
 713              		.loc 1 329 94 is_stmt 0 view .LVU204
 714 0000 10B5     		push	{r4, lr}
 715              	.LCFI1:
 716              		.cfi_def_cfa_offset 8
 717              		.cfi_offset 4, -8
 718              		.cfi_offset 14, -4
 719 0002 1446     		mov	r4, r2
 330:./drivers/gpio/stm32f4_gpio.c ****     char buf_local = ((char*)buf)[0];
 720              		.loc 1 330 5 is_stmt 1 view .LVU205
 721              		.loc 1 330 10 is_stmt 0 view .LVU206
 722 0004 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 723              	.LVL69:
 331:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = file->private_data;
 724              		.loc 1 331 5 is_stmt 1 view .LVU207
 725              		.loc 1 331 25 is_stmt 0 view .LVU208
 726 0006 836A     		ldr	r3, [r0, #40]
 727              	.LVL70:
 332:./drivers/gpio/stm32f4_gpio.c **** 
 333:./drivers/gpio/stm32f4_gpio.c ****     if(device->gpio_number == 0xffff) {
 728              		.loc 1 333 5 is_stmt 1 view .LVU209
 729              		.loc 1 333 14 is_stmt 0 view .LVU210
 730 0008 1988     		ldrh	r1, [r3]
 731              	.LVL71:
 732              		.loc 1 333 7 view .LVU211
 733 000a 4FF6FF70 		movw	r0, #65535
 734              	.LVL72:
 735              		.loc 1 333 7 view .LVU212
 736 000e 8142     		cmp	r1, r0
 737 0010 08D0     		beq	.L57
 334:./drivers/gpio/stm32f4_gpio.c ****         printk("please use ioctl to set pin number first\n\r");
 335:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 336:./drivers/gpio/stm32f4_gpio.c ****     }
 337:./drivers/gpio/stm32f4_gpio.c **** 
 338:./drivers/gpio/stm32f4_gpio.c ****     if(buf_local == '0') {
 738              		.loc 1 338 5 is_stmt 1 view .LVU213
 739              		.loc 1 338 7 is_stmt 0 view .LVU214
 740 0012 302A     		cmp	r2, #48
 741 0014 0CD0     		beq	.L58
 339:./drivers/gpio/stm32f4_gpio.c ****         GPIO_ResetBits(device->gpio_type, device->gpio_number);
 340:./drivers/gpio/stm32f4_gpio.c ****     }
 341:./drivers/gpio/stm32f4_gpio.c ****     else if(buf_local == '1') {
 742              		.loc 1 341 10 is_stmt 1 view .LVU215
 743              		.loc 1 341 12 is_stmt 0 view .LVU216
 744 0016 312A     		cmp	r2, #49
 745 0018 0ED1     		bne	.L55
 342:./drivers/gpio/stm32f4_gpio.c ****         GPIO_SetBits(device->gpio_type, device->gpio_number);
 746              		.loc 1 342 9 is_stmt 1 view .LVU217
 747 001a 5868     		ldr	r0, [r3, #4]
 748 001c FFF7FEFF 		bl	GPIO_SetBits
 749              	.LVL73:
ARM GAS  /tmp/cc2wwjO4.s 			page 21


 750              	.L54:
 343:./drivers/gpio/stm32f4_gpio.c ****     }
 344:./drivers/gpio/stm32f4_gpio.c ****     else {
 345:./drivers/gpio/stm32f4_gpio.c ****         printk("error input\n\r");
 346:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 347:./drivers/gpio/stm32f4_gpio.c ****     }
 348:./drivers/gpio/stm32f4_gpio.c **** 
 349:./drivers/gpio/stm32f4_gpio.c ****     return len;
 751              		.loc 1 349 5 view .LVU218
 752              		.loc 1 349 12 is_stmt 0 view .LVU219
 753 0020 2046     		mov	r0, r4
 754              	.L50:
 350:./drivers/gpio/stm32f4_gpio.c **** }
 755              		.loc 1 350 1 view .LVU220
 756 0022 10BD     		pop	{r4, pc}
 757              	.LVL74:
 758              	.L57:
 334:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 759              		.loc 1 334 9 is_stmt 1 view .LVU221
 760 0024 0748     		ldr	r0, .L59
 761 0026 FFF7FEFF 		bl	printk
 762              	.LVL75:
 335:./drivers/gpio/stm32f4_gpio.c ****     }
 763              		.loc 1 335 9 view .LVU222
 335:./drivers/gpio/stm32f4_gpio.c ****     }
 764              		.loc 1 335 16 is_stmt 0 view .LVU223
 765 002a 6FF01500 		mvn	r0, #21
 766 002e F8E7     		b	.L50
 767              	.LVL76:
 768              	.L58:
 339:./drivers/gpio/stm32f4_gpio.c ****     }
 769              		.loc 1 339 9 is_stmt 1 view .LVU224
 770 0030 5868     		ldr	r0, [r3, #4]
 771 0032 FFF7FEFF 		bl	GPIO_ResetBits
 772              	.LVL77:
 339:./drivers/gpio/stm32f4_gpio.c ****     }
 773              		.loc 1 339 9 is_stmt 0 view .LVU225
 774 0036 F3E7     		b	.L54
 775              	.LVL78:
 776              	.L55:
 345:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 777              		.loc 1 345 9 is_stmt 1 view .LVU226
 778 0038 0348     		ldr	r0, .L59+4
 779 003a FFF7FEFF 		bl	printk
 780              	.LVL79:
 346:./drivers/gpio/stm32f4_gpio.c ****     }
 781              		.loc 1 346 9 view .LVU227
 346:./drivers/gpio/stm32f4_gpio.c ****     }
 782              		.loc 1 346 16 is_stmt 0 view .LVU228
 783 003e 6FF01500 		mvn	r0, #21
 784 0042 EEE7     		b	.L50
 785              	.L60:
 786              		.align	2
 787              	.L59:
 788 0044 00000000 		.word	.LC0
 789 0048 2C000000 		.word	.LC1
 790              		.cfi_endproc
ARM GAS  /tmp/cc2wwjO4.s 			page 22


 791              	.LFE1048:
 793              		.section	.text.gpio_release,"ax",%progbits
 794              		.align	1
 795              		.syntax unified
 796              		.thumb
 797              		.thumb_func
 799              	gpio_release:
 800              	.LVL80:
 801              	.LFB1050:
 351:./drivers/gpio/stm32f4_gpio.c **** 
 352:./drivers/gpio/stm32f4_gpio.c **** static int gpio_read(struct file *file, char __user *buf, size_t len, loff_t *offset) {
 353:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = file->private_data;
 354:./drivers/gpio/stm32f4_gpio.c ****     if(device->gpio_number == 0xffff) {
 355:./drivers/gpio/stm32f4_gpio.c ****         printk("please use ioctl to set pin number first\n\r");
 356:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 357:./drivers/gpio/stm32f4_gpio.c ****     }
 358:./drivers/gpio/stm32f4_gpio.c ****     int value = GPIO_ReadInputDataBit(device->gpio_type, device->gpio_number);
 359:./drivers/gpio/stm32f4_gpio.c ****     if(value == 0) {
 360:./drivers/gpio/stm32f4_gpio.c ****         copy_to_user(buf, "0", 1);
 361:./drivers/gpio/stm32f4_gpio.c ****         printk("gpio input value is 0\n\r");
 362:./drivers/gpio/stm32f4_gpio.c ****     }
 363:./drivers/gpio/stm32f4_gpio.c ****     else {
 364:./drivers/gpio/stm32f4_gpio.c ****         copy_to_user(buf, "1", 1);
 365:./drivers/gpio/stm32f4_gpio.c ****         printk("gpio input value is 1\n\r");
 366:./drivers/gpio/stm32f4_gpio.c ****     }
 367:./drivers/gpio/stm32f4_gpio.c ****     return len;
 368:./drivers/gpio/stm32f4_gpio.c **** }
 369:./drivers/gpio/stm32f4_gpio.c **** 
 370:./drivers/gpio/stm32f4_gpio.c **** static int gpio_release(struct inode *inode, struct file *file) {
 802              		.loc 1 370 65 is_stmt 1 view -0
 803              		.cfi_startproc
 804              		@ args = 0, pretend = 0, frame = 0
 805              		@ frame_needed = 0, uses_anonymous_args = 0
 806              		.loc 1 370 65 is_stmt 0 view .LVU230
 807 0000 08B5     		push	{r3, lr}
 808              	.LCFI2:
 809              		.cfi_def_cfa_offset 8
 810              		.cfi_offset 3, -8
 811              		.cfi_offset 14, -4
 371:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = file->private_data;
 812              		.loc 1 371 5 is_stmt 1 view .LVU231
 813              	.LVL81:
 372:./drivers/gpio/stm32f4_gpio.c ****     kfree(device);
 814              		.loc 1 372 5 view .LVU232
 815              	.LBB16:
 816              	.LBI16:
 817              		.file 2 "./include/linux/slab.h"
   1:./include/linux/slab.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/slab.h **** /*
   3:./include/linux/slab.h ****  * Written by Mark Hemment, 1996 (markhe@nextd.demon.co.uk).
   4:./include/linux/slab.h ****  *
   5:./include/linux/slab.h ****  * (C) SGI 2006, Christoph Lameter
   6:./include/linux/slab.h ****  * 	Cleaned up and restructured to ease the addition of alternative
   7:./include/linux/slab.h ****  * 	implementations of SLAB allocators.
   8:./include/linux/slab.h ****  * (C) Linux Foundation 2008-2013
   9:./include/linux/slab.h ****  *      Unified interface for all slab allocators
  10:./include/linux/slab.h ****  */
ARM GAS  /tmp/cc2wwjO4.s 			page 23


  11:./include/linux/slab.h **** 
  12:./include/linux/slab.h **** #ifndef _LINUX_SLAB_H
  13:./include/linux/slab.h **** #define	_LINUX_SLAB_H
  14:./include/linux/slab.h **** 
  15:./include/linux/slab.h **** #include <linux/cache.h>
  16:./include/linux/slab.h **** #include <linux/overflow.h>
  17:./include/linux/slab.h **** #include <linux/types.h>
  18:./include/linux/slab.h **** #include <linux/raid/pq.h>
  19:./include/linux/slab.h **** #include <linux/gfp_types.h>
  20:./include/linux/slab.h **** #include <linux/numa.h>
  21:./include/linux/slab.h **** #include <linux/reciprocal_div.h>
  22:./include/linux/slab.h **** #include <linux/spinlock.h>
  23:./include/linux/slab.h **** 
  24:./include/linux/slab.h **** enum _slab_flag_bits {
  25:./include/linux/slab.h **** 	_SLAB_CONSISTENCY_CHECKS,
  26:./include/linux/slab.h **** 	_SLAB_RED_ZONE,
  27:./include/linux/slab.h **** 	_SLAB_POISON,
  28:./include/linux/slab.h **** 	_SLAB_KMALLOC,
  29:./include/linux/slab.h **** 	_SLAB_HWCACHE_ALIGN,
  30:./include/linux/slab.h **** 	_SLAB_CACHE_DMA,
  31:./include/linux/slab.h **** 	_SLAB_CACHE_DMA32,
  32:./include/linux/slab.h **** 	_SLAB_STORE_USER,
  33:./include/linux/slab.h **** 	_SLAB_PANIC,
  34:./include/linux/slab.h **** 	_SLAB_TYPESAFE_BY_RCU,
  35:./include/linux/slab.h **** 	_SLAB_TRACE,
  36:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
  37:./include/linux/slab.h **** 	_SLAB_DEBUG_OBJECTS,
  38:./include/linux/slab.h **** #endif
  39:./include/linux/slab.h **** 	_SLAB_NOLEAKTRACE,
  40:./include/linux/slab.h **** 	_SLAB_NO_MERGE,
  41:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
  42:./include/linux/slab.h **** 	_SLAB_FAILSLAB,
  43:./include/linux/slab.h **** #endif
  44:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
  45:./include/linux/slab.h **** 	_SLAB_ACCOUNT,
  46:./include/linux/slab.h **** #endif
  47:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
  48:./include/linux/slab.h **** 	_SLAB_KASAN,
  49:./include/linux/slab.h **** #endif
  50:./include/linux/slab.h **** 	_SLAB_NO_USER_FLAGS,
  51:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
  52:./include/linux/slab.h **** 	_SLAB_SKIP_KFENCE,
  53:./include/linux/slab.h **** #endif
  54:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
  55:./include/linux/slab.h **** 	_SLAB_RECLAIM_ACCOUNT,
  56:./include/linux/slab.h **** #endif
  57:./include/linux/slab.h **** 	_SLAB_OBJECT_POISON,
  58:./include/linux/slab.h **** 	_SLAB_CMPXCHG_DOUBLE,
  59:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
  60:./include/linux/slab.h **** 	_SLAB_NO_OBJ_EXT,
  61:./include/linux/slab.h **** #endif
  62:./include/linux/slab.h **** 	_SLAB_FLAGS_LAST_BIT
  63:./include/linux/slab.h **** };
  64:./include/linux/slab.h **** 
  65:./include/linux/slab.h **** 
  66:./include/linux/slab.h **** 
  67:./include/linux/slab.h **** #define __SLAB_FLAG_BIT(nr)	((slab_flags_t __force)(1U << (nr)))
ARM GAS  /tmp/cc2wwjO4.s 			page 24


  68:./include/linux/slab.h **** #define __SLAB_FLAG_UNUSED	((slab_flags_t __force)(0U))
  69:./include/linux/slab.h **** 
  70:./include/linux/slab.h **** /*
  71:./include/linux/slab.h ****  * Flags to pass to kmem_cache_create().
  72:./include/linux/slab.h ****  * The ones marked DEBUG need CONFIG_SLUB_DEBUG enabled, otherwise are no-op
  73:./include/linux/slab.h ****  */
  74:./include/linux/slab.h **** /* DEBUG: Perform (expensive) checks on alloc/free */
  75:./include/linux/slab.h **** #define SLAB_CONSISTENCY_CHECKS	__SLAB_FLAG_BIT(_SLAB_CONSISTENCY_CHECKS)
  76:./include/linux/slab.h **** /* DEBUG: Red zone objs in a cache */
  77:./include/linux/slab.h **** #define SLAB_RED_ZONE		__SLAB_FLAG_BIT(_SLAB_RED_ZONE)
  78:./include/linux/slab.h **** /* DEBUG: Poison objects */
  79:./include/linux/slab.h **** #define SLAB_POISON		__SLAB_FLAG_BIT(_SLAB_POISON)
  80:./include/linux/slab.h **** /* Indicate a kmalloc slab */
  81:./include/linux/slab.h **** #define SLAB_KMALLOC		__SLAB_FLAG_BIT(_SLAB_KMALLOC)
  82:./include/linux/slab.h **** /**
  83:./include/linux/slab.h ****  * define SLAB_HWCACHE_ALIGN - Align objects on cache line boundaries.
  84:./include/linux/slab.h ****  *
  85:./include/linux/slab.h ****  * Sufficiently large objects are aligned on cache line boundary. For object
  86:./include/linux/slab.h ****  * size smaller than a half of cache line size, the alignment is on the half of
  87:./include/linux/slab.h ****  * cache line size. In general, if object size is smaller than 1/2^n of cache
  88:./include/linux/slab.h ****  * line size, the alignment is adjusted to 1/2^n.
  89:./include/linux/slab.h ****  *
  90:./include/linux/slab.h ****  * If explicit alignment is also requested by the respective
  91:./include/linux/slab.h ****  * &struct kmem_cache_args field, the greater of both is alignments is applied.
  92:./include/linux/slab.h ****  */
  93:./include/linux/slab.h **** #define SLAB_HWCACHE_ALIGN	__SLAB_FLAG_BIT(_SLAB_HWCACHE_ALIGN)
  94:./include/linux/slab.h **** /* Use GFP_DMA memory */
  95:./include/linux/slab.h **** #define SLAB_CACHE_DMA		__SLAB_FLAG_BIT(_SLAB_CACHE_DMA)
  96:./include/linux/slab.h **** /* Use GFP_DMA32 memory */
  97:./include/linux/slab.h **** #define SLAB_CACHE_DMA32	__SLAB_FLAG_BIT(_SLAB_CACHE_DMA32)
  98:./include/linux/slab.h **** /* DEBUG: Store the last owner for bug hunting */
  99:./include/linux/slab.h **** #define SLAB_STORE_USER		__SLAB_FLAG_BIT(_SLAB_STORE_USER)
 100:./include/linux/slab.h **** /* Panic if kmem_cache_create() fails */
 101:./include/linux/slab.h **** #define SLAB_PANIC		__SLAB_FLAG_BIT(_SLAB_PANIC)
 102:./include/linux/slab.h **** /**
 103:./include/linux/slab.h ****  * define SLAB_TYPESAFE_BY_RCU - **WARNING** READ THIS!
 104:./include/linux/slab.h ****  *
 105:./include/linux/slab.h ****  * This delays freeing the SLAB page by a grace period, it does _NOT_
 106:./include/linux/slab.h ****  * delay object freeing. This means that if you do kmem_cache_free()
 107:./include/linux/slab.h ****  * that memory location is free to be reused at any time. Thus it may
 108:./include/linux/slab.h ****  * be possible to see another object there in the same RCU grace period.
 109:./include/linux/slab.h ****  *
 110:./include/linux/slab.h ****  * This feature only ensures the memory location backing the object
 111:./include/linux/slab.h ****  * stays valid, the trick to using this is relying on an independent
 112:./include/linux/slab.h ****  * object validation pass. Something like:
 113:./include/linux/slab.h ****  *
 114:./include/linux/slab.h ****  * ::
 115:./include/linux/slab.h ****  *
 116:./include/linux/slab.h ****  *  begin:
 117:./include/linux/slab.h ****  *   rcu_read_lock();
 118:./include/linux/slab.h ****  *   obj = lockless_lookup(key);
 119:./include/linux/slab.h ****  *   if (obj) {
 120:./include/linux/slab.h ****  *     if (!try_get_ref(obj)) // might fail for free objects
 121:./include/linux/slab.h ****  *       rcu_read_unlock();
 122:./include/linux/slab.h ****  *       goto begin;
 123:./include/linux/slab.h ****  *
 124:./include/linux/slab.h ****  *     if (obj->key != key) { // not the object we expected
ARM GAS  /tmp/cc2wwjO4.s 			page 25


 125:./include/linux/slab.h ****  *       put_ref(obj);
 126:./include/linux/slab.h ****  *       rcu_read_unlock();
 127:./include/linux/slab.h ****  *       goto begin;
 128:./include/linux/slab.h ****  *     }
 129:./include/linux/slab.h ****  *   }
 130:./include/linux/slab.h ****  *  rcu_read_unlock();
 131:./include/linux/slab.h ****  *
 132:./include/linux/slab.h ****  * This is useful if we need to approach a kernel structure obliquely,
 133:./include/linux/slab.h ****  * from its address obtained without the usual locking. We can lock
 134:./include/linux/slab.h ****  * the structure to stabilize it and check it's still at the given address,
 135:./include/linux/slab.h ****  * only if we can be sure that the memory has not been meanwhile reused
 136:./include/linux/slab.h ****  * for some other kind of object (which our subsystem's lock might corrupt).
 137:./include/linux/slab.h ****  *
 138:./include/linux/slab.h ****  * rcu_read_lock before reading the address, then rcu_read_unlock after
 139:./include/linux/slab.h ****  * taking the spinlock within the structure expected at that address.
 140:./include/linux/slab.h ****  *
 141:./include/linux/slab.h ****  * Note that it is not possible to acquire a lock within a structure
 142:./include/linux/slab.h ****  * allocated with SLAB_TYPESAFE_BY_RCU without first acquiring a reference
 143:./include/linux/slab.h ****  * as described above.  The reason is that SLAB_TYPESAFE_BY_RCU pages
 144:./include/linux/slab.h ****  * are not zeroed before being given to the slab, which means that any
 145:./include/linux/slab.h ****  * locks must be initialized after each and every kmem_struct_alloc().
 146:./include/linux/slab.h ****  * Alternatively, make the ctor passed to kmem_cache_create() initialize
 147:./include/linux/slab.h ****  * the locks at page-allocation time, as is done in __i915_request_ctor(),
 148:./include/linux/slab.h ****  * sighand_ctor(), and anon_vma_ctor().  Such a ctor permits readers
 149:./include/linux/slab.h ****  * to safely acquire those ctor-initialized locks under rcu_read_lock()
 150:./include/linux/slab.h ****  * protection.
 151:./include/linux/slab.h ****  *
 152:./include/linux/slab.h ****  * Note that SLAB_TYPESAFE_BY_RCU was originally named SLAB_DESTROY_BY_RCU.
 153:./include/linux/slab.h ****  */
 154:./include/linux/slab.h **** #define SLAB_TYPESAFE_BY_RCU	__SLAB_FLAG_BIT(_SLAB_TYPESAFE_BY_RCU)
 155:./include/linux/slab.h **** /* Trace allocations and frees */
 156:./include/linux/slab.h **** #define SLAB_TRACE		__SLAB_FLAG_BIT(_SLAB_TRACE)
 157:./include/linux/slab.h **** 
 158:./include/linux/slab.h **** /* Flag to prevent checks on free */
 159:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
 160:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_BIT(_SLAB_DEBUG_OBJECTS)
 161:./include/linux/slab.h **** #else
 162:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_UNUSED
 163:./include/linux/slab.h **** #endif
 164:./include/linux/slab.h **** 
 165:./include/linux/slab.h **** /* Avoid kmemleak tracing */
 166:./include/linux/slab.h **** #define SLAB_NOLEAKTRACE	__SLAB_FLAG_BIT(_SLAB_NOLEAKTRACE)
 167:./include/linux/slab.h **** 
 168:./include/linux/slab.h **** /*
 169:./include/linux/slab.h ****  * Prevent merging with compatible kmem caches. This flag should be used
 170:./include/linux/slab.h ****  * cautiously. Valid use cases:
 171:./include/linux/slab.h ****  *
 172:./include/linux/slab.h ****  * - caches created for self-tests (e.g. kunit)
 173:./include/linux/slab.h ****  * - general caches created and used by a subsystem, only when a
 174:./include/linux/slab.h ****  *   (subsystem-specific) debug option is enabled
 175:./include/linux/slab.h ****  * - performance critical caches, should be very rare and consulted with slab
 176:./include/linux/slab.h ****  *   maintainers, and not used together with CONFIG_SLUB_TINY
 177:./include/linux/slab.h ****  */
 178:./include/linux/slab.h **** #define SLAB_NO_MERGE		__SLAB_FLAG_BIT(_SLAB_NO_MERGE)
 179:./include/linux/slab.h **** 
 180:./include/linux/slab.h **** /* Fault injection mark */
 181:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
ARM GAS  /tmp/cc2wwjO4.s 			page 26


 182:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_BIT(_SLAB_FAILSLAB)
 183:./include/linux/slab.h **** #else
 184:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_UNUSED
 185:./include/linux/slab.h **** #endif
 186:./include/linux/slab.h **** /**
 187:./include/linux/slab.h ****  * define SLAB_ACCOUNT - Account allocations to memcg.
 188:./include/linux/slab.h ****  *
 189:./include/linux/slab.h ****  * All object allocations from this cache will be memcg accounted, regardless of
 190:./include/linux/slab.h ****  * __GFP_ACCOUNT being or not being passed to individual allocations.
 191:./include/linux/slab.h ****  */
 192:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
 193:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_BIT(_SLAB_ACCOUNT)
 194:./include/linux/slab.h **** #else
 195:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_UNUSED
 196:./include/linux/slab.h **** #endif
 197:./include/linux/slab.h **** 
 198:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
 199:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_BIT(_SLAB_KASAN)
 200:./include/linux/slab.h **** #else
 201:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_UNUSED
 202:./include/linux/slab.h **** #endif
 203:./include/linux/slab.h **** 
 204:./include/linux/slab.h **** /*
 205:./include/linux/slab.h ****  * Ignore user specified debugging flags.
 206:./include/linux/slab.h ****  * Intended for caches created for self-tests so they have only flags
 207:./include/linux/slab.h ****  * specified in the code and other flags are ignored.
 208:./include/linux/slab.h ****  */
 209:./include/linux/slab.h **** #define SLAB_NO_USER_FLAGS	__SLAB_FLAG_BIT(_SLAB_NO_USER_FLAGS)
 210:./include/linux/slab.h **** 
 211:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
 212:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_BIT(_SLAB_SKIP_KFENCE)
 213:./include/linux/slab.h **** #else
 214:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_UNUSED
 215:./include/linux/slab.h **** #endif
 216:./include/linux/slab.h **** 
 217:./include/linux/slab.h **** /* The following flags affect the page allocator grouping pages by mobility */
 218:./include/linux/slab.h **** /**
 219:./include/linux/slab.h ****  * define SLAB_RECLAIM_ACCOUNT - Objects are reclaimable.
 220:./include/linux/slab.h ****  *
 221:./include/linux/slab.h ****  * Use this flag for caches that have an associated shrinker. As a result, slab
 222:./include/linux/slab.h ****  * pages are allocated with __GFP_RECLAIMABLE, which affects grouping pages by
 223:./include/linux/slab.h ****  * mobility, and are accounted in SReclaimable counter in /proc/meminfo
 224:./include/linux/slab.h ****  */
 225:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
 226:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_BIT(_SLAB_RECLAIM_ACCOUNT)
 227:./include/linux/slab.h **** #else
 228:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_UNUSED
 229:./include/linux/slab.h **** #endif
 230:./include/linux/slab.h **** #define SLAB_TEMPORARY		SLAB_RECLAIM_ACCOUNT	/* Objects are short-lived */
 231:./include/linux/slab.h **** 
 232:./include/linux/slab.h **** /* Slab created using create_boot_cache */
 233:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
 234:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_BIT(_SLAB_NO_OBJ_EXT)
 235:./include/linux/slab.h **** #else
 236:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_UNUSED
 237:./include/linux/slab.h **** #endif
 238:./include/linux/slab.h **** 
ARM GAS  /tmp/cc2wwjO4.s 			page 27


 239:./include/linux/slab.h **** /*
 240:./include/linux/slab.h ****  * freeptr_t represents a SLUB freelist pointer, which might be encoded
 241:./include/linux/slab.h ****  * and not dereferenceable if CONFIG_SLAB_FREELIST_HARDENED is enabled.
 242:./include/linux/slab.h ****  */
 243:./include/linux/slab.h **** typedef struct { unsigned long v; } freeptr_t;
 244:./include/linux/slab.h **** 
 245:./include/linux/slab.h **** /*
 246:./include/linux/slab.h ****  * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.
 247:./include/linux/slab.h ****  *
 248:./include/linux/slab.h ****  * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault.
 249:./include/linux/slab.h ****  *
 250:./include/linux/slab.h ****  * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.
 251:./include/linux/slab.h ****  * Both make kfree a no-op.
 252:./include/linux/slab.h ****  */
 253:./include/linux/slab.h **** #define ZERO_SIZE_PTR ((void *)16)
 254:./include/linux/slab.h **** 
 255:./include/linux/slab.h **** #define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) <= \
 256:./include/linux/slab.h **** 				(unsigned long)ZERO_SIZE_PTR)
 257:./include/linux/slab.h **** 
 258:./include/linux/slab.h **** 
 259:./include/linux/slab.h **** 
 260:./include/linux/slab.h **** 
 261:./include/linux/slab.h **** 
 262:./include/linux/slab.h **** #ifdef CONFIG_SLUB_CPU_PARTIAL
 263:./include/linux/slab.h **** #define slub_percpu_partial(c)			((c)->partial)
 264:./include/linux/slab.h **** 
 265:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)		\
 266:./include/linux/slab.h **** ({						\
 267:./include/linux/slab.h **** 	slub_percpu_partial(c) = (p)->next;	\
 268:./include/linux/slab.h **** })
 269:./include/linux/slab.h **** 
 270:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	READ_ONCE(slub_percpu_partial(c))
 271:./include/linux/slab.h **** #else
 272:./include/linux/slab.h **** #define slub_percpu_partial(c)			NULL
 273:./include/linux/slab.h **** 
 274:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)
 275:./include/linux/slab.h **** 
 276:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	NULL
 277:./include/linux/slab.h **** 
 278:./include/linux/slab.h **** 
 279:./include/linux/slab.h **** #endif // CONFIG_SLUB_CPU_PARTIAL
 280:./include/linux/slab.h **** 
 281:./include/linux/slab.h **** /*
 282:./include/linux/slab.h **** 	* Word size structure that can be atomically updated or read and that
 283:./include/linux/slab.h **** 	* contains both the order and the number of objects that a slab of the
 284:./include/linux/slab.h **** 	* given order would contain.
 285:./include/linux/slab.h **** 	*/				
 286:./include/linux/slab.h **** struct kmem_cache_order_objects {
 287:./include/linux/slab.h **** 	unsigned int x;
 288:./include/linux/slab.h **** };
 289:./include/linux/slab.h **** 
 290:./include/linux/slab.h **** struct kmem_cache_node {
 291:./include/linux/slab.h **** 	spinlock_t list_lock;
 292:./include/linux/slab.h **** 	unsigned long nr_partial;
 293:./include/linux/slab.h **** 	struct list_head partial;
 294:./include/linux/slab.h **** #ifdef CONFIG_SLUB_DEBUG
 295:./include/linux/slab.h **** 	atomic_long_t nr_slabs;
ARM GAS  /tmp/cc2wwjO4.s 			page 28


 296:./include/linux/slab.h **** 	atomic_long_t total_objects;
 297:./include/linux/slab.h **** 	struct list_head full;
 298:./include/linux/slab.h **** #endif
 299:./include/linux/slab.h **** };
 300:./include/linux/slab.h **** 
 301:./include/linux/slab.h **** struct kmem_cache {
 302:./include/linux/slab.h **** 	#ifndef CONFIG_SLUB_TINY
 303:./include/linux/slab.h **** 	//	struct kmem_cache_cpu __percpu *cpu_slab;
 304:./include/linux/slab.h **** 	#endif
 305:./include/linux/slab.h **** 		/* Used for retrieving partial slabs, etc. */
 306:./include/linux/slab.h **** 		slab_flags_t flags;
 307:./include/linux/slab.h **** 		unsigned long min_partial;
 308:./include/linux/slab.h **** 		unsigned int size;		/* Object size including metadata */
 309:./include/linux/slab.h **** 		unsigned int object_size;	/* Object size without metadata */
 310:./include/linux/slab.h **** 		struct reciprocal_value reciprocal_size;
 311:./include/linux/slab.h **** 		unsigned int offset;		/* Free pointer offset */
 312:./include/linux/slab.h **** 	#ifdef CONFIG_SLUB_CPU_PARTIAL
 313:./include/linux/slab.h **** 		/* Number of per cpu partial objects to keep around */
 314:./include/linux/slab.h **** 		unsigned int cpu_partial;
 315:./include/linux/slab.h **** 		/* Number of per cpu partial slabs to keep around */
 316:./include/linux/slab.h **** 		unsigned int cpu_partial_slabs;
 317:./include/linux/slab.h **** 	#endif
 318:./include/linux/slab.h **** 		struct kmem_cache_order_objects oo;
 319:./include/linux/slab.h **** 	
 320:./include/linux/slab.h **** 		/* Allocation and freeing of slabs */
 321:./include/linux/slab.h **** 		struct kmem_cache_order_objects min;
 322:./include/linux/slab.h **** 		gfp_t allocflags;		/* gfp flags to use on each alloc */
 323:./include/linux/slab.h **** 		int refcount;			/* Refcount for slab cache destroy */
 324:./include/linux/slab.h **** 		void (*ctor)(void *object);	/* Object constructor */
 325:./include/linux/slab.h **** 		unsigned int inuse;		/* Offset to metadata */
 326:./include/linux/slab.h **** 		unsigned int align;		/* Alignment */
 327:./include/linux/slab.h **** 		unsigned int red_left_pad;	/* Left redzone padding size */
 328:./include/linux/slab.h **** 		const char *name;		/* Name (only for display!) */
 329:./include/linux/slab.h **** 		struct list_head list;		/* List of slab caches */
 330:./include/linux/slab.h **** 	#ifdef CONFIG_SYSFS
 331:./include/linux/slab.h **** 		struct kobject kobj;		/* For sysfs */
 332:./include/linux/slab.h **** 	#endif
 333:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_HARDENED
 334:./include/linux/slab.h **** 		unsigned long random;
 335:./include/linux/slab.h **** 	#endif
 336:./include/linux/slab.h **** 	
 337:./include/linux/slab.h **** 	#ifdef CONFIG_NUMA
 338:./include/linux/slab.h **** 		/*
 339:./include/linux/slab.h **** 			* Defragmentation by allocating from a remote node.
 340:./include/linux/slab.h **** 			*/
 341:./include/linux/slab.h **** 		unsigned int remote_node_defrag_ratio;
 342:./include/linux/slab.h **** 	#endif
 343:./include/linux/slab.h **** 	
 344:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_RANDOM
 345:./include/linux/slab.h **** 		unsigned int *random_seq;
 346:./include/linux/slab.h **** 	#endif
 347:./include/linux/slab.h **** 	
 348:./include/linux/slab.h **** 	#ifdef CONFIG_KASAN_GENERIC
 349:./include/linux/slab.h **** 		struct kasan_cache kasan_info;
 350:./include/linux/slab.h **** 	#endif
 351:./include/linux/slab.h **** 	
 352:./include/linux/slab.h **** 	#ifdef CONFIG_HARDENED_USERCOPY
ARM GAS  /tmp/cc2wwjO4.s 			page 29


 353:./include/linux/slab.h **** 		unsigned int useroffset;	/* Usercopy region offset */
 354:./include/linux/slab.h **** 		unsigned int usersize;		/* Usercopy region size */
 355:./include/linux/slab.h **** 	#endif
 356:./include/linux/slab.h **** 	
 357:./include/linux/slab.h **** 		struct kmem_cache_node *node[MAX_NUMNODES];
 358:./include/linux/slab.h **** 	};
 359:./include/linux/slab.h **** 					
 360:./include/linux/slab.h **** 
 361:./include/linux/slab.h **** 
 362:./include/linux/slab.h **** 
 363:./include/linux/slab.h **** 
 364:./include/linux/slab.h **** #define KMALLOC_WAIT 1
 365:./include/linux/slab.h **** 
 366:./include/linux/slab.h **** 
 367:./include/linux/slab.h **** extern void* __smalloc__(u32 size, gfp_t flags);
 368:./include/linux/slab.h **** extern void  __sfree__(void* addr);
 369:./include/linux/slab.h **** 
 370:./include/linux/slab.h **** 
 371:./include/linux/slab.h **** static void inline *vmalloc(unsigned long size){
 372:./include/linux/slab.h **** 	return __smalloc__(size,GFP_TRANSHUGE_LIGHT);
 373:./include/linux/slab.h **** }
 374:./include/linux/slab.h **** 
 375:./include/linux/slab.h **** static void inline vfree(void *addr){
 376:./include/linux/slab.h **** 	__sfree__(addr);
 377:./include/linux/slab.h **** }
 378:./include/linux/slab.h **** 
 379:./include/linux/slab.h **** static void inline *kmalloc(size_t size, gfp_t flags){
 380:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 381:./include/linux/slab.h **** }
 382:./include/linux/slab.h **** 
 383:./include/linux/slab.h **** static void inline kfree(const void *ptr){
 818              		.loc 2 383 20 view .LVU233
 819              	.LBB17:
 384:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 820              		.loc 2 384 2 view .LVU234
 821 0002 886A     		ldr	r0, [r1, #40]
 822              	.LVL82:
 823              		.loc 2 384 2 is_stmt 0 view .LVU235
 824 0004 FFF7FEFF 		bl	__sfree__
 825              	.LVL83:
 826              		.loc 2 384 2 view .LVU236
 827              	.LBE17:
 828              	.LBE16:
 373:./drivers/gpio/stm32f4_gpio.c ****     return 0;
 829              		.loc 1 373 5 is_stmt 1 view .LVU237
 374:./drivers/gpio/stm32f4_gpio.c **** }
 830              		.loc 1 374 1 is_stmt 0 view .LVU238
 831 0008 0020     		movs	r0, #0
 832 000a 08BD     		pop	{r3, pc}
 833              		.cfi_endproc
 834              	.LFE1050:
 836              		.section	.rodata.gpio_open.str1.4,"aMS",%progbits,1
 837              		.align	2
 838              	.LC2:
 839 0000 6F70656E 		.ascii	"open gpios device\012\015\000"
 839      20677069 
 839      6F732064 
ARM GAS  /tmp/cc2wwjO4.s 			page 30


 839      65766963 
 839      650A0D00 
 840              		.section	.text.gpio_open,"ax",%progbits
 841              		.align	1
 842              		.syntax unified
 843              		.thumb
 844              		.thumb_func
 846              	gpio_open:
 847              	.LVL84:
 848              	.LFB1047:
 319:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = kmalloc(sizeof(struct gpio_device), GFP_KERNEL);
 849              		.loc 1 319 62 is_stmt 1 view -0
 850              		.cfi_startproc
 851              		@ args = 0, pretend = 0, frame = 0
 852              		@ frame_needed = 0, uses_anonymous_args = 0
 319:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = kmalloc(sizeof(struct gpio_device), GFP_KERNEL);
 853              		.loc 1 319 62 is_stmt 0 view .LVU240
 854 0000 38B5     		push	{r3, r4, r5, lr}
 855              	.LCFI3:
 856              		.cfi_def_cfa_offset 16
 857              		.cfi_offset 3, -16
 858              		.cfi_offset 4, -12
 859              		.cfi_offset 5, -8
 860              		.cfi_offset 14, -4
 861 0002 0D46     		mov	r5, r1
 320:./drivers/gpio/stm32f4_gpio.c ****     if(device == NULL) return -ENOMEM;
 862              		.loc 1 320 5 is_stmt 1 view .LVU241
 863              	.LVL85:
 864              	.LBB18:
 865              	.LBI18:
 379:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 866              		.loc 2 379 21 view .LVU242
 867              	.LBB19:
 380:./include/linux/slab.h **** }
 868              		.loc 2 380 2 view .LVU243
 380:./include/linux/slab.h **** }
 869              		.loc 2 380 9 is_stmt 0 view .LVU244
 870 0004 4FF44C61 		mov	r1, #3264
 871              	.LVL86:
 380:./include/linux/slab.h **** }
 872              		.loc 2 380 9 view .LVU245
 873 0008 1420     		movs	r0, #20
 874              	.LVL87:
 380:./include/linux/slab.h **** }
 875              		.loc 2 380 9 view .LVU246
 876 000a FFF7FEFF 		bl	__smalloc__
 877              	.LVL88:
 380:./include/linux/slab.h **** }
 878              		.loc 2 380 9 view .LVU247
 879              	.LBE19:
 880              	.LBE18:
 321:./drivers/gpio/stm32f4_gpio.c ****     device->gpio_number = 0xffff;
 881              		.loc 1 321 5 is_stmt 1 view .LVU248
 321:./drivers/gpio/stm32f4_gpio.c ****     device->gpio_number = 0xffff;
 882              		.loc 1 321 7 is_stmt 0 view .LVU249
 883 000e 50B1     		cbz	r0, .L65
 322:./drivers/gpio/stm32f4_gpio.c ****     device->gpio_type = NULL;
ARM GAS  /tmp/cc2wwjO4.s 			page 31


 884              		.loc 1 322 5 is_stmt 1 view .LVU250
 322:./drivers/gpio/stm32f4_gpio.c ****     device->gpio_type = NULL;
 885              		.loc 1 322 25 is_stmt 0 view .LVU251
 886 0010 4FF6FF72 		movw	r2, #65535
 887 0014 0280     		strh	r2, [r0]	@ movhi
 323:./drivers/gpio/stm32f4_gpio.c ****     file->private_data = device;
 888              		.loc 1 323 5 is_stmt 1 view .LVU252
 323:./drivers/gpio/stm32f4_gpio.c ****     file->private_data = device;
 889              		.loc 1 323 23 is_stmt 0 view .LVU253
 890 0016 0024     		movs	r4, #0
 891 0018 4460     		str	r4, [r0, #4]
 324:./drivers/gpio/stm32f4_gpio.c ****     printk("open gpios device\n\r");
 892              		.loc 1 324 5 is_stmt 1 view .LVU254
 324:./drivers/gpio/stm32f4_gpio.c ****     printk("open gpios device\n\r");
 893              		.loc 1 324 24 is_stmt 0 view .LVU255
 894 001a A862     		str	r0, [r5, #40]
 325:./drivers/gpio/stm32f4_gpio.c ****     return 0;
 895              		.loc 1 325 5 is_stmt 1 view .LVU256
 896 001c 0348     		ldr	r0, .L67
 897              	.LVL89:
 325:./drivers/gpio/stm32f4_gpio.c ****     return 0;
 898              		.loc 1 325 5 is_stmt 0 view .LVU257
 899 001e FFF7FEFF 		bl	printk
 900              	.LVL90:
 326:./drivers/gpio/stm32f4_gpio.c **** }
 901              		.loc 1 326 5 is_stmt 1 view .LVU258
 326:./drivers/gpio/stm32f4_gpio.c **** }
 902              		.loc 1 326 12 is_stmt 0 view .LVU259
 903 0022 2046     		mov	r0, r4
 904              	.L63:
 327:./drivers/gpio/stm32f4_gpio.c **** 
 905              		.loc 1 327 1 view .LVU260
 906 0024 38BD     		pop	{r3, r4, r5, pc}
 907              	.LVL91:
 908              	.L65:
 321:./drivers/gpio/stm32f4_gpio.c ****     device->gpio_number = 0xffff;
 909              		.loc 1 321 31 discriminator 1 view .LVU261
 910 0026 6FF00B00 		mvn	r0, #11
 911              	.LVL92:
 321:./drivers/gpio/stm32f4_gpio.c ****     device->gpio_number = 0xffff;
 912              		.loc 1 321 31 discriminator 1 view .LVU262
 913 002a FBE7     		b	.L63
 914              	.L68:
 915              		.align	2
 916              	.L67:
 917 002c 00000000 		.word	.LC2
 918              		.cfi_endproc
 919              	.LFE1047:
 921              		.section	.rodata.gpio_read.str1.4,"aMS",%progbits,1
 922              		.align	2
 923              	.LC3:
 924 0000 6770696F 		.ascii	"gpio input value is 0\012\015\000"
 924      20696E70 
 924      75742076 
 924      616C7565 
 924      20697320 
 925              		.align	2
ARM GAS  /tmp/cc2wwjO4.s 			page 32


 926              	.LC4:
 927 0018 6770696F 		.ascii	"gpio input value is 1\012\015\000"
 927      20696E70 
 927      75742076 
 927      616C7565 
 927      20697320 
 928              		.section	.text.gpio_read,"ax",%progbits
 929              		.align	1
 930              		.syntax unified
 931              		.thumb
 932              		.thumb_func
 934              	gpio_read:
 935              	.LVL93:
 936              	.LFB1049:
 352:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = file->private_data;
 937              		.loc 1 352 87 is_stmt 1 view -0
 938              		.cfi_startproc
 939              		@ args = 0, pretend = 0, frame = 0
 940              		@ frame_needed = 0, uses_anonymous_args = 0
 352:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = file->private_data;
 941              		.loc 1 352 87 is_stmt 0 view .LVU264
 942 0000 38B5     		push	{r3, r4, r5, lr}
 943              	.LCFI4:
 944              		.cfi_def_cfa_offset 16
 945              		.cfi_offset 3, -16
 946              		.cfi_offset 4, -12
 947              		.cfi_offset 5, -8
 948              		.cfi_offset 14, -4
 949 0002 0D46     		mov	r5, r1
 353:./drivers/gpio/stm32f4_gpio.c ****     if(device->gpio_number == 0xffff) {
 950              		.loc 1 353 5 is_stmt 1 view .LVU265
 353:./drivers/gpio/stm32f4_gpio.c ****     if(device->gpio_number == 0xffff) {
 951              		.loc 1 353 25 is_stmt 0 view .LVU266
 952 0004 836A     		ldr	r3, [r0, #40]
 953              	.LVL94:
 354:./drivers/gpio/stm32f4_gpio.c ****         printk("please use ioctl to set pin number first\n\r");
 954              		.loc 1 354 5 is_stmt 1 view .LVU267
 354:./drivers/gpio/stm32f4_gpio.c ****         printk("please use ioctl to set pin number first\n\r");
 955              		.loc 1 354 14 is_stmt 0 view .LVU268
 956 0006 1988     		ldrh	r1, [r3]
 957              	.LVL95:
 354:./drivers/gpio/stm32f4_gpio.c ****         printk("please use ioctl to set pin number first\n\r");
 958              		.loc 1 354 7 view .LVU269
 959 0008 4FF6FF7C 		movw	ip, #65535
 960 000c 6145     		cmp	r1, ip
 961 000e 0BD0     		beq	.L75
 962 0010 1446     		mov	r4, r2
 358:./drivers/gpio/stm32f4_gpio.c ****     if(value == 0) {
 963              		.loc 1 358 5 is_stmt 1 view .LVU270
 358:./drivers/gpio/stm32f4_gpio.c ****     if(value == 0) {
 964              		.loc 1 358 17 is_stmt 0 view .LVU271
 965 0012 5868     		ldr	r0, [r3, #4]
 966              	.LVL96:
 358:./drivers/gpio/stm32f4_gpio.c ****     if(value == 0) {
 967              		.loc 1 358 17 view .LVU272
 968 0014 FFF7FEFF 		bl	GPIO_ReadInputDataBit
 969              	.LVL97:
ARM GAS  /tmp/cc2wwjO4.s 			page 33


 359:./drivers/gpio/stm32f4_gpio.c ****         copy_to_user(buf, "0", 1);
 970              		.loc 1 359 5 is_stmt 1 view .LVU273
 359:./drivers/gpio/stm32f4_gpio.c ****         copy_to_user(buf, "0", 1);
 971              		.loc 1 359 7 is_stmt 0 view .LVU274
 972 0018 60B9     		cbnz	r0, .L72
 360:./drivers/gpio/stm32f4_gpio.c ****         printk("gpio input value is 0\n\r");
 973              		.loc 1 360 9 is_stmt 1 view .LVU275
 974              	.LVL98:
 975              	.LBB20:
 976              	.LBI20:
 977              		.file 3 "./include/linux/uaccess.h"
   1:./include/linux/uaccess.h **** #ifndef _UACCESS_H
   2:./include/linux/uaccess.h **** #define _UACCESS_H
   3:./include/linux/uaccess.h **** 
   4:./include/linux/uaccess.h **** #include <linux/compiler.h>
   5:./include/linux/uaccess.h **** #include <linux/types.h>
   6:./include/linux/uaccess.h **** #include <linux/string.h>
   7:./include/linux/uaccess.h **** 
   8:./include/linux/uaccess.h **** static inline int copy_from_user(void *to, const void __user *from, size_t n) //用于裸机环境
   9:./include/linux/uaccess.h **** {
  10:./include/linux/uaccess.h ****     memcpy(to, (void *)from, n);
  11:./include/linux/uaccess.h ****     return 0;
  12:./include/linux/uaccess.h **** }
  13:./include/linux/uaccess.h **** static inline int copy_to_user(void __user *to, const void *from, size_t n) //用于裸机环境中
 978              		.loc 3 13 19 view .LVU276
 979              	.LBB21:
  14:./include/linux/uaccess.h **** {
  15:./include/linux/uaccess.h ****     memcpy((void *)to, from, n);
 980              		.loc 3 15 5 view .LVU277
 981 001a 3023     		movs	r3, #48
 982 001c 2B70     		strb	r3, [r5]
  16:./include/linux/uaccess.h ****     return 0;
 983              		.loc 3 16 5 view .LVU278
 984              	.LVL99:
 985              		.loc 3 16 5 is_stmt 0 view .LVU279
 986              	.LBE21:
 987              	.LBE20:
 361:./drivers/gpio/stm32f4_gpio.c ****     }
 988              		.loc 1 361 9 is_stmt 1 view .LVU280
 989 001e 0848     		ldr	r0, .L76
 990              	.LVL100:
 361:./drivers/gpio/stm32f4_gpio.c ****     }
 991              		.loc 1 361 9 is_stmt 0 view .LVU281
 992 0020 FFF7FEFF 		bl	printk
 993              	.LVL101:
 994              	.L73:
 367:./drivers/gpio/stm32f4_gpio.c **** }
 995              		.loc 1 367 5 is_stmt 1 view .LVU282
 367:./drivers/gpio/stm32f4_gpio.c **** }
 996              		.loc 1 367 12 is_stmt 0 view .LVU283
 997 0024 2046     		mov	r0, r4
 998              	.LVL102:
 999              	.L69:
 368:./drivers/gpio/stm32f4_gpio.c **** 
 1000              		.loc 1 368 1 view .LVU284
 1001 0026 38BD     		pop	{r3, r4, r5, pc}
 1002              	.LVL103:
ARM GAS  /tmp/cc2wwjO4.s 			page 34


 1003              	.L75:
 355:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 1004              		.loc 1 355 9 is_stmt 1 view .LVU285
 1005 0028 0648     		ldr	r0, .L76+4
 1006              	.LVL104:
 355:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 1007              		.loc 1 355 9 is_stmt 0 view .LVU286
 1008 002a FFF7FEFF 		bl	printk
 1009              	.LVL105:
 356:./drivers/gpio/stm32f4_gpio.c ****     }
 1010              		.loc 1 356 9 is_stmt 1 view .LVU287
 356:./drivers/gpio/stm32f4_gpio.c ****     }
 1011              		.loc 1 356 16 is_stmt 0 view .LVU288
 1012 002e 6FF01500 		mvn	r0, #21
 1013 0032 F8E7     		b	.L69
 1014              	.LVL106:
 1015              	.L72:
 364:./drivers/gpio/stm32f4_gpio.c ****         printk("gpio input value is 1\n\r");
 1016              		.loc 1 364 9 is_stmt 1 view .LVU289
 1017              	.LBB22:
 1018              	.LBI22:
  13:./include/linux/uaccess.h **** {
 1019              		.loc 3 13 19 view .LVU290
 1020              	.LBB23:
  15:./include/linux/uaccess.h ****     return 0;
 1021              		.loc 3 15 5 view .LVU291
 1022 0034 3123     		movs	r3, #49
 1023 0036 2B70     		strb	r3, [r5]
 1024              		.loc 3 16 5 view .LVU292
 1025              	.LVL107:
 1026              		.loc 3 16 5 is_stmt 0 view .LVU293
 1027              	.LBE23:
 1028              	.LBE22:
 365:./drivers/gpio/stm32f4_gpio.c ****     }
 1029              		.loc 1 365 9 is_stmt 1 view .LVU294
 1030 0038 0348     		ldr	r0, .L76+8
 1031              	.LVL108:
 365:./drivers/gpio/stm32f4_gpio.c ****     }
 1032              		.loc 1 365 9 is_stmt 0 view .LVU295
 1033 003a FFF7FEFF 		bl	printk
 1034              	.LVL109:
 1035 003e F1E7     		b	.L73
 1036              	.L77:
 1037              		.align	2
 1038              	.L76:
 1039 0040 00000000 		.word	.LC3
 1040 0044 00000000 		.word	.LC0
 1041 0048 18000000 		.word	.LC4
 1042              		.cfi_endproc
 1043              	.LFE1049:
 1045              		.section	.rodata.str1.4,"aMS",%progbits,1
 1046              		.align	2
 1047              	.LC5:
 1048 0000 6770696F 		.ascii	"gpios\000"
 1048      7300
 1049 0006 0000     		.align	2
 1050              	.LC6:
ARM GAS  /tmp/cc2wwjO4.s 			page 35


 1051 0008 72656769 		.ascii	"register gpio (%d) \012\000"
 1051      73746572 
 1051      20677069 
 1051      6F202825 
 1051      6429200A 
 1052 001d 000000   		.align	2
 1053              	.LC7:
 1054 0020 63616E20 		.ascii	"can not create gpio_class\012\000"
 1054      6E6F7420 
 1054      63726561 
 1054      74652067 
 1054      70696F5F 
 1055 003b 00       		.align	2
 1056              	.LC8:
 1057 003c 63616E20 		.ascii	"can not create gpios device\012\000"
 1057      6E6F7420 
 1057      63726561 
 1057      74652067 
 1057      70696F73 
 1058              		.section	.init.text,"ax",%progbits
 1059              		.align	1
 1060              		.syntax unified
 1061              		.thumb
 1062              		.thumb_func
 1064              	gpio_init:
 1065              	.LFB1052:
 375:./drivers/gpio/stm32f4_gpio.c **** 
 376:./drivers/gpio/stm32f4_gpio.c **** 
 377:./drivers/gpio/stm32f4_gpio.c **** static long compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
 378:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = file->private_data;
 379:./drivers/gpio/stm32f4_gpio.c ****     if(cmd != GPIO_SET_PIN_NUMBER && device->gpio_number == 0xffff) {
 380:./drivers/gpio/stm32f4_gpio.c ****         printk("please set pin number first\n\r");
 381:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 382:./drivers/gpio/stm32f4_gpio.c ****     }
 383:./drivers/gpio/stm32f4_gpio.c **** 
 384:./drivers/gpio/stm32f4_gpio.c ****     uint16_t pin_number = get_gpio_number(arg);
 385:./drivers/gpio/stm32f4_gpio.c ****     GPIO_TypeDef *gpio_type = get_gpio_type(arg);
 386:./drivers/gpio/stm32f4_gpio.c ****     uint32_t APB_RCC_Source = Get_APB_RCC_Source(gpio_type);
 387:./drivers/gpio/stm32f4_gpio.c **** 
 388:./drivers/gpio/stm32f4_gpio.c ****     switch(cmd) {
 389:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_SET_PIN_NUMBER:
 390:./drivers/gpio/stm32f4_gpio.c ****             if(gpio_type == NULL) {
 391:./drivers/gpio/stm32f4_gpio.c ****                 printk("gpio type is not useful\n\r");
 392:./drivers/gpio/stm32f4_gpio.c ****                 return -EINVAL;
 393:./drivers/gpio/stm32f4_gpio.c ****             }
 394:./drivers/gpio/stm32f4_gpio.c ****             if(APB_RCC_Source == 0xffffffff) {
 395:./drivers/gpio/stm32f4_gpio.c ****                 printk("APB_RCC_Source is not useful\n\r");
 396:./drivers/gpio/stm32f4_gpio.c ****                 return -EINVAL;
 397:./drivers/gpio/stm32f4_gpio.c ****             }
 398:./drivers/gpio/stm32f4_gpio.c ****             print_gpio_number(pin_number);
 399:./drivers/gpio/stm32f4_gpio.c ****             print_gpio_type(gpio_type);
 400:./drivers/gpio/stm32f4_gpio.c ****             
 401:./drivers/gpio/stm32f4_gpio.c ****             RCC_AHB1PeriphClockCmd(APB_RCC_Source, ENABLE);
 402:./drivers/gpio/stm32f4_gpio.c ****             device->gpio_number = pin_number;
 403:./drivers/gpio/stm32f4_gpio.c ****             device->gpio_type = gpio_type;
 404:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Pin = pin_number;
 405:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
ARM GAS  /tmp/cc2wwjO4.s 			page 36


 406:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 407:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 408:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 409:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_AF = GPIO_AF0; // 默认AF0
 410:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 411:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 412:./drivers/gpio/stm32f4_gpio.c ****             
 413:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_PULL_UP:
 414:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 415:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 416:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 417:./drivers/gpio/stm32f4_gpio.c ****             
 418:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_PULL_DOWN:
 419:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 420:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 421:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 422:./drivers/gpio/stm32f4_gpio.c ****             
 423:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_INPUT:
 424:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 425:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 426:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 427:./drivers/gpio/stm32f4_gpio.c ****             
 428:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_OUTPUT:
 429:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 430:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 431:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 432:./drivers/gpio/stm32f4_gpio.c ****             
 433:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_HIGH:
 434:./drivers/gpio/stm32f4_gpio.c ****             GPIO_SetBits(gpio_type, pin_number);
 435:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 436:./drivers/gpio/stm32f4_gpio.c ****             
 437:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_LOW:
 438:./drivers/gpio/stm32f4_gpio.c ****             GPIO_ResetBits(gpio_type, pin_number);
 439:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 440:./drivers/gpio/stm32f4_gpio.c ****             
 441:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_SET_AF: {
 442:./drivers/gpio/stm32f4_gpio.c ****             // 设置复用功能，参数格式：高16位为AF编号，低16位为pin编号
 443:./drivers/gpio/stm32f4_gpio.c ****             uint8_t af = (arg >> 16) & 0xF;
 444:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 445:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_AF = af;
 446:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 447:./drivers/gpio/stm32f4_gpio.c ****             printk("Set pin AF to %d\n\r", af);
 448:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 449:./drivers/gpio/stm32f4_gpio.c ****         }
 450:./drivers/gpio/stm32f4_gpio.c ****             
 451:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_GET_AF: {
 452:./drivers/gpio/stm32f4_gpio.c ****             // 获取当前复用功能
 453:./drivers/gpio/stm32f4_gpio.c ****             uint8_t af = GPIO_GetAF(gpio_type, pin_number);
 454:./drivers/gpio/stm32f4_gpio.c ****             printk("Current pin AF: %d\n\r", af);
 455:./drivers/gpio/stm32f4_gpio.c ****             return af; // 返回当前AF值
 456:./drivers/gpio/stm32f4_gpio.c ****         }
 457:./drivers/gpio/stm32f4_gpio.c ****             
 458:./drivers/gpio/stm32f4_gpio.c ****         default:
 459:./drivers/gpio/stm32f4_gpio.c ****             return -EINVAL;
 460:./drivers/gpio/stm32f4_gpio.c ****     }
 461:./drivers/gpio/stm32f4_gpio.c **** }
 462:./drivers/gpio/stm32f4_gpio.c **** 
ARM GAS  /tmp/cc2wwjO4.s 			page 37


 463:./drivers/gpio/stm32f4_gpio.c **** static struct file_operations gpio_fops = {
 464:./drivers/gpio/stm32f4_gpio.c ****     .owner = THIS_MODULE,
 465:./drivers/gpio/stm32f4_gpio.c ****     .open = gpio_open,
 466:./drivers/gpio/stm32f4_gpio.c ****     .write = gpio_write,
 467:./drivers/gpio/stm32f4_gpio.c ****     .read = gpio_read,
 468:./drivers/gpio/stm32f4_gpio.c ****     .unlocked_ioctl = compat_ioctl,
 469:./drivers/gpio/stm32f4_gpio.c ****     .release = gpio_release,
 470:./drivers/gpio/stm32f4_gpio.c **** };
 471:./drivers/gpio/stm32f4_gpio.c **** 
 472:./drivers/gpio/stm32f4_gpio.c **** static int __init gpio_init(void)
 473:./drivers/gpio/stm32f4_gpio.c **** {
 1066              		.loc 1 473 1 is_stmt 1 view -0
 1067              		.cfi_startproc
 1068              		@ args = 0, pretend = 0, frame = 0
 1069              		@ frame_needed = 0, uses_anonymous_args = 0
 1070 0000 70B5     		push	{r4, r5, r6, lr}
 1071              	.LCFI5:
 1072              		.cfi_def_cfa_offset 16
 1073              		.cfi_offset 4, -16
 1074              		.cfi_offset 5, -12
 1075              		.cfi_offset 6, -8
 1076              		.cfi_offset 14, -4
 1077 0002 82B0     		sub	sp, sp, #8
 1078              	.LCFI6:
 1079              		.cfi_def_cfa_offset 24
 474:./drivers/gpio/stm32f4_gpio.c ****     int major = register_chrdev(0, "gpios", &gpio_fops);
 1080              		.loc 1 474 5 view .LVU297
 1081              	.LVL110:
 1082              	.LBB24:
 1083              	.LBI24:
 1084              		.file 4 "./include/linux/fs.h"
   1:./include/linux/fs.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/fs.h **** #ifndef _LINUX_FS_H
   3:./include/linux/fs.h **** #define _LINUX_FS_H
   4:./include/linux/fs.h **** 
   5:./include/linux/fs.h **** #include <linux/types.h>
   6:./include/linux/fs.h **** #include <linux/errseq.h> 
   7:./include/linux/fs.h **** #include <linux/spinlock.h> 
   8:./include/linux/fs.h **** #include <linux/list.h>
   9:./include/linux/fs.h **** #include <linux/rbtree_types.h>  
  10:./include/linux/fs.h **** #include <linux/uuid.h>  
  11:./include/linux/fs.h **** #include <linux/uidgid_types.h>   
  12:./include/linux/fs.h **** #include <linux/projid.h>       
  13:./include/linux/fs.h **** #include <linux/time64.h> 
  14:./include/linux/fs.h **** #include <linux/mnt_idmapping.h>  
  15:./include/linux/fs.h **** #include <linux/mutex.h>         
  16:./include/linux/fs.h **** #include <linux/uio.h>              
  17:./include/linux/fs.h **** #include <linux/migrate_mode.h>  
  18:./include/linux/fs.h **** #include <linux/raid/pq.h> 
  19:./include/linux/fs.h **** #include <linux/lockdep_types.h>
  20:./include/linux/fs.h **** #include <linux/wait.h>				
  21:./include/linux/fs.h **** #include <linux/pipe_fs_i.h>
  22:./include/linux/fs.h **** #include <linux/fcntl.h>
  23:./include/linux/fs.h **** #include <linux/xarray.h>
  24:./include/linux/fs.h **** #include <linux/blkdev.h>
  25:./include/linux/fs.h **** #include <linux/dcache.h>
  26:./include/linux/fs.h **** #include <linux/mm_type.h>
ARM GAS  /tmp/cc2wwjO4.s 			page 38


  27:./include/linux/fs.h **** #include <linux/statfs.h>
  28:./include/linux/fs.h **** #include <linux/stat.h>
  29:./include/linux/fs.h **** #include <linux/path.h>
  30:./include/linux/fs.h **** 
  31:./include/linux/fs.h **** 
  32:./include/linux/fs.h **** struct dentry;
  33:./include/linux/fs.h **** struct file;
  34:./include/linux/fs.h **** struct inode;
  35:./include/linux/fs.h **** struct kiocb;
  36:./include/linux/fs.h **** struct file_operations;
  37:./include/linux/fs.h **** struct inode_operations  ;
  38:./include/linux/fs.h **** struct dentry_operations ;
  39:./include/linux/fs.h **** struct writeback_control ;
  40:./include/linux/fs.h **** struct address_space;
  41:./include/linux/fs.h **** struct seq_file ;
  42:./include/linux/fs.h **** struct shrink_control;
  43:./include/linux/fs.h **** struct file_system_type;
  44:./include/linux/fs.h **** struct buffer_head;
  45:./include/linux/fs.h **** 
  46:./include/linux/fs.h **** #define MAY_EXEC		0x00000001
  47:./include/linux/fs.h **** #define MAY_WRITE		0x00000002
  48:./include/linux/fs.h **** #define MAY_READ		0x00000004
  49:./include/linux/fs.h **** #define MAY_APPEND		0x00000008
  50:./include/linux/fs.h **** #define MAY_ACCESS		0x00000010
  51:./include/linux/fs.h **** #define MAY_OPEN		0x00000020
  52:./include/linux/fs.h **** #define MAY_CHDIR		0x00000040
  53:./include/linux/fs.h **** /* called from RCU mode, don't block */
  54:./include/linux/fs.h **** #define MAY_NOT_BLOCK		0x00000080
  55:./include/linux/fs.h **** 
  56:./include/linux/fs.h **** /*
  57:./include/linux/fs.h ****  * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond
  58:./include/linux/fs.h ****  * to O_WRONLY and O_RDWR via the strange trick in do_dentry_open()
  59:./include/linux/fs.h ****  */
  60:./include/linux/fs.h **** 
  61:./include/linux/fs.h **** /* file is open for reading */
  62:./include/linux/fs.h **** #define FMODE_READ		((__force fmode_t)(1 << 0))
  63:./include/linux/fs.h **** /* file is open for writing */
  64:./include/linux/fs.h **** #define FMODE_WRITE		((__force fmode_t)(1 << 1))
  65:./include/linux/fs.h **** /* file is seekable */
  66:./include/linux/fs.h **** #define FMODE_LSEEK		((__force fmode_t)(1 << 2))
  67:./include/linux/fs.h **** /* file can be accessed using pread */
  68:./include/linux/fs.h **** #define FMODE_PREAD		((__force fmode_t)(1 << 3))
  69:./include/linux/fs.h **** /* file can be accessed using pwrite */
  70:./include/linux/fs.h **** #define FMODE_PWRITE		((__force fmode_t)(1 << 4))
  71:./include/linux/fs.h **** /* File is opened for execution with sys_execve / sys_uselib */
  72:./include/linux/fs.h **** #define FMODE_EXEC		((__force fmode_t)(1 << 5))
  73:./include/linux/fs.h **** /* File writes are restricted (block device specific) */
  74:./include/linux/fs.h **** #define FMODE_WRITE_RESTRICTED	((__force fmode_t)(1 << 6))
  75:./include/linux/fs.h **** /* File supports atomic writes */
  76:./include/linux/fs.h **** #define FMODE_CAN_ATOMIC_WRITE	((__force fmode_t)(1 << 7))
  77:./include/linux/fs.h **** 
  78:./include/linux/fs.h **** /* FMODE_* bit 8 */
  79:./include/linux/fs.h **** 
  80:./include/linux/fs.h **** /* 32bit hashes as llseek() offset (for directories) */
  81:./include/linux/fs.h **** #define FMODE_32BITHASH         ((__force fmode_t)(1 << 9))
  82:./include/linux/fs.h **** /* 64bit hashes as llseek() offset (for directories) */
  83:./include/linux/fs.h **** #define FMODE_64BITHASH         ((__force fmode_t)(1 << 10))
ARM GAS  /tmp/cc2wwjO4.s 			page 39


  84:./include/linux/fs.h **** 
  85:./include/linux/fs.h **** /*
  86:./include/linux/fs.h ****  * Don't update ctime and mtime.
  87:./include/linux/fs.h ****  *
  88:./include/linux/fs.h ****  * Currently a special hack for the XFS open_by_handle ioctl, but we'll
  89:./include/linux/fs.h ****  * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.
  90:./include/linux/fs.h ****  */
  91:./include/linux/fs.h **** #define FMODE_NOCMTIME		((__force fmode_t)(1 << 11))
  92:./include/linux/fs.h **** 
  93:./include/linux/fs.h **** /* Expect random access pattern */
  94:./include/linux/fs.h **** #define FMODE_RANDOM		((__force fmode_t)(1 << 12))
  95:./include/linux/fs.h **** 
  96:./include/linux/fs.h **** /* FMODE_* bit 13 */
  97:./include/linux/fs.h **** 
  98:./include/linux/fs.h **** /* File is opened with O_PATH; almost nothing can be done with it */
  99:./include/linux/fs.h **** #define FMODE_PATH		((__force fmode_t)(1 << 14))
 100:./include/linux/fs.h **** 
 101:./include/linux/fs.h **** /* File needs atomic accesses to f_pos */
 102:./include/linux/fs.h **** #define FMODE_ATOMIC_POS	((__force fmode_t)(1 << 15))
 103:./include/linux/fs.h **** /* Write access to underlying fs */
 104:./include/linux/fs.h **** #define FMODE_WRITER		((__force fmode_t)(1 << 16))
 105:./include/linux/fs.h **** /* Has read method(s) */
 106:./include/linux/fs.h **** #define FMODE_CAN_READ          ((__force fmode_t)(1 << 17))
 107:./include/linux/fs.h **** /* Has write method(s) */
 108:./include/linux/fs.h **** #define FMODE_CAN_WRITE         ((__force fmode_t)(1 << 18))
 109:./include/linux/fs.h **** 
 110:./include/linux/fs.h **** #define FMODE_OPENED		((__force fmode_t)(1 << 19))
 111:./include/linux/fs.h **** #define FMODE_CREATED		((__force fmode_t)(1 << 20))
 112:./include/linux/fs.h **** 
 113:./include/linux/fs.h **** /* File is stream-like */
 114:./include/linux/fs.h **** #define FMODE_STREAM		((__force fmode_t)(1 << 21))
 115:./include/linux/fs.h **** 
 116:./include/linux/fs.h **** /* File supports DIRECT IO */
 117:./include/linux/fs.h **** #define	FMODE_CAN_ODIRECT	((__force fmode_t)(1 << 22))
 118:./include/linux/fs.h **** 
 119:./include/linux/fs.h **** #define	FMODE_NOREUSE		((__force fmode_t)(1 << 23))
 120:./include/linux/fs.h **** 
 121:./include/linux/fs.h **** /* FMODE_* bit 24 */
 122:./include/linux/fs.h **** 
 123:./include/linux/fs.h **** /* File is embedded in backing_file object */
 124:./include/linux/fs.h **** #define FMODE_BACKING		((__force fmode_t)(1 << 25))
 125:./include/linux/fs.h **** 
 126:./include/linux/fs.h **** /* File was opened by fanotify and shouldn't generate fanotify events */
 127:./include/linux/fs.h **** #define FMODE_NONOTIFY		((__force fmode_t)(1 << 26))
 128:./include/linux/fs.h **** 
 129:./include/linux/fs.h **** /* File is capable of returning -EAGAIN if I/O will block */
 130:./include/linux/fs.h **** #define FMODE_NOWAIT		((__force fmode_t)(1 << 27))
 131:./include/linux/fs.h **** 
 132:./include/linux/fs.h **** /* File represents mount that needs unmounting */
 133:./include/linux/fs.h **** #define FMODE_NEED_UNMOUNT	((__force fmode_t)(1 << 28))
 134:./include/linux/fs.h **** 
 135:./include/linux/fs.h **** /* File does not contribute to nr_files count */
 136:./include/linux/fs.h **** #define FMODE_NOACCOUNT		((__force fmode_t)(1 << 29))
 137:./include/linux/fs.h **** 
 138:./include/linux/fs.h **** /*
 139:./include/linux/fs.h ****  * Attribute flags.  These should be or-ed together to figure out what
 140:./include/linux/fs.h ****  * has been changed!
ARM GAS  /tmp/cc2wwjO4.s 			page 40


 141:./include/linux/fs.h ****  */
 142:./include/linux/fs.h **** #define ATTR_MODE	(1 << 0)
 143:./include/linux/fs.h **** #define ATTR_UID	(1 << 1)
 144:./include/linux/fs.h **** #define ATTR_GID	(1 << 2)
 145:./include/linux/fs.h **** #define ATTR_SIZE	(1 << 3)
 146:./include/linux/fs.h **** #define ATTR_ATIME	(1 << 4)
 147:./include/linux/fs.h **** #define ATTR_MTIME	(1 << 5)
 148:./include/linux/fs.h **** #define ATTR_CTIME	(1 << 6)
 149:./include/linux/fs.h **** #define ATTR_ATIME_SET	(1 << 7)
 150:./include/linux/fs.h **** #define ATTR_MTIME_SET	(1 << 8)
 151:./include/linux/fs.h **** #define ATTR_FORCE	(1 << 9) /* Not a change, but a change it */
 152:./include/linux/fs.h **** #define ATTR_KILL_SUID	(1 << 11)
 153:./include/linux/fs.h **** #define ATTR_KILL_SGID	(1 << 12)
 154:./include/linux/fs.h **** #define ATTR_FILE	(1 << 13)
 155:./include/linux/fs.h **** #define ATTR_KILL_PRIV	(1 << 14)
 156:./include/linux/fs.h **** #define ATTR_OPEN	(1 << 15) /* Truncating from open(O_TRUNC) */
 157:./include/linux/fs.h **** #define ATTR_TIMES_SET	(1 << 16)
 158:./include/linux/fs.h **** #define ATTR_TOUCH	(1 << 17)
 159:./include/linux/fs.h **** #define ATTR_DELEG	(1 << 18) /* Delegated attrs. Don't break write delegations */
 160:./include/linux/fs.h **** 
 161:./include/linux/fs.h **** /*
 162:./include/linux/fs.h ****  * Whiteout is represented by a char device.  The following constants define the
 163:./include/linux/fs.h ****  * mode and device number to use.
 164:./include/linux/fs.h ****  */
 165:./include/linux/fs.h **** #define WHITEOUT_MODE 0
 166:./include/linux/fs.h **** #define WHITEOUT_DEV 0
 167:./include/linux/fs.h **** 
 168:./include/linux/fs.h **** 
 169:./include/linux/fs.h **** 
 170:./include/linux/fs.h **** /********************************************************
 171:./include/linux/fs.h ****  * 														*
 172:./include/linux/fs.h ****  * 			   		     iattr  						*
 173:./include/linux/fs.h ****  *														* 
 174:./include/linux/fs.h **** *********************************************************/
 175:./include/linux/fs.h **** 
 176:./include/linux/fs.h **** 
 177:./include/linux/fs.h **** struct iattr {
 178:./include/linux/fs.h **** 	unsigned int	ia_valid;
 179:./include/linux/fs.h **** 	umode_t		ia_mode;
 180:./include/linux/fs.h **** 	union {
 181:./include/linux/fs.h **** 		kuid_t		ia_uid;
 182:./include/linux/fs.h **** 		vfsuid_t	ia_vfsuid;
 183:./include/linux/fs.h **** 	};
 184:./include/linux/fs.h **** 	union {
 185:./include/linux/fs.h **** 		kgid_t		ia_gid;
 186:./include/linux/fs.h **** 		vfsgid_t	ia_vfsgid;
 187:./include/linux/fs.h **** 	};
 188:./include/linux/fs.h **** 	loff_t		ia_size;
 189:./include/linux/fs.h **** 	struct timespec64 ia_atime;
 190:./include/linux/fs.h **** 	struct timespec64 ia_mtime;
 191:./include/linux/fs.h **** 	struct timespec64 ia_ctime;
 192:./include/linux/fs.h **** 	struct file	*ia_file;
 193:./include/linux/fs.h **** };
 194:./include/linux/fs.h **** 
 195:./include/linux/fs.h **** /********************************************************
 196:./include/linux/fs.h ****  * 														*
 197:./include/linux/fs.h ****  * 			     address_space  						*
ARM GAS  /tmp/cc2wwjO4.s 			page 41


 198:./include/linux/fs.h ****  *														* 
 199:./include/linux/fs.h **** *********************************************************/
 200:./include/linux/fs.h **** struct file_ra_state {
 201:./include/linux/fs.h **** 	pgoff_t start;
 202:./include/linux/fs.h **** 	unsigned int size;
 203:./include/linux/fs.h **** 	unsigned int async_size;
 204:./include/linux/fs.h **** 	unsigned int ra_pages;
 205:./include/linux/fs.h **** 	unsigned int mmap_miss;
 206:./include/linux/fs.h **** 	loff_t prev_pos;
 207:./include/linux/fs.h **** };
 208:./include/linux/fs.h **** 
 209:./include/linux/fs.h **** struct iov_iter {
 210:./include/linux/fs.h **** 	u8 iter_type;
 211:./include/linux/fs.h **** 	bool nofault;
 212:./include/linux/fs.h **** 	bool data_source;
 213:./include/linux/fs.h **** 	size_t iov_offset;
 214:./include/linux/fs.h **** 	/*
 215:./include/linux/fs.h **** 	 * Hack alert: overlay ubuf_iovec with iovec + count, so
 216:./include/linux/fs.h **** 	 * that the members resolve correctly regardless of the type
 217:./include/linux/fs.h **** 	 * of iterator used. This means that you can use:
 218:./include/linux/fs.h **** 	 *
 219:./include/linux/fs.h **** 	 * &iter->__ubuf_iovec or iter->__iov
 220:./include/linux/fs.h **** 	 *
 221:./include/linux/fs.h **** 	 * interchangably for the user_backed cases, hence simplifying
 222:./include/linux/fs.h **** 	 * some of the cases that need to deal with both.
 223:./include/linux/fs.h **** 	 */
 224:./include/linux/fs.h **** 	union {
 225:./include/linux/fs.h **** 		/*
 226:./include/linux/fs.h **** 		 * This really should be a const, but we cannot do that without
 227:./include/linux/fs.h **** 		 * also modifying any of the zero-filling iter init functions.
 228:./include/linux/fs.h **** 		 * Leave it non-const for now, but it should be treated as such.
 229:./include/linux/fs.h **** 		 */
 230:./include/linux/fs.h **** 		struct iovec __ubuf_iovec;
 231:./include/linux/fs.h **** 		struct {
 232:./include/linux/fs.h **** 			union {
 233:./include/linux/fs.h **** 				/* use iter_iov() to get the current vec */
 234:./include/linux/fs.h **** 				const struct iovec *__iov;
 235:./include/linux/fs.h **** 				const struct kvec *kvec;
 236:./include/linux/fs.h **** 				const struct bio_vec *bvec;
 237:./include/linux/fs.h **** 				const struct folio_queue *folioq;
 238:./include/linux/fs.h **** 				struct xarray *xarray;
 239:./include/linux/fs.h **** 				void __user *ubuf;
 240:./include/linux/fs.h **** 			};
 241:./include/linux/fs.h **** 			size_t count;
 242:./include/linux/fs.h **** 		};
 243:./include/linux/fs.h **** 	};
 244:./include/linux/fs.h **** 	union {
 245:./include/linux/fs.h **** 		unsigned long nr_segs;
 246:./include/linux/fs.h **** 		u8 folioq_slot;
 247:./include/linux/fs.h **** 		loff_t xarray_start;
 248:./include/linux/fs.h **** 	};
 249:./include/linux/fs.h **** };
 250:./include/linux/fs.h **** 
 251:./include/linux/fs.h **** struct address_space_operations {
 252:./include/linux/fs.h **** 	int (*writepage)(struct page *page, struct writeback_control *wbc);
 253:./include/linux/fs.h **** 	int (*read_folio)(struct file *, struct folio *);
 254:./include/linux/fs.h **** 
ARM GAS  /tmp/cc2wwjO4.s 			page 42


 255:./include/linux/fs.h **** 	/* Write back some dirty pages from this mapping. */
 256:./include/linux/fs.h **** 	int (*writepages)(struct address_space *, struct writeback_control *);
 257:./include/linux/fs.h **** 
 258:./include/linux/fs.h **** 	/* Mark a folio dirty.  Return true if this dirtied it */
 259:./include/linux/fs.h **** 	bool (*dirty_folio)(struct address_space *, struct folio *);
 260:./include/linux/fs.h **** 
 261:./include/linux/fs.h **** 	void (*readahead)(struct readahead_control *);
 262:./include/linux/fs.h **** 
 263:./include/linux/fs.h **** 	int (*write_begin)(struct file *, struct address_space *mapping,
 264:./include/linux/fs.h **** 				loff_t pos, unsigned len,
 265:./include/linux/fs.h **** 				struct folio **foliop, void **fsdata);
 266:./include/linux/fs.h **** 	int (*write_end)(struct file *, struct address_space *mapping,
 267:./include/linux/fs.h **** 				loff_t pos, unsigned len, unsigned copied,
 268:./include/linux/fs.h **** 				struct folio *folio, void *fsdata);
 269:./include/linux/fs.h **** 
 270:./include/linux/fs.h **** 	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
 271:./include/linux/fs.h **** 	sector_t (*bmap)(struct address_space *, sector_t);
 272:./include/linux/fs.h **** 	void (*invalidate_folio) (struct folio *, size_t offset, size_t len);
 273:./include/linux/fs.h **** 	bool (*release_folio)(struct folio *, gfp_t);
 274:./include/linux/fs.h **** 	void (*free_folio)(struct folio *folio);
 275:./include/linux/fs.h **** 	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);
 276:./include/linux/fs.h **** 	/*
 277:./include/linux/fs.h **** 	 * migrate the contents of a folio to the specified target. If
 278:./include/linux/fs.h **** 	 * migrate_mode is MIGRATE_ASYNC, it must not block.
 279:./include/linux/fs.h **** 	 */
 280:./include/linux/fs.h **** 	int (*migrate_folio)(struct address_space *, struct folio *dst,
 281:./include/linux/fs.h **** 			struct folio *src, enum migrate_mode);
 282:./include/linux/fs.h **** 	int (*launder_folio)(struct folio *);
 283:./include/linux/fs.h **** 	bool (*is_partially_uptodate) (struct folio *, size_t from,
 284:./include/linux/fs.h **** 			size_t count);
 285:./include/linux/fs.h **** 	void (*is_dirty_writeback) (struct folio *, bool *dirty, bool *wb);
 286:./include/linux/fs.h **** 	int (*error_remove_folio)(struct address_space *, struct folio *);
 287:./include/linux/fs.h **** 
 288:./include/linux/fs.h **** 	/* swapfile support */
 289:./include/linux/fs.h **** 	// int (*swap_activate)(struct swap_info_struct *sis, struct file *file,
 290:./include/linux/fs.h **** 	// 			sector_t *span);
 291:./include/linux/fs.h **** 	// void (*swap_deactivate)(struct file *file);
 292:./include/linux/fs.h **** 	// int (*swap_rw)(struct kiocb *iocb, struct iov_iter *iter);
 293:./include/linux/fs.h **** };
 294:./include/linux/fs.h **** 
 295:./include/linux/fs.h ****  struct address_space {
 296:./include/linux/fs.h **** 	struct inode		*host;
 297:./include/linux/fs.h **** 	struct xarray		i_pages;
 298:./include/linux/fs.h **** 	gfp_t			gfp_mask;
 299:./include/linux/fs.h **** 	atomic_t		i_mmap_writable;
 300:./include/linux/fs.h **** #ifdef CONFIG_READ_ONLY_THP_FOR_FS
 301:./include/linux/fs.h **** 	/* number of thp, only for non-shmem files */
 302:./include/linux/fs.h **** 	atomic_t		nr_thps;
 303:./include/linux/fs.h **** #endif
 304:./include/linux/fs.h **** 	struct rb_root_cached	i_mmap;
 305:./include/linux/fs.h **** 	unsigned long		nrpages;
 306:./include/linux/fs.h **** 	pgoff_t			writeback_index;
 307:./include/linux/fs.h **** 	const struct address_space_operations *a_ops;
 308:./include/linux/fs.h **** 	unsigned long		flags;
 309:./include/linux/fs.h **** 	errseq_t		wb_err;
 310:./include/linux/fs.h **** 	spinlock_t		i_private_lock;
 311:./include/linux/fs.h **** 	struct list_head	i_private_list;
ARM GAS  /tmp/cc2wwjO4.s 			page 43


 312:./include/linux/fs.h **** 	void *			i_private_data;
 313:./include/linux/fs.h **** } __attribute__((aligned(sizeof(long)))) __randomize_layout;
 314:./include/linux/fs.h **** 
 315:./include/linux/fs.h **** /********************************************************
 316:./include/linux/fs.h ****  * 														*
 317:./include/linux/fs.h ****  * 			   		  file struct						*
 318:./include/linux/fs.h ****  *														* 
 319:./include/linux/fs.h **** *********************************************************/
 320:./include/linux/fs.h **** 
 321:./include/linux/fs.h **** struct file {
 322:./include/linux/fs.h **** 	struct mutex					f_ref;
 323:./include/linux/fs.h **** 	struct mutex					f_lock;
 324:./include/linux/fs.h **** 	fmode_t							f_mode;
 325:./include/linux/fs.h **** 	const struct file_operations	*f_op;                            
 326:./include/linux/fs.h **** 	//	struct address_space			*f_mapping;
 327:./include/linux/fs.h **** 	void							*private_data;
 328:./include/linux/fs.h **** 	struct inode					*f_inode;
 329:./include/linux/fs.h **** 	unsigned int					f_flags;
 330:./include/linux/fs.h **** 	unsigned int					f_iocb_flags;
 331:./include/linux/fs.h **** 	char *						    f_path;
 332:./include/linux/fs.h **** 	union {
 333:./include/linux/fs.h **** 		struct mutex				f_pos_lock;
 334:./include/linux/fs.h **** 		u64							f_pipe;
 335:./include/linux/fs.h **** 	};
 336:./include/linux/fs.h **** 	loff_t							f_pos;
 337:./include/linux/fs.h **** 	void *							f_private;
 338:./include/linux/fs.h **** 	spinlock_t                      f_slock;
 339:./include/linux/fs.h **** }__attribute__((aligned(sizeof(long)))) __randomize_layout;	
 340:./include/linux/fs.h **** 
 341:./include/linux/fs.h **** 
 342:./include/linux/fs.h **** /********************************************************
 343:./include/linux/fs.h ****  * 														*
 344:./include/linux/fs.h ****  * 			   		  inode struct						*
 345:./include/linux/fs.h ****  *														* 
 346:./include/linux/fs.h **** *********************************************************/
 347:./include/linux/fs.h **** 
 348:./include/linux/fs.h **** #define IOP_FASTPERM	0x0001
 349:./include/linux/fs.h **** #define IOP_LOOKUP	0x0002
 350:./include/linux/fs.h **** #define IOP_NOFOLLOW	0x0004
 351:./include/linux/fs.h **** #define IOP_XATTR	0x0008
 352:./include/linux/fs.h **** #define IOP_DEFAULT_READLINK	0x0010
 353:./include/linux/fs.h **** #define IOP_MGTIME	0x0020
 354:./include/linux/fs.h **** 
 355:./include/linux/fs.h **** /*
 356:./include/linux/fs.h ****  * Keep mostly read-only and often accessed (especially for
 357:./include/linux/fs.h ****  * the RCU path lookup and 'stat' data) fields at the beginning
 358:./include/linux/fs.h ****  * of the 'struct inode'
 359:./include/linux/fs.h ****  */
 360:./include/linux/fs.h **** 
 361:./include/linux/fs.h **** struct inode {
 362:./include/linux/fs.h **** 	umode_t            i_mode;   
 363:./include/linux/fs.h **** 
 364:./include/linux/fs.h **** 	unsigned short     		i_opflags;     /* inode 操作标志对应IOP宏 */
 365:./include/linux/fs.h **** 	kuid_t             i_uid;         /* 文件所有者用户ID */
 366:./include/linux/fs.h **** 	kgid_t             i_gid;         /* 文件所有者组ID */
 367:./include/linux/fs.h **** 
 368:./include/linux/fs.h **** 	unsigned int       i_flags;    
ARM GAS  /tmp/cc2wwjO4.s 			page 44


 369:./include/linux/fs.h **** 	const struct inode_operations *i_op;     
 370:./include/linux/fs.h **** 	struct super_block            *i_sb;       
 371:./include/linux/fs.h **** 	struct address_space	      *i_mapping;   
 372:./include/linux/fs.h **** 	dev_t             i_rdev;       
 373:./include/linux/fs.h **** 	loff_t            i_size;        
 374:./include/linux/fs.h **** 	time64_t          i_atime_sec;   
 375:./include/linux/fs.h **** 	time64_t          i_mtime_sec;   
 376:./include/linux/fs.h **** 	time64_t          i_ctime_sec;    
 377:./include/linux/fs.h **** 	u32               i_atime_nsec;   
 378:./include/linux/fs.h **** 	u32               i_mtime_nsec;   
 379:./include/linux/fs.h **** 	u32               i_ctime_nsec;  
 380:./include/linux/fs.h **** 	unsigned short    i_bytes;
 381:./include/linux/fs.h **** 	u32			i_state;
 382:./include/linux/fs.h **** 	struct hlist_node	i_hash;
 383:./include/linux/fs.h **** 	struct list_head	i_io_list;	/* backing dev IO list */
 384:./include/linux/fs.h **** 	spinlock_t	        i_lock;	/* i_blocks, i_bytes, maybe i_size */
 385:./include/linux/fs.h **** 	struct list_head	i_sb_list;
 386:./include/linux/fs.h **** 	struct list_head	i_dentry;
 387:./include/linux/fs.h **** 	atomic_t		i_count;
 388:./include/linux/fs.h **** 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 389:./include/linux/fs.h **** 	void (*free_inode)(struct inode *);
 390:./include/linux/fs.h **** 	void			*i_private; /* fs or device private pointer */
 391:./include/linux/fs.h **** }__attribute__((aligned(sizeof(long)))) __randomize_layout;
 392:./include/linux/fs.h **** 
 393:./include/linux/fs.h **** /********************************************************
 394:./include/linux/fs.h ****  * 														*
 395:./include/linux/fs.h ****  * 			   inode inode_operations					*
 396:./include/linux/fs.h ****  *														* 
 397:./include/linux/fs.h **** *********************************************************/
 398:./include/linux/fs.h **** 
 399:./include/linux/fs.h **** struct mnt_idmap {void * no_data;};
 400:./include/linux/fs.h **** 
 401:./include/linux/fs.h **** struct inode_operations {
 402:./include/linux/fs.h **** 	struct dentry  	 *(*lookup) 	   (struct inode *    ,struct dentry *, unsigned int);
 403:./include/linux/fs.h **** 	const char 	     *(*get_link) 	   (struct dentry *   , struct inode *, struct delayed_call *);
 404:./include/linux/fs.h **** 	int 			  (*permission)    (struct mnt_idmap *, struct inode *, int);
 405:./include/linux/fs.h **** 	struct posix_acl *(*get_inode_acl) (struct inode *	  , int, bool);
 406:./include/linux/fs.h **** 	int 			  (*readlink) 	   (struct dentry *   , char __user * ,int);
 407:./include/linux/fs.h **** 	int 			  (*create) 	   (struct mnt_idmap *, struct inode *,struct dentry *,umode_t, bool);
 408:./include/linux/fs.h **** 	int 			  (*link) 		   (struct dentry *   ,struct inode * ,struct dentry *);
 409:./include/linux/fs.h **** 	int 			  (*unlink) 	   (struct inode *	  ,struct dentry * );
 410:./include/linux/fs.h **** 	int 			  (*symlink) 	   (struct mnt_idmap *, struct inode *,struct dentry *,const char *);
 411:./include/linux/fs.h **** 	int 			  (*mkdir) 		   (struct mnt_idmap *, struct inode *,struct dentry *,umode_t);
 412:./include/linux/fs.h **** 	int 			  (*rmdir)		   (struct inode *	  ,struct dentry * );
 413:./include/linux/fs.h **** 	int 			  (*mknod) 		   (struct mnt_idmap *, struct inode *,struct dentry *,umode_t,dev_t);
 414:./include/linux/fs.h **** 	int 			  (*rename) 	   (struct mnt_idmap *, struct inode *, struct dentry *,struct inode *, struct
 415:./include/linux/fs.h **** 	int 			  (*setattr)	   (struct mnt_idmap *, struct dentry*, struct iattr *);
 416:./include/linux/fs.h **** 	int 			  (*getattr) 	   (struct mnt_idmap *, const struct path *,struct kstat *, u32, unsigned int
 417:./include/linux/fs.h **** 	ssize_t 		  (*listxattr) 	   (struct dentry *	  , char *		  , size_t);
 418:./include/linux/fs.h **** 	int 			  (*fiemap)		   (struct inode *	  , struct fiemap_extent_info *, u64 start,u64 len);
 419:./include/linux/fs.h **** 	int 			  (*update_time)   (struct inode *    , int);
 420:./include/linux/fs.h **** 	int 			  (*atomic_open)   (struct inode *    , struct dentry*,struct file *, unsigned open_flag,um
 421:./include/linux/fs.h **** 	int 			  (*tmpfile)	   (struct mnt_idmap *, struct inode *,struct file *, umode_t);
 422:./include/linux/fs.h **** 	struct posix_acl *(*get_acl)	   (struct mnt_idmap *, struct dentry*,int);
 423:./include/linux/fs.h **** 	int 			  (*set_acl)	   (struct mnt_idmap *, struct dentry*,struct posix_acl *, int);
 424:./include/linux/fs.h **** 	int 			  (*fileattr_set)  (struct mnt_idmap *idmap,struct dentry *dentry, struct fileattr *fa);
 425:./include/linux/fs.h **** 	int 			  (*fileattr_get)  (struct dentry *dentry  , struct fileattr *fa);
ARM GAS  /tmp/cc2wwjO4.s 			page 45


 426:./include/linux/fs.h **** 	struct offset_ctx*(*get_offset_ctx)(struct inode *inode);
 427:./include/linux/fs.h **** };
 428:./include/linux/fs.h **** 
 429:./include/linux/fs.h **** /********************************************************
 430:./include/linux/fs.h ****  * 														*
 431:./include/linux/fs.h ****  * 			       file_operations						*
 432:./include/linux/fs.h ****  *														* 
 433:./include/linux/fs.h **** *********************************************************/
 434:./include/linux/fs.h **** 
 435:./include/linux/fs.h **** struct kiocb {
 436:./include/linux/fs.h **** 	struct file		*ki_filp;
 437:./include/linux/fs.h **** 	loff_t			ki_pos;
 438:./include/linux/fs.h **** 	void (*ki_complete)(struct kiocb *iocb, long ret);
 439:./include/linux/fs.h **** 	void			*private;
 440:./include/linux/fs.h **** 	int			ki_flags;
 441:./include/linux/fs.h **** 	u16			ki_ioprio; /* See linux/ioprio.h */
 442:./include/linux/fs.h **** 	union {
 443:./include/linux/fs.h **** 	//	struct wait_page_queue	*ki_waitq;
 444:./include/linux/fs.h **** 		ssize_t (*dio_complete)(void *data);
 445:./include/linux/fs.h **** 	};
 446:./include/linux/fs.h **** };
 447:./include/linux/fs.h **** 
 448:./include/linux/fs.h **** struct dir_context;
 449:./include/linux/fs.h **** typedef bool (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,
 450:./include/linux/fs.h **** 			 unsigned);
 451:./include/linux/fs.h **** 
 452:./include/linux/fs.h **** struct dir_context {
 453:./include/linux/fs.h **** 	filldir_t actor;
 454:./include/linux/fs.h **** 	loff_t pos;
 455:./include/linux/fs.h **** };
 456:./include/linux/fs.h **** 
 457:./include/linux/fs.h **** 
 458:./include/linux/fs.h **** 
 459:./include/linux/fs.h **** 
 460:./include/linux/fs.h **** typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);
 461:./include/linux/fs.h **** 
 462:./include/linux/fs.h **** typedef struct poll_table_struct {
 463:./include/linux/fs.h **** 	poll_queue_proc _qproc;
 464:./include/linux/fs.h **** 	__poll_t _key;
 465:./include/linux/fs.h **** } poll_table;
 466:./include/linux/fs.h **** 
 467:./include/linux/fs.h **** typedef unsigned int __bitwise fop_flags_t;
 468:./include/linux/fs.h **** typedef void *fl_owner_t;
 469:./include/linux/fs.h **** 
 470:./include/linux/fs.h **** struct file_operations {
 471:./include/linux/fs.h **** 	void *owner;
 472:./include/linux/fs.h **** 	fop_flags_t fop_flags;
 473:./include/linux/fs.h **** 	loff_t (*llseek) (struct file *, loff_t, int);
 474:./include/linux/fs.h **** 	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
 475:./include/linux/fs.h **** 	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
 476:./include/linux/fs.h **** ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
 477:./include/linux/fs.h **** ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
 478:./include/linux/fs.h **** 	int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,unsigned int flags);
 479:./include/linux/fs.h **** 	int (*iterate_shared) (struct file *, struct dir_context *);
 480:./include/linux/fs.h **** 	__poll_t (*poll) (struct file *, struct poll_table_struct *);
 481:./include/linux/fs.h **** 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 482:./include/linux/fs.h **** 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
ARM GAS  /tmp/cc2wwjO4.s 			page 46


 483:./include/linux/fs.h **** int (*mmap) (struct file *, struct vm_area_struct *);
 484:./include/linux/fs.h **** 	int (*open) (struct inode *, struct file *);
 485:./include/linux/fs.h **** 	int (*flush) (struct file *, fl_owner_t id);
 486:./include/linux/fs.h **** 	int (*release) (struct inode *, struct file *);
 487:./include/linux/fs.h **** 	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
 488:./include/linux/fs.h **** 	int (*fasync) (int, struct file *, int);
 489:./include/linux/fs.h **** 	int (*lock) (struct file *, int, struct file_lock *);
 490:./include/linux/fs.h **** 	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, uns
 491:./include/linux/fs.h **** 	int (*check_flags)(int);
 492:./include/linux/fs.h **** 	int (*flock) (struct file *, int, struct file_lock *);
 493:./include/linux/fs.h **** ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 494:./include/linux/fs.h **** ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
 495:./include/linux/fs.h **** 	void (*splice_eof)(struct file *file);
 496:./include/linux/fs.h **** 	int (*setlease)(struct file *, int, struct file_lease **, void **);
 497:./include/linux/fs.h **** 	long (*fallocate)(struct file *file, int mode, loff_t offset,loff_t len);
 498:./include/linux/fs.h **** 	void (*show_fdinfo)(struct seq_file *m, struct file *f);
 499:./include/linux/fs.h **** #ifndef CONFIG_MMU
 500:./include/linux/fs.h **** 	unsigned (*mmap_capabilities)(struct file *);
 501:./include/linux/fs.h **** #endif
 502:./include/linux/fs.h **** 	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,loff_t, size_t, unsigned int);
 503:./include/linux/fs.h **** 	loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,struct file *file_out, loff_t pos_o
 504:./include/linux/fs.h **** 	int (*fadvise)(struct file *, loff_t, loff_t, int);
 505:./include/linux/fs.h **** 	int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags);
 506:./include/linux/fs.h **** 	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *,unsigned int poll_flags);
 507:./include/linux/fs.h **** };
 508:./include/linux/fs.h **** 
 509:./include/linux/fs.h **** 
 510:./include/linux/fs.h **** /********************************************************
 511:./include/linux/fs.h ****  * 														*
 512:./include/linux/fs.h ****  * 			       super_block							*
 513:./include/linux/fs.h ****  *														* 
 514:./include/linux/fs.h **** *********************************************************/
 515:./include/linux/fs.h **** 
 516:./include/linux/fs.h **** struct rcu_sync {
 517:./include/linux/fs.h **** 	int			gp_state;
 518:./include/linux/fs.h **** 	int			gp_count;
 519:./include/linux/fs.h **** 	wait_queue_head_t	gp_wait;
 520:./include/linux/fs.h **** 
 521:./include/linux/fs.h **** 	struct rcu_head		cb_head;
 522:./include/linux/fs.h **** };
 523:./include/linux/fs.h **** 
 524:./include/linux/fs.h **** struct rcuwait {
 525:./include/linux/fs.h **** 	//struct task_struct __rcu *task;
 526:./include/linux/fs.h **** };
 527:./include/linux/fs.h **** 
 528:./include/linux/fs.h **** struct percpu_rw_semaphore {
 529:./include/linux/fs.h **** 	struct rcu_sync		rss;
 530:./include/linux/fs.h **** 	unsigned int __percpu	*read_count;
 531:./include/linux/fs.h **** 	struct rcuwait		writer;
 532:./include/linux/fs.h **** 	wait_queue_head_t	waiters;
 533:./include/linux/fs.h **** 	atomic_t		block;
 534:./include/linux/fs.h **** #ifdef CONFIG_DEBUG_LOCK_ALLOC
 535:./include/linux/fs.h **** 	struct lockdep_map	dep_map;
 536:./include/linux/fs.h **** #endif
 537:./include/linux/fs.h **** };
 538:./include/linux/fs.h **** 
 539:./include/linux/fs.h **** /*
ARM GAS  /tmp/cc2wwjO4.s 			page 47


 540:./include/linux/fs.h ****  * sb->s_flags.  Note that these mirror the equivalent MS_* flags where
 541:./include/linux/fs.h ****  * represented in both.
 542:./include/linux/fs.h ****  */
 543:./include/linux/fs.h **** #define SB_RDONLY       BIT(0)	/* Mount read-only */
 544:./include/linux/fs.h **** #define SB_NOSUID       BIT(1)	/* Ignore suid and sgid bits */
 545:./include/linux/fs.h **** #define SB_NODEV        BIT(2)	/* Disallow access to device special files */
 546:./include/linux/fs.h **** #define SB_NOEXEC       BIT(3)	/* Disallow program execution */
 547:./include/linux/fs.h **** #define SB_SYNCHRONOUS  BIT(4)	/* Writes are synced at once */
 548:./include/linux/fs.h **** #define SB_MANDLOCK     BIT(6)	/* Allow mandatory locks on an FS */
 549:./include/linux/fs.h **** #define SB_DIRSYNC      BIT(7)	/* Directory modifications are synchronous */
 550:./include/linux/fs.h **** #define SB_NOATIME      BIT(10)	/* Do not update access times. */
 551:./include/linux/fs.h **** #define SB_NODIRATIME   BIT(11)	/* Do not update directory access times */
 552:./include/linux/fs.h **** #define SB_SILENT       BIT(15)
 553:./include/linux/fs.h **** #define SB_POSIXACL     BIT(16)	/* Supports POSIX ACLs */
 554:./include/linux/fs.h **** #define SB_INLINECRYPT  BIT(17)	/* Use blk-crypto for encrypted files */
 555:./include/linux/fs.h **** #define SB_KERNMOUNT    BIT(22)	/* this is a kern_mount call */
 556:./include/linux/fs.h **** #define SB_I_VERSION    BIT(23)	/* Update inode I_version field */
 557:./include/linux/fs.h **** #define SB_LAZYTIME     BIT(25)	/* Update the on-disk [acm]times lazily */
 558:./include/linux/fs.h **** 
 559:./include/linux/fs.h **** /* These sb flags are internal to the kernel */
 560:./include/linux/fs.h **** #define SB_DEAD         BIT(21)
 561:./include/linux/fs.h **** #define SB_DYING        BIT(24)
 562:./include/linux/fs.h **** #define SB_SUBMOUNT     BIT(26)
 563:./include/linux/fs.h **** #define SB_FORCE        BIT(27)
 564:./include/linux/fs.h **** #define SB_NOSEC        BIT(28)
 565:./include/linux/fs.h **** #define SB_BORN         BIT(29)
 566:./include/linux/fs.h **** #define SB_ACTIVE       BIT(30)
 567:./include/linux/fs.h **** #define SB_NOUSER       BIT(31)
 568:./include/linux/fs.h **** 
 569:./include/linux/fs.h **** /* These flags relate to encoding and casefolding */
 570:./include/linux/fs.h **** #define SB_ENC_STRICT_MODE_FL	(1 << 0)
 571:./include/linux/fs.h **** 
 572:./include/linux/fs.h **** #define sb_has_strict_encoding(sb) \
 573:./include/linux/fs.h **** 	(sb->s_encoding_flags & SB_ENC_STRICT_MODE_FL)
 574:./include/linux/fs.h **** 
 575:./include/linux/fs.h **** /*
 576:./include/linux/fs.h ****  *	Umount options
 577:./include/linux/fs.h ****  */
 578:./include/linux/fs.h **** 
 579:./include/linux/fs.h **** #define MNT_FORCE	0x00000001	/* Attempt to forcibily umount */
 580:./include/linux/fs.h **** #define MNT_DETACH	0x00000002	/* Just detach from the tree */
 581:./include/linux/fs.h **** #define MNT_EXPIRE	0x00000004	/* Mark for expiry */
 582:./include/linux/fs.h **** #define UMOUNT_NOFOLLOW	0x00000008	/* Don't follow symlink on umount */
 583:./include/linux/fs.h **** #define UMOUNT_UNUSED	0x80000000	/* Flag guaranteed to be unused */
 584:./include/linux/fs.h **** 
 585:./include/linux/fs.h **** /* sb->s_iflags */
 586:./include/linux/fs.h **** #define SB_I_CGROUPWB	0x00000001	/* cgroup-aware writeback enabled */
 587:./include/linux/fs.h **** #define SB_I_NOEXEC	0x00000002	/* Ignore executables on this fs */
 588:./include/linux/fs.h **** #define SB_I_NODEV	0x00000004	/* Ignore devices on this fs */
 589:./include/linux/fs.h **** #define SB_I_STABLE_WRITES 0x00000008	/* don't modify blks until WB is done */
 590:./include/linux/fs.h **** 
 591:./include/linux/fs.h **** /* sb->s_iflags to limit user namespace mounts */
 592:./include/linux/fs.h **** #define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */
 593:./include/linux/fs.h **** #define SB_I_IMA_UNVERIFIABLE_SIGNATURE	0x00000020
 594:./include/linux/fs.h **** #define SB_I_UNTRUSTED_MOUNTER		0x00000040
 595:./include/linux/fs.h **** #define SB_I_EVM_HMAC_UNSUPPORTED	0x00000080
 596:./include/linux/fs.h **** 
ARM GAS  /tmp/cc2wwjO4.s 			page 48


 597:./include/linux/fs.h **** #define SB_I_SKIP_SYNC	0x00000100	/* Skip superblock at global sync */
 598:./include/linux/fs.h **** #define SB_I_PERSB_BDI	0x00000200	/* has a per-sb bdi */
 599:./include/linux/fs.h **** #define SB_I_TS_EXPIRY_WARNED 0x00000400 /* warned about timestamp range expiry */
 600:./include/linux/fs.h **** #define SB_I_RETIRED	0x00000800	/* superblock shouldn't be reused */
 601:./include/linux/fs.h **** #define SB_I_NOUMASK	0x00001000	/* VFS does not apply umask */
 602:./include/linux/fs.h **** #define SB_I_NOIDMAP	0x00002000	/* No idmapped mounts on this superblock */
 603:./include/linux/fs.h **** 
 604:./include/linux/fs.h **** 
 605:./include/linux/fs.h **** enum {
 606:./include/linux/fs.h **** 	SB_UNFROZEN = 0,		/* FS is unfrozen */
 607:./include/linux/fs.h **** 	SB_FREEZE_WRITE	= 1,		/* Writes, dir ops, ioctls frozen */
 608:./include/linux/fs.h **** 	SB_FREEZE_PAGEFAULT = 2,	/* Page faults stopped as well */
 609:./include/linux/fs.h **** 	SB_FREEZE_FS = 3,		/* For internal FS use (e.g. to stop
 610:./include/linux/fs.h **** 					 	* internal threads if needed) */
 611:./include/linux/fs.h **** 	SB_FREEZE_COMPLETE = 4,		/* ->freeze_fs finished successfully */
 612:./include/linux/fs.h **** };
 613:./include/linux/fs.h **** 
 614:./include/linux/fs.h **** #define SB_FREEZE_LEVELS (SB_FREEZE_COMPLETE - 1)
 615:./include/linux/fs.h **** 
 616:./include/linux/fs.h **** struct sb_writers {
 617:./include/linux/fs.h **** 	unsigned short			frozen;		/* Is sb frozen? */
 618:./include/linux/fs.h **** 	int				freeze_kcount;	/* How many kernel freeze requests? */
 619:./include/linux/fs.h **** 	int				freeze_ucount;	/* How many userspace freeze requests? */
 620:./include/linux/fs.h **** 	struct percpu_rw_semaphore	rw_sem[SB_FREEZE_LEVELS];
 621:./include/linux/fs.h **** };
 622:./include/linux/fs.h **** 
 623:./include/linux/fs.h **** #define	UUID_STRING_LEN		36
 624:./include/linux/fs.h **** 
 625:./include/linux/fs.h **** 
 626:./include/linux/fs.h **** 
 627:./include/linux/fs.h **** struct super_block 
 628:./include/linux/fs.h **** { 
 629:./include/linux/fs.h **** 	struct list_head				s_list;		/* Keep this first */
 630:./include/linux/fs.h ****     dev_t							s_dev;		/* search index; _not_ kdev_t */
 631:./include/linux/fs.h **** 	unsigned long					s_blocksize;
 632:./include/linux/fs.h ****     const struct super_operations	*s_op;
 633:./include/linux/fs.h **** 	const struct dquot_operations	*dq_op;
 634:./include/linux/fs.h **** 
 635:./include/linux/fs.h **** 	struct dentry		*s_root;      //superblock的根目录结点
 636:./include/linux/fs.h **** 	struct block_device	*s_bdev; 
 637:./include/linux/fs.h **** 	struct hlist_node	s_instances;
 638:./include/linux/fs.h **** 	struct list_head	s_mounts;
 639:./include/linux/fs.h **** 	void			   *s_fs_info;	/* Filesystem private info */
 640:./include/linux/fs.h **** 	char			    s_sysfs_name[UUID_STRING_LEN + 1];
 641:./include/linux/fs.h **** 	unsigned int		s_max_links;
 642:./include/linux/fs.h **** 	struct mutex            		s_vfs_rename_mutex;	/* Kludge */
 643:./include/linux/fs.h **** 	const struct dentry_operations *s_d_op; /* default d_op for dentries */
 644:./include/linux/fs.h **** 	struct hlist_head s_pins;
 645:./include/linux/fs.h **** };
 646:./include/linux/fs.h **** 
 647:./include/linux/fs.h **** 
 648:./include/linux/fs.h **** /********************************************************
 649:./include/linux/fs.h ****  * 														*
 650:./include/linux/fs.h ****  * 			       super_operations						*
 651:./include/linux/fs.h ****  *														* 
 652:./include/linux/fs.h **** *********************************************************/
 653:./include/linux/fs.h **** 
ARM GAS  /tmp/cc2wwjO4.s 			page 49


 654:./include/linux/fs.h **** struct seq_operations ;
 655:./include/linux/fs.h **** struct seq_file {
 656:./include/linux/fs.h **** 	char *buf;
 657:./include/linux/fs.h **** 	size_t size;
 658:./include/linux/fs.h **** 	size_t from;
 659:./include/linux/fs.h **** 	size_t count;
 660:./include/linux/fs.h **** 	size_t pad_until;
 661:./include/linux/fs.h **** 	loff_t index;
 662:./include/linux/fs.h **** 	loff_t read_pos;
 663:./include/linux/fs.h **** 	struct mutex lock;
 664:./include/linux/fs.h **** 	const struct seq_operations *op;
 665:./include/linux/fs.h **** 	int poll_event;
 666:./include/linux/fs.h **** 	const struct file *file;
 667:./include/linux/fs.h **** 	void *private;
 668:./include/linux/fs.h **** };
 669:./include/linux/fs.h **** 
 670:./include/linux/fs.h **** struct seq_operations {
 671:./include/linux/fs.h **** 	void * (*start) (struct seq_file *m, loff_t *pos);
 672:./include/linux/fs.h **** 	void (*stop) (struct seq_file *m, void *v);
 673:./include/linux/fs.h **** 	void * (*next) (struct seq_file *m, void *v, loff_t *pos);
 674:./include/linux/fs.h **** 	int (*show) (struct seq_file *m, void *v);
 675:./include/linux/fs.h **** };
 676:./include/linux/fs.h **** 
 677:./include/linux/fs.h **** enum freeze_holder {
 678:./include/linux/fs.h **** 	FREEZE_HOLDER_KERNEL	= (1U << 0),
 679:./include/linux/fs.h **** 	FREEZE_HOLDER_USERSPACE	= (1U << 1),
 680:./include/linux/fs.h **** 	FREEZE_MAY_NEST		= (1U << 2),
 681:./include/linux/fs.h **** };
 682:./include/linux/fs.h **** 
 683:./include/linux/fs.h **** struct writeback_control {
 684:./include/linux/fs.h **** 	unsigned long nr_to_write;
 685:./include/linux/fs.h **** };
 686:./include/linux/fs.h **** 
 687:./include/linux/fs.h **** 
 688:./include/linux/fs.h **** struct shrink_control {
 689:./include/linux/fs.h **** 	gfp_t gfp_mask;
 690:./include/linux/fs.h **** 	int nid;
 691:./include/linux/fs.h **** 	unsigned long nr_to_scan;
 692:./include/linux/fs.h **** 	unsigned long nr_scanned;
 693:./include/linux/fs.h ****     //struct mem_cgroup *memcg;
 694:./include/linux/fs.h **** };
 695:./include/linux/fs.h **** 
 696:./include/linux/fs.h **** struct super_operations {
 697:./include/linux/fs.h ****    	struct inode *(*alloc_inode)(struct super_block *sb);
 698:./include/linux/fs.h **** 	void (*destroy_inode)       (struct inode *);
 699:./include/linux/fs.h **** 	void (*free_inode)          (struct inode *);
 700:./include/linux/fs.h ****    	void (*dirty_inode)         (struct inode *, int flags);
 701:./include/linux/fs.h **** 	int  (*write_inode)         (struct inode *, struct writeback_control *wbc);
 702:./include/linux/fs.h **** 	int  (*drop_inode)          (struct inode *);
 703:./include/linux/fs.h **** 	void (*evict_inode)         (struct inode *);
 704:./include/linux/fs.h **** 	void (*put_super)           (struct super_block *);
 705:./include/linux/fs.h **** 	int  (*sync_fs)             (struct super_block *sb, int wait);
 706:./include/linux/fs.h **** 	int  (*freeze_super)        (struct super_block *, enum freeze_holder who);
 707:./include/linux/fs.h **** 	int  (*freeze_fs)           (struct super_block *);
 708:./include/linux/fs.h **** 	int  (*thaw_super)          (struct super_block *, enum freeze_holder who);
 709:./include/linux/fs.h **** 	int  (*unfreeze_fs)         (struct super_block *);
 710:./include/linux/fs.h **** 	int  (*statfs)              (struct dentry *, struct kstatfs *);
ARM GAS  /tmp/cc2wwjO4.s 			page 50


 711:./include/linux/fs.h **** 	int  (*remount_fs)          (struct super_block *, int *, char *);
 712:./include/linux/fs.h **** 	void (*umount_begin)        (struct super_block *);
 713:./include/linux/fs.h **** 	int  (*show_options)        (struct seq_file *, struct dentry *);
 714:./include/linux/fs.h **** 	int  (*show_devname)        (struct seq_file *, struct dentry *);
 715:./include/linux/fs.h **** 	int  (*show_path)           (struct seq_file *, struct dentry *);
 716:./include/linux/fs.h **** 	int  (*show_stats)          (struct seq_file *, struct dentry *);
 717:./include/linux/fs.h **** 
 718:./include/linux/fs.h **** #ifdef CONFIG_QUOTA
 719:./include/linux/fs.h **** 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
 720:./include/linux/fs.h **** 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 721:./include/linux/fs.h **** 	struct dquot __rcu **(*get_dquots)(struct inode *);
 722:./include/linux/fs.h **** #endif
 723:./include/linux/fs.h **** 
 724:./include/linux/fs.h **** 	long (*nr_cached_objects)(struct super_block *,struct shrink_control *);
 725:./include/linux/fs.h **** 	long (*free_cached_objects)(struct super_block *,struct shrink_control *);
 726:./include/linux/fs.h **** 	void (*shutdown)(struct super_block *sb);
 727:./include/linux/fs.h **** };
 728:./include/linux/fs.h **** 
 729:./include/linux/fs.h **** 
 730:./include/linux/fs.h **** 
 731:./include/linux/fs.h **** /********************************************************
 732:./include/linux/fs.h ****  * 														*
 733:./include/linux/fs.h ****  * 			       dquot_operations						*
 734:./include/linux/fs.h ****  *														* 
 735:./include/linux/fs.h **** *********************************************************/
 736:./include/linux/fs.h **** 
 737:./include/linux/fs.h **** typedef __kernel_uid32_t 	qid_t; /* Type in which we store ids in memory */
 738:./include/linux/fs.h **** typedef long long 			qsize_t;	/* Type in which we store sizes */
 739:./include/linux/fs.h **** 
 740:./include/linux/fs.h **** #undef USRQUOTA
 741:./include/linux/fs.h **** #undef GRPQUOTA
 742:./include/linux/fs.h **** #undef PRJQUOTA
 743:./include/linux/fs.h **** enum quota_type {
 744:./include/linux/fs.h **** 	USRQUOTA = 0,		/* element used for user quotas */
 745:./include/linux/fs.h **** 	GRPQUOTA = 1,		/* element used for group quotas */
 746:./include/linux/fs.h **** 	PRJQUOTA = 2,		/* element used for project quotas */
 747:./include/linux/fs.h **** };
 748:./include/linux/fs.h **** 
 749:./include/linux/fs.h **** struct kqid {			/* Type in which we store the quota identifier */
 750:./include/linux/fs.h **** 	union {
 751:./include/linux/fs.h **** 		kuid_t uid;
 752:./include/linux/fs.h **** 		kgid_t gid;
 753:./include/linux/fs.h **** 		kprojid_t projid;
 754:./include/linux/fs.h **** 	};
 755:./include/linux/fs.h **** 	enum quota_type type;  /* USRQUOTA (uid) or GRPQUOTA (gid) or PRJQUOTA (projid) */
 756:./include/linux/fs.h **** };
 757:./include/linux/fs.h **** 
 758:./include/linux/fs.h **** struct mem_dqblk {
 759:./include/linux/fs.h **** 	qsize_t dqb_bhardlimit;	/* absolute limit on disk blks alloc */
 760:./include/linux/fs.h **** 	qsize_t dqb_bsoftlimit;	/* preferred limit on disk blks */
 761:./include/linux/fs.h **** 	qsize_t dqb_curspace;	/* current used space */
 762:./include/linux/fs.h **** 	qsize_t dqb_rsvspace;   /* current reserved space for delalloc*/
 763:./include/linux/fs.h **** 	qsize_t dqb_ihardlimit;	/* absolute limit on allocated inodes */
 764:./include/linux/fs.h **** 	qsize_t dqb_isoftlimit;	/* preferred inode limit */
 765:./include/linux/fs.h **** 	qsize_t dqb_curinodes;	/* current # allocated inodes */
 766:./include/linux/fs.h **** 	time64_t dqb_btime;	/* time limit for excessive disk use */
 767:./include/linux/fs.h **** 	time64_t dqb_itime;	/* time limit for excessive inode use */
ARM GAS  /tmp/cc2wwjO4.s 			page 51


 768:./include/linux/fs.h **** };
 769:./include/linux/fs.h **** 
 770:./include/linux/fs.h **** struct dquot {
 771:./include/linux/fs.h **** 	struct hlist_node dq_hash;	/* Hash list in memory [dq_list_lock] */
 772:./include/linux/fs.h **** 	struct list_head dq_inuse;	/* List of all quotas [dq_list_lock] */
 773:./include/linux/fs.h **** 	struct list_head dq_free;	/* Free list element [dq_list_lock] */
 774:./include/linux/fs.h **** 	struct list_head dq_dirty;	/* List of dirty dquots [dq_list_lock] */
 775:./include/linux/fs.h **** 	struct mutex dq_lock;		/* dquot IO lock */
 776:./include/linux/fs.h **** //	spinlock_t dq_dqb_lock;		/* Lock protecting dq_dqb changes */
 777:./include/linux/fs.h **** 	atomic_t dq_count;		/* Use count */
 778:./include/linux/fs.h **** 	struct super_block *dq_sb;	/* superblock this applies to */
 779:./include/linux/fs.h **** 	struct kqid dq_id;		/* ID this applies to (uid, gid, projid) */
 780:./include/linux/fs.h **** 	loff_t dq_off;			/* Offset of dquot on disk [dq_lock, stable once set] */
 781:./include/linux/fs.h **** 	unsigned long dq_flags;		/* See DQ_* */
 782:./include/linux/fs.h **** 	struct mem_dqblk dq_dqb;	/* Diskquota usage [dq_dqb_lock] */
 783:./include/linux/fs.h **** };
 784:./include/linux/fs.h **** 
 785:./include/linux/fs.h **** /* Operations which must be implemented by each quota format */
 786:./include/linux/fs.h **** 
 787:./include/linux/fs.h **** struct quota_format_ops {
 788:./include/linux/fs.h **** 	int (*check_quota_file)(struct super_block *sb, int type);	/* Detect whether file is in our format
 789:./include/linux/fs.h **** 	int (*read_file_info)(struct super_block *sb, int type);	/* Read main info about file - called on 
 790:./include/linux/fs.h **** 	int (*write_file_info)(struct super_block *sb, int type);	/* Write main info about file */
 791:./include/linux/fs.h **** 	int (*free_file_info)(struct super_block *sb, int type);	/* Called on quotaoff() */
 792:./include/linux/fs.h **** 	int (*read_dqblk)(struct dquot *dquot);		/* Read structure for one user */
 793:./include/linux/fs.h **** 	int (*commit_dqblk)(struct dquot *dquot);	/* Write structure for one user */
 794:./include/linux/fs.h **** 	int (*release_dqblk)(struct dquot *dquot);	/* Called when last reference to dquot is being dropped
 795:./include/linux/fs.h **** 	int (*get_next_id)(struct super_block *sb, struct kqid *qid);	/* Get next ID with existing structu
 796:./include/linux/fs.h **** };
 797:./include/linux/fs.h **** 
 798:./include/linux/fs.h **** struct dquot_operations {
 799:./include/linux/fs.h **** 	int (*write_dquot) (struct dquot *);		/* Ordinary dquot write */
 800:./include/linux/fs.h **** 	struct dquot *(*alloc_dquot)(struct super_block *, int);	/* Allocate memory for new dquot */
 801:./include/linux/fs.h **** 	void (*destroy_dquot)(struct dquot *);		/* Free memory for dquot */
 802:./include/linux/fs.h **** 	int (*acquire_dquot) (struct dquot *);		/* Quota is going to be created on disk */
 803:./include/linux/fs.h **** 	int (*release_dquot) (struct dquot *);		/* Quota is going to be deleted from disk */
 804:./include/linux/fs.h **** 	int (*mark_dirty) (struct dquot *);		/* Dquot is marked dirty */
 805:./include/linux/fs.h **** 	int (*write_info) (struct super_block *, int);	/* Write of quota "superblock" */
 806:./include/linux/fs.h **** 	/* get reserved quota for delayed alloc, value returned is managed by
 807:./include/linux/fs.h **** 	 * quota code only */
 808:./include/linux/fs.h **** 	qsize_t *(*get_reserved_space) (struct inode *);
 809:./include/linux/fs.h **** 	int (*get_projid) (struct inode *, kprojid_t *);/* Get project ID */
 810:./include/linux/fs.h **** 	/* Get number of inodes that were charged for a given inode */
 811:./include/linux/fs.h **** 	int (*get_inode_usage) (struct inode *, qsize_t *);
 812:./include/linux/fs.h **** 	/* Get next ID with active quota structure */
 813:./include/linux/fs.h **** 	int (*get_next_id) (struct super_block *sb, struct kqid *qid);
 814:./include/linux/fs.h **** };
 815:./include/linux/fs.h **** 
 816:./include/linux/fs.h **** /********************************************************
 817:./include/linux/fs.h ****  * 														*
 818:./include/linux/fs.h ****  * 			       file_system_type						*
 819:./include/linux/fs.h ****  *														* 
 820:./include/linux/fs.h **** *********************************************************/
 821:./include/linux/fs.h **** 
 822:./include/linux/fs.h **** struct fs_parameter_spec {
 823:./include/linux/fs.h **** 	const char		*name;
 824:./include/linux/fs.h **** //	fs_param_type		*type;	/* The desired parameter type */
ARM GAS  /tmp/cc2wwjO4.s 			page 52


 825:./include/linux/fs.h **** 	u8			opt;	/* Option number (returned by fs_parse()) */
 826:./include/linux/fs.h **** 	unsigned short		flags;
 827:./include/linux/fs.h **** #define fs_param_neg_with_no	0x0002	/* "noxxx" is negative param */
 828:./include/linux/fs.h **** #define fs_param_can_be_empty	0x0004	/* "xxx=" is allowed */
 829:./include/linux/fs.h **** #define fs_param_deprecated	0x0008	/* The param is deprecated */
 830:./include/linux/fs.h **** 	const void		*data;
 831:./include/linux/fs.h **** };
 832:./include/linux/fs.h **** 
 833:./include/linux/fs.h **** 
 834:./include/linux/fs.h **** struct file_system_type {
 835:./include/linux/fs.h **** 	const char *name;
 836:./include/linux/fs.h **** 	int fs_flags;
 837:./include/linux/fs.h **** #define FS_REQUIRES_DEV		1 
 838:./include/linux/fs.h **** #define FS_BINARY_MOUNTDATA	2
 839:./include/linux/fs.h **** #define FS_HAS_SUBTYPE		4
 840:./include/linux/fs.h **** #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 841:./include/linux/fs.h **** #define FS_DISALLOW_NOTIFY_PERM	16	/* Disable fanotify permission events */
 842:./include/linux/fs.h **** #define FS_ALLOW_IDMAP         32      /* FS has been updated to handle vfs idmappings. */
 843:./include/linux/fs.h **** #define FS_MGTIME		64	/* FS uses multigrain timestamps */
 844:./include/linux/fs.h **** #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 845:./include/linux/fs.h **** 	int (*init_fs_context)(struct fs_context *);
 846:./include/linux/fs.h **** 	const struct fs_parameter_spec *parameters;
 847:./include/linux/fs.h **** 	struct dentry *(*mount) (struct file_system_type *, int,
 848:./include/linux/fs.h **** 		       const char *, void *);
 849:./include/linux/fs.h **** 	void (*kill_sb) (struct super_block *);
 850:./include/linux/fs.h **** 	void *owner;
 851:./include/linux/fs.h **** 	struct file_system_type * next;
 852:./include/linux/fs.h **** 	struct hlist_head fs_supers;
 853:./include/linux/fs.h **** 
 854:./include/linux/fs.h **** 	struct lock_class_key s_lock_key;
 855:./include/linux/fs.h **** 	struct lock_class_key s_umount_key;
 856:./include/linux/fs.h **** 	struct lock_class_key s_vfs_rename_key;
 857:./include/linux/fs.h **** 	struct lock_class_key s_writers_key[SB_FREEZE_LEVELS];
 858:./include/linux/fs.h **** 	struct lock_class_key i_lock_key;
 859:./include/linux/fs.h **** 	struct lock_class_key i_mutex_key;
 860:./include/linux/fs.h **** 	struct lock_class_key invalidate_lock_key;
 861:./include/linux/fs.h **** 	struct lock_class_key i_mutex_dir_key;
 862:./include/linux/fs.h **** };
 863:./include/linux/fs.h **** 
 864:./include/linux/fs.h **** 
 865:./include/linux/fs.h **** 
 866:./include/linux/fs.h **** extern int register_filesystem(struct file_system_type *);
 867:./include/linux/fs.h **** extern int unregister_filesystem(struct file_system_type *);
 868:./include/linux/fs.h **** extern struct file_system_type *lookup_fs_type(const char *name);
 869:./include/linux/fs.h **** 
 870:./include/linux/fs.h **** /*--------------------------------------------------------------------------*/
 871:./include/linux/fs.h **** static inline bool is_sync_kiocb(struct kiocb *kiocb){
 872:./include/linux/fs.h **** 	return kiocb->ki_complete == NULL;
 873:./include/linux/fs.h **** }
 874:./include/linux/fs.h **** static inline struct inode *file_inode(const struct file *f){
 875:./include/linux/fs.h **** 	return f->f_inode;
 876:./include/linux/fs.h **** }
 877:./include/linux/fs.h **** /*--------------------------------------------------------------------------*/
 878:./include/linux/fs.h **** 
 879:./include/linux/fs.h **** extern int remove_dentry(char* path);
 880:./include/linux/fs.h **** extern struct file *filp_open(const char * path, int flags, umode_t mode);
 881:./include/linux/fs.h **** extern ssize_t kernel_read(struct file *file, void * buf, size_t count, loff_t *ppos);
ARM GAS  /tmp/cc2wwjO4.s 			page 53


 882:./include/linux/fs.h **** extern ssize_t kernel_write(struct file *file,const void * buf, size_t count, loff_t *ppos);
 883:./include/linux/fs.h **** extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
 884:./include/linux/fs.h **** extern int file_close(struct file *file, fl_owner_t id);
 885:./include/linux/fs.h **** 
 886:./include/linux/fs.h **** 
 887:./include/linux/fs.h **** 
 888:./include/linux/fs.h **** /* fs/char_dev.c */
 889:./include/linux/fs.h **** #define CHRDEV_MAJOR_MAX 512
 890:./include/linux/fs.h **** /* Marks the bottom of the first segment of free char majors */
 891:./include/linux/fs.h **** #define CHRDEV_MAJOR_DYN_END 234
 892:./include/linux/fs.h **** /* Marks the top and bottom of the second segment of free char majors */
 893:./include/linux/fs.h **** #define CHRDEV_MAJOR_DYN_EXT_START 511
 894:./include/linux/fs.h **** #define CHRDEV_MAJOR_DYN_EXT_END 384
 895:./include/linux/fs.h **** 
 896:./include/linux/fs.h **** 
 897:./include/linux/fs.h **** 
 898:./include/linux/fs.h **** extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
 899:./include/linux/fs.h **** extern int register_chrdev_region(dev_t, unsigned, const char *);
 900:./include/linux/fs.h **** extern int __register_chrdev(unsigned int major, unsigned int baseminor,
 901:./include/linux/fs.h ****     unsigned int count, const char *name,
 902:./include/linux/fs.h ****     const struct file_operations *fops);
 903:./include/linux/fs.h **** extern void __unregister_chrdev(unsigned int major, unsigned int baseminor,
 904:./include/linux/fs.h **** 		unsigned int count, const char *name);
 905:./include/linux/fs.h **** extern void unregister_chrdev_region(dev_t, unsigned);
 906:./include/linux/fs.h **** 
 907:./include/linux/fs.h **** static inline int register_chrdev(unsigned int major, const char *name,
 1085              		.loc 4 907 19 view .LVU298
 1086              	.LBB25:
 908:./include/linux/fs.h **** 	const struct file_operations *fops)
 909:./include/linux/fs.h **** {
 910:./include/linux/fs.h **** return __register_chrdev(major, 0, 256, name, fops);
 1087              		.loc 4 910 1 view .LVU299
 1088              		.loc 4 910 8 is_stmt 0 view .LVU300
 1089 0004 164C     		ldr	r4, .L84
 1090 0006 174B     		ldr	r3, .L84+4
 1091 0008 0093     		str	r3, [sp]
 1092 000a 2346     		mov	r3, r4
 1093 000c 4FF48072 		mov	r2, #256
 1094 0010 0021     		movs	r1, #0
 1095 0012 0846     		mov	r0, r1
 1096 0014 FFF7FEFF 		bl	__register_chrdev
 1097              	.LVL111:
 1098 0018 0546     		mov	r5, r0
 1099              	.LVL112:
 1100              		.loc 4 910 8 view .LVU301
 1101              	.LBE25:
 1102              	.LBE24:
 475:./drivers/gpio/stm32f4_gpio.c **** 	pr_info ( "register gpio (%d) \n" , major);
 1103              		.loc 1 475 2 is_stmt 1 view .LVU302
 1104 001a 0146     		mov	r1, r0
 1105 001c 1248     		ldr	r0, .L84+8
 1106              	.LVL113:
 1107              		.loc 1 475 2 is_stmt 0 view .LVU303
 1108 001e FFF7FEFF 		bl	printk
 1109              	.LVL114:
 476:./drivers/gpio/stm32f4_gpio.c **** 
 477:./drivers/gpio/stm32f4_gpio.c ****     struct class* gpio_class = class_create(THIS_MODULE,"gpios");
ARM GAS  /tmp/cc2wwjO4.s 			page 54


 1110              		.loc 1 477 5 is_stmt 1 view .LVU304
 1111              		.loc 1 477 32 is_stmt 0 view .LVU305
 1112 0022 2146     		mov	r1, r4
 1113 0024 0020     		movs	r0, #0
 1114 0026 FFF7FEFF 		bl	class_create
 1115              	.LVL115:
 1116 002a 0446     		mov	r4, r0
 1117              	.LVL116:
 478:./drivers/gpio/stm32f4_gpio.c ****     if(IS_ERR(gpio_class)){
 1118              		.loc 1 478 5 is_stmt 1 view .LVU306
 1119              	.LBB26:
 1120              	.LBI26:
 1121              		.file 5 "./include/linux/err.h"
   1:./include/linux/err.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/err.h **** #ifndef _LINUX_ERR_H
   3:./include/linux/err.h **** #define _LINUX_ERR_H
   4:./include/linux/err.h **** 
   5:./include/linux/err.h **** #include <linux/compiler_attributes.h>
   6:./include/linux/err.h **** #include <linux/compiler.h>
   7:./include/linux/err.h **** #include <linux/types.h>
   8:./include/linux/err.h **** 
   9:./include/linux/err.h **** #include <asm/errno.h>
  10:./include/linux/err.h **** 
  11:./include/linux/err.h **** /*
  12:./include/linux/err.h ****  * Kernel pointers have redundant information, so we can use a
  13:./include/linux/err.h ****  * scheme where we can return either an error code or a normal
  14:./include/linux/err.h ****  * pointer with the same return value.
  15:./include/linux/err.h ****  *
  16:./include/linux/err.h ****  * This should be a per-architecture thing, to allow different
  17:./include/linux/err.h ****  * error and pointer decisions.
  18:./include/linux/err.h ****  */
  19:./include/linux/err.h **** #define MAX_ERRNO	4095
  20:./include/linux/err.h **** 
  21:./include/linux/err.h **** #ifndef __ASSEMBLY__
  22:./include/linux/err.h **** 
  23:./include/linux/err.h **** /**
  24:./include/linux/err.h ****  * IS_ERR_VALUE - Detect an error pointer.
  25:./include/linux/err.h ****  * @x: The pointer to check.
  26:./include/linux/err.h ****  *
  27:./include/linux/err.h ****  * Like IS_ERR(), but does not generate a compiler warning if result is unused.
  28:./include/linux/err.h ****  */
  29:./include/linux/err.h **** 
  30:./include/linux/err.h **** #ifndef unlikely
  31:./include/linux/err.h **** #  define unlikely(x) __builtin_expect(!!(x), 0)
  32:./include/linux/err.h **** #endif
  33:./include/linux/err.h **** 
  34:./include/linux/err.h **** #ifndef likely
  35:./include/linux/err.h **** #  define likely(x) __builtin_expect(!!(x), 1)
  36:./include/linux/err.h **** #endif
  37:./include/linux/err.h **** 
  38:./include/linux/err.h **** #define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)
  39:./include/linux/err.h **** 
  40:./include/linux/err.h **** /**
  41:./include/linux/err.h ****  * ERR_PTR - Create an error pointer.
  42:./include/linux/err.h ****  * @error: A negative error code.
  43:./include/linux/err.h ****  *
  44:./include/linux/err.h ****  * Encodes @error into a pointer value. Users should consider the result
ARM GAS  /tmp/cc2wwjO4.s 			page 55


  45:./include/linux/err.h ****  * opaque and not assume anything about how the error is encoded.
  46:./include/linux/err.h ****  *
  47:./include/linux/err.h ****  * Return: A pointer with @error encoded within its value.
  48:./include/linux/err.h ****  */
  49:./include/linux/err.h **** static inline void * __must_check ERR_PTR(long error)
  50:./include/linux/err.h **** {
  51:./include/linux/err.h **** 	return (void *) error;
  52:./include/linux/err.h **** }
  53:./include/linux/err.h **** 
  54:./include/linux/err.h **** /* Return the pointer in the percpu address space. */
  55:./include/linux/err.h **** #define ERR_PTR_PCPU(error) ((void __percpu *)(unsigned long)ERR_PTR(error))
  56:./include/linux/err.h **** 
  57:./include/linux/err.h **** /**
  58:./include/linux/err.h ****  * PTR_ERR - Extract the error code from an error pointer.
  59:./include/linux/err.h ****  * @ptr: An error pointer.
  60:./include/linux/err.h ****  * Return: The error code within @ptr.
  61:./include/linux/err.h ****  */
  62:./include/linux/err.h **** static inline long __must_check PTR_ERR(__force const void *ptr)
  63:./include/linux/err.h **** {
  64:./include/linux/err.h **** 	return (long) ptr;
  65:./include/linux/err.h **** }
  66:./include/linux/err.h **** 
  67:./include/linux/err.h **** /* Read an error pointer from the percpu address space. */
  68:./include/linux/err.h **** #define PTR_ERR_PCPU(ptr) (PTR_ERR((const void *)(__force const unsigned long)(ptr)))
  69:./include/linux/err.h **** 
  70:./include/linux/err.h **** /**
  71:./include/linux/err.h ****  * IS_ERR - Detect an error pointer.
  72:./include/linux/err.h ****  * @ptr: The pointer to check.
  73:./include/linux/err.h ****  * Return: true if @ptr is an error pointer, false otherwise.
  74:./include/linux/err.h ****  */
  75:./include/linux/err.h **** static inline bool __must_check IS_ERR(__force const void *ptr)
 1122              		.loc 5 75 33 view .LVU307
 1123              	.LBB27:
  76:./include/linux/err.h **** {
  77:./include/linux/err.h **** 	return IS_ERR_VALUE((unsigned long)ptr);
 1124              		.loc 5 77 2 view .LVU308
 1125              		.loc 5 77 9 is_stmt 0 view .LVU309
 1126 002c 10F5805F 		cmn	r0, #4096
 1127 0030 94BF     		ite	ls
 1128 0032 0026     		movls	r6, #0
 1129 0034 0126     		movhi	r6, #1
 1130              	.LVL117:
 1131              		.loc 5 77 9 view .LVU310
 1132              	.LBE27:
 1133              	.LBE26:
 1134              		.loc 1 478 7 discriminator 1 view .LVU311
 1135 0036 5EB9     		cbnz	r6, .L82
 1136              	.LVL118:
 1137              	.L79:
 479:./drivers/gpio/stm32f4_gpio.c ****         pr_info("can not create gpio_class\n");
 480:./drivers/gpio/stm32f4_gpio.c ****     }
 481:./drivers/gpio/stm32f4_gpio.c ****     struct device * dev = device_create(gpio_class,NULL,major,NULL,"gpios");
 1138              		.loc 1 481 5 is_stmt 1 view .LVU312
 1139              		.loc 1 481 27 is_stmt 0 view .LVU313
 1140 0038 094B     		ldr	r3, .L84
 1141 003a 0093     		str	r3, [sp]
 1142 003c 0023     		movs	r3, #0
ARM GAS  /tmp/cc2wwjO4.s 			page 56


 1143 003e 2A46     		mov	r2, r5
 1144 0040 1946     		mov	r1, r3
 1145 0042 2046     		mov	r0, r4
 1146 0044 FFF7FEFF 		bl	device_create
 1147              	.LVL119:
 482:./drivers/gpio/stm32f4_gpio.c ****     if(IS_ERR(gpio_class)){
 1148              		.loc 1 482 5 is_stmt 1 view .LVU314
 1149              		.loc 1 482 7 is_stmt 0 discriminator 1 view .LVU315
 1150 0048 36B9     		cbnz	r6, .L83
 1151              	.L80:
 483:./drivers/gpio/stm32f4_gpio.c ****         pr_info("can not create gpios device\n");
 484:./drivers/gpio/stm32f4_gpio.c ****     }
 485:./drivers/gpio/stm32f4_gpio.c ****     return 0;
 1152              		.loc 1 485 5 is_stmt 1 view .LVU316
 486:./drivers/gpio/stm32f4_gpio.c **** }
 1153              		.loc 1 486 1 is_stmt 0 view .LVU317
 1154 004a 0020     		movs	r0, #0
 1155 004c 02B0     		add	sp, sp, #8
 1156              	.LCFI7:
 1157              		.cfi_remember_state
 1158              		.cfi_def_cfa_offset 16
 1159              		@ sp needed
 1160 004e 70BD     		pop	{r4, r5, r6, pc}
 1161              	.LVL120:
 1162              	.L82:
 1163              	.LCFI8:
 1164              		.cfi_restore_state
 479:./drivers/gpio/stm32f4_gpio.c ****     }
 1165              		.loc 1 479 9 is_stmt 1 view .LVU318
 1166 0050 0648     		ldr	r0, .L84+12
 1167              	.LVL121:
 479:./drivers/gpio/stm32f4_gpio.c ****     }
 1168              		.loc 1 479 9 is_stmt 0 view .LVU319
 1169 0052 FFF7FEFF 		bl	printk
 1170              	.LVL122:
 1171 0056 EFE7     		b	.L79
 1172              	.L83:
 483:./drivers/gpio/stm32f4_gpio.c ****         pr_info("can not create gpios device\n");
 1173              		.loc 1 483 9 is_stmt 1 view .LVU320
 1174 0058 0548     		ldr	r0, .L84+16
 1175 005a FFF7FEFF 		bl	printk
 1176              	.LVL123:
 1177 005e F4E7     		b	.L80
 1178              	.L85:
 1179              		.align	2
 1180              	.L84:
 1181 0060 00000000 		.word	.LC5
 1182 0064 00000000 		.word	gpio_fops
 1183 0068 08000000 		.word	.LC6
 1184 006c 20000000 		.word	.LC7
 1185 0070 3C000000 		.word	.LC8
 1186              		.cfi_endproc
 1187              	.LFE1052:
 1189              		.section	.rodata.print_gpio_number.str1.4,"aMS",%progbits,1
 1190              		.align	2
 1191              	.LC9:
 1192 0000 25732573 		.ascii	"%s%s%s\000"
ARM GAS  /tmp/cc2wwjO4.s 			page 57


 1192      257300
 1193 0007 00       		.align	2
 1194              	.LC10:
 1195 0008 6572726F 		.ascii	"error pin number: %d%s\000"
 1195      72207069 
 1195      6E206E75 
 1195      6D626572 
 1195      3A202564 
 1196              		.section	.text.print_gpio_number,"ax",%progbits
 1197              		.align	1
 1198              		.global	print_gpio_number
 1199              		.syntax unified
 1200              		.thumb
 1201              		.thumb_func
 1203              	print_gpio_number:
 1204              	.LVL124:
 1205              	.LFB1035:
 150:./drivers/gpio/stm32f4_gpio.c ****     static const char prefix[] = "export gpio: GPIO_Pin_";
 1206              		.loc 1 150 38 view -0
 1207              		.cfi_startproc
 1208              		@ args = 0, pretend = 0, frame = 8
 1209              		@ frame_needed = 0, uses_anonymous_args = 0
 150:./drivers/gpio/stm32f4_gpio.c ****     static const char prefix[] = "export gpio: GPIO_Pin_";
 1210              		.loc 1 150 38 is_stmt 0 view .LVU322
 1211 0000 00B5     		push	{lr}
 1212              	.LCFI9:
 1213              		.cfi_def_cfa_offset 4
 1214              		.cfi_offset 14, -4
 1215 0002 83B0     		sub	sp, sp, #12
 1216              	.LCFI10:
 1217              		.cfi_def_cfa_offset 16
 151:./drivers/gpio/stm32f4_gpio.c ****     static const char suffix[] = "\n\r";
 1218              		.loc 1 151 5 is_stmt 1 view .LVU323
 152:./drivers/gpio/stm32f4_gpio.c ****     if(pin >= GPIO_Pin_0 && pin <= GPIO_Pin_15) {
 1219              		.loc 1 152 5 view .LVU324
 153:./drivers/gpio/stm32f4_gpio.c ****         // 计算引脚号(0-15)
 1220              		.loc 1 153 5 view .LVU325
 153:./drivers/gpio/stm32f4_gpio.c ****         // 计算引脚号(0-15)
 1221              		.loc 1 153 26 is_stmt 0 view .LVU326
 1222 0004 431E     		subs	r3, r0, #1
 153:./drivers/gpio/stm32f4_gpio.c ****         // 计算引脚号(0-15)
 1223              		.loc 1 153 7 view .LVU327
 1224 0006 13F4004F 		tst	r3, #32768
 1225 000a 1ED1     		bne	.L96
 1226              	.LBB28:
 155:./drivers/gpio/stm32f4_gpio.c ****         while(pin >>= 1) { pin_num++; }
 1227              		.loc 1 155 17 view .LVU328
 1228 000c 0023     		movs	r3, #0
 1229 000e 01E0     		b	.L87
 1230              	.LVL125:
 1231              	.L89:
 156:./drivers/gpio/stm32f4_gpio.c ****         char buf[5] = {0}; // 最大存储"15"+null
 1232              		.loc 1 156 28 is_stmt 1 discriminator 2 view .LVU329
 156:./drivers/gpio/stm32f4_gpio.c ****         char buf[5] = {0}; // 最大存储"15"+null
 1233              		.loc 1 156 35 is_stmt 0 discriminator 2 view .LVU330
 1234 0010 0133     		adds	r3, r3, #1
 1235              	.LVL126:
ARM GAS  /tmp/cc2wwjO4.s 			page 58


 156:./drivers/gpio/stm32f4_gpio.c ****         char buf[5] = {0}; // 最大存储"15"+null
 1236              		.loc 1 156 35 discriminator 2 view .LVU331
 1237 0012 DBB2     		uxtb	r3, r3
 1238              	.LVL127:
 1239              	.L87:
 156:./drivers/gpio/stm32f4_gpio.c ****         char buf[5] = {0}; // 最大存储"15"+null
 1240              		.loc 1 156 15 is_stmt 1 discriminator 1 view .LVU332
 156:./drivers/gpio/stm32f4_gpio.c ****         char buf[5] = {0}; // 最大存储"15"+null
 1241              		.loc 1 156 15 is_stmt 0 discriminator 1 view .LVU333
 1242 0014 4008     		lsrs	r0, r0, #1
 1243              	.LVL128:
 156:./drivers/gpio/stm32f4_gpio.c ****         char buf[5] = {0}; // 最大存储"15"+null
 1244              		.loc 1 156 15 discriminator 1 view .LVU334
 1245 0016 FBD1     		bne	.L89
 157:./drivers/gpio/stm32f4_gpio.c ****         if(pin_num < 10) {
 1246              		.loc 1 157 9 is_stmt 1 view .LVU335
 157:./drivers/gpio/stm32f4_gpio.c ****         if(pin_num < 10) {
 1247              		.loc 1 157 14 is_stmt 0 view .LVU336
 1248 0018 0022     		movs	r2, #0
 1249 001a 0092     		str	r2, [sp]
 1250 001c 8DF80420 		strb	r2, [sp, #4]
 158:./drivers/gpio/stm32f4_gpio.c ****             buf[0] = '0' + pin_num;
 1251              		.loc 1 158 9 is_stmt 1 view .LVU337
 158:./drivers/gpio/stm32f4_gpio.c ****             buf[0] = '0' + pin_num;
 1252              		.loc 1 158 11 is_stmt 0 view .LVU338
 1253 0020 092B     		cmp	r3, #9
 1254 0022 0BD8     		bhi	.L90
 159:./drivers/gpio/stm32f4_gpio.c ****         } else {
 1255              		.loc 1 159 13 is_stmt 1 view .LVU339
 159:./drivers/gpio/stm32f4_gpio.c ****         } else {
 1256              		.loc 1 159 26 is_stmt 0 view .LVU340
 1257 0024 3033     		adds	r3, r3, #48
 1258              	.LVL129:
 159:./drivers/gpio/stm32f4_gpio.c ****         } else {
 1259              		.loc 1 159 20 view .LVU341
 1260 0026 8DF80030 		strb	r3, [sp]
 1261              	.LVL130:
 1262              	.L91:
 164:./drivers/gpio/stm32f4_gpio.c ****     } else {
 1263              		.loc 1 164 9 is_stmt 1 view .LVU342
 1264 002a 0B4B     		ldr	r3, .L97
 1265 002c 6A46     		mov	r2, sp
 1266 002e 0B49     		ldr	r1, .L97+4
 1267 0030 0B48     		ldr	r0, .L97+8
 1268 0032 FFF7FEFF 		bl	printk
 1269              	.LVL131:
 1270              	.L86:
 164:./drivers/gpio/stm32f4_gpio.c ****     } else {
 1271              		.loc 1 164 9 is_stmt 0 view .LVU343
 1272              	.LBE28:
 168:./drivers/gpio/stm32f4_gpio.c **** 
 1273              		.loc 1 168 1 view .LVU344
 1274 0036 03B0     		add	sp, sp, #12
 1275              	.LCFI11:
 1276              		.cfi_remember_state
 1277              		.cfi_def_cfa_offset 4
 1278              		@ sp needed
ARM GAS  /tmp/cc2wwjO4.s 			page 59


 1279 0038 5DF804FB 		ldr	pc, [sp], #4
 1280              	.LVL132:
 1281              	.L90:
 1282              	.LCFI12:
 1283              		.cfi_restore_state
 1284              	.LBB29:
 161:./drivers/gpio/stm32f4_gpio.c ****             buf[1] = '0' + (pin_num - 10);
 1285              		.loc 1 161 13 is_stmt 1 view .LVU345
 161:./drivers/gpio/stm32f4_gpio.c ****             buf[1] = '0' + (pin_num - 10);
 1286              		.loc 1 161 20 is_stmt 0 view .LVU346
 1287 003c 3122     		movs	r2, #49
 1288 003e 8DF80020 		strb	r2, [sp]
 162:./drivers/gpio/stm32f4_gpio.c ****         }       
 1289              		.loc 1 162 13 is_stmt 1 view .LVU347
 162:./drivers/gpio/stm32f4_gpio.c ****         }       
 1290              		.loc 1 162 26 is_stmt 0 view .LVU348
 1291 0042 2633     		adds	r3, r3, #38
 1292              	.LVL133:
 162:./drivers/gpio/stm32f4_gpio.c ****         }       
 1293              		.loc 1 162 20 view .LVU349
 1294 0044 8DF80130 		strb	r3, [sp, #1]
 1295 0048 EFE7     		b	.L91
 1296              	.LVL134:
 1297              	.L96:
 162:./drivers/gpio/stm32f4_gpio.c ****         }       
 1298              		.loc 1 162 20 view .LVU350
 1299              	.LBE29:
 166:./drivers/gpio/stm32f4_gpio.c ****     }
 1300              		.loc 1 166 9 is_stmt 1 view .LVU351
 1301 004a 034A     		ldr	r2, .L97
 1302 004c 0146     		mov	r1, r0
 1303 004e 0548     		ldr	r0, .L97+12
 1304              	.LVL135:
 166:./drivers/gpio/stm32f4_gpio.c ****     }
 1305              		.loc 1 166 9 is_stmt 0 view .LVU352
 1306 0050 FFF7FEFF 		bl	printk
 1307              	.LVL136:
 168:./drivers/gpio/stm32f4_gpio.c **** 
 1308              		.loc 1 168 1 view .LVU353
 1309 0054 EFE7     		b	.L86
 1310              	.L98:
 1311 0056 00BF     		.align	2
 1312              	.L97:
 1313 0058 00000000 		.word	suffix.2
 1314 005c 00000000 		.word	prefix.3
 1315 0060 00000000 		.word	.LC9
 1316 0064 08000000 		.word	.LC10
 1317              		.cfi_endproc
 1318              	.LFE1035:
 1320              		.section	.rodata.print_gpio_type.str1.4,"aMS",%progbits,1
 1321              		.align	2
 1322              	.LC11:
 1323 0000 25732563 		.ascii	"%s%c%s\000"
 1323      257300
 1324 0007 00       		.align	2
 1325              	.LC12:
 1326 0008 6572726F 		.ascii	"error gpio type%s\000"
ARM GAS  /tmp/cc2wwjO4.s 			page 60


 1326      72206770 
 1326      696F2074 
 1326      79706525 
 1326      7300
 1327              		.section	.text.print_gpio_type,"ax",%progbits
 1328              		.align	1
 1329              		.global	print_gpio_type
 1330              		.syntax unified
 1331              		.thumb
 1332              		.thumb_func
 1334              	print_gpio_type:
 1335              	.LVL137:
 1336              	.LFB1036:
 170:./drivers/gpio/stm32f4_gpio.c ****     static const char prefix[] = "gpio type is :GPIO";
 1337              		.loc 1 170 42 is_stmt 1 view -0
 1338              		.cfi_startproc
 1339              		@ args = 0, pretend = 0, frame = 0
 1340              		@ frame_needed = 0, uses_anonymous_args = 0
 170:./drivers/gpio/stm32f4_gpio.c ****     static const char prefix[] = "gpio type is :GPIO";
 1341              		.loc 1 170 42 is_stmt 0 view .LVU355
 1342 0000 08B5     		push	{r3, lr}
 1343              	.LCFI13:
 1344              		.cfi_def_cfa_offset 8
 1345              		.cfi_offset 3, -8
 1346              		.cfi_offset 14, -4
 171:./drivers/gpio/stm32f4_gpio.c ****     static const char suffix[] = "\n\r";
 1347              		.loc 1 171 5 is_stmt 1 view .LVU356
 172:./drivers/gpio/stm32f4_gpio.c ****     
 1348              		.loc 1 172 5 view .LVU357
 174:./drivers/gpio/stm32f4_gpio.c ****         char port = 'A' + ((uint32_t)type - (uint32_t)GPIOA) / 0x400;
 1349              		.loc 1 174 5 view .LVU358
 174:./drivers/gpio/stm32f4_gpio.c ****         char port = 'A' + ((uint32_t)type - (uint32_t)GPIOA) / 0x400;
 1350              		.loc 1 174 22 is_stmt 0 view .LVU359
 1351 0002 00F13F40 		add	r0, r0, #-1090519040
 1352              	.LVL138:
 174:./drivers/gpio/stm32f4_gpio.c ****         char port = 'A' + ((uint32_t)type - (uint32_t)GPIOA) / 0x400;
 1353              		.loc 1 174 22 view .LVU360
 1354 0006 00F57E00 		add	r0, r0, #16646144
 1355              	.LVL139:
 174:./drivers/gpio/stm32f4_gpio.c ****         char port = 'A' + ((uint32_t)type - (uint32_t)GPIOA) / 0x400;
 1356              		.loc 1 174 7 view .LVU361
 1357 000a B0F5205F 		cmp	r0, #10240
 1358 000e 0AD8     		bhi	.L100
 1359              	.LBB30:
 175:./drivers/gpio/stm32f4_gpio.c ****         printk("%s%c%s", prefix, port, suffix);
 1360              		.loc 1 175 9 is_stmt 1 view .LVU362
 175:./drivers/gpio/stm32f4_gpio.c ****         printk("%s%c%s", prefix, port, suffix);
 1361              		.loc 1 175 25 is_stmt 0 view .LVU363
 1362 0010 C0F38720 		ubfx	r0, r0, #10, #8
 1363              	.LVL140:
 175:./drivers/gpio/stm32f4_gpio.c ****         printk("%s%c%s", prefix, port, suffix);
 1364              		.loc 1 175 14 view .LVU364
 1365 0014 00F14102 		add	r2, r0, #65
 1366              	.LVL141:
 176:./drivers/gpio/stm32f4_gpio.c ****     } else {
 1367              		.loc 1 176 9 is_stmt 1 view .LVU365
 1368 0018 054B     		ldr	r3, .L103
ARM GAS  /tmp/cc2wwjO4.s 			page 61


 1369 001a D2B2     		uxtb	r2, r2
 176:./drivers/gpio/stm32f4_gpio.c ****     } else {
 1370              		.loc 1 176 9 is_stmt 0 view .LVU366
 1371 001c 0549     		ldr	r1, .L103+4
 1372 001e 0648     		ldr	r0, .L103+8
 1373 0020 FFF7FEFF 		bl	printk
 1374              	.LVL142:
 1375              	.L99:
 176:./drivers/gpio/stm32f4_gpio.c ****     } else {
 1376              		.loc 1 176 9 view .LVU367
 1377              	.LBE30:
 180:./drivers/gpio/stm32f4_gpio.c **** 
 1378              		.loc 1 180 1 view .LVU368
 1379 0024 08BD     		pop	{r3, pc}
 1380              	.L100:
 178:./drivers/gpio/stm32f4_gpio.c ****     }
 1381              		.loc 1 178 9 is_stmt 1 view .LVU369
 1382 0026 0249     		ldr	r1, .L103
 1383 0028 0448     		ldr	r0, .L103+12
 1384 002a FFF7FEFF 		bl	printk
 1385              	.LVL143:
 180:./drivers/gpio/stm32f4_gpio.c **** 
 1386              		.loc 1 180 1 is_stmt 0 view .LVU370
 1387 002e F9E7     		b	.L99
 1388              	.L104:
 1389              		.align	2
 1390              	.L103:
 1391 0030 00000000 		.word	suffix.0
 1392 0034 00000000 		.word	prefix.1
 1393 0038 00000000 		.word	.LC11
 1394 003c 08000000 		.word	.LC12
 1395              		.cfi_endproc
 1396              	.LFE1036:
 1398              		.section	.rodata.compat_ioctl.str1.4,"aMS",%progbits,1
 1399              		.align	2
 1400              	.LC13:
 1401 0000 706C6561 		.ascii	"please set pin number first\012\015\000"
 1401      73652073 
 1401      65742070 
 1401      696E206E 
 1401      756D6265 
 1402 001e 0000     		.align	2
 1403              	.LC14:
 1404 0020 6770696F 		.ascii	"gpio type is not useful\012\015\000"
 1404      20747970 
 1404      65206973 
 1404      206E6F74 
 1404      20757365 
 1405 003a 0000     		.align	2
 1406              	.LC15:
 1407 003c 4150425F 		.ascii	"APB_RCC_Source is not useful\012\015\000"
 1407      5243435F 
 1407      536F7572 
 1407      63652069 
 1407      73206E6F 
 1408 005b 00       		.align	2
 1409              	.LC16:
ARM GAS  /tmp/cc2wwjO4.s 			page 62


 1410 005c 53657420 		.ascii	"Set pin AF to %d\012\015\000"
 1410      70696E20 
 1410      41462074 
 1410      6F202564 
 1410      0A0D00
 1411 006f 00       		.align	2
 1412              	.LC17:
 1413 0070 43757272 		.ascii	"Current pin AF: %d\012\015\000"
 1413      656E7420 
 1413      70696E20 
 1413      41463A20 
 1413      25640A0D 
 1414              		.section	.text.compat_ioctl,"ax",%progbits
 1415              		.align	1
 1416              		.syntax unified
 1417              		.thumb
 1418              		.thumb_func
 1420              	compat_ioctl:
 1421              	.LVL144:
 1422              	.LFB1051:
 377:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = file->private_data;
 1423              		.loc 1 377 82 is_stmt 1 view -0
 1424              		.cfi_startproc
 1425              		@ args = 0, pretend = 0, frame = 0
 1426              		@ frame_needed = 0, uses_anonymous_args = 0
 377:./drivers/gpio/stm32f4_gpio.c ****     struct gpio_device *device = file->private_data;
 1427              		.loc 1 377 82 is_stmt 0 view .LVU372
 1428 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1429              	.LCFI14:
 1430              		.cfi_def_cfa_offset 32
 1431              		.cfi_offset 3, -32
 1432              		.cfi_offset 4, -28
 1433              		.cfi_offset 5, -24
 1434              		.cfi_offset 6, -20
 1435              		.cfi_offset 7, -16
 1436              		.cfi_offset 8, -12
 1437              		.cfi_offset 9, -8
 1438              		.cfi_offset 14, -4
 1439 0004 0C46     		mov	r4, r1
 1440 0006 1546     		mov	r5, r2
 378:./drivers/gpio/stm32f4_gpio.c ****     if(cmd != GPIO_SET_PIN_NUMBER && device->gpio_number == 0xffff) {
 1441              		.loc 1 378 5 is_stmt 1 view .LVU373
 378:./drivers/gpio/stm32f4_gpio.c ****     if(cmd != GPIO_SET_PIN_NUMBER && device->gpio_number == 0xffff) {
 1442              		.loc 1 378 25 is_stmt 0 view .LVU374
 1443 0008 876A     		ldr	r7, [r0, #40]
 1444              	.LVL145:
 379:./drivers/gpio/stm32f4_gpio.c ****         printk("please set pin number first\n\r");
 1445              		.loc 1 379 5 is_stmt 1 view .LVU375
 379:./drivers/gpio/stm32f4_gpio.c ****         printk("please set pin number first\n\r");
 1446              		.loc 1 379 7 is_stmt 0 view .LVU376
 1447 000a 4029     		cmp	r1, #64
 1448 000c 04D0     		beq	.L106
 379:./drivers/gpio/stm32f4_gpio.c ****         printk("please set pin number first\n\r");
 1449              		.loc 1 379 44 discriminator 1 view .LVU377
 1450 000e 3A88     		ldrh	r2, [r7]
 1451              	.LVL146:
 379:./drivers/gpio/stm32f4_gpio.c ****         printk("please set pin number first\n\r");
ARM GAS  /tmp/cc2wwjO4.s 			page 63


 1452              		.loc 1 379 35 discriminator 1 view .LVU378
 1453 0010 4FF6FF73 		movw	r3, #65535
 1454 0014 9A42     		cmp	r2, r3
 1455 0016 26D0     		beq	.L124
 1456              	.L106:
 384:./drivers/gpio/stm32f4_gpio.c ****     GPIO_TypeDef *gpio_type = get_gpio_type(arg);
 1457              		.loc 1 384 5 is_stmt 1 view .LVU379
 384:./drivers/gpio/stm32f4_gpio.c ****     GPIO_TypeDef *gpio_type = get_gpio_type(arg);
 1458              		.loc 1 384 27 is_stmt 0 view .LVU380
 1459 0018 AEB2     		uxth	r6, r5
 1460 001a 3046     		mov	r0, r6
 1461              	.LVL147:
 384:./drivers/gpio/stm32f4_gpio.c ****     GPIO_TypeDef *gpio_type = get_gpio_type(arg);
 1462              		.loc 1 384 27 view .LVU381
 1463 001c FFF7FEFF 		bl	get_gpio_number
 1464              	.LVL148:
 384:./drivers/gpio/stm32f4_gpio.c ****     GPIO_TypeDef *gpio_type = get_gpio_type(arg);
 1465              		.loc 1 384 27 view .LVU382
 1466 0020 8046     		mov	r8, r0
 1467              	.LVL149:
 385:./drivers/gpio/stm32f4_gpio.c ****     uint32_t APB_RCC_Source = Get_APB_RCC_Source(gpio_type);
 1468              		.loc 1 385 5 is_stmt 1 view .LVU383
 385:./drivers/gpio/stm32f4_gpio.c ****     uint32_t APB_RCC_Source = Get_APB_RCC_Source(gpio_type);
 1469              		.loc 1 385 31 is_stmt 0 view .LVU384
 1470 0022 3046     		mov	r0, r6
 1471 0024 FFF7FEFF 		bl	get_gpio_type
 1472              	.LVL150:
 1473 0028 0646     		mov	r6, r0
 1474              	.LVL151:
 386:./drivers/gpio/stm32f4_gpio.c **** 
 1475              		.loc 1 386 5 is_stmt 1 view .LVU385
 386:./drivers/gpio/stm32f4_gpio.c **** 
 1476              		.loc 1 386 31 is_stmt 0 view .LVU386
 1477 002a FFF7FEFF 		bl	Get_APB_RCC_Source
 1478              	.LVL152:
 386:./drivers/gpio/stm32f4_gpio.c **** 
 1479              		.loc 1 386 31 view .LVU387
 1480 002e 8146     		mov	r9, r0
 1481              	.LVL153:
 388:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_SET_PIN_NUMBER:
 1482              		.loc 1 388 5 is_stmt 1 view .LVU388
 1483 0030 202C     		cmp	r4, #32
 1484 0032 1ED8     		bhi	.L108
 1485 0034 002C     		cmp	r4, #0
 1486 0036 00F09B80 		beq	.L120
 1487 003a 013C     		subs	r4, r4, #1
 1488              	.LVL154:
 388:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_SET_PIN_NUMBER:
 1489              		.loc 1 388 5 is_stmt 0 view .LVU389
 1490 003c 1F2C     		cmp	r4, #31
 1491 003e 00F29A80 		bhi	.L121
 1492 0042 DFE804F0 		tbb	[pc, r4]
 1493              	.L110:
 1494 0046 5E       		.byte	(.L115-.L110)/2
 1495 0047 66       		.byte	(.L114-.L110)/2
 1496 0048 98       		.byte	(.L121-.L110)/2
 1497 0049 75       		.byte	(.L113-.L110)/2
ARM GAS  /tmp/cc2wwjO4.s 			page 64


 1498 004a 98       		.byte	(.L121-.L110)/2
 1499 004b 98       		.byte	(.L121-.L110)/2
 1500 004c 98       		.byte	(.L121-.L110)/2
 1501 004d 6F       		.byte	(.L112-.L110)/2
 1502 004e 98       		.byte	(.L121-.L110)/2
 1503 004f 98       		.byte	(.L121-.L110)/2
 1504 0050 98       		.byte	(.L121-.L110)/2
 1505 0051 98       		.byte	(.L121-.L110)/2
 1506 0052 98       		.byte	(.L121-.L110)/2
 1507 0053 98       		.byte	(.L121-.L110)/2
 1508 0054 98       		.byte	(.L121-.L110)/2
 1509 0055 4C       		.byte	(.L111-.L110)/2
 1510 0056 98       		.byte	(.L121-.L110)/2
 1511 0057 98       		.byte	(.L121-.L110)/2
 1512 0058 98       		.byte	(.L121-.L110)/2
 1513 0059 98       		.byte	(.L121-.L110)/2
 1514 005a 98       		.byte	(.L121-.L110)/2
 1515 005b 98       		.byte	(.L121-.L110)/2
 1516 005c 98       		.byte	(.L121-.L110)/2
 1517 005d 98       		.byte	(.L121-.L110)/2
 1518 005e 98       		.byte	(.L121-.L110)/2
 1519 005f 98       		.byte	(.L121-.L110)/2
 1520 0060 98       		.byte	(.L121-.L110)/2
 1521 0061 98       		.byte	(.L121-.L110)/2
 1522 0062 98       		.byte	(.L121-.L110)/2
 1523 0063 98       		.byte	(.L121-.L110)/2
 1524 0064 98       		.byte	(.L121-.L110)/2
 1525 0065 55       		.byte	(.L109-.L110)/2
 1526              	.LVL155:
 1527              		.p2align 1
 1528              	.L124:
 380:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 1529              		.loc 1 380 9 is_stmt 1 view .LVU390
 1530 0066 4848     		ldr	r0, .L127
 1531              	.LVL156:
 380:./drivers/gpio/stm32f4_gpio.c ****         return -EINVAL;
 1532              		.loc 1 380 9 is_stmt 0 view .LVU391
 1533 0068 FFF7FEFF 		bl	printk
 1534              	.LVL157:
 381:./drivers/gpio/stm32f4_gpio.c ****     }
 1535              		.loc 1 381 9 is_stmt 1 view .LVU392
 381:./drivers/gpio/stm32f4_gpio.c ****     }
 1536              		.loc 1 381 16 is_stmt 0 view .LVU393
 1537 006c 6FF01504 		mvn	r4, #21
 1538              	.LVL158:
 381:./drivers/gpio/stm32f4_gpio.c ****     }
 1539              		.loc 1 381 16 view .LVU394
 1540 0070 83E0     		b	.L105
 1541              	.LVL159:
 1542              	.L108:
 388:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_SET_PIN_NUMBER:
 1543              		.loc 1 388 5 view .LVU395
 1544 0072 B4F5807F 		cmp	r4, #256
 1545 0076 61D0     		beq	.L116
 1546 0078 40F20113 		movw	r3, #257
 1547 007c 9C42     		cmp	r4, r3
 1548 007e 6DD0     		beq	.L117
ARM GAS  /tmp/cc2wwjO4.s 			page 65


 1549 0080 402C     		cmp	r4, #64
 1550 0082 7DD1     		bne	.L122
 390:./drivers/gpio/stm32f4_gpio.c ****                 printk("gpio type is not useful\n\r");
 1551              		.loc 1 390 13 is_stmt 1 view .LVU396
 390:./drivers/gpio/stm32f4_gpio.c ****                 printk("gpio type is not useful\n\r");
 1552              		.loc 1 390 15 is_stmt 0 view .LVU397
 1553 0084 FEB1     		cbz	r6, .L125
 394:./drivers/gpio/stm32f4_gpio.c ****                 printk("APB_RCC_Source is not useful\n\r");
 1554              		.loc 1 394 13 is_stmt 1 view .LVU398
 394:./drivers/gpio/stm32f4_gpio.c ****                 printk("APB_RCC_Source is not useful\n\r");
 1555              		.loc 1 394 15 is_stmt 0 view .LVU399
 1556 0086 B0F1FF3F 		cmp	r0, #-1
 1557 008a 22D0     		beq	.L126
 398:./drivers/gpio/stm32f4_gpio.c ****             print_gpio_type(gpio_type);
 1558              		.loc 1 398 13 is_stmt 1 view .LVU400
 1559 008c 4046     		mov	r0, r8
 1560              	.LVL160:
 398:./drivers/gpio/stm32f4_gpio.c ****             print_gpio_type(gpio_type);
 1561              		.loc 1 398 13 is_stmt 0 view .LVU401
 1562 008e FFF7FEFF 		bl	print_gpio_number
 1563              	.LVL161:
 399:./drivers/gpio/stm32f4_gpio.c ****             
 1564              		.loc 1 399 13 is_stmt 1 view .LVU402
 1565 0092 3046     		mov	r0, r6
 1566 0094 FFF7FEFF 		bl	print_gpio_type
 1567              	.LVL162:
 401:./drivers/gpio/stm32f4_gpio.c ****             device->gpio_number = pin_number;
 1568              		.loc 1 401 13 view .LVU403
 1569 0098 0121     		movs	r1, #1
 1570 009a 4846     		mov	r0, r9
 1571 009c FFF7FEFF 		bl	RCC_AHB1PeriphClockCmd
 1572              	.LVL163:
 402:./drivers/gpio/stm32f4_gpio.c ****             device->gpio_type = gpio_type;
 1573              		.loc 1 402 13 view .LVU404
 402:./drivers/gpio/stm32f4_gpio.c ****             device->gpio_type = gpio_type;
 1574              		.loc 1 402 33 is_stmt 0 view .LVU405
 1575 00a0 A7F80080 		strh	r8, [r7]	@ movhi
 403:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Pin = pin_number;
 1576              		.loc 1 403 13 is_stmt 1 view .LVU406
 403:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Pin = pin_number;
 1577              		.loc 1 403 31 is_stmt 0 view .LVU407
 1578 00a4 7E60     		str	r6, [r7, #4]
 404:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 1579              		.loc 1 404 13 is_stmt 1 view .LVU408
 404:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 1580              		.loc 1 404 49 is_stmt 0 view .LVU409
 1581 00a6 A7F80880 		strh	r8, [r7, #8]	@ movhi
 405:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 1582              		.loc 1 405 13 is_stmt 1 view .LVU410
 405:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 1583              		.loc 1 405 50 is_stmt 0 view .LVU411
 1584 00aa 0123     		movs	r3, #1
 1585 00ac 7B81     		strh	r3, [r7, #10]	@ movhi
 406:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 1586              		.loc 1 406 13 is_stmt 1 view .LVU412
 406:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 1587              		.loc 1 406 51 is_stmt 0 view .LVU413
ARM GAS  /tmp/cc2wwjO4.s 			page 66


 1588 00ae 0024     		movs	r4, #0
 1589              	.LVL164:
 406:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 1590              		.loc 1 406 51 view .LVU414
 1591 00b0 FC81     		strh	r4, [r7, #14]	@ movhi
 407:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 1592              		.loc 1 407 13 is_stmt 1 view .LVU415
 407:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 1593              		.loc 1 407 51 is_stmt 0 view .LVU416
 1594 00b2 0223     		movs	r3, #2
 1595 00b4 BB81     		strh	r3, [r7, #12]	@ movhi
 408:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_AF = GPIO_AF0; // 默认AF0
 1596              		.loc 1 408 13 is_stmt 1 view .LVU417
 408:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_AF = GPIO_AF0; // 默认AF0
 1597              		.loc 1 408 50 is_stmt 0 view .LVU418
 1598 00b6 3C82     		strh	r4, [r7, #16]	@ movhi
 409:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1599              		.loc 1 409 13 is_stmt 1 view .LVU419
 409:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1600              		.loc 1 409 48 is_stmt 0 view .LVU420
 1601 00b8 BC74     		strb	r4, [r7, #18]
 410:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1602              		.loc 1 410 13 is_stmt 1 view .LVU421
 1603 00ba 07F10801 		add	r1, r7, #8
 1604 00be 3046     		mov	r0, r6
 1605 00c0 FFF7FEFF 		bl	GPIO_Init
 1606              	.LVL165:
 411:./drivers/gpio/stm32f4_gpio.c ****             
 1607              		.loc 1 411 13 view .LVU422
 411:./drivers/gpio/stm32f4_gpio.c ****             
 1608              		.loc 1 411 20 is_stmt 0 view .LVU423
 1609 00c4 59E0     		b	.L105
 1610              	.LVL166:
 1611              	.L125:
 391:./drivers/gpio/stm32f4_gpio.c ****                 return -EINVAL;
 1612              		.loc 1 391 17 is_stmt 1 view .LVU424
 1613 00c6 3148     		ldr	r0, .L127+4
 1614              	.LVL167:
 391:./drivers/gpio/stm32f4_gpio.c ****                 return -EINVAL;
 1615              		.loc 1 391 17 is_stmt 0 view .LVU425
 1616 00c8 FFF7FEFF 		bl	printk
 1617              	.LVL168:
 392:./drivers/gpio/stm32f4_gpio.c ****             }
 1618              		.loc 1 392 17 is_stmt 1 view .LVU426
 392:./drivers/gpio/stm32f4_gpio.c ****             }
 1619              		.loc 1 392 24 is_stmt 0 view .LVU427
 1620 00cc 6FF01504 		mvn	r4, #21
 1621              	.LVL169:
 392:./drivers/gpio/stm32f4_gpio.c ****             }
 1622              		.loc 1 392 24 view .LVU428
 1623 00d0 53E0     		b	.L105
 1624              	.LVL170:
 1625              	.L126:
 395:./drivers/gpio/stm32f4_gpio.c ****                 return -EINVAL;
 1626              		.loc 1 395 17 is_stmt 1 view .LVU429
 1627 00d2 2F48     		ldr	r0, .L127+8
 1628              	.LVL171:
ARM GAS  /tmp/cc2wwjO4.s 			page 67


 395:./drivers/gpio/stm32f4_gpio.c ****                 return -EINVAL;
 1629              		.loc 1 395 17 is_stmt 0 view .LVU430
 1630 00d4 FFF7FEFF 		bl	printk
 1631              	.LVL172:
 396:./drivers/gpio/stm32f4_gpio.c ****             }
 1632              		.loc 1 396 17 is_stmt 1 view .LVU431
 396:./drivers/gpio/stm32f4_gpio.c ****             }
 1633              		.loc 1 396 24 is_stmt 0 view .LVU432
 1634 00d8 6FF01504 		mvn	r4, #21
 1635              	.LVL173:
 396:./drivers/gpio/stm32f4_gpio.c ****             }
 1636              		.loc 1 396 24 view .LVU433
 1637 00dc 4DE0     		b	.L105
 1638              	.LVL174:
 1639              	.L111:
 414:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1640              		.loc 1 414 13 is_stmt 1 view .LVU434
 414:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1641              		.loc 1 414 50 is_stmt 0 view .LVU435
 1642 00de 0123     		movs	r3, #1
 1643 00e0 3B82     		strh	r3, [r7, #16]	@ movhi
 415:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1644              		.loc 1 415 13 is_stmt 1 view .LVU436
 1645 00e2 07F10801 		add	r1, r7, #8
 1646 00e6 3046     		mov	r0, r6
 1647              	.LVL175:
 415:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1648              		.loc 1 415 13 is_stmt 0 view .LVU437
 1649 00e8 FFF7FEFF 		bl	GPIO_Init
 1650              	.LVL176:
 416:./drivers/gpio/stm32f4_gpio.c ****             
 1651              		.loc 1 416 13 is_stmt 1 view .LVU438
 416:./drivers/gpio/stm32f4_gpio.c ****             
 1652              		.loc 1 416 20 is_stmt 0 view .LVU439
 1653 00ec 0024     		movs	r4, #0
 1654              	.LVL177:
 416:./drivers/gpio/stm32f4_gpio.c ****             
 1655              		.loc 1 416 20 view .LVU440
 1656 00ee 44E0     		b	.L105
 1657              	.LVL178:
 1658              	.L109:
 419:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1659              		.loc 1 419 13 is_stmt 1 view .LVU441
 419:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1660              		.loc 1 419 50 is_stmt 0 view .LVU442
 1661 00f0 0223     		movs	r3, #2
 1662 00f2 3B82     		strh	r3, [r7, #16]	@ movhi
 420:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1663              		.loc 1 420 13 is_stmt 1 view .LVU443
 1664 00f4 07F10801 		add	r1, r7, #8
 1665 00f8 3046     		mov	r0, r6
 1666              	.LVL179:
 420:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1667              		.loc 1 420 13 is_stmt 0 view .LVU444
 1668 00fa FFF7FEFF 		bl	GPIO_Init
 1669              	.LVL180:
 421:./drivers/gpio/stm32f4_gpio.c ****             
ARM GAS  /tmp/cc2wwjO4.s 			page 68


 1670              		.loc 1 421 13 is_stmt 1 view .LVU445
 421:./drivers/gpio/stm32f4_gpio.c ****             
 1671              		.loc 1 421 20 is_stmt 0 view .LVU446
 1672 00fe 0024     		movs	r4, #0
 1673 0100 3BE0     		b	.L105
 1674              	.LVL181:
 1675              	.L115:
 424:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1676              		.loc 1 424 13 is_stmt 1 view .LVU447
 424:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1677              		.loc 1 424 50 is_stmt 0 view .LVU448
 1678 0102 0024     		movs	r4, #0
 1679 0104 7C81     		strh	r4, [r7, #10]	@ movhi
 425:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1680              		.loc 1 425 13 is_stmt 1 view .LVU449
 1681 0106 07F10801 		add	r1, r7, #8
 1682 010a 3046     		mov	r0, r6
 1683              	.LVL182:
 425:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1684              		.loc 1 425 13 is_stmt 0 view .LVU450
 1685 010c FFF7FEFF 		bl	GPIO_Init
 1686              	.LVL183:
 426:./drivers/gpio/stm32f4_gpio.c ****             
 1687              		.loc 1 426 13 is_stmt 1 view .LVU451
 426:./drivers/gpio/stm32f4_gpio.c ****             
 1688              		.loc 1 426 20 is_stmt 0 view .LVU452
 1689 0110 33E0     		b	.L105
 1690              	.LVL184:
 1691              	.L114:
 429:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1692              		.loc 1 429 13 is_stmt 1 view .LVU453
 429:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1693              		.loc 1 429 50 is_stmt 0 view .LVU454
 1694 0112 0123     		movs	r3, #1
 1695 0114 7B81     		strh	r3, [r7, #10]	@ movhi
 430:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1696              		.loc 1 430 13 is_stmt 1 view .LVU455
 1697 0116 07F10801 		add	r1, r7, #8
 1698 011a 3046     		mov	r0, r6
 1699              	.LVL185:
 430:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1700              		.loc 1 430 13 is_stmt 0 view .LVU456
 1701 011c FFF7FEFF 		bl	GPIO_Init
 1702              	.LVL186:
 431:./drivers/gpio/stm32f4_gpio.c ****             
 1703              		.loc 1 431 13 is_stmt 1 view .LVU457
 431:./drivers/gpio/stm32f4_gpio.c ****             
 1704              		.loc 1 431 20 is_stmt 0 view .LVU458
 1705 0120 0024     		movs	r4, #0
 1706 0122 2AE0     		b	.L105
 1707              	.LVL187:
 1708              	.L112:
 434:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1709              		.loc 1 434 13 is_stmt 1 view .LVU459
 1710 0124 4146     		mov	r1, r8
 1711 0126 3046     		mov	r0, r6
 1712              	.LVL188:
ARM GAS  /tmp/cc2wwjO4.s 			page 69


 434:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1713              		.loc 1 434 13 is_stmt 0 view .LVU460
 1714 0128 FFF7FEFF 		bl	GPIO_SetBits
 1715              	.LVL189:
 435:./drivers/gpio/stm32f4_gpio.c ****             
 1716              		.loc 1 435 13 is_stmt 1 view .LVU461
 435:./drivers/gpio/stm32f4_gpio.c ****             
 1717              		.loc 1 435 20 is_stmt 0 view .LVU462
 1718 012c 0024     		movs	r4, #0
 1719 012e 24E0     		b	.L105
 1720              	.LVL190:
 1721              	.L113:
 438:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1722              		.loc 1 438 13 is_stmt 1 view .LVU463
 1723 0130 4146     		mov	r1, r8
 1724 0132 3046     		mov	r0, r6
 1725              	.LVL191:
 438:./drivers/gpio/stm32f4_gpio.c ****             return 0;
 1726              		.loc 1 438 13 is_stmt 0 view .LVU464
 1727 0134 FFF7FEFF 		bl	GPIO_ResetBits
 1728              	.LVL192:
 439:./drivers/gpio/stm32f4_gpio.c ****             
 1729              		.loc 1 439 13 is_stmt 1 view .LVU465
 439:./drivers/gpio/stm32f4_gpio.c ****             
 1730              		.loc 1 439 20 is_stmt 0 view .LVU466
 1731 0138 0024     		movs	r4, #0
 1732 013a 1EE0     		b	.L105
 1733              	.LVL193:
 1734              	.L116:
 1735              	.LBB31:
 443:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 1736              		.loc 1 443 13 is_stmt 1 view .LVU467
 443:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 1737              		.loc 1 443 21 is_stmt 0 view .LVU468
 1738 013c C5F30345 		ubfx	r5, r5, #16, #4
 1739              	.LVL194:
 444:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_AF = af;
 1740              		.loc 1 444 13 is_stmt 1 view .LVU469
 444:./drivers/gpio/stm32f4_gpio.c ****             device->GPIO_InitStructure.GPIO_AF = af;
 1741              		.loc 1 444 50 is_stmt 0 view .LVU470
 1742 0140 0223     		movs	r3, #2
 1743 0142 7B81     		strh	r3, [r7, #10]	@ movhi
 445:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1744              		.loc 1 445 13 is_stmt 1 view .LVU471
 445:./drivers/gpio/stm32f4_gpio.c ****             GPIO_Init(gpio_type, &device->GPIO_InitStructure);
 1745              		.loc 1 445 48 is_stmt 0 view .LVU472
 1746 0144 BD74     		strb	r5, [r7, #18]
 446:./drivers/gpio/stm32f4_gpio.c ****             printk("Set pin AF to %d\n\r", af);
 1747              		.loc 1 446 13 is_stmt 1 view .LVU473
 1748 0146 07F10801 		add	r1, r7, #8
 1749 014a 3046     		mov	r0, r6
 1750              	.LVL195:
 446:./drivers/gpio/stm32f4_gpio.c ****             printk("Set pin AF to %d\n\r", af);
 1751              		.loc 1 446 13 is_stmt 0 view .LVU474
 1752 014c FFF7FEFF 		bl	GPIO_Init
 1753              	.LVL196:
 447:./drivers/gpio/stm32f4_gpio.c ****             return 0;
ARM GAS  /tmp/cc2wwjO4.s 			page 70


 1754              		.loc 1 447 13 is_stmt 1 view .LVU475
 1755 0150 2946     		mov	r1, r5
 1756 0152 1048     		ldr	r0, .L127+12
 1757 0154 FFF7FEFF 		bl	printk
 1758              	.LVL197:
 448:./drivers/gpio/stm32f4_gpio.c ****         }
 1759              		.loc 1 448 13 view .LVU476
 448:./drivers/gpio/stm32f4_gpio.c ****         }
 1760              		.loc 1 448 20 is_stmt 0 view .LVU477
 1761 0158 0024     		movs	r4, #0
 1762              	.LVL198:
 448:./drivers/gpio/stm32f4_gpio.c ****         }
 1763              		.loc 1 448 20 view .LVU478
 1764 015a 0EE0     		b	.L105
 1765              	.LVL199:
 1766              	.L117:
 448:./drivers/gpio/stm32f4_gpio.c ****         }
 1767              		.loc 1 448 20 view .LVU479
 1768              	.LBE31:
 1769              	.LBB32:
 453:./drivers/gpio/stm32f4_gpio.c ****             printk("Current pin AF: %d\n\r", af);
 1770              		.loc 1 453 13 is_stmt 1 view .LVU480
 453:./drivers/gpio/stm32f4_gpio.c ****             printk("Current pin AF: %d\n\r", af);
 1771              		.loc 1 453 26 is_stmt 0 view .LVU481
 1772 015c 4146     		mov	r1, r8
 1773 015e 3046     		mov	r0, r6
 1774              	.LVL200:
 453:./drivers/gpio/stm32f4_gpio.c ****             printk("Current pin AF: %d\n\r", af);
 1775              		.loc 1 453 26 view .LVU482
 1776 0160 FFF7FEFF 		bl	GPIO_GetAF
 1777              	.LVL201:
 1778 0164 0146     		mov	r1, r0
 1779              	.LVL202:
 454:./drivers/gpio/stm32f4_gpio.c ****             return af; // 返回当前AF值
 1780              		.loc 1 454 13 is_stmt 1 view .LVU483
 1781 0166 0446     		mov	r4, r0
 1782              	.LVL203:
 454:./drivers/gpio/stm32f4_gpio.c ****             return af; // 返回当前AF值
 1783              		.loc 1 454 13 is_stmt 0 view .LVU484
 1784 0168 0B48     		ldr	r0, .L127+16
 1785              	.LVL204:
 454:./drivers/gpio/stm32f4_gpio.c ****             return af; // 返回当前AF值
 1786              		.loc 1 454 13 view .LVU485
 1787 016a FFF7FEFF 		bl	printk
 1788              	.LVL205:
 455:./drivers/gpio/stm32f4_gpio.c ****         }
 1789              		.loc 1 455 13 is_stmt 1 view .LVU486
 455:./drivers/gpio/stm32f4_gpio.c ****         }
 1790              		.loc 1 455 20 is_stmt 0 view .LVU487
 1791 016e 04E0     		b	.L105
 1792              	.LVL206:
 1793              	.L120:
 455:./drivers/gpio/stm32f4_gpio.c ****         }
 1794              		.loc 1 455 20 view .LVU488
 1795              	.LBE32:
 388:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_SET_PIN_NUMBER:
 1796              		.loc 1 388 5 view .LVU489
ARM GAS  /tmp/cc2wwjO4.s 			page 71


 1797 0170 6FF01504 		mvn	r4, #21
 1798              	.LVL207:
 388:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_SET_PIN_NUMBER:
 1799              		.loc 1 388 5 view .LVU490
 1800 0174 01E0     		b	.L105
 1801              	.L121:
 1802 0176 6FF01504 		mvn	r4, #21
 1803              	.LVL208:
 1804              	.L105:
 461:./drivers/gpio/stm32f4_gpio.c **** 
 1805              		.loc 1 461 1 view .LVU491
 1806 017a 2046     		mov	r0, r4
 1807 017c BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1808              	.LVL209:
 1809              	.L122:
 388:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_SET_PIN_NUMBER:
 1810              		.loc 1 388 5 view .LVU492
 1811 0180 6FF01504 		mvn	r4, #21
 1812              	.LVL210:
 388:./drivers/gpio/stm32f4_gpio.c ****         case GPIO_SET_PIN_NUMBER:
 1813              		.loc 1 388 5 view .LVU493
 1814 0184 F9E7     		b	.L105
 1815              	.L128:
 1816 0186 00BF     		.align	2
 1817              	.L127:
 1818 0188 00000000 		.word	.LC13
 1819 018c 20000000 		.word	.LC14
 1820 0190 3C000000 		.word	.LC15
 1821 0194 5C000000 		.word	.LC16
 1822 0198 70000000 		.word	.LC17
 1823              		.cfi_endproc
 1824              	.LFE1051:
 1826              		.section	.rodata.suffix.0,"a"
 1827              		.align	2
 1830              	suffix.0:
 1831 0000 0A0D00   		.ascii	"\012\015\000"
 1832              		.section	.rodata.prefix.1,"a"
 1833              		.align	2
 1836              	prefix.1:
 1837 0000 6770696F 		.ascii	"gpio type is :GPIO\000"
 1837      20747970 
 1837      65206973 
 1837      203A4750 
 1837      494F00
 1838              		.section	.rodata.suffix.2,"a"
 1839              		.align	2
 1842              	suffix.2:
 1843 0000 0A0D00   		.ascii	"\012\015\000"
 1844              		.section	.rodata.prefix.3,"a"
 1845              		.align	2
 1848              	prefix.3:
 1849 0000 6578706F 		.ascii	"export gpio: GPIO_Pin_\000"
 1849      72742067 
 1849      70696F3A 
 1849      20475049 
 1849      4F5F5069 
 1850              		.section	.deviceinitcall,"aw"
ARM GAS  /tmp/cc2wwjO4.s 			page 72


 1851              		.align	2
 1854              	_initcall_gpio_init:
 1855 0000 00000000 		.word	gpio_init
 1856              		.section	.data.gpio_fops,"aw"
 1857              		.align	2
 1860              	gpio_fops:
 1861 0000 00000000 		.word	0
 1862 0004 00000000 		.space	8
 1862      00000000 
 1863 000c 00000000 		.word	gpio_read
 1864 0010 00000000 		.word	gpio_write
 1865 0014 00000000 		.space	20
 1865      00000000 
 1865      00000000 
 1865      00000000 
 1865      00000000 
 1866 0028 00000000 		.word	compat_ioctl
 1867 002c 00000000 		.space	8
 1867      00000000 
 1868 0034 00000000 		.word	gpio_open
 1869 0038 00000000 		.space	4
 1870 003c 00000000 		.word	gpio_release
 1871 0040 00000000 		.space	72
 1871      00000000 
 1871      00000000 
 1871      00000000 
 1871      00000000 
 1872              		.section	.rodata.gpio_Types,"a"
 1873              		.align	2
 1876              	gpio_Types:
 1877 0000 00000240 		.word	1073872896
 1878 0004 00040240 		.word	1073873920
 1879 0008 00080240 		.word	1073874944
 1880 000c 000C0240 		.word	1073875968
 1881 0010 00100240 		.word	1073876992
 1882 0014 00140240 		.word	1073878016
 1883 0018 00180240 		.word	1073879040
 1884 001c 001C0240 		.word	1073880064
 1885 0020 00200240 		.word	1073881088
 1886 0024 00240240 		.word	1073882112
 1887 0028 00280240 		.word	1073883136
 1888              		.section	.rodata.gpio_pins,"a"
 1889              		.align	2
 1892              	gpio_pins:
 1893 0000 0100     		.short	1
 1894 0002 0200     		.short	2
 1895 0004 0400     		.short	4
 1896 0006 0800     		.short	8
 1897 0008 1000     		.short	16
 1898 000a 2000     		.short	32
 1899 000c 4000     		.short	64
 1900 000e 8000     		.short	128
 1901 0010 0001     		.short	256
 1902 0012 0002     		.short	512
 1903 0014 0004     		.short	1024
 1904 0016 0008     		.short	2048
 1905 0018 0010     		.short	4096
ARM GAS  /tmp/cc2wwjO4.s 			page 73


 1906 001a 0020     		.short	8192
 1907 001c 0040     		.short	16384
 1908 001e 0080     		.short	-32768
 1909              		.text
 1910              	.Letext0:
 1911              		.file 6 "./include/asm-generic/int-l64.h"
 1912              		.file 7 "./include/asm-generic/posix_types.h"
 1913              		.file 8 "./include/uapi/linux/types.h"
 1914              		.file 9 "./include/linux/types.h"
 1915              		.file 10 "./include/linux/init.h"
 1916              		.file 11 "./include/linux/errseq.h"
 1917              		.file 12 "./include/linux/time64.h"
 1918              		.file 13 "./arch/arm_m/include/asm/spinlock.h"
 1919              		.file 14 "./include/linux/spinlock_types_raw.h"
 1920              		.file 15 "./include/linux/spinlock_types.h"
 1921              		.file 16 "./include/linux/rbtree_types.h"
 1922              		.file 17 "./include/linux/uidgid_types.h"
 1923              		.file 18 "./include/linux/projid.h"
 1924              		.file 19 "./include/linux/mnt_idmapping.h"
 1925              		.file 20 "./include/linux/mutex.h"
 1926              		.file 21 "./include/linux/uio.h"
 1927              		.file 22 "./include/linux/wait.h"
 1928              		.file 23 "./include/linux/xarray.h"
 1929              		.file 24 "./include/linux/migrate_mode.h"
 1930              		.file 25 "./include/linux/rw_hint.h"
 1931              		.file 26 "./include/linux/reciprocal_div.h"
 1932              		.file 27 "./include/linux/mm_type.h"
 1933              		.file 28 "./include/linux/bvec.h"
 1934              		.file 29 "./include/linux/blk_types.h"
 1935              		.file 30 "./include/linux/blkdev.h"
 1936              		.file 31 "./include/linux/bio.h"
 1937              		.file 32 "./include/linux/mempool_super_haper.h"
 1938              		.file 33 "./include/linux/mempool.h"
 1939              		.file 34 "./include/linux/lockdep_types.h"
 1940              		.file 35 "./include/linux/workqueue_types.h"
 1941              		.file 36 "./include/linux/blk-mq.h"
 1942              		.file 37 "./include/linux/dcache.h"
 1943              		.file 38 "./include/uapi/linux/pr.h"
 1944              		.file 39 "./include/linux/pr.h"
 1945              		.file 40 "./include/linux/hdreg.h"
 1946              		.file 41 "./include/linux/lockref.h"
 1947              		.file 42 "./include/linux/path.h"
 1948              		.file 43 "./include/linux/statfs.h"
 1949              		.file 44 "./include/linux/stat.h"
 1950              		.file 45 "./include/linux/gfp_types.h"
 1951              		.file 46 "./include/linux/device.h"
 1952              		.file 47 "./arch/arm_m/include/asm/string.h"
 1953              		.file 48 "./include/linux/printk.h"
ARM GAS  /tmp/cc2wwjO4.s 			page 74


DEFINED SYMBOLS
                            *ABS*:00000000 stm32f4_gpio.c
     /tmp/cc2wwjO4.s:21     .text.GPIO_SetAF:00000000 $t
     /tmp/cc2wwjO4.s:26     .text.GPIO_SetAF:00000000 GPIO_SetAF
     /tmp/cc2wwjO4.s:112    .text.GPIO_Init:00000000 $t
     /tmp/cc2wwjO4.s:117    .text.GPIO_Init:00000000 GPIO_Init
     /tmp/cc2wwjO4.s:275    .text.GPIO_SetBits:00000000 $t
     /tmp/cc2wwjO4.s:280    .text.GPIO_SetBits:00000000 GPIO_SetBits
     /tmp/cc2wwjO4.s:297    .text.GPIO_ResetBits:00000000 $t
     /tmp/cc2wwjO4.s:302    .text.GPIO_ResetBits:00000000 GPIO_ResetBits
     /tmp/cc2wwjO4.s:322    .text.GPIO_ReadInputDataBit:00000000 $t
     /tmp/cc2wwjO4.s:327    .text.GPIO_ReadInputDataBit:00000000 GPIO_ReadInputDataBit
     /tmp/cc2wwjO4.s:351    .text.RCC_AHB1PeriphClockCmd:00000000 $t
     /tmp/cc2wwjO4.s:356    .text.RCC_AHB1PeriphClockCmd:00000000 RCC_AHB1PeriphClockCmd
     /tmp/cc2wwjO4.s:386    .text.RCC_AHB1PeriphClockCmd:00000020 $d
     /tmp/cc2wwjO4.s:391    .text.get_gpio_number:00000000 $t
     /tmp/cc2wwjO4.s:396    .text.get_gpio_number:00000000 get_gpio_number
     /tmp/cc2wwjO4.s:418    .text.get_gpio_number:0000000c $d
     /tmp/cc2wwjO4.s:1892   .rodata.gpio_pins:00000000 gpio_pins
     /tmp/cc2wwjO4.s:423    .text.get_gpio_type:00000000 $t
     /tmp/cc2wwjO4.s:428    .text.get_gpio_type:00000000 get_gpio_type
     /tmp/cc2wwjO4.s:461    .text.get_gpio_type:00000014 $d
     /tmp/cc2wwjO4.s:1876   .rodata.gpio_Types:00000000 gpio_Types
     /tmp/cc2wwjO4.s:466    .text.Get_APB_RCC_Source:00000000 $t
     /tmp/cc2wwjO4.s:471    .text.Get_APB_RCC_Source:00000000 Get_APB_RCC_Source
     /tmp/cc2wwjO4.s:619    .text.Get_APB_RCC_Source:00000090 $d
     /tmp/cc2wwjO4.s:624    .text.GPIO_GetAF:00000000 $t
     /tmp/cc2wwjO4.s:629    .text.GPIO_GetAF:00000000 GPIO_GetAF
     /tmp/cc2wwjO4.s:694    .rodata.gpio_write.str1.4:00000000 $d
     /tmp/cc2wwjO4.s:701    .text.gpio_write:00000000 $t
     /tmp/cc2wwjO4.s:706    .text.gpio_write:00000000 gpio_write
     /tmp/cc2wwjO4.s:788    .text.gpio_write:00000044 $d
     /tmp/cc2wwjO4.s:794    .text.gpio_release:00000000 $t
     /tmp/cc2wwjO4.s:799    .text.gpio_release:00000000 gpio_release
     /tmp/cc2wwjO4.s:837    .rodata.gpio_open.str1.4:00000000 $d
     /tmp/cc2wwjO4.s:841    .text.gpio_open:00000000 $t
     /tmp/cc2wwjO4.s:846    .text.gpio_open:00000000 gpio_open
     /tmp/cc2wwjO4.s:917    .text.gpio_open:0000002c $d
     /tmp/cc2wwjO4.s:922    .rodata.gpio_read.str1.4:00000000 $d
     /tmp/cc2wwjO4.s:929    .text.gpio_read:00000000 $t
     /tmp/cc2wwjO4.s:934    .text.gpio_read:00000000 gpio_read
     /tmp/cc2wwjO4.s:1039   .text.gpio_read:00000040 $d
     /tmp/cc2wwjO4.s:1046   .rodata.str1.4:00000000 $d
     /tmp/cc2wwjO4.s:1059   .init.text:00000000 $t
     /tmp/cc2wwjO4.s:1064   .init.text:00000000 gpio_init
     /tmp/cc2wwjO4.s:1181   .init.text:00000060 $d
     /tmp/cc2wwjO4.s:1860   .data.gpio_fops:00000000 gpio_fops
     /tmp/cc2wwjO4.s:1190   .rodata.print_gpio_number.str1.4:00000000 $d
     /tmp/cc2wwjO4.s:1197   .text.print_gpio_number:00000000 $t
     /tmp/cc2wwjO4.s:1203   .text.print_gpio_number:00000000 print_gpio_number
     /tmp/cc2wwjO4.s:1313   .text.print_gpio_number:00000058 $d
     /tmp/cc2wwjO4.s:1842   .rodata.suffix.2:00000000 suffix.2
     /tmp/cc2wwjO4.s:1848   .rodata.prefix.3:00000000 prefix.3
     /tmp/cc2wwjO4.s:1321   .rodata.print_gpio_type.str1.4:00000000 $d
     /tmp/cc2wwjO4.s:1328   .text.print_gpio_type:00000000 $t
     /tmp/cc2wwjO4.s:1334   .text.print_gpio_type:00000000 print_gpio_type
     /tmp/cc2wwjO4.s:1391   .text.print_gpio_type:00000030 $d
ARM GAS  /tmp/cc2wwjO4.s 			page 75


     /tmp/cc2wwjO4.s:1830   .rodata.suffix.0:00000000 suffix.0
     /tmp/cc2wwjO4.s:1836   .rodata.prefix.1:00000000 prefix.1
     /tmp/cc2wwjO4.s:1399   .rodata.compat_ioctl.str1.4:00000000 $d
     /tmp/cc2wwjO4.s:1415   .text.compat_ioctl:00000000 $t
     /tmp/cc2wwjO4.s:1420   .text.compat_ioctl:00000000 compat_ioctl
     /tmp/cc2wwjO4.s:1494   .text.compat_ioctl:00000046 $d
     /tmp/cc2wwjO4.s:1527   .text.compat_ioctl:00000066 $t
     /tmp/cc2wwjO4.s:1818   .text.compat_ioctl:00000188 $d
     /tmp/cc2wwjO4.s:1827   .rodata.suffix.0:00000000 $d
     /tmp/cc2wwjO4.s:1833   .rodata.prefix.1:00000000 $d
     /tmp/cc2wwjO4.s:1839   .rodata.suffix.2:00000000 $d
     /tmp/cc2wwjO4.s:1845   .rodata.prefix.3:00000000 $d
     /tmp/cc2wwjO4.s:1851   .deviceinitcall:00000000 $d
     /tmp/cc2wwjO4.s:1854   .deviceinitcall:00000000 _initcall_gpio_init
     /tmp/cc2wwjO4.s:1857   .data.gpio_fops:00000000 $d
     /tmp/cc2wwjO4.s:1873   .rodata.gpio_Types:00000000 $d
     /tmp/cc2wwjO4.s:1889   .rodata.gpio_pins:00000000 $d

UNDEFINED SYMBOLS
printk
__sfree__
__smalloc__
__register_chrdev
class_create
device_create
