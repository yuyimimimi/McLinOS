ARM GAS  /tmp/cc47XXUh.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"fdt_wip.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./lib/fdt/fdt_wip.c"
  20              		.section	.text.fdt_nop_region_,"ax",%progbits
  21              		.align	1
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	fdt_nop_region_:
  27              	.LVL0:
  28              	.LFB77:
   1:./lib/fdt/fdt_wip.c **** // SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
   2:./lib/fdt/fdt_wip.c **** /*
   3:./lib/fdt/fdt_wip.c ****  * libfdt - Flat Device Tree manipulation
   4:./lib/fdt/fdt_wip.c ****  * Copyright (C) 2006 David Gibson, IBM Corporation.
   5:./lib/fdt/fdt_wip.c ****  */
   6:./lib/fdt/fdt_wip.c **** #include <linux/libfdt_env.h>
   7:./lib/fdt/fdt_wip.c **** 
   8:./lib/fdt/fdt_wip.c **** #include <linux/fdt.h>
   9:./lib/fdt/fdt_wip.c **** #include <linux/libfdt.h>
  10:./lib/fdt/fdt_wip.c **** 
  11:./lib/fdt/fdt_wip.c **** 
  12:./lib/fdt/fdt_wip.c **** #include "libfdt_internal.h"
  13:./lib/fdt/fdt_wip.c **** 
  14:./lib/fdt/fdt_wip.c **** int fdt_setprop_inplace_namelen_partial(void *fdt, int nodeoffset,
  15:./lib/fdt/fdt_wip.c **** 					const char *name, int namelen,
  16:./lib/fdt/fdt_wip.c **** 					uint32_t idx, const void *val,
  17:./lib/fdt/fdt_wip.c **** 					int len)
  18:./lib/fdt/fdt_wip.c **** {
  19:./lib/fdt/fdt_wip.c **** 	void *propval;
  20:./lib/fdt/fdt_wip.c **** 	int proplen;
  21:./lib/fdt/fdt_wip.c **** 
  22:./lib/fdt/fdt_wip.c **** 	propval = fdt_getprop_namelen_w(fdt, nodeoffset, name, namelen,
  23:./lib/fdt/fdt_wip.c **** 					&proplen);
  24:./lib/fdt/fdt_wip.c **** 	if (!propval)
  25:./lib/fdt/fdt_wip.c **** 		return proplen;
  26:./lib/fdt/fdt_wip.c **** 
  27:./lib/fdt/fdt_wip.c **** 	if ((unsigned)proplen < (len + idx))
  28:./lib/fdt/fdt_wip.c **** 		return -FDT_ERR_NOSPACE;
  29:./lib/fdt/fdt_wip.c **** 
  30:./lib/fdt/fdt_wip.c **** 	memcpy((char *)propval + idx, val, len);
ARM GAS  /tmp/cc47XXUh.s 			page 2


  31:./lib/fdt/fdt_wip.c **** 	return 0;
  32:./lib/fdt/fdt_wip.c **** }
  33:./lib/fdt/fdt_wip.c **** 
  34:./lib/fdt/fdt_wip.c **** int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
  35:./lib/fdt/fdt_wip.c **** 			const void *val, int len)
  36:./lib/fdt/fdt_wip.c **** {
  37:./lib/fdt/fdt_wip.c **** 	const void *propval;
  38:./lib/fdt/fdt_wip.c **** 	int proplen;
  39:./lib/fdt/fdt_wip.c **** 
  40:./lib/fdt/fdt_wip.c **** 	propval = fdt_getprop(fdt, nodeoffset, name, &proplen);
  41:./lib/fdt/fdt_wip.c **** 	if (!propval)
  42:./lib/fdt/fdt_wip.c **** 		return proplen;
  43:./lib/fdt/fdt_wip.c **** 
  44:./lib/fdt/fdt_wip.c **** 	if (proplen != len)
  45:./lib/fdt/fdt_wip.c **** 		return -FDT_ERR_NOSPACE;
  46:./lib/fdt/fdt_wip.c **** 
  47:./lib/fdt/fdt_wip.c **** 	return fdt_setprop_inplace_namelen_partial(fdt, nodeoffset, name,
  48:./lib/fdt/fdt_wip.c **** 						   strlen(name), 0,
  49:./lib/fdt/fdt_wip.c **** 						   val, len);
  50:./lib/fdt/fdt_wip.c **** }
  51:./lib/fdt/fdt_wip.c **** 
  52:./lib/fdt/fdt_wip.c **** static void fdt_nop_region_(void *start, int len)
  53:./lib/fdt/fdt_wip.c **** {
  29              		.loc 1 53 1 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  54:./lib/fdt/fdt_wip.c **** 	fdt32_t *p;
  34              		.loc 1 54 2 view .LVU1
  55:./lib/fdt/fdt_wip.c **** 
  56:./lib/fdt/fdt_wip.c **** 	for (p = start; (char *)p < ((char *)start + len); p++)
  35              		.loc 1 56 2 view .LVU2
  36              		.loc 1 56 9 is_stmt 0 view .LVU3
  37 0000 0346     		mov	r3, r0
  38              		.loc 1 56 2 view .LVU4
  39 0002 03E0     		b	.L2
  40              	.LVL1:
  41              	.L3:
  57:./lib/fdt/fdt_wip.c **** 		*p = cpu_to_fdt32(FDT_NOP);
  42              		.loc 1 57 3 is_stmt 1 view .LVU5
  43              		.loc 1 57 6 is_stmt 0 discriminator 1 view .LVU6
  44 0004 4FF08062 		mov	r2, #67108864
  45 0008 43F8042B 		str	r2, [r3], #4
  46              	.LVL2:
  56:./lib/fdt/fdt_wip.c **** 		*p = cpu_to_fdt32(FDT_NOP);
  47              		.loc 1 56 54 is_stmt 1 discriminator 3 view .LVU7
  48              	.L2:
  56:./lib/fdt/fdt_wip.c **** 		*p = cpu_to_fdt32(FDT_NOP);
  49              		.loc 1 56 28 discriminator 1 view .LVU8
  56:./lib/fdt/fdt_wip.c **** 		*p = cpu_to_fdt32(FDT_NOP);
  50              		.loc 1 56 45 is_stmt 0 discriminator 1 view .LVU9
  51 000c 4218     		adds	r2, r0, r1
  56:./lib/fdt/fdt_wip.c **** 		*p = cpu_to_fdt32(FDT_NOP);
  52              		.loc 1 56 28 discriminator 1 view .LVU10
  53 000e 9A42     		cmp	r2, r3
  54 0010 F8D8     		bhi	.L3
ARM GAS  /tmp/cc47XXUh.s 			page 3


  58:./lib/fdt/fdt_wip.c **** }
  55              		.loc 1 58 1 view .LVU11
  56 0012 7047     		bx	lr
  57              		.cfi_endproc
  58              	.LFE77:
  60              		.section	.text.fdt_setprop_inplace_namelen_partial,"ax",%progbits
  61              		.align	1
  62              		.global	fdt_setprop_inplace_namelen_partial
  63              		.syntax unified
  64              		.thumb
  65              		.thumb_func
  67              	fdt_setprop_inplace_namelen_partial:
  68              	.LVL3:
  69              	.LFB75:
  18:./lib/fdt/fdt_wip.c **** 	void *propval;
  70              		.loc 1 18 1 is_stmt 1 view -0
  71              		.cfi_startproc
  72              		@ args = 12, pretend = 0, frame = 8
  73              		@ frame_needed = 0, uses_anonymous_args = 0
  18:./lib/fdt/fdt_wip.c **** 	void *propval;
  74              		.loc 1 18 1 is_stmt 0 view .LVU13
  75 0000 70B5     		push	{r4, r5, r6, lr}
  76              	.LCFI0:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82 0002 84B0     		sub	sp, sp, #16
  83              	.LCFI1:
  84              		.cfi_def_cfa_offset 32
  85 0004 089C     		ldr	r4, [sp, #32]
  86 0006 0A9D     		ldr	r5, [sp, #40]
  19:./lib/fdt/fdt_wip.c **** 	int proplen;
  87              		.loc 1 19 2 is_stmt 1 view .LVU14
  20:./lib/fdt/fdt_wip.c **** 
  88              		.loc 1 20 2 view .LVU15
  22:./lib/fdt/fdt_wip.c **** 					&proplen);
  89              		.loc 1 22 2 view .LVU16
  90              	.LVL4:
  91              	.LBB10:
  92              	.LBI10:
  93              		.file 2 "./include/linux/libfdt.h"
   1:./include/linux/libfdt.h **** /* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause) */
   2:./include/linux/libfdt.h **** #ifndef LIBFDT_H
   3:./include/linux/libfdt.h **** #define LIBFDT_H
   4:./include/linux/libfdt.h **** /*
   5:./include/linux/libfdt.h ****  * libfdt - Flat Device Tree manipulation
   6:./include/linux/libfdt.h ****  * Copyright (C) 2006 David Gibson, IBM Corporation.
   7:./include/linux/libfdt.h ****  */
   8:./include/linux/libfdt.h **** 
   9:./include/linux/libfdt.h **** #include <linux/libfdt_env.h>
  10:./include/linux/libfdt.h **** #include <linux/fdt.h>
  11:./include/linux/libfdt.h **** 
  12:./include/linux/libfdt.h **** #ifdef __cplusplus
  13:./include/linux/libfdt.h **** extern "C" {
  14:./include/linux/libfdt.h **** #endif
ARM GAS  /tmp/cc47XXUh.s 			page 4


  15:./include/linux/libfdt.h **** 
  16:./include/linux/libfdt.h **** 
  17:./include/linux/libfdt.h **** extern const uint8_t __dtb_file_start_address[];
  18:./include/linux/libfdt.h **** extern const uint8_t __dtb_file_end_address[];
  19:./include/linux/libfdt.h **** 
  20:./include/linux/libfdt.h **** #define FDT_FIRST_SUPPORTED_VERSION	0x02
  21:./include/linux/libfdt.h **** #define FDT_LAST_COMPATIBLE_VERSION	0x10
  22:./include/linux/libfdt.h **** #define FDT_LAST_SUPPORTED_VERSION	0x11
  23:./include/linux/libfdt.h **** 
  24:./include/linux/libfdt.h **** /* Error codes: informative error codes */
  25:./include/linux/libfdt.h **** #define FDT_ERR_NOTFOUND	1
  26:./include/linux/libfdt.h **** 	/* FDT_ERR_NOTFOUND: The requested node or property does not exist */
  27:./include/linux/libfdt.h **** #define FDT_ERR_EXISTS		2
  28:./include/linux/libfdt.h **** 	/* FDT_ERR_EXISTS: Attempted to create a node or property which
  29:./include/linux/libfdt.h **** 	 * already exists */
  30:./include/linux/libfdt.h **** #define FDT_ERR_NOSPACE		3
  31:./include/linux/libfdt.h **** 	/* FDT_ERR_NOSPACE: Operation needed to expand the device
  32:./include/linux/libfdt.h **** 	 * tree, but its buffer did not have sufficient space to
  33:./include/linux/libfdt.h **** 	 * contain the expanded tree. Use fdt_open_into() to move the
  34:./include/linux/libfdt.h **** 	 * device tree to a buffer with more space. */
  35:./include/linux/libfdt.h **** 
  36:./include/linux/libfdt.h **** /* Error codes: codes for bad parameters */
  37:./include/linux/libfdt.h **** #define FDT_ERR_BADOFFSET	4
  38:./include/linux/libfdt.h **** 	/* FDT_ERR_BADOFFSET: Function was passed a structure block
  39:./include/linux/libfdt.h **** 	 * offset which is out-of-bounds, or which points to an
  40:./include/linux/libfdt.h **** 	 * unsuitable part of the structure for the operation. */
  41:./include/linux/libfdt.h **** #define FDT_ERR_BADPATH		5
  42:./include/linux/libfdt.h **** 	/* FDT_ERR_BADPATH: Function was passed a badly formatted path
  43:./include/linux/libfdt.h **** 	 * (e.g. missing a leading / for a function which requires an
  44:./include/linux/libfdt.h **** 	 * absolute path) */
  45:./include/linux/libfdt.h **** #define FDT_ERR_BADPHANDLE	6
  46:./include/linux/libfdt.h **** 	/* FDT_ERR_BADPHANDLE: Function was passed an invalid phandle.
  47:./include/linux/libfdt.h **** 	 * This can be caused either by an invalid phandle property
  48:./include/linux/libfdt.h **** 	 * length, or the phandle value was either 0 or -1, which are
  49:./include/linux/libfdt.h **** 	 * not permitted. */
  50:./include/linux/libfdt.h **** #define FDT_ERR_BADSTATE	7
  51:./include/linux/libfdt.h **** 	/* FDT_ERR_BADSTATE: Function was passed an incomplete device
  52:./include/linux/libfdt.h **** 	 * tree created by the sequential-write functions, which is
  53:./include/linux/libfdt.h **** 	 * not sufficiently complete for the requested operation. */
  54:./include/linux/libfdt.h **** 
  55:./include/linux/libfdt.h **** /* Error codes: codes for bad device tree blobs */
  56:./include/linux/libfdt.h **** #define FDT_ERR_TRUNCATED	8
  57:./include/linux/libfdt.h **** 	/* FDT_ERR_TRUNCATED: FDT or a sub-block is improperly
  58:./include/linux/libfdt.h **** 	 * terminated (overflows, goes outside allowed bounds, or
  59:./include/linux/libfdt.h **** 	 * isn't properly terminated).  */
  60:./include/linux/libfdt.h **** #define FDT_ERR_BADMAGIC	9
  61:./include/linux/libfdt.h **** 	/* FDT_ERR_BADMAGIC: Given "device tree" appears not to be a
  62:./include/linux/libfdt.h **** 	 * device tree at all - it is missing the flattened device
  63:./include/linux/libfdt.h **** 	 * tree magic number. */
  64:./include/linux/libfdt.h **** #define FDT_ERR_BADVERSION	10
  65:./include/linux/libfdt.h **** 	/* FDT_ERR_BADVERSION: Given device tree has a version which
  66:./include/linux/libfdt.h **** 	 * can't be handled by the requested operation.  For
  67:./include/linux/libfdt.h **** 	 * read-write functions, this may mean that fdt_open_into() is
  68:./include/linux/libfdt.h **** 	 * required to convert the tree to the expected version. */
  69:./include/linux/libfdt.h **** #define FDT_ERR_BADSTRUCTURE	11
  70:./include/linux/libfdt.h **** 	/* FDT_ERR_BADSTRUCTURE: Given device tree has a corrupt
  71:./include/linux/libfdt.h **** 	 * structure block or other serious error (e.g. misnested
ARM GAS  /tmp/cc47XXUh.s 			page 5


  72:./include/linux/libfdt.h **** 	 * nodes, or subnodes preceding properties). */
  73:./include/linux/libfdt.h **** #define FDT_ERR_BADLAYOUT	12
  74:./include/linux/libfdt.h **** 	/* FDT_ERR_BADLAYOUT: For read-write functions, the given
  75:./include/linux/libfdt.h **** 	 * device tree has it's sub-blocks in an order that the
  76:./include/linux/libfdt.h **** 	 * function can't handle (memory reserve map, then structure,
  77:./include/linux/libfdt.h **** 	 * then strings).  Use fdt_open_into() to reorganize the tree
  78:./include/linux/libfdt.h **** 	 * into a form suitable for the read-write operations. */
  79:./include/linux/libfdt.h **** 
  80:./include/linux/libfdt.h **** /* "Can't happen" error indicating a bug in libfdt */
  81:./include/linux/libfdt.h **** #define FDT_ERR_INTERNAL	13
  82:./include/linux/libfdt.h **** 	/* FDT_ERR_INTERNAL: libfdt has failed an internal assertion.
  83:./include/linux/libfdt.h **** 	 * Should never be returned, if it is, it indicates a bug in
  84:./include/linux/libfdt.h **** 	 * libfdt itself. */
  85:./include/linux/libfdt.h **** 
  86:./include/linux/libfdt.h **** /* Errors in device tree content */
  87:./include/linux/libfdt.h **** #define FDT_ERR_BADNCELLS	14
  88:./include/linux/libfdt.h **** 	/* FDT_ERR_BADNCELLS: Device tree has a #address-cells, #size-cells
  89:./include/linux/libfdt.h **** 	 * or similar property with a bad format or value */
  90:./include/linux/libfdt.h **** 
  91:./include/linux/libfdt.h **** #define FDT_ERR_BADVALUE	15
  92:./include/linux/libfdt.h **** 	/* FDT_ERR_BADVALUE: Device tree has a property with an unexpected
  93:./include/linux/libfdt.h **** 	 * value. For example: a property expected to contain a string list
  94:./include/linux/libfdt.h **** 	 * is not NUL-terminated within the length of its value. */
  95:./include/linux/libfdt.h **** 
  96:./include/linux/libfdt.h **** #define FDT_ERR_BADOVERLAY	16
  97:./include/linux/libfdt.h **** 	/* FDT_ERR_BADOVERLAY: The device tree overlay, while
  98:./include/linux/libfdt.h **** 	 * correctly structured, cannot be applied due to some
  99:./include/linux/libfdt.h **** 	 * unexpected or missing value, property or node. */
 100:./include/linux/libfdt.h **** 
 101:./include/linux/libfdt.h **** #define FDT_ERR_NOPHANDLES	17
 102:./include/linux/libfdt.h **** 	/* FDT_ERR_NOPHANDLES: The device tree doesn't have any
 103:./include/linux/libfdt.h **** 	 * phandle available anymore without causing an overflow */
 104:./include/linux/libfdt.h **** 
 105:./include/linux/libfdt.h **** #define FDT_ERR_BADFLAGS	18
 106:./include/linux/libfdt.h **** 	/* FDT_ERR_BADFLAGS: The function was passed a flags field that
 107:./include/linux/libfdt.h **** 	 * contains invalid flags or an invalid combination of flags. */
 108:./include/linux/libfdt.h **** 
 109:./include/linux/libfdt.h **** #define FDT_ERR_ALIGNMENT	19
 110:./include/linux/libfdt.h **** 	/* FDT_ERR_ALIGNMENT: The device tree base address is not 8-byte
 111:./include/linux/libfdt.h **** 	 * aligned. */
 112:./include/linux/libfdt.h **** 
 113:./include/linux/libfdt.h **** #define FDT_ERR_MAX		19
 114:./include/linux/libfdt.h **** 
 115:./include/linux/libfdt.h **** /* constants */
 116:./include/linux/libfdt.h **** #define FDT_MAX_PHANDLE 0xfffffffe
 117:./include/linux/libfdt.h **** 	/* Valid values for phandles range from 1 to 2^32-2. */
 118:./include/linux/libfdt.h **** 
 119:./include/linux/libfdt.h **** /**********************************************************************/
 120:./include/linux/libfdt.h **** /* Low-level functions (you probably don't need these)                */
 121:./include/linux/libfdt.h **** /**********************************************************************/
 122:./include/linux/libfdt.h **** 
 123:./include/linux/libfdt.h **** #ifndef SWIG /* This function is not useful in Python */
 124:./include/linux/libfdt.h **** const void *fdt_offset_ptr(const void *fdt, int offset, unsigned int checklen);
 125:./include/linux/libfdt.h **** #endif
 126:./include/linux/libfdt.h **** static inline void *fdt_offset_ptr_w(void *fdt, int offset, int checklen)
 127:./include/linux/libfdt.h **** {
 128:./include/linux/libfdt.h **** 	return (void *)(uintptr_t)fdt_offset_ptr(fdt, offset, checklen);
ARM GAS  /tmp/cc47XXUh.s 			page 6


 129:./include/linux/libfdt.h **** }
 130:./include/linux/libfdt.h **** 
 131:./include/linux/libfdt.h **** uint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset);
 132:./include/linux/libfdt.h **** 
 133:./include/linux/libfdt.h **** /*
 134:./include/linux/libfdt.h ****  * External helpers to access words from a device tree blob. They're built
 135:./include/linux/libfdt.h ****  * to work even with unaligned pointers on platforms (such as ARMv5) that don't
 136:./include/linux/libfdt.h ****  * like unaligned loads and stores.
 137:./include/linux/libfdt.h ****  */
 138:./include/linux/libfdt.h **** static inline uint16_t fdt16_ld(const fdt16_t *p)
 139:./include/linux/libfdt.h **** {
 140:./include/linux/libfdt.h **** 	const uint8_t *bp = (const uint8_t *)p;
 141:./include/linux/libfdt.h **** 
 142:./include/linux/libfdt.h **** 	return ((uint16_t)bp[0] << 8) | bp[1];
 143:./include/linux/libfdt.h **** }
 144:./include/linux/libfdt.h **** 
 145:./include/linux/libfdt.h **** static inline uint32_t fdt32_ld(const fdt32_t *p)
 146:./include/linux/libfdt.h **** {
 147:./include/linux/libfdt.h **** 	const uint8_t *bp = (const uint8_t *)p;
 148:./include/linux/libfdt.h **** 
 149:./include/linux/libfdt.h **** 	return ((uint32_t)bp[0] << 24)
 150:./include/linux/libfdt.h **** 		| ((uint32_t)bp[1] << 16)
 151:./include/linux/libfdt.h **** 		| ((uint32_t)bp[2] << 8)
 152:./include/linux/libfdt.h **** 		| bp[3];
 153:./include/linux/libfdt.h **** }
 154:./include/linux/libfdt.h **** 
 155:./include/linux/libfdt.h **** static inline void fdt32_st(void *property, uint32_t value)
 156:./include/linux/libfdt.h **** {
 157:./include/linux/libfdt.h **** 	uint8_t *bp = (uint8_t *)property;
 158:./include/linux/libfdt.h **** 
 159:./include/linux/libfdt.h **** 	bp[0] = value >> 24;
 160:./include/linux/libfdt.h **** 	bp[1] = (value >> 16) & 0xff;
 161:./include/linux/libfdt.h **** 	bp[2] = (value >> 8) & 0xff;
 162:./include/linux/libfdt.h **** 	bp[3] = value & 0xff;
 163:./include/linux/libfdt.h **** }
 164:./include/linux/libfdt.h **** 
 165:./include/linux/libfdt.h **** static inline uint64_t fdt64_ld(const fdt64_t *p)
 166:./include/linux/libfdt.h **** {
 167:./include/linux/libfdt.h **** 	const uint8_t *bp = (const uint8_t *)p;
 168:./include/linux/libfdt.h **** 
 169:./include/linux/libfdt.h **** 	return ((uint64_t)bp[0] << 56)
 170:./include/linux/libfdt.h **** 		| ((uint64_t)bp[1] << 48)
 171:./include/linux/libfdt.h **** 		| ((uint64_t)bp[2] << 40)
 172:./include/linux/libfdt.h **** 		| ((uint64_t)bp[3] << 32)
 173:./include/linux/libfdt.h **** 		| ((uint64_t)bp[4] << 24)
 174:./include/linux/libfdt.h **** 		| ((uint64_t)bp[5] << 16)
 175:./include/linux/libfdt.h **** 		| ((uint64_t)bp[6] << 8)
 176:./include/linux/libfdt.h **** 		| bp[7];
 177:./include/linux/libfdt.h **** }
 178:./include/linux/libfdt.h **** 
 179:./include/linux/libfdt.h **** static inline void fdt64_st(void *property, uint64_t value)
 180:./include/linux/libfdt.h **** {
 181:./include/linux/libfdt.h **** 	uint8_t *bp = (uint8_t *)property;
 182:./include/linux/libfdt.h **** 
 183:./include/linux/libfdt.h **** 	bp[0] = value >> 56;
 184:./include/linux/libfdt.h **** 	bp[1] = (value >> 48) & 0xff;
 185:./include/linux/libfdt.h **** 	bp[2] = (value >> 40) & 0xff;
ARM GAS  /tmp/cc47XXUh.s 			page 7


 186:./include/linux/libfdt.h **** 	bp[3] = (value >> 32) & 0xff;
 187:./include/linux/libfdt.h **** 	bp[4] = (value >> 24) & 0xff;
 188:./include/linux/libfdt.h **** 	bp[5] = (value >> 16) & 0xff;
 189:./include/linux/libfdt.h **** 	bp[6] = (value >> 8) & 0xff;
 190:./include/linux/libfdt.h **** 	bp[7] = value & 0xff;
 191:./include/linux/libfdt.h **** }
 192:./include/linux/libfdt.h **** 
 193:./include/linux/libfdt.h **** /**********************************************************************/
 194:./include/linux/libfdt.h **** /* Traversal functions                                                */
 195:./include/linux/libfdt.h **** /**********************************************************************/
 196:./include/linux/libfdt.h **** 
 197:./include/linux/libfdt.h **** int fdt_next_node(const void *fdt, int offset, int *depth);
 198:./include/linux/libfdt.h **** 
 199:./include/linux/libfdt.h **** /**
 200:./include/linux/libfdt.h ****  * fdt_first_subnode() - get offset of first direct subnode
 201:./include/linux/libfdt.h ****  * @fdt:	FDT blob
 202:./include/linux/libfdt.h ****  * @offset:	Offset of node to check
 203:./include/linux/libfdt.h ****  *
 204:./include/linux/libfdt.h ****  * Return: offset of first subnode, or -FDT_ERR_NOTFOUND if there is none
 205:./include/linux/libfdt.h ****  */
 206:./include/linux/libfdt.h **** int fdt_first_subnode(const void *fdt, int offset);
 207:./include/linux/libfdt.h **** 
 208:./include/linux/libfdt.h **** /**
 209:./include/linux/libfdt.h ****  * fdt_next_subnode() - get offset of next direct subnode
 210:./include/linux/libfdt.h ****  * @fdt:	FDT blob
 211:./include/linux/libfdt.h ****  * @offset:	Offset of previous subnode
 212:./include/linux/libfdt.h ****  *
 213:./include/linux/libfdt.h ****  * After first calling fdt_first_subnode(), call this function repeatedly to
 214:./include/linux/libfdt.h ****  * get direct subnodes of a parent node.
 215:./include/linux/libfdt.h ****  *
 216:./include/linux/libfdt.h ****  * Return: offset of next subnode, or -FDT_ERR_NOTFOUND if there are no more
 217:./include/linux/libfdt.h ****  *         subnodes
 218:./include/linux/libfdt.h ****  */
 219:./include/linux/libfdt.h **** int fdt_next_subnode(const void *fdt, int offset);
 220:./include/linux/libfdt.h **** 
 221:./include/linux/libfdt.h **** /**
 222:./include/linux/libfdt.h ****  * fdt_for_each_subnode - iterate over all subnodes of a parent
 223:./include/linux/libfdt.h ****  *
 224:./include/linux/libfdt.h ****  * @node:	child node (int, lvalue)
 225:./include/linux/libfdt.h ****  * @fdt:	FDT blob (const void *)
 226:./include/linux/libfdt.h ****  * @parent:	parent node (int)
 227:./include/linux/libfdt.h ****  *
 228:./include/linux/libfdt.h ****  * This is actually a wrapper around a for loop and would be used like so:
 229:./include/linux/libfdt.h ****  *
 230:./include/linux/libfdt.h ****  *	fdt_for_each_subnode(node, fdt, parent) {
 231:./include/linux/libfdt.h ****  *		Use node
 232:./include/linux/libfdt.h ****  *		...
 233:./include/linux/libfdt.h ****  *	}
 234:./include/linux/libfdt.h ****  *
 235:./include/linux/libfdt.h ****  *	if ((node < 0) && (node != -FDT_ERR_NOTFOUND)) {
 236:./include/linux/libfdt.h ****  *		Error handling
 237:./include/linux/libfdt.h ****  *	}
 238:./include/linux/libfdt.h ****  *
 239:./include/linux/libfdt.h ****  * Note that this is implemented as a macro and @node is used as
 240:./include/linux/libfdt.h ****  * iterator in the loop. The parent variable be constant or even a
 241:./include/linux/libfdt.h ****  * literal.
 242:./include/linux/libfdt.h ****  */
ARM GAS  /tmp/cc47XXUh.s 			page 8


 243:./include/linux/libfdt.h **** #define fdt_for_each_subnode(node, fdt, parent)		\
 244:./include/linux/libfdt.h **** 	for (node = fdt_first_subnode(fdt, parent);	\
 245:./include/linux/libfdt.h **** 	     node >= 0;					\
 246:./include/linux/libfdt.h **** 	     node = fdt_next_subnode(fdt, node))
 247:./include/linux/libfdt.h **** 
 248:./include/linux/libfdt.h **** /**********************************************************************/
 249:./include/linux/libfdt.h **** /* General functions                                                  */
 250:./include/linux/libfdt.h **** /**********************************************************************/
 251:./include/linux/libfdt.h **** #define fdt_get_header(fdt, field) \
 252:./include/linux/libfdt.h **** 	(fdt32_ld(&((const struct fdt_header *)(fdt))->field))
 253:./include/linux/libfdt.h **** #define fdt_magic(fdt)			(fdt_get_header(fdt, magic))
 254:./include/linux/libfdt.h **** #define fdt_totalsize(fdt)		(fdt_get_header(fdt, totalsize))
 255:./include/linux/libfdt.h **** #define fdt_off_dt_struct(fdt)		(fdt_get_header(fdt, off_dt_struct))
 256:./include/linux/libfdt.h **** #define fdt_off_dt_strings(fdt)		(fdt_get_header(fdt, off_dt_strings))
 257:./include/linux/libfdt.h **** #define fdt_off_mem_rsvmap(fdt)		(fdt_get_header(fdt, off_mem_rsvmap))
 258:./include/linux/libfdt.h **** #define fdt_version(fdt)		(fdt_get_header(fdt, version))
 259:./include/linux/libfdt.h **** #define fdt_last_comp_version(fdt)	(fdt_get_header(fdt, last_comp_version))
 260:./include/linux/libfdt.h **** #define fdt_boot_cpuid_phys(fdt)	(fdt_get_header(fdt, boot_cpuid_phys))
 261:./include/linux/libfdt.h **** #define fdt_size_dt_strings(fdt)	(fdt_get_header(fdt, size_dt_strings))
 262:./include/linux/libfdt.h **** #define fdt_size_dt_struct(fdt)		(fdt_get_header(fdt, size_dt_struct))
 263:./include/linux/libfdt.h **** 
 264:./include/linux/libfdt.h **** #define fdt_set_hdr_(name) \
 265:./include/linux/libfdt.h **** 	static inline void fdt_set_##name(void *fdt, uint32_t val) \
 266:./include/linux/libfdt.h **** 	{ \
 267:./include/linux/libfdt.h **** 		struct fdt_header *fdth = (struct fdt_header *)fdt; \
 268:./include/linux/libfdt.h **** 		fdth->name = cpu_to_fdt32(val); \
 269:./include/linux/libfdt.h **** 	}
 270:./include/linux/libfdt.h **** fdt_set_hdr_(magic)
 271:./include/linux/libfdt.h **** fdt_set_hdr_(totalsize)
 272:./include/linux/libfdt.h **** fdt_set_hdr_(off_dt_struct)
 273:./include/linux/libfdt.h **** fdt_set_hdr_(off_dt_strings)
 274:./include/linux/libfdt.h **** fdt_set_hdr_(off_mem_rsvmap)
 275:./include/linux/libfdt.h **** fdt_set_hdr_(version)
 276:./include/linux/libfdt.h **** fdt_set_hdr_(last_comp_version)
 277:./include/linux/libfdt.h **** fdt_set_hdr_(boot_cpuid_phys)
 278:./include/linux/libfdt.h **** fdt_set_hdr_(size_dt_strings)
 279:./include/linux/libfdt.h **** fdt_set_hdr_(size_dt_struct)
 280:./include/linux/libfdt.h **** #undef fdt_set_hdr_
 281:./include/linux/libfdt.h **** 
 282:./include/linux/libfdt.h **** /**
 283:./include/linux/libfdt.h ****  * fdt_header_size - return the size of the tree's header
 284:./include/linux/libfdt.h ****  * @fdt: pointer to a flattened device tree
 285:./include/linux/libfdt.h ****  *
 286:./include/linux/libfdt.h ****  * Return: size of DTB header in bytes
 287:./include/linux/libfdt.h ****  */
 288:./include/linux/libfdt.h **** size_t fdt_header_size(const void *fdt);
 289:./include/linux/libfdt.h **** 
 290:./include/linux/libfdt.h **** /**
 291:./include/linux/libfdt.h ****  * fdt_header_size_ - internal function to get header size from a version number
 292:./include/linux/libfdt.h ****  * @version: device tree version number
 293:./include/linux/libfdt.h ****  *
 294:./include/linux/libfdt.h ****  * Return: size of DTB header in bytes
 295:./include/linux/libfdt.h ****  */
 296:./include/linux/libfdt.h **** size_t fdt_header_size_(uint32_t version);
 297:./include/linux/libfdt.h **** 
 298:./include/linux/libfdt.h **** /**
 299:./include/linux/libfdt.h ****  * fdt_check_header - sanity check a device tree header
ARM GAS  /tmp/cc47XXUh.s 			page 9


 300:./include/linux/libfdt.h ****  * @fdt: pointer to data which might be a flattened device tree
 301:./include/linux/libfdt.h ****  *
 302:./include/linux/libfdt.h ****  * fdt_check_header() checks that the given buffer contains what
 303:./include/linux/libfdt.h ****  * appears to be a flattened device tree, and that the header contains
 304:./include/linux/libfdt.h ****  * valid information (to the extent that can be determined from the
 305:./include/linux/libfdt.h ****  * header alone).
 306:./include/linux/libfdt.h ****  *
 307:./include/linux/libfdt.h ****  * returns:
 308:./include/linux/libfdt.h ****  *     0, if the buffer appears to contain a valid device tree
 309:./include/linux/libfdt.h ****  *     -FDT_ERR_BADMAGIC,
 310:./include/linux/libfdt.h ****  *     -FDT_ERR_BADVERSION,
 311:./include/linux/libfdt.h ****  *     -FDT_ERR_BADSTATE,
 312:./include/linux/libfdt.h ****  *     -FDT_ERR_TRUNCATED, standard meanings, as above
 313:./include/linux/libfdt.h ****  */
 314:./include/linux/libfdt.h **** int fdt_check_header(const void *fdt);
 315:./include/linux/libfdt.h **** 
 316:./include/linux/libfdt.h **** /**
 317:./include/linux/libfdt.h ****  * fdt_move - move a device tree around in memory
 318:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree to move
 319:./include/linux/libfdt.h ****  * @buf: pointer to memory where the device is to be moved
 320:./include/linux/libfdt.h ****  * @bufsize: size of the memory space at buf
 321:./include/linux/libfdt.h ****  *
 322:./include/linux/libfdt.h ****  * fdt_move() relocates, if possible, the device tree blob located at
 323:./include/linux/libfdt.h ****  * fdt to the buffer at buf of size bufsize.  The buffer may overlap
 324:./include/linux/libfdt.h ****  * with the existing device tree blob at fdt.  Therefore,
 325:./include/linux/libfdt.h ****  *     fdt_move(fdt, fdt, fdt_totalsize(fdt))
 326:./include/linux/libfdt.h ****  * should always succeed.
 327:./include/linux/libfdt.h ****  *
 328:./include/linux/libfdt.h ****  * returns:
 329:./include/linux/libfdt.h ****  *     0, on success
 330:./include/linux/libfdt.h ****  *     -FDT_ERR_NOSPACE, bufsize is insufficient to contain the device tree
 331:./include/linux/libfdt.h ****  *     -FDT_ERR_BADMAGIC,
 332:./include/linux/libfdt.h ****  *     -FDT_ERR_BADVERSION,
 333:./include/linux/libfdt.h ****  *     -FDT_ERR_BADSTATE, standard meanings
 334:./include/linux/libfdt.h ****  */
 335:./include/linux/libfdt.h **** int fdt_move(const void *fdt, void *buf, int bufsize);
 336:./include/linux/libfdt.h **** 
 337:./include/linux/libfdt.h **** /**********************************************************************/
 338:./include/linux/libfdt.h **** /* Read-only functions                                                */
 339:./include/linux/libfdt.h **** /**********************************************************************/
 340:./include/linux/libfdt.h **** 
 341:./include/linux/libfdt.h **** int fdt_check_full(const void *fdt, size_t bufsize);
 342:./include/linux/libfdt.h **** 
 343:./include/linux/libfdt.h **** /**
 344:./include/linux/libfdt.h ****  * fdt_get_string - retrieve a string from the strings block of a device tree
 345:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 346:./include/linux/libfdt.h ****  * @stroffset: offset of the string within the strings block (native endian)
 347:./include/linux/libfdt.h ****  * @lenp: optional pointer to return the string's length
 348:./include/linux/libfdt.h ****  *
 349:./include/linux/libfdt.h ****  * fdt_get_string() retrieves a pointer to a single string from the
 350:./include/linux/libfdt.h ****  * strings block of the device tree blob at fdt, and optionally also
 351:./include/linux/libfdt.h ****  * returns the string's length in *lenp.
 352:./include/linux/libfdt.h ****  *
 353:./include/linux/libfdt.h ****  * returns:
 354:./include/linux/libfdt.h ****  *     a pointer to the string, on success
 355:./include/linux/libfdt.h ****  *     NULL, if stroffset is out of bounds, or doesn't point to a valid string
 356:./include/linux/libfdt.h ****  */
ARM GAS  /tmp/cc47XXUh.s 			page 10


 357:./include/linux/libfdt.h **** const char *fdt_get_string(const void *fdt, int stroffset, int *lenp);
 358:./include/linux/libfdt.h **** 
 359:./include/linux/libfdt.h **** /**
 360:./include/linux/libfdt.h ****  * fdt_string - retrieve a string from the strings block of a device tree
 361:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 362:./include/linux/libfdt.h ****  * @stroffset: offset of the string within the strings block (native endian)
 363:./include/linux/libfdt.h ****  *
 364:./include/linux/libfdt.h ****  * fdt_string() retrieves a pointer to a single string from the
 365:./include/linux/libfdt.h ****  * strings block of the device tree blob at fdt.
 366:./include/linux/libfdt.h ****  *
 367:./include/linux/libfdt.h ****  * returns:
 368:./include/linux/libfdt.h ****  *     a pointer to the string, on success
 369:./include/linux/libfdt.h ****  *     NULL, if stroffset is out of bounds, or doesn't point to a valid string
 370:./include/linux/libfdt.h ****  */
 371:./include/linux/libfdt.h **** const char *fdt_string(const void *fdt, int stroffset);
 372:./include/linux/libfdt.h **** 
 373:./include/linux/libfdt.h **** /**
 374:./include/linux/libfdt.h ****  * fdt_find_max_phandle - find and return the highest phandle in a tree
 375:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 376:./include/linux/libfdt.h ****  * @phandle: return location for the highest phandle value found in the tree
 377:./include/linux/libfdt.h ****  *
 378:./include/linux/libfdt.h ****  * fdt_find_max_phandle() finds the highest phandle value in the given device
 379:./include/linux/libfdt.h ****  * tree. The value returned in @phandle is only valid if the function returns
 380:./include/linux/libfdt.h ****  * success.
 381:./include/linux/libfdt.h ****  *
 382:./include/linux/libfdt.h ****  * returns:
 383:./include/linux/libfdt.h ****  *     0 on success or a negative error code on failure
 384:./include/linux/libfdt.h ****  */
 385:./include/linux/libfdt.h **** int fdt_find_max_phandle(const void *fdt, uint32_t *phandle);
 386:./include/linux/libfdt.h **** 
 387:./include/linux/libfdt.h **** /**
 388:./include/linux/libfdt.h ****  * fdt_get_max_phandle - retrieves the highest phandle in a tree
 389:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 390:./include/linux/libfdt.h ****  *
 391:./include/linux/libfdt.h ****  * fdt_get_max_phandle retrieves the highest phandle in the given
 392:./include/linux/libfdt.h ****  * device tree. This will ignore badly formatted phandles, or phandles
 393:./include/linux/libfdt.h ****  * with a value of 0 or -1.
 394:./include/linux/libfdt.h ****  *
 395:./include/linux/libfdt.h ****  * This function is deprecated in favour of fdt_find_max_phandle().
 396:./include/linux/libfdt.h ****  *
 397:./include/linux/libfdt.h ****  * returns:
 398:./include/linux/libfdt.h ****  *      the highest phandle on success
 399:./include/linux/libfdt.h ****  *      0, if no phandle was found in the device tree
 400:./include/linux/libfdt.h ****  *      -1, if an error occurred
 401:./include/linux/libfdt.h ****  */
 402:./include/linux/libfdt.h **** static inline uint32_t fdt_get_max_phandle(const void *fdt)
 403:./include/linux/libfdt.h **** {
 404:./include/linux/libfdt.h **** 	uint32_t phandle;
 405:./include/linux/libfdt.h **** 	int err;
 406:./include/linux/libfdt.h **** 
 407:./include/linux/libfdt.h **** 	err = fdt_find_max_phandle(fdt, &phandle);
 408:./include/linux/libfdt.h **** 	if (err < 0)
 409:./include/linux/libfdt.h **** 		return (uint32_t)-1;
 410:./include/linux/libfdt.h **** 
 411:./include/linux/libfdt.h **** 	return phandle;
 412:./include/linux/libfdt.h **** }
 413:./include/linux/libfdt.h **** 
ARM GAS  /tmp/cc47XXUh.s 			page 11


 414:./include/linux/libfdt.h **** /**
 415:./include/linux/libfdt.h ****  * fdt_generate_phandle - return a new, unused phandle for a device tree blob
 416:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 417:./include/linux/libfdt.h ****  * @phandle: return location for the new phandle
 418:./include/linux/libfdt.h ****  *
 419:./include/linux/libfdt.h ****  * Walks the device tree blob and looks for the highest phandle value. On
 420:./include/linux/libfdt.h ****  * success, the new, unused phandle value (one higher than the previously
 421:./include/linux/libfdt.h ****  * highest phandle value in the device tree blob) will be returned in the
 422:./include/linux/libfdt.h ****  * @phandle parameter.
 423:./include/linux/libfdt.h ****  *
 424:./include/linux/libfdt.h ****  * Return: 0 on success or a negative error-code on failure
 425:./include/linux/libfdt.h ****  */
 426:./include/linux/libfdt.h **** int fdt_generate_phandle(const void *fdt, uint32_t *phandle);
 427:./include/linux/libfdt.h **** 
 428:./include/linux/libfdt.h **** /**
 429:./include/linux/libfdt.h ****  * fdt_num_mem_rsv - retrieve the number of memory reserve map entries
 430:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 431:./include/linux/libfdt.h ****  *
 432:./include/linux/libfdt.h ****  * Returns the number of entries in the device tree blob's memory
 433:./include/linux/libfdt.h ****  * reservation map.  This does not include the terminating 0,0 entry
 434:./include/linux/libfdt.h ****  * or any other (0,0) entries reserved for expansion.
 435:./include/linux/libfdt.h ****  *
 436:./include/linux/libfdt.h ****  * returns:
 437:./include/linux/libfdt.h ****  *     the number of entries
 438:./include/linux/libfdt.h ****  */
 439:./include/linux/libfdt.h **** int fdt_num_mem_rsv(const void *fdt);
 440:./include/linux/libfdt.h **** 
 441:./include/linux/libfdt.h **** /**
 442:./include/linux/libfdt.h ****  * fdt_get_mem_rsv - retrieve one memory reserve map entry
 443:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 444:./include/linux/libfdt.h ****  * @n: index of reserve map entry
 445:./include/linux/libfdt.h ****  * @address: pointer to 64-bit variable to hold the start address
 446:./include/linux/libfdt.h ****  * @size: pointer to 64-bit variable to hold the size of the entry
 447:./include/linux/libfdt.h ****  *
 448:./include/linux/libfdt.h ****  * On success, @address and @size will contain the address and size of
 449:./include/linux/libfdt.h ****  * the n-th reserve map entry from the device tree blob, in
 450:./include/linux/libfdt.h ****  * native-endian format.
 451:./include/linux/libfdt.h ****  *
 452:./include/linux/libfdt.h ****  * returns:
 453:./include/linux/libfdt.h ****  *     0, on success
 454:./include/linux/libfdt.h ****  *     -FDT_ERR_BADMAGIC,
 455:./include/linux/libfdt.h ****  *     -FDT_ERR_BADVERSION,
 456:./include/linux/libfdt.h ****  *     -FDT_ERR_BADSTATE, standard meanings
 457:./include/linux/libfdt.h ****  */
 458:./include/linux/libfdt.h **** int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size);
 459:./include/linux/libfdt.h **** 
 460:./include/linux/libfdt.h **** /**
 461:./include/linux/libfdt.h ****  * fdt_subnode_offset_namelen - find a subnode based on substring
 462:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 463:./include/linux/libfdt.h ****  * @parentoffset: structure block offset of a node
 464:./include/linux/libfdt.h ****  * @name: name of the subnode to locate
 465:./include/linux/libfdt.h ****  * @namelen: number of characters of name to consider
 466:./include/linux/libfdt.h ****  *
 467:./include/linux/libfdt.h ****  * Identical to fdt_subnode_offset(), but only examine the first
 468:./include/linux/libfdt.h ****  * namelen characters of name for matching the subnode name.  This is
 469:./include/linux/libfdt.h ****  * useful for finding subnodes based on a portion of a larger string,
 470:./include/linux/libfdt.h ****  * such as a full path.
ARM GAS  /tmp/cc47XXUh.s 			page 12


 471:./include/linux/libfdt.h ****  *
 472:./include/linux/libfdt.h ****  * Return: offset of the subnode or -FDT_ERR_NOTFOUND if name not found.
 473:./include/linux/libfdt.h ****  */
 474:./include/linux/libfdt.h **** #ifndef SWIG /* Not available in Python */
 475:./include/linux/libfdt.h **** int fdt_subnode_offset_namelen(const void *fdt, int parentoffset,
 476:./include/linux/libfdt.h **** 			       const char *name, int namelen);
 477:./include/linux/libfdt.h **** #endif
 478:./include/linux/libfdt.h **** /**
 479:./include/linux/libfdt.h ****  * fdt_subnode_offset - find a subnode of a given node
 480:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 481:./include/linux/libfdt.h ****  * @parentoffset: structure block offset of a node
 482:./include/linux/libfdt.h ****  * @name: name of the subnode to locate
 483:./include/linux/libfdt.h ****  *
 484:./include/linux/libfdt.h ****  * fdt_subnode_offset() finds a subnode of the node at structure block
 485:./include/linux/libfdt.h ****  * offset parentoffset with the given name.  name may include a unit
 486:./include/linux/libfdt.h ****  * address, in which case fdt_subnode_offset() will find the subnode
 487:./include/linux/libfdt.h ****  * with that unit address, or the unit address may be omitted, in
 488:./include/linux/libfdt.h ****  * which case fdt_subnode_offset() will find an arbitrary subnode
 489:./include/linux/libfdt.h ****  * whose name excluding unit address matches the given name.
 490:./include/linux/libfdt.h ****  *
 491:./include/linux/libfdt.h ****  * returns:
 492:./include/linux/libfdt.h ****  *	structure block offset of the requested subnode (>=0), on success
 493:./include/linux/libfdt.h ****  *	-FDT_ERR_NOTFOUND, if the requested subnode does not exist
 494:./include/linux/libfdt.h ****  *	-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE
 495:./include/linux/libfdt.h ****  *		tag
 496:./include/linux/libfdt.h ****  *	-FDT_ERR_BADMAGIC,
 497:./include/linux/libfdt.h ****  *	-FDT_ERR_BADVERSION,
 498:./include/linux/libfdt.h ****  *	-FDT_ERR_BADSTATE,
 499:./include/linux/libfdt.h ****  *	-FDT_ERR_BADSTRUCTURE,
 500:./include/linux/libfdt.h ****  *	-FDT_ERR_TRUNCATED, standard meanings.
 501:./include/linux/libfdt.h ****  */
 502:./include/linux/libfdt.h **** int fdt_subnode_offset(const void *fdt, int parentoffset, const char *name);
 503:./include/linux/libfdt.h **** 
 504:./include/linux/libfdt.h **** /**
 505:./include/linux/libfdt.h ****  * fdt_path_offset_namelen - find a tree node by its full path
 506:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 507:./include/linux/libfdt.h ****  * @path: full path of the node to locate
 508:./include/linux/libfdt.h ****  * @namelen: number of characters of path to consider
 509:./include/linux/libfdt.h ****  *
 510:./include/linux/libfdt.h ****  * Identical to fdt_path_offset(), but only consider the first namelen
 511:./include/linux/libfdt.h ****  * characters of path as the path name.
 512:./include/linux/libfdt.h ****  *
 513:./include/linux/libfdt.h ****  * Return: offset of the node or negative libfdt error value otherwise
 514:./include/linux/libfdt.h ****  */
 515:./include/linux/libfdt.h **** #ifndef SWIG /* Not available in Python */
 516:./include/linux/libfdt.h **** int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen);
 517:./include/linux/libfdt.h **** #endif
 518:./include/linux/libfdt.h **** 
 519:./include/linux/libfdt.h **** /**
 520:./include/linux/libfdt.h ****  * fdt_path_offset - find a tree node by its full path
 521:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 522:./include/linux/libfdt.h ****  * @path: full path of the node to locate
 523:./include/linux/libfdt.h ****  *
 524:./include/linux/libfdt.h ****  * fdt_path_offset() finds a node of a given path in the device tree.
 525:./include/linux/libfdt.h ****  * Each path component may omit the unit address portion, but the
 526:./include/linux/libfdt.h ****  * results of this are undefined if any such path component is
 527:./include/linux/libfdt.h ****  * ambiguous (that is if there are multiple nodes at the relevant
ARM GAS  /tmp/cc47XXUh.s 			page 13


 528:./include/linux/libfdt.h ****  * level matching the given component, differentiated only by unit
 529:./include/linux/libfdt.h ****  * address).
 530:./include/linux/libfdt.h ****  *
 531:./include/linux/libfdt.h ****  * If the path is not absolute (i.e. does not begin with '/'), the
 532:./include/linux/libfdt.h ****  * first component is treated as an alias.  That is, the property by
 533:./include/linux/libfdt.h ****  * that name is looked up in the /aliases node, and the value of that
 534:./include/linux/libfdt.h ****  * property used in place of that first component.
 535:./include/linux/libfdt.h ****  *
 536:./include/linux/libfdt.h ****  * For example, for this small fragment
 537:./include/linux/libfdt.h ****  *
 538:./include/linux/libfdt.h ****  * / {
 539:./include/linux/libfdt.h ****  *     aliases {
 540:./include/linux/libfdt.h ****  *         i2c2 = &foo; // RHS compiles to "/soc@0/i2c@30a40000/eeprom@52"
 541:./include/linux/libfdt.h ****  *     };
 542:./include/linux/libfdt.h ****  *     soc@0 {
 543:./include/linux/libfdt.h ****  *         foo: i2c@30a40000 {
 544:./include/linux/libfdt.h ****  *             bar: eeprom@52 {
 545:./include/linux/libfdt.h ****  *             };
 546:./include/linux/libfdt.h ****  *         };
 547:./include/linux/libfdt.h ****  *     };
 548:./include/linux/libfdt.h ****  * };
 549:./include/linux/libfdt.h ****  *
 550:./include/linux/libfdt.h ****  * these would be equivalent:
 551:./include/linux/libfdt.h ****  *
 552:./include/linux/libfdt.h ****  *   /soc@0/i2c@30a40000/eeprom@52
 553:./include/linux/libfdt.h ****  *   i2c2/eeprom@52
 554:./include/linux/libfdt.h ****  *
 555:./include/linux/libfdt.h ****  * returns:
 556:./include/linux/libfdt.h ****  *	structure block offset of the node with the requested path (>=0), on
 557:./include/linux/libfdt.h ****  *		success
 558:./include/linux/libfdt.h ****  *	-FDT_ERR_BADPATH, given path does not begin with '/' and the first
 559:./include/linux/libfdt.h ****  *		component is not a valid alias
 560:./include/linux/libfdt.h ****  *	-FDT_ERR_NOTFOUND, if the requested node does not exist
 561:./include/linux/libfdt.h ****  *	-FDT_ERR_BADMAGIC,
 562:./include/linux/libfdt.h ****  *	-FDT_ERR_BADVERSION,
 563:./include/linux/libfdt.h ****  *	-FDT_ERR_BADSTATE,
 564:./include/linux/libfdt.h ****  *	-FDT_ERR_BADSTRUCTURE,
 565:./include/linux/libfdt.h ****  *	-FDT_ERR_TRUNCATED, standard meanings.
 566:./include/linux/libfdt.h ****  */
 567:./include/linux/libfdt.h **** int fdt_path_offset(const void *fdt, const char *path);
 568:./include/linux/libfdt.h **** 
 569:./include/linux/libfdt.h **** /**
 570:./include/linux/libfdt.h ****  * fdt_get_name - retrieve the name of a given node
 571:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 572:./include/linux/libfdt.h ****  * @nodeoffset: structure block offset of the starting node
 573:./include/linux/libfdt.h ****  * @lenp: pointer to an integer variable (will be overwritten) or NULL
 574:./include/linux/libfdt.h ****  *
 575:./include/linux/libfdt.h ****  * fdt_get_name() retrieves the name (including unit address) of the
 576:./include/linux/libfdt.h ****  * device tree node at structure block offset nodeoffset.  If lenp is
 577:./include/linux/libfdt.h ****  * non-NULL, the length of this name is also returned, in the integer
 578:./include/linux/libfdt.h ****  * pointed to by lenp.
 579:./include/linux/libfdt.h ****  *
 580:./include/linux/libfdt.h ****  * returns:
 581:./include/linux/libfdt.h ****  *	pointer to the node's name, on success
 582:./include/linux/libfdt.h ****  *		If lenp is non-NULL, *lenp contains the length of that name
 583:./include/linux/libfdt.h ****  *			(>=0)
 584:./include/linux/libfdt.h ****  *	NULL, on error
ARM GAS  /tmp/cc47XXUh.s 			page 14


 585:./include/linux/libfdt.h ****  *		if lenp is non-NULL *lenp contains an error code (<0):
 586:./include/linux/libfdt.h ****  *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
 587:./include/linux/libfdt.h ****  *			tag
 588:./include/linux/libfdt.h ****  *		-FDT_ERR_BADMAGIC,
 589:./include/linux/libfdt.h ****  *		-FDT_ERR_BADVERSION,
 590:./include/linux/libfdt.h ****  *		-FDT_ERR_BADSTATE, standard meanings
 591:./include/linux/libfdt.h ****  */
 592:./include/linux/libfdt.h **** const char *fdt_get_name(const void *fdt, int nodeoffset, int *lenp);
 593:./include/linux/libfdt.h **** 
 594:./include/linux/libfdt.h **** /**
 595:./include/linux/libfdt.h ****  * fdt_first_property_offset - find the offset of a node's first property
 596:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 597:./include/linux/libfdt.h ****  * @nodeoffset: structure block offset of a node
 598:./include/linux/libfdt.h ****  *
 599:./include/linux/libfdt.h ****  * fdt_first_property_offset() finds the first property of the node at
 600:./include/linux/libfdt.h ****  * the given structure block offset.
 601:./include/linux/libfdt.h ****  *
 602:./include/linux/libfdt.h ****  * returns:
 603:./include/linux/libfdt.h ****  *	structure block offset of the property (>=0), on success
 604:./include/linux/libfdt.h ****  *	-FDT_ERR_NOTFOUND, if the requested node has no properties
 605:./include/linux/libfdt.h ****  *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_BEGIN_NODE tag
 606:./include/linux/libfdt.h ****  *	-FDT_ERR_BADMAGIC,
 607:./include/linux/libfdt.h ****  *	-FDT_ERR_BADVERSION,
 608:./include/linux/libfdt.h ****  *	-FDT_ERR_BADSTATE,
 609:./include/linux/libfdt.h ****  *	-FDT_ERR_BADSTRUCTURE,
 610:./include/linux/libfdt.h ****  *	-FDT_ERR_TRUNCATED, standard meanings.
 611:./include/linux/libfdt.h ****  */
 612:./include/linux/libfdt.h **** int fdt_first_property_offset(const void *fdt, int nodeoffset);
 613:./include/linux/libfdt.h **** 
 614:./include/linux/libfdt.h **** /**
 615:./include/linux/libfdt.h ****  * fdt_next_property_offset - step through a node's properties
 616:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 617:./include/linux/libfdt.h ****  * @offset: structure block offset of a property
 618:./include/linux/libfdt.h ****  *
 619:./include/linux/libfdt.h ****  * fdt_next_property_offset() finds the property immediately after the
 620:./include/linux/libfdt.h ****  * one at the given structure block offset.  This will be a property
 621:./include/linux/libfdt.h ****  * of the same node as the given property.
 622:./include/linux/libfdt.h ****  *
 623:./include/linux/libfdt.h ****  * returns:
 624:./include/linux/libfdt.h ****  *	structure block offset of the next property (>=0), on success
 625:./include/linux/libfdt.h ****  *	-FDT_ERR_NOTFOUND, if the given property is the last in its node
 626:./include/linux/libfdt.h ****  *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_PROP tag
 627:./include/linux/libfdt.h ****  *	-FDT_ERR_BADMAGIC,
 628:./include/linux/libfdt.h ****  *	-FDT_ERR_BADVERSION,
 629:./include/linux/libfdt.h ****  *	-FDT_ERR_BADSTATE,
 630:./include/linux/libfdt.h ****  *	-FDT_ERR_BADSTRUCTURE,
 631:./include/linux/libfdt.h ****  *	-FDT_ERR_TRUNCATED, standard meanings.
 632:./include/linux/libfdt.h ****  */
 633:./include/linux/libfdt.h **** int fdt_next_property_offset(const void *fdt, int offset);
 634:./include/linux/libfdt.h **** 
 635:./include/linux/libfdt.h **** /**
 636:./include/linux/libfdt.h ****  * fdt_for_each_property_offset - iterate over all properties of a node
 637:./include/linux/libfdt.h ****  *
 638:./include/linux/libfdt.h ****  * @property:	property offset (int, lvalue)
 639:./include/linux/libfdt.h ****  * @fdt:	FDT blob (const void *)
 640:./include/linux/libfdt.h ****  * @node:	node offset (int)
 641:./include/linux/libfdt.h ****  *
ARM GAS  /tmp/cc47XXUh.s 			page 15


 642:./include/linux/libfdt.h ****  * This is actually a wrapper around a for loop and would be used like so:
 643:./include/linux/libfdt.h ****  *
 644:./include/linux/libfdt.h ****  *	fdt_for_each_property_offset(property, fdt, node) {
 645:./include/linux/libfdt.h ****  *		Use property
 646:./include/linux/libfdt.h ****  *		...
 647:./include/linux/libfdt.h ****  *	}
 648:./include/linux/libfdt.h ****  *
 649:./include/linux/libfdt.h ****  *	if ((property < 0) && (property != -FDT_ERR_NOTFOUND)) {
 650:./include/linux/libfdt.h ****  *		Error handling
 651:./include/linux/libfdt.h ****  *	}
 652:./include/linux/libfdt.h ****  *
 653:./include/linux/libfdt.h ****  * Note that this is implemented as a macro and property is used as
 654:./include/linux/libfdt.h ****  * iterator in the loop. The node variable can be constant or even a
 655:./include/linux/libfdt.h ****  * literal.
 656:./include/linux/libfdt.h ****  */
 657:./include/linux/libfdt.h **** #define fdt_for_each_property_offset(property, fdt, node)	\
 658:./include/linux/libfdt.h **** 	for (property = fdt_first_property_offset(fdt, node);	\
 659:./include/linux/libfdt.h **** 	     property >= 0;					\
 660:./include/linux/libfdt.h **** 	     property = fdt_next_property_offset(fdt, property))
 661:./include/linux/libfdt.h **** 
 662:./include/linux/libfdt.h **** /**
 663:./include/linux/libfdt.h ****  * fdt_get_property_by_offset - retrieve the property at a given offset
 664:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 665:./include/linux/libfdt.h ****  * @offset: offset of the property to retrieve
 666:./include/linux/libfdt.h ****  * @lenp: pointer to an integer variable (will be overwritten) or NULL
 667:./include/linux/libfdt.h ****  *
 668:./include/linux/libfdt.h ****  * fdt_get_property_by_offset() retrieves a pointer to the
 669:./include/linux/libfdt.h ****  * fdt_property structure within the device tree blob at the given
 670:./include/linux/libfdt.h ****  * offset.  If lenp is non-NULL, the length of the property value is
 671:./include/linux/libfdt.h ****  * also returned, in the integer pointed to by lenp.
 672:./include/linux/libfdt.h ****  *
 673:./include/linux/libfdt.h ****  * Note that this code only works on device tree versions >= 16. fdt_getprop()
 674:./include/linux/libfdt.h ****  * works on all versions.
 675:./include/linux/libfdt.h ****  *
 676:./include/linux/libfdt.h ****  * returns:
 677:./include/linux/libfdt.h ****  *	pointer to the structure representing the property
 678:./include/linux/libfdt.h ****  *		if lenp is non-NULL, *lenp contains the length of the property
 679:./include/linux/libfdt.h ****  *		value (>=0)
 680:./include/linux/libfdt.h ****  *	NULL, on error
 681:./include/linux/libfdt.h ****  *		if lenp is non-NULL, *lenp contains an error code (<0):
 682:./include/linux/libfdt.h ****  *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
 683:./include/linux/libfdt.h ****  *		-FDT_ERR_BADMAGIC,
 684:./include/linux/libfdt.h ****  *		-FDT_ERR_BADVERSION,
 685:./include/linux/libfdt.h ****  *		-FDT_ERR_BADSTATE,
 686:./include/linux/libfdt.h ****  *		-FDT_ERR_BADSTRUCTURE,
 687:./include/linux/libfdt.h ****  *		-FDT_ERR_TRUNCATED, standard meanings
 688:./include/linux/libfdt.h ****  */
 689:./include/linux/libfdt.h **** const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
 690:./include/linux/libfdt.h **** 						      int offset,
 691:./include/linux/libfdt.h **** 						      int *lenp);
 692:./include/linux/libfdt.h **** static inline struct fdt_property *fdt_get_property_by_offset_w(void *fdt,
 693:./include/linux/libfdt.h **** 								int offset,
 694:./include/linux/libfdt.h **** 								int *lenp)
 695:./include/linux/libfdt.h **** {
 696:./include/linux/libfdt.h **** 	return (struct fdt_property *)(uintptr_t)
 697:./include/linux/libfdt.h **** 		fdt_get_property_by_offset(fdt, offset, lenp);
 698:./include/linux/libfdt.h **** }
ARM GAS  /tmp/cc47XXUh.s 			page 16


 699:./include/linux/libfdt.h **** 
 700:./include/linux/libfdt.h **** /**
 701:./include/linux/libfdt.h ****  * fdt_get_property_namelen - find a property based on substring
 702:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 703:./include/linux/libfdt.h ****  * @nodeoffset: offset of the node whose property to find
 704:./include/linux/libfdt.h ****  * @name: name of the property to find
 705:./include/linux/libfdt.h ****  * @namelen: number of characters of name to consider
 706:./include/linux/libfdt.h ****  * @lenp: pointer to an integer variable (will be overwritten) or NULL
 707:./include/linux/libfdt.h ****  *
 708:./include/linux/libfdt.h ****  * Identical to fdt_get_property(), but only examine the first namelen
 709:./include/linux/libfdt.h ****  * characters of name for matching the property name.
 710:./include/linux/libfdt.h ****  *
 711:./include/linux/libfdt.h ****  * Return: pointer to the structure representing the property, or NULL
 712:./include/linux/libfdt.h ****  *         if not found
 713:./include/linux/libfdt.h ****  */
 714:./include/linux/libfdt.h **** #ifndef SWIG /* Not available in Python */
 715:./include/linux/libfdt.h **** const struct fdt_property *fdt_get_property_namelen(const void *fdt,
 716:./include/linux/libfdt.h **** 						    int nodeoffset,
 717:./include/linux/libfdt.h **** 						    const char *name,
 718:./include/linux/libfdt.h **** 						    int namelen, int *lenp);
 719:./include/linux/libfdt.h **** static inline struct fdt_property *
 720:./include/linux/libfdt.h **** fdt_get_property_namelen_w(void *fdt, int nodeoffset, const char *name,
 721:./include/linux/libfdt.h **** 			   int namelen, int *lenp)
 722:./include/linux/libfdt.h **** {
 723:./include/linux/libfdt.h **** 	return (struct fdt_property *)(uintptr_t)fdt_get_property_namelen(
 724:./include/linux/libfdt.h **** 		fdt, nodeoffset, name, namelen, lenp);
 725:./include/linux/libfdt.h **** }
 726:./include/linux/libfdt.h **** #endif
 727:./include/linux/libfdt.h **** 
 728:./include/linux/libfdt.h **** /**
 729:./include/linux/libfdt.h ****  * fdt_get_property - find a given property in a given node
 730:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 731:./include/linux/libfdt.h ****  * @nodeoffset: offset of the node whose property to find
 732:./include/linux/libfdt.h ****  * @name: name of the property to find
 733:./include/linux/libfdt.h ****  * @lenp: pointer to an integer variable (will be overwritten) or NULL
 734:./include/linux/libfdt.h ****  *
 735:./include/linux/libfdt.h ****  * fdt_get_property() retrieves a pointer to the fdt_property
 736:./include/linux/libfdt.h ****  * structure within the device tree blob corresponding to the property
 737:./include/linux/libfdt.h ****  * named 'name' of the node at offset nodeoffset.  If lenp is
 738:./include/linux/libfdt.h ****  * non-NULL, the length of the property value is also returned, in the
 739:./include/linux/libfdt.h ****  * integer pointed to by lenp.
 740:./include/linux/libfdt.h ****  *
 741:./include/linux/libfdt.h ****  * returns:
 742:./include/linux/libfdt.h ****  *	pointer to the structure representing the property
 743:./include/linux/libfdt.h ****  *		if lenp is non-NULL, *lenp contains the length of the property
 744:./include/linux/libfdt.h ****  *		value (>=0)
 745:./include/linux/libfdt.h ****  *	NULL, on error
 746:./include/linux/libfdt.h ****  *		if lenp is non-NULL, *lenp contains an error code (<0):
 747:./include/linux/libfdt.h ****  *		-FDT_ERR_NOTFOUND, node does not have named property
 748:./include/linux/libfdt.h ****  *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
 749:./include/linux/libfdt.h ****  *			tag
 750:./include/linux/libfdt.h ****  *		-FDT_ERR_BADMAGIC,
 751:./include/linux/libfdt.h ****  *		-FDT_ERR_BADVERSION,
 752:./include/linux/libfdt.h ****  *		-FDT_ERR_BADSTATE,
 753:./include/linux/libfdt.h ****  *		-FDT_ERR_BADSTRUCTURE,
 754:./include/linux/libfdt.h ****  *		-FDT_ERR_TRUNCATED, standard meanings
 755:./include/linux/libfdt.h ****  */
ARM GAS  /tmp/cc47XXUh.s 			page 17


 756:./include/linux/libfdt.h **** const struct fdt_property *fdt_get_property(const void *fdt, int nodeoffset,
 757:./include/linux/libfdt.h **** 					    const char *name, int *lenp);
 758:./include/linux/libfdt.h **** static inline struct fdt_property *fdt_get_property_w(void *fdt, int nodeoffset,
 759:./include/linux/libfdt.h **** 						      const char *name,
 760:./include/linux/libfdt.h **** 						      int *lenp)
 761:./include/linux/libfdt.h **** {
 762:./include/linux/libfdt.h **** 	return (struct fdt_property *)(uintptr_t)
 763:./include/linux/libfdt.h **** 		fdt_get_property(fdt, nodeoffset, name, lenp);
 764:./include/linux/libfdt.h **** }
 765:./include/linux/libfdt.h **** 
 766:./include/linux/libfdt.h **** /**
 767:./include/linux/libfdt.h ****  * fdt_getprop_by_offset - retrieve the value of a property at a given offset
 768:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 769:./include/linux/libfdt.h ****  * @offset: offset of the property to read
 770:./include/linux/libfdt.h ****  * @namep: pointer to a string variable (will be overwritten) or NULL
 771:./include/linux/libfdt.h ****  * @lenp: pointer to an integer variable (will be overwritten) or NULL
 772:./include/linux/libfdt.h ****  *
 773:./include/linux/libfdt.h ****  * fdt_getprop_by_offset() retrieves a pointer to the value of the
 774:./include/linux/libfdt.h ****  * property at structure block offset 'offset' (this will be a pointer
 775:./include/linux/libfdt.h ****  * to within the device blob itself, not a copy of the value).  If
 776:./include/linux/libfdt.h ****  * lenp is non-NULL, the length of the property value is also
 777:./include/linux/libfdt.h ****  * returned, in the integer pointed to by lenp.  If namep is non-NULL,
 778:./include/linux/libfdt.h ****  * the property's name will also be returned in the char * pointed to
 779:./include/linux/libfdt.h ****  * by namep (this will be a pointer to within the device tree's string
 780:./include/linux/libfdt.h ****  * block, not a new copy of the name).
 781:./include/linux/libfdt.h ****  *
 782:./include/linux/libfdt.h ****  * returns:
 783:./include/linux/libfdt.h ****  *	pointer to the property's value
 784:./include/linux/libfdt.h ****  *		if lenp is non-NULL, *lenp contains the length of the property
 785:./include/linux/libfdt.h ****  *		value (>=0)
 786:./include/linux/libfdt.h ****  *		if namep is non-NULL *namep contains a pointer to the property
 787:./include/linux/libfdt.h ****  *		name.
 788:./include/linux/libfdt.h ****  *	NULL, on error
 789:./include/linux/libfdt.h ****  *		if lenp is non-NULL, *lenp contains an error code (<0):
 790:./include/linux/libfdt.h ****  *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
 791:./include/linux/libfdt.h ****  *		-FDT_ERR_BADMAGIC,
 792:./include/linux/libfdt.h ****  *		-FDT_ERR_BADVERSION,
 793:./include/linux/libfdt.h ****  *		-FDT_ERR_BADSTATE,
 794:./include/linux/libfdt.h ****  *		-FDT_ERR_BADSTRUCTURE,
 795:./include/linux/libfdt.h ****  *		-FDT_ERR_TRUNCATED, standard meanings
 796:./include/linux/libfdt.h ****  */
 797:./include/linux/libfdt.h **** #ifndef SWIG /* This function is not useful in Python */
 798:./include/linux/libfdt.h **** const void *fdt_getprop_by_offset(const void *fdt, int offset,
 799:./include/linux/libfdt.h **** 				  const char **namep, int *lenp);
 800:./include/linux/libfdt.h **** #endif
 801:./include/linux/libfdt.h **** 
 802:./include/linux/libfdt.h **** /**
 803:./include/linux/libfdt.h ****  * fdt_getprop_namelen - get property value based on substring
 804:./include/linux/libfdt.h ****  * @fdt: pointer to the device tree blob
 805:./include/linux/libfdt.h ****  * @nodeoffset: offset of the node whose property to find
 806:./include/linux/libfdt.h ****  * @name: name of the property to find
 807:./include/linux/libfdt.h ****  * @namelen: number of characters of name to consider
 808:./include/linux/libfdt.h ****  * @lenp: pointer to an integer variable (will be overwritten) or NULL
 809:./include/linux/libfdt.h ****  *
 810:./include/linux/libfdt.h ****  * Identical to fdt_getprop(), but only examine the first namelen
 811:./include/linux/libfdt.h ****  * characters of name for matching the property name.
 812:./include/linux/libfdt.h ****  *
ARM GAS  /tmp/cc47XXUh.s 			page 18


 813:./include/linux/libfdt.h ****  * Return: pointer to the property's value or NULL on error
 814:./include/linux/libfdt.h ****  */
 815:./include/linux/libfdt.h **** #ifndef SWIG /* Not available in Python */
 816:./include/linux/libfdt.h **** const void *fdt_getprop_namelen(const void *fdt, int nodeoffset,
 817:./include/linux/libfdt.h **** 				const char *name, int namelen, int *lenp);
 818:./include/linux/libfdt.h **** static inline void *fdt_getprop_namelen_w(void *fdt, int nodeoffset,
  94              		.loc 2 818 21 view .LVU17
  95              	.LBB11:
 819:./include/linux/libfdt.h **** 					  const char *name, int namelen,
 820:./include/linux/libfdt.h **** 					  int *lenp)
 821:./include/linux/libfdt.h **** {
 822:./include/linux/libfdt.h **** 	return (void *)(uintptr_t)fdt_getprop_namelen(fdt, nodeoffset, name,
  96              		.loc 2 822 2 view .LVU18
  97              		.loc 2 822 28 is_stmt 0 view .LVU19
  98 0008 03AE     		add	r6, sp, #12
  99              	.LVL5:
 100              		.loc 2 822 28 view .LVU20
 101 000a 0096     		str	r6, [sp]
 102 000c FFF7FEFF 		bl	fdt_getprop_namelen
 103              	.LVL6:
 104              		.loc 2 822 28 view .LVU21
 105              	.LBE11:
 106              	.LBE10:
  24:./lib/fdt/fdt_wip.c **** 		return proplen;
 107              		.loc 1 24 2 is_stmt 1 view .LVU22
  24:./lib/fdt/fdt_wip.c **** 		return proplen;
 108              		.loc 1 24 5 is_stmt 0 view .LVU23
 109 0010 58B1     		cbz	r0, .L9
  27:./lib/fdt/fdt_wip.c **** 		return -FDT_ERR_NOSPACE;
 110              		.loc 1 27 2 is_stmt 1 view .LVU24
  27:./lib/fdt/fdt_wip.c **** 		return -FDT_ERR_NOSPACE;
 111              		.loc 1 27 31 is_stmt 0 view .LVU25
 112 0012 2919     		adds	r1, r5, r4
  27:./lib/fdt/fdt_wip.c **** 		return -FDT_ERR_NOSPACE;
 113              		.loc 1 27 24 view .LVU26
 114 0014 039A     		ldr	r2, [sp, #12]
  27:./lib/fdt/fdt_wip.c **** 		return -FDT_ERR_NOSPACE;
 115              		.loc 1 27 5 view .LVU27
 116 0016 9142     		cmp	r1, r2
 117 0018 09D8     		bhi	.L7
  30:./lib/fdt/fdt_wip.c **** 	return 0;
 118              		.loc 1 30 2 is_stmt 1 view .LVU28
 119 001a 2A46     		mov	r2, r5
 120 001c 0999     		ldr	r1, [sp, #36]
 121 001e 2044     		add	r0, r0, r4
 122              	.LVL7:
  30:./lib/fdt/fdt_wip.c **** 	return 0;
 123              		.loc 1 30 2 is_stmt 0 view .LVU29
 124 0020 FFF7FEFF 		bl	memcpy
 125              	.LVL8:
  31:./lib/fdt/fdt_wip.c **** }
 126              		.loc 1 31 2 is_stmt 1 view .LVU30
  31:./lib/fdt/fdt_wip.c **** }
 127              		.loc 1 31 9 is_stmt 0 view .LVU31
 128 0024 0020     		movs	r0, #0
 129              	.L4:
  32:./lib/fdt/fdt_wip.c **** 
ARM GAS  /tmp/cc47XXUh.s 			page 19


 130              		.loc 1 32 1 view .LVU32
 131 0026 04B0     		add	sp, sp, #16
 132              	.LCFI2:
 133              		.cfi_remember_state
 134              		.cfi_def_cfa_offset 16
 135              		@ sp needed
 136 0028 70BD     		pop	{r4, r5, r6, pc}
 137              	.LVL9:
 138              	.L9:
 139              	.LCFI3:
 140              		.cfi_restore_state
  25:./lib/fdt/fdt_wip.c **** 
 141              		.loc 1 25 3 is_stmt 1 view .LVU33
  25:./lib/fdt/fdt_wip.c **** 
 142              		.loc 1 25 10 is_stmt 0 view .LVU34
 143 002a 0398     		ldr	r0, [sp, #12]
 144              	.LVL10:
  25:./lib/fdt/fdt_wip.c **** 
 145              		.loc 1 25 10 view .LVU35
 146 002c FBE7     		b	.L4
 147              	.LVL11:
 148              	.L7:
  28:./lib/fdt/fdt_wip.c **** 
 149              		.loc 1 28 10 view .LVU36
 150 002e 6FF00200 		mvn	r0, #2
 151              	.LVL12:
  28:./lib/fdt/fdt_wip.c **** 
 152              		.loc 1 28 10 view .LVU37
 153 0032 F8E7     		b	.L4
 154              		.cfi_endproc
 155              	.LFE75:
 157              		.section	.text.fdt_setprop_inplace,"ax",%progbits
 158              		.align	1
 159              		.global	fdt_setprop_inplace
 160              		.syntax unified
 161              		.thumb
 162              		.thumb_func
 164              	fdt_setprop_inplace:
 165              	.LVL13:
 166              	.LFB76:
  36:./lib/fdt/fdt_wip.c **** 	const void *propval;
 167              		.loc 1 36 1 is_stmt 1 view -0
 168              		.cfi_startproc
 169              		@ args = 4, pretend = 0, frame = 8
 170              		@ frame_needed = 0, uses_anonymous_args = 0
  36:./lib/fdt/fdt_wip.c **** 	const void *propval;
 171              		.loc 1 36 1 is_stmt 0 view .LVU39
 172 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 173              	.LCFI4:
 174              		.cfi_def_cfa_offset 24
 175              		.cfi_offset 4, -24
 176              		.cfi_offset 5, -20
 177              		.cfi_offset 6, -16
 178              		.cfi_offset 7, -12
 179              		.cfi_offset 8, -8
 180              		.cfi_offset 14, -4
 181 0004 86B0     		sub	sp, sp, #24
ARM GAS  /tmp/cc47XXUh.s 			page 20


 182              	.LCFI5:
 183              		.cfi_def_cfa_offset 48
 184 0006 0746     		mov	r7, r0
 185 0008 8846     		mov	r8, r1
 186 000a 1446     		mov	r4, r2
 187 000c 1D46     		mov	r5, r3
 188 000e 0C9E     		ldr	r6, [sp, #48]
  37:./lib/fdt/fdt_wip.c **** 	int proplen;
 189              		.loc 1 37 2 is_stmt 1 view .LVU40
  38:./lib/fdt/fdt_wip.c **** 
 190              		.loc 1 38 2 view .LVU41
  40:./lib/fdt/fdt_wip.c **** 	if (!propval)
 191              		.loc 1 40 2 view .LVU42
  40:./lib/fdt/fdt_wip.c **** 	if (!propval)
 192              		.loc 1 40 12 is_stmt 0 view .LVU43
 193 0010 05AB     		add	r3, sp, #20
 194              	.LVL14:
  40:./lib/fdt/fdt_wip.c **** 	if (!propval)
 195              		.loc 1 40 12 view .LVU44
 196 0012 FFF7FEFF 		bl	fdt_getprop
 197              	.LVL15:
  41:./lib/fdt/fdt_wip.c **** 		return proplen;
 198              		.loc 1 41 2 is_stmt 1 view .LVU45
  41:./lib/fdt/fdt_wip.c **** 		return proplen;
 199              		.loc 1 41 5 is_stmt 0 view .LVU46
 200 0016 90B1     		cbz	r0, .L15
  44:./lib/fdt/fdt_wip.c **** 		return -FDT_ERR_NOSPACE;
 201              		.loc 1 44 2 is_stmt 1 view .LVU47
  44:./lib/fdt/fdt_wip.c **** 		return -FDT_ERR_NOSPACE;
 202              		.loc 1 44 14 is_stmt 0 view .LVU48
 203 0018 059B     		ldr	r3, [sp, #20]
  44:./lib/fdt/fdt_wip.c **** 		return -FDT_ERR_NOSPACE;
 204              		.loc 1 44 5 view .LVU49
 205 001a B342     		cmp	r3, r6
 206 001c 11D1     		bne	.L13
  47:./lib/fdt/fdt_wip.c **** 						   strlen(name), 0,
 207              		.loc 1 47 2 is_stmt 1 view .LVU50
  48:./lib/fdt/fdt_wip.c **** 						   val, len);
 208              		.loc 1 48 10 is_stmt 0 view .LVU51
 209 001e 2046     		mov	r0, r4
 210              	.LVL16:
  48:./lib/fdt/fdt_wip.c **** 						   val, len);
 211              		.loc 1 48 10 view .LVU52
 212 0020 FFF7FEFF 		bl	strlen
 213              	.LVL17:
 214 0024 0346     		mov	r3, r0
  47:./lib/fdt/fdt_wip.c **** 						   strlen(name), 0,
 215              		.loc 1 47 9 view .LVU53
 216 0026 0296     		str	r6, [sp, #8]
 217 0028 0195     		str	r5, [sp, #4]
 218 002a 0022     		movs	r2, #0
 219 002c 0092     		str	r2, [sp]
 220 002e 2246     		mov	r2, r4
 221 0030 4146     		mov	r1, r8
 222 0032 3846     		mov	r0, r7
 223 0034 FFF7FEFF 		bl	fdt_setprop_inplace_namelen_partial
 224              	.LVL18:
ARM GAS  /tmp/cc47XXUh.s 			page 21


 225              	.L10:
  50:./lib/fdt/fdt_wip.c **** 
 226              		.loc 1 50 1 view .LVU54
 227 0038 06B0     		add	sp, sp, #24
 228              	.LCFI6:
 229              		.cfi_remember_state
 230              		.cfi_def_cfa_offset 24
 231              		@ sp needed
 232 003a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 233              	.LVL19:
 234              	.L15:
 235              	.LCFI7:
 236              		.cfi_restore_state
  42:./lib/fdt/fdt_wip.c **** 
 237              		.loc 1 42 3 is_stmt 1 view .LVU55
  42:./lib/fdt/fdt_wip.c **** 
 238              		.loc 1 42 10 is_stmt 0 view .LVU56
 239 003e 0598     		ldr	r0, [sp, #20]
 240              	.LVL20:
  42:./lib/fdt/fdt_wip.c **** 
 241              		.loc 1 42 10 view .LVU57
 242 0040 FAE7     		b	.L10
 243              	.LVL21:
 244              	.L13:
  45:./lib/fdt/fdt_wip.c **** 
 245              		.loc 1 45 10 view .LVU58
 246 0042 6FF00200 		mvn	r0, #2
 247              	.LVL22:
  45:./lib/fdt/fdt_wip.c **** 
 248              		.loc 1 45 10 view .LVU59
 249 0046 F7E7     		b	.L10
 250              		.cfi_endproc
 251              	.LFE76:
 253              		.section	.text.fdt_nop_property,"ax",%progbits
 254              		.align	1
 255              		.global	fdt_nop_property
 256              		.syntax unified
 257              		.thumb
 258              		.thumb_func
 260              	fdt_nop_property:
 261              	.LVL23:
 262              	.LFB78:
  59:./lib/fdt/fdt_wip.c **** 
  60:./lib/fdt/fdt_wip.c **** int fdt_nop_property(void *fdt, int nodeoffset, const char *name)
  61:./lib/fdt/fdt_wip.c **** {
 263              		.loc 1 61 1 is_stmt 1 view -0
 264              		.cfi_startproc
 265              		@ args = 0, pretend = 0, frame = 8
 266              		@ frame_needed = 0, uses_anonymous_args = 0
 267              		.loc 1 61 1 is_stmt 0 view .LVU61
 268 0000 00B5     		push	{lr}
 269              	.LCFI8:
 270              		.cfi_def_cfa_offset 4
 271              		.cfi_offset 14, -4
 272 0002 83B0     		sub	sp, sp, #12
 273              	.LCFI9:
 274              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/cc47XXUh.s 			page 22


  62:./lib/fdt/fdt_wip.c **** 	struct fdt_property *prop;
 275              		.loc 1 62 2 is_stmt 1 view .LVU62
  63:./lib/fdt/fdt_wip.c **** 	int len;
 276              		.loc 1 63 2 view .LVU63
  64:./lib/fdt/fdt_wip.c **** 
  65:./lib/fdt/fdt_wip.c **** 	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
 277              		.loc 1 65 2 view .LVU64
 278              	.LVL24:
 279              	.LBB12:
 280              	.LBI12:
 758:./include/linux/libfdt.h **** 						      const char *name,
 281              		.loc 2 758 36 view .LVU65
 282              	.LBB13:
 762:./include/linux/libfdt.h **** 		fdt_get_property(fdt, nodeoffset, name, lenp);
 283              		.loc 2 762 2 view .LVU66
 763:./include/linux/libfdt.h **** }
 284              		.loc 2 763 3 is_stmt 0 view .LVU67
 285 0004 01AB     		add	r3, sp, #4
 286              	.LVL25:
 763:./include/linux/libfdt.h **** }
 287              		.loc 2 763 3 view .LVU68
 288 0006 FFF7FEFF 		bl	fdt_get_property
 289              	.LVL26:
 763:./include/linux/libfdt.h **** }
 290              		.loc 2 763 3 view .LVU69
 291              	.LBE13:
 292              	.LBE12:
  66:./lib/fdt/fdt_wip.c **** 	if (!prop)
 293              		.loc 1 66 2 is_stmt 1 view .LVU70
 294              		.loc 1 66 5 is_stmt 0 view .LVU71
 295 000a 38B1     		cbz	r0, .L20
  67:./lib/fdt/fdt_wip.c **** 		return len;
  68:./lib/fdt/fdt_wip.c **** 
  69:./lib/fdt/fdt_wip.c **** 	fdt_nop_region_(prop, len + sizeof(*prop));
 296              		.loc 1 69 2 is_stmt 1 view .LVU72
 297 000c 0199     		ldr	r1, [sp, #4]
 298 000e 0C31     		adds	r1, r1, #12
 299 0010 FFF7FEFF 		bl	fdt_nop_region_
 300              	.LVL27:
  70:./lib/fdt/fdt_wip.c **** 
  71:./lib/fdt/fdt_wip.c **** 	return 0;
 301              		.loc 1 71 2 view .LVU73
 302              		.loc 1 71 9 is_stmt 0 view .LVU74
 303 0014 0020     		movs	r0, #0
 304              	.L16:
  72:./lib/fdt/fdt_wip.c **** }
 305              		.loc 1 72 1 view .LVU75
 306 0016 03B0     		add	sp, sp, #12
 307              	.LCFI10:
 308              		.cfi_remember_state
 309              		.cfi_def_cfa_offset 4
 310              		@ sp needed
 311 0018 5DF804FB 		ldr	pc, [sp], #4
 312              	.LVL28:
 313              	.L20:
 314              	.LCFI11:
 315              		.cfi_restore_state
ARM GAS  /tmp/cc47XXUh.s 			page 23


  67:./lib/fdt/fdt_wip.c **** 		return len;
 316              		.loc 1 67 3 is_stmt 1 view .LVU76
  67:./lib/fdt/fdt_wip.c **** 		return len;
 317              		.loc 1 67 10 is_stmt 0 view .LVU77
 318 001c 0198     		ldr	r0, [sp, #4]
 319              	.LVL29:
  67:./lib/fdt/fdt_wip.c **** 		return len;
 320              		.loc 1 67 10 view .LVU78
 321 001e FAE7     		b	.L16
 322              		.cfi_endproc
 323              	.LFE78:
 325              		.section	.text.fdt_node_end_offset_,"ax",%progbits
 326              		.align	1
 327              		.global	fdt_node_end_offset_
 328              		.syntax unified
 329              		.thumb
 330              		.thumb_func
 332              	fdt_node_end_offset_:
 333              	.LVL30:
 334              	.LFB79:
  73:./lib/fdt/fdt_wip.c **** 
  74:./lib/fdt/fdt_wip.c **** int fdt_node_end_offset_(void *fdt, int offset)
  75:./lib/fdt/fdt_wip.c **** {
 335              		.loc 1 75 1 is_stmt 1 view -0
 336              		.cfi_startproc
 337              		@ args = 0, pretend = 0, frame = 8
 338              		@ frame_needed = 0, uses_anonymous_args = 0
 339              		.loc 1 75 1 is_stmt 0 view .LVU80
 340 0000 10B5     		push	{r4, lr}
 341              	.LCFI12:
 342              		.cfi_def_cfa_offset 8
 343              		.cfi_offset 4, -8
 344              		.cfi_offset 14, -4
 345 0002 82B0     		sub	sp, sp, #8
 346              	.LCFI13:
 347              		.cfi_def_cfa_offset 16
 348 0004 0446     		mov	r4, r0
  76:./lib/fdt/fdt_wip.c **** 	int depth = 0;
 349              		.loc 1 76 2 is_stmt 1 view .LVU81
 350              		.loc 1 76 6 is_stmt 0 view .LVU82
 351 0006 0023     		movs	r3, #0
 352 0008 0193     		str	r3, [sp, #4]
  77:./lib/fdt/fdt_wip.c **** 
  78:./lib/fdt/fdt_wip.c **** 	while ((offset >= 0) && (depth >= 0))
 353              		.loc 1 78 2 is_stmt 1 view .LVU83
 354              		.loc 1 78 8 is_stmt 0 view .LVU84
 355 000a 04E0     		b	.L22
 356              	.LVL31:
 357              	.L24:
  79:./lib/fdt/fdt_wip.c **** 		offset = fdt_next_node(fdt, offset, &depth);
 358              		.loc 1 79 3 is_stmt 1 view .LVU85
 359              		.loc 1 79 12 is_stmt 0 view .LVU86
 360 000c 01AA     		add	r2, sp, #4
 361 000e 2046     		mov	r0, r4
 362 0010 FFF7FEFF 		bl	fdt_next_node
 363              	.LVL32:
 364              		.loc 1 79 12 view .LVU87
ARM GAS  /tmp/cc47XXUh.s 			page 24


 365 0014 0146     		mov	r1, r0
 366              	.LVL33:
 367              	.L22:
  78:./lib/fdt/fdt_wip.c **** 		offset = fdt_next_node(fdt, offset, &depth);
 368              		.loc 1 78 23 is_stmt 1 view .LVU88
 369 0016 0029     		cmp	r1, #0
 370 0018 02DB     		blt	.L23
  78:./lib/fdt/fdt_wip.c **** 		offset = fdt_next_node(fdt, offset, &depth);
 371              		.loc 1 78 33 is_stmt 0 discriminator 1 view .LVU89
 372 001a 019B     		ldr	r3, [sp, #4]
  78:./lib/fdt/fdt_wip.c **** 		offset = fdt_next_node(fdt, offset, &depth);
 373              		.loc 1 78 23 discriminator 1 view .LVU90
 374 001c 002B     		cmp	r3, #0
 375 001e F5DA     		bge	.L24
 376              	.L23:
  80:./lib/fdt/fdt_wip.c **** 
  81:./lib/fdt/fdt_wip.c **** 	return offset;
 377              		.loc 1 81 2 is_stmt 1 view .LVU91
  82:./lib/fdt/fdt_wip.c **** }
 378              		.loc 1 82 1 is_stmt 0 view .LVU92
 379 0020 0846     		mov	r0, r1
 380 0022 02B0     		add	sp, sp, #8
 381              	.LCFI14:
 382              		.cfi_def_cfa_offset 8
 383              		@ sp needed
 384 0024 10BD     		pop	{r4, pc}
 385              		.loc 1 82 1 view .LVU93
 386              		.cfi_endproc
 387              	.LFE79:
 389              		.section	.text.fdt_nop_node,"ax",%progbits
 390              		.align	1
 391              		.global	fdt_nop_node
 392              		.syntax unified
 393              		.thumb
 394              		.thumb_func
 396              	fdt_nop_node:
 397              	.LVL34:
 398              	.LFB80:
  83:./lib/fdt/fdt_wip.c **** 
  84:./lib/fdt/fdt_wip.c **** int fdt_nop_node(void *fdt, int nodeoffset)
  85:./lib/fdt/fdt_wip.c **** {
 399              		.loc 1 85 1 is_stmt 1 view -0
 400              		.cfi_startproc
 401              		@ args = 0, pretend = 0, frame = 0
 402              		@ frame_needed = 0, uses_anonymous_args = 0
 403              		.loc 1 85 1 is_stmt 0 view .LVU95
 404 0000 70B5     		push	{r4, r5, r6, lr}
 405              	.LCFI15:
 406              		.cfi_def_cfa_offset 16
 407              		.cfi_offset 4, -16
 408              		.cfi_offset 5, -12
 409              		.cfi_offset 6, -8
 410              		.cfi_offset 14, -4
 411 0002 0646     		mov	r6, r0
 412 0004 0D46     		mov	r5, r1
  86:./lib/fdt/fdt_wip.c **** 	int endoffset;
 413              		.loc 1 86 2 is_stmt 1 view .LVU96
ARM GAS  /tmp/cc47XXUh.s 			page 25


  87:./lib/fdt/fdt_wip.c **** 
  88:./lib/fdt/fdt_wip.c **** 	endoffset = fdt_node_end_offset_(fdt, nodeoffset);
 414              		.loc 1 88 2 view .LVU97
 415              		.loc 1 88 14 is_stmt 0 view .LVU98
 416 0006 FFF7FEFF 		bl	fdt_node_end_offset_
 417              	.LVL35:
  89:./lib/fdt/fdt_wip.c **** 	if (endoffset < 0)
 418              		.loc 1 89 2 is_stmt 1 view .LVU99
 419              		.loc 1 89 5 is_stmt 0 view .LVU100
 420 000a 041E     		subs	r4, r0, #0
 421 000c 08DB     		blt	.L26
  90:./lib/fdt/fdt_wip.c **** 		return endoffset;
  91:./lib/fdt/fdt_wip.c **** 
  92:./lib/fdt/fdt_wip.c **** 	fdt_nop_region_(fdt_offset_ptr_w(fdt, nodeoffset, 0),
 422              		.loc 1 92 2 is_stmt 1 view .LVU101
 423              	.LVL36:
 424              	.LBB14:
 425              	.LBI14:
 126:./include/linux/libfdt.h **** {
 426              		.loc 2 126 21 view .LVU102
 427              	.LBB15:
 128:./include/linux/libfdt.h **** }
 428              		.loc 2 128 2 view .LVU103
 128:./include/linux/libfdt.h **** }
 429              		.loc 2 128 28 is_stmt 0 view .LVU104
 430 000e 0022     		movs	r2, #0
 431 0010 2946     		mov	r1, r5
 432 0012 3046     		mov	r0, r6
 433              	.LVL37:
 128:./include/linux/libfdt.h **** }
 434              		.loc 2 128 28 view .LVU105
 435 0014 FFF7FEFF 		bl	fdt_offset_ptr
 436              	.LVL38:
 128:./include/linux/libfdt.h **** }
 437              		.loc 2 128 28 view .LVU106
 438              	.LBE15:
 439              	.LBE14:
 440              		.loc 1 92 2 discriminator 1 view .LVU107
 441 0018 611B     		subs	r1, r4, r5
 442 001a FFF7FEFF 		bl	fdt_nop_region_
 443              	.LVL39:
  93:./lib/fdt/fdt_wip.c **** 			endoffset - nodeoffset);
  94:./lib/fdt/fdt_wip.c **** 	return 0;
 444              		.loc 1 94 2 is_stmt 1 view .LVU108
 445              		.loc 1 94 9 is_stmt 0 view .LVU109
 446 001e 0024     		movs	r4, #0
 447              	.LVL40:
 448              	.L26:
  95:./lib/fdt/fdt_wip.c **** }
 449              		.loc 1 95 1 view .LVU110
 450 0020 2046     		mov	r0, r4
 451 0022 70BD     		pop	{r4, r5, r6, pc}
 452              		.loc 1 95 1 view .LVU111
 453              		.cfi_endproc
 454              	.LFE80:
 456              		.text
 457              	.Letext0:
ARM GAS  /tmp/cc47XXUh.s 			page 26


 458              		.file 3 "./include/asm-generic/int-l64.h"
 459              		.file 4 "./include/asm-generic/posix_types.h"
 460              		.file 5 "./include/linux/types.h"
 461              		.file 6 "./include/linux/libfdt_env.h"
 462              		.file 7 "./include/linux/fdt.h"
 463              		.file 8 "./arch/arm_m/include/asm/string.h"
 464              		.file 9 "<built-in>"
ARM GAS  /tmp/cc47XXUh.s 			page 27


DEFINED SYMBOLS
                            *ABS*:00000000 fdt_wip.c
     /tmp/cc47XXUh.s:21     .text.fdt_nop_region_:00000000 $t
     /tmp/cc47XXUh.s:26     .text.fdt_nop_region_:00000000 fdt_nop_region_
     /tmp/cc47XXUh.s:61     .text.fdt_setprop_inplace_namelen_partial:00000000 $t
     /tmp/cc47XXUh.s:67     .text.fdt_setprop_inplace_namelen_partial:00000000 fdt_setprop_inplace_namelen_partial
     /tmp/cc47XXUh.s:158    .text.fdt_setprop_inplace:00000000 $t
     /tmp/cc47XXUh.s:164    .text.fdt_setprop_inplace:00000000 fdt_setprop_inplace
     /tmp/cc47XXUh.s:254    .text.fdt_nop_property:00000000 $t
     /tmp/cc47XXUh.s:260    .text.fdt_nop_property:00000000 fdt_nop_property
     /tmp/cc47XXUh.s:326    .text.fdt_node_end_offset_:00000000 $t
     /tmp/cc47XXUh.s:332    .text.fdt_node_end_offset_:00000000 fdt_node_end_offset_
     /tmp/cc47XXUh.s:390    .text.fdt_nop_node:00000000 $t
     /tmp/cc47XXUh.s:396    .text.fdt_nop_node:00000000 fdt_nop_node

UNDEFINED SYMBOLS
fdt_getprop_namelen
memcpy
fdt_getprop
strlen
fdt_get_property
fdt_next_node
fdt_offset_ptr
