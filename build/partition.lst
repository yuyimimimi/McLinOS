ARM GAS  /tmp/ccz04fb7.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"partition.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./block/partition.c"
  20              		.section	.text.__page_create,"ax",%progbits
  21              		.align	1
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	__page_create:
  27              	.LVL0:
  28              	.LFB910:
  29              		.file 2 "./include/linux/mm_type.h"
   1:./include/linux/mm_type.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/mm_type.h **** #ifndef _LINUX_MM_TYPES_H
   3:./include/linux/mm_type.h **** #define _LINUX_MM_TYPES_H
   4:./include/linux/mm_type.h **** 
   5:./include/linux/mm_type.h **** #include <linux/list.h>
   6:./include/linux/mm_type.h **** #include <linux/spinlock.h>
   7:./include/linux/mm_type.h **** #include <linux/slab.h>
   8:./include/linux/mm_type.h **** #include <linux/atomic.h>
   9:./include/linux/mm_type.h **** #include <linux/errno.h>
  10:./include/linux/mm_type.h **** 
  11:./include/linux/mm_type.h **** 
  12:./include/linux/mm_type.h **** 
  13:./include/linux/mm_type.h **** struct page {
  14:./include/linux/mm_type.h **** 	unsigned long flags;		/* Atomic flags, some possibly
  15:./include/linux/mm_type.h **** 					 * updated asynchronously */
  16:./include/linux/mm_type.h **** 	/*
  17:./include/linux/mm_type.h **** 	 * Five words (20/40 bytes) are available in this union.
  18:./include/linux/mm_type.h **** 	 * WARNING: bit 0 of the first word is used for PageTail(). That
  19:./include/linux/mm_type.h **** 	 * means the other users of this union MUST NOT use the bit to
  20:./include/linux/mm_type.h **** 	 * avoid collision and false-positive PageTail().
  21:./include/linux/mm_type.h **** 	 */
  22:./include/linux/mm_type.h **** 	union {
  23:./include/linux/mm_type.h **** 		struct {	/* Page cache and anonymous pages */
  24:./include/linux/mm_type.h **** 			/**
  25:./include/linux/mm_type.h **** 			 * @lru: Pageout list, eg. active_list protected by
  26:./include/linux/mm_type.h **** 			 * lruvec->lru_lock.  Sometimes used as a generic list
  27:./include/linux/mm_type.h **** 			 * by the page owner.
  28:./include/linux/mm_type.h **** 			 */
  29:./include/linux/mm_type.h **** 			union {
ARM GAS  /tmp/ccz04fb7.s 			page 2


  30:./include/linux/mm_type.h **** 				struct list_head lru;
  31:./include/linux/mm_type.h **** 
  32:./include/linux/mm_type.h **** 				/* Or, for the Unevictable "LRU list" slot */
  33:./include/linux/mm_type.h **** 				struct {
  34:./include/linux/mm_type.h **** 					/* Always even, to negate PageTail */
  35:./include/linux/mm_type.h **** 					void *__filler;
  36:./include/linux/mm_type.h **** 					/* Count page's or folio's mlocks */
  37:./include/linux/mm_type.h **** 					unsigned int mlock_count;
  38:./include/linux/mm_type.h **** 				};
  39:./include/linux/mm_type.h **** 
  40:./include/linux/mm_type.h **** 				/* Or, free page */
  41:./include/linux/mm_type.h **** 				struct list_head buddy_list;
  42:./include/linux/mm_type.h **** 				struct list_head pcp_list;
  43:./include/linux/mm_type.h **** 			};
  44:./include/linux/mm_type.h **** 			/* See page-flags.h for PAGE_MAPPING_FLAGS */
  45:./include/linux/mm_type.h **** 			struct address_space *mapping;
  46:./include/linux/mm_type.h **** 			union {
  47:./include/linux/mm_type.h **** 				pgoff_t index;		/* Our offset within mapping. */
  48:./include/linux/mm_type.h **** 				unsigned long share;	/* share count for fsdax */
  49:./include/linux/mm_type.h **** 			};
  50:./include/linux/mm_type.h **** 			/**
  51:./include/linux/mm_type.h **** 			 * @private: Mapping-private opaque data.
  52:./include/linux/mm_type.h **** 			 * Usually used for buffer_heads if PagePrivate.
  53:./include/linux/mm_type.h **** 			 * Used for swp_entry_t if swapcache flag set.
  54:./include/linux/mm_type.h **** 			 * Indicates order in the buddy system if PageBuddy.
  55:./include/linux/mm_type.h **** 			 */
  56:./include/linux/mm_type.h **** 			unsigned long private;
  57:./include/linux/mm_type.h **** 		};
  58:./include/linux/mm_type.h **** 		struct {	/* page_pool used by netstack */
  59:./include/linux/mm_type.h **** 			/**
  60:./include/linux/mm_type.h **** 			 * @pp_magic: magic value to avoid recycling non
  61:./include/linux/mm_type.h **** 			 * page_pool allocated pages.
  62:./include/linux/mm_type.h **** 			 */
  63:./include/linux/mm_type.h **** 			unsigned long pp_magic;
  64:./include/linux/mm_type.h **** 		//	struct page_pool *pp; 
  65:./include/linux/mm_type.h **** 			unsigned long _pp_mapping_pad;
  66:./include/linux/mm_type.h **** 			unsigned long dma_addr;
  67:./include/linux/mm_type.h **** 		//	atomic_long_t pp_ref_count;
  68:./include/linux/mm_type.h **** 		};
  69:./include/linux/mm_type.h **** 		struct {	/* Tail pages of compound page */
  70:./include/linux/mm_type.h **** 			unsigned long compound_head;	/* Bit zero is set */
  71:./include/linux/mm_type.h **** 		};
  72:./include/linux/mm_type.h **** 		struct {	/* ZONE_DEVICE pages */
  73:./include/linux/mm_type.h **** 			/** @pgmap: Points to the hosting device page map. */
  74:./include/linux/mm_type.h **** 			// struct dev_pagemap *pgmap;
  75:./include/linux/mm_type.h **** 			void *zone_device_data;
  76:./include/linux/mm_type.h **** 			/*
  77:./include/linux/mm_type.h **** 			 * ZONE_DEVICE private pages are counted as being
  78:./include/linux/mm_type.h **** 			 * mapped so the next 3 words hold the mapping, index,
  79:./include/linux/mm_type.h **** 			 * and private fields from the source anonymous or
  80:./include/linux/mm_type.h **** 			 * page cache page while the page is migrated to device
  81:./include/linux/mm_type.h **** 			 * private memory.
  82:./include/linux/mm_type.h **** 			 * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also
  83:./include/linux/mm_type.h **** 			 * use the mapping, index, and private fields when
  84:./include/linux/mm_type.h **** 			 * pmem backed DAX files are mapped.
  85:./include/linux/mm_type.h **** 			 */
  86:./include/linux/mm_type.h **** 		};
ARM GAS  /tmp/ccz04fb7.s 			page 3


  87:./include/linux/mm_type.h **** 
  88:./include/linux/mm_type.h **** 		/** @rcu_head: You can use this to free a page by RCU. */
  89:./include/linux/mm_type.h **** 		struct rcu_head rcu_head;
  90:./include/linux/mm_type.h **** 	};
  91:./include/linux/mm_type.h **** 
  92:./include/linux/mm_type.h **** 	union {		/* This union is 4 bytes in size. */
  93:./include/linux/mm_type.h **** 		/*
  94:./include/linux/mm_type.h **** 		 * For head pages of typed folios, the value stored here
  95:./include/linux/mm_type.h **** 		 * allows for determining what this page is used for. The
  96:./include/linux/mm_type.h **** 		 * tail pages of typed folios will not store a type
  97:./include/linux/mm_type.h **** 		 * (page_type == _mapcount == -1).
  98:./include/linux/mm_type.h **** 		 *
  99:./include/linux/mm_type.h **** 		 * See page-flags.h for a list of page types which are currently
 100:./include/linux/mm_type.h **** 		 * stored here.
 101:./include/linux/mm_type.h **** 		 *
 102:./include/linux/mm_type.h **** 		 * Owners of typed folios may reuse the lower 16 bit of the
 103:./include/linux/mm_type.h **** 		 * head page page_type field after setting the page type,
 104:./include/linux/mm_type.h **** 		 * but must reset these 16 bit to -1 before clearing the
 105:./include/linux/mm_type.h **** 		 * page type.
 106:./include/linux/mm_type.h **** 		 */
 107:./include/linux/mm_type.h **** 		unsigned int page_type;
 108:./include/linux/mm_type.h **** 
 109:./include/linux/mm_type.h **** 		/*
 110:./include/linux/mm_type.h **** 		 * For pages that are part of non-typed folios for which mappings
 111:./include/linux/mm_type.h **** 		 * are tracked via the RMAP, encodes the number of times this page
 112:./include/linux/mm_type.h **** 		 * is directly referenced by a page table.
 113:./include/linux/mm_type.h **** 		 *
 114:./include/linux/mm_type.h **** 		 * Note that the mapcount is always initialized to -1, so that
 115:./include/linux/mm_type.h **** 		 * transitions both from it and to it can be tracked, using
 116:./include/linux/mm_type.h **** 		 * atomic_inc_and_test() and atomic_add_negative(-1).
 117:./include/linux/mm_type.h **** 		 */
 118:./include/linux/mm_type.h **** 		atomic_t _mapcount;
 119:./include/linux/mm_type.h **** 	};
 120:./include/linux/mm_type.h **** 
 121:./include/linux/mm_type.h **** 	/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */
 122:./include/linux/mm_type.h **** 	atomic_t _refcount;
 123:./include/linux/mm_type.h **** 
 124:./include/linux/mm_type.h **** #ifdef CONFIG_MEMCG
 125:./include/linux/mm_type.h **** 	unsigned long memcg_data;
 126:./include/linux/mm_type.h **** #elif defined(CONFIG_SLAB_OBJ_EXT)
 127:./include/linux/mm_type.h **** 	unsigned long _unused_slab_obj_exts;
 128:./include/linux/mm_type.h **** #endif
 129:./include/linux/mm_type.h **** 
 130:./include/linux/mm_type.h **** 	/*
 131:./include/linux/mm_type.h **** 	 * On machines where all RAM is mapped into kernel address space,
 132:./include/linux/mm_type.h **** 	 * we can simply calculate the virtual address. On machines with
 133:./include/linux/mm_type.h **** 	 * highmem some memory is mapped into kernel virtual memory
 134:./include/linux/mm_type.h **** 	 * dynamically, so we need a place to store that address.
 135:./include/linux/mm_type.h **** 	 * Note that this field could be 16 bits on x86 ... ;)
 136:./include/linux/mm_type.h **** 	 *
 137:./include/linux/mm_type.h **** 	 * Architectures with slow multiplication can define
 138:./include/linux/mm_type.h **** 	 * WANT_PAGE_VIRTUAL in asm/page.h
 139:./include/linux/mm_type.h **** 	 */
 140:./include/linux/mm_type.h **** #if defined(WANT_PAGE_VIRTUAL)
 141:./include/linux/mm_type.h **** 	void *virtual;			/* Kernel virtual address (NULL if
 142:./include/linux/mm_type.h **** 					   not kmapped, ie. highmem) */
 143:./include/linux/mm_type.h **** #endif /* WANT_PAGE_VIRTUAL */
ARM GAS  /tmp/ccz04fb7.s 			page 4


 144:./include/linux/mm_type.h **** 
 145:./include/linux/mm_type.h **** #ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS
 146:./include/linux/mm_type.h **** 	int _last_cpupid;
 147:./include/linux/mm_type.h **** #endif
 148:./include/linux/mm_type.h **** 
 149:./include/linux/mm_type.h **** #ifdef CONFIG_KMSAN
 150:./include/linux/mm_type.h **** 	/*
 151:./include/linux/mm_type.h **** 	 * KMSAN metadata for this page:
 152:./include/linux/mm_type.h **** 	 *  - shadow page: every bit indicates whether the corresponding
 153:./include/linux/mm_type.h **** 	 *    bit of the original page is initialized (0) or not (1);
 154:./include/linux/mm_type.h **** 	 *  - origin page: every 4 bytes contain an id of the stack trace
 155:./include/linux/mm_type.h **** 	 *    where the uninitialized value was created.
 156:./include/linux/mm_type.h **** 	 */
 157:./include/linux/mm_type.h **** 	struct page *kmsan_shadow;
 158:./include/linux/mm_type.h **** 	struct page *kmsan_origin;
 159:./include/linux/mm_type.h **** #endif
 160:./include/linux/mm_type.h **** };
 161:./include/linux/mm_type.h **** 
 162:./include/linux/mm_type.h **** #if CONFIG_MMU 
 163:./include/linux/mm_type.h ****   #include <mm_page.h>
 164:./include/linux/mm_type.h **** 
 165:./include/linux/mm_type.h **** #else
 166:./include/linux/mm_type.h **** 
 167:./include/linux/mm_type.h **** 
 168:./include/linux/mm_type.h **** 
 169:./include/linux/mm_type.h **** 
 170:./include/linux/mm_type.h **** #define PG_locked       (1 << 0)
 171:./include/linux/mm_type.h **** #define PG_referenced   (1 << 1)
 172:./include/linux/mm_type.h **** #define PG_uptodate     (1 << 2)
 173:./include/linux/mm_type.h **** #define PG_dirty        (1 << 11)
 174:./include/linux/mm_type.h **** #define PG_active       (1 << 12)
 175:./include/linux/mm_type.h **** 
 176:./include/linux/mm_type.h **** static inline void __set_page_flag(struct page *page, unsigned long flag){
 177:./include/linux/mm_type.h ****     if (page)
 178:./include/linux/mm_type.h ****         page->flags |= flag;
 179:./include/linux/mm_type.h **** }
 180:./include/linux/mm_type.h **** static inline void __clear_page_flag(struct page *page, unsigned long flag){
 181:./include/linux/mm_type.h ****     if (page)
 182:./include/linux/mm_type.h ****         page->flags &= ~flag;
 183:./include/linux/mm_type.h **** }
 184:./include/linux/mm_type.h **** 
 185:./include/linux/mm_type.h **** static inline int __test_page_flag(struct page *page, unsigned long flag){
 186:./include/linux/mm_type.h ****     return (page && (page->flags & flag)) ? 1 : 0;
 187:./include/linux/mm_type.h **** }
 188:./include/linux/mm_type.h **** 
 189:./include/linux/mm_type.h **** static inline struct page *__page_create(gfp_t flags ){
  30              		.loc 2 189 55 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		.loc 2 189 55 is_stmt 0 view .LVU1
  35 0000 08B5     		push	{r3, lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 8
  38              		.cfi_offset 3, -8
  39              		.cfi_offset 14, -4
  40 0002 0146     		mov	r1, r0
ARM GAS  /tmp/ccz04fb7.s 			page 5


 190:./include/linux/mm_type.h ****     struct page *page = (struct page *)kmalloc(sizeof(struct page), flags);
  41              		.loc 2 190 5 is_stmt 1 view .LVU2
  42              	.LVL1:
  43              	.LBB67:
  44              	.LBI67:
  45              		.file 3 "./include/linux/slab.h"
   1:./include/linux/slab.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/slab.h **** /*
   3:./include/linux/slab.h ****  * Written by Mark Hemment, 1996 (markhe@nextd.demon.co.uk).
   4:./include/linux/slab.h ****  *
   5:./include/linux/slab.h ****  * (C) SGI 2006, Christoph Lameter
   6:./include/linux/slab.h ****  * 	Cleaned up and restructured to ease the addition of alternative
   7:./include/linux/slab.h ****  * 	implementations of SLAB allocators.
   8:./include/linux/slab.h ****  * (C) Linux Foundation 2008-2013
   9:./include/linux/slab.h ****  *      Unified interface for all slab allocators
  10:./include/linux/slab.h ****  */
  11:./include/linux/slab.h **** 
  12:./include/linux/slab.h **** #ifndef _LINUX_SLAB_H
  13:./include/linux/slab.h **** #define	_LINUX_SLAB_H
  14:./include/linux/slab.h **** 
  15:./include/linux/slab.h **** #include <linux/cache.h>
  16:./include/linux/slab.h **** #include <linux/overflow.h>
  17:./include/linux/slab.h **** #include <linux/types.h>
  18:./include/linux/slab.h **** #include <linux/raid/pq.h>
  19:./include/linux/slab.h **** #include <linux/gfp_types.h>
  20:./include/linux/slab.h **** #include <linux/numa.h>
  21:./include/linux/slab.h **** #include <linux/reciprocal_div.h>
  22:./include/linux/slab.h **** #include <linux/spinlock.h>
  23:./include/linux/slab.h **** 
  24:./include/linux/slab.h **** enum _slab_flag_bits {
  25:./include/linux/slab.h **** 	_SLAB_CONSISTENCY_CHECKS,
  26:./include/linux/slab.h **** 	_SLAB_RED_ZONE,
  27:./include/linux/slab.h **** 	_SLAB_POISON,
  28:./include/linux/slab.h **** 	_SLAB_KMALLOC,
  29:./include/linux/slab.h **** 	_SLAB_HWCACHE_ALIGN,
  30:./include/linux/slab.h **** 	_SLAB_CACHE_DMA,
  31:./include/linux/slab.h **** 	_SLAB_CACHE_DMA32,
  32:./include/linux/slab.h **** 	_SLAB_STORE_USER,
  33:./include/linux/slab.h **** 	_SLAB_PANIC,
  34:./include/linux/slab.h **** 	_SLAB_TYPESAFE_BY_RCU,
  35:./include/linux/slab.h **** 	_SLAB_TRACE,
  36:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
  37:./include/linux/slab.h **** 	_SLAB_DEBUG_OBJECTS,
  38:./include/linux/slab.h **** #endif
  39:./include/linux/slab.h **** 	_SLAB_NOLEAKTRACE,
  40:./include/linux/slab.h **** 	_SLAB_NO_MERGE,
  41:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
  42:./include/linux/slab.h **** 	_SLAB_FAILSLAB,
  43:./include/linux/slab.h **** #endif
  44:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
  45:./include/linux/slab.h **** 	_SLAB_ACCOUNT,
  46:./include/linux/slab.h **** #endif
  47:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
  48:./include/linux/slab.h **** 	_SLAB_KASAN,
  49:./include/linux/slab.h **** #endif
  50:./include/linux/slab.h **** 	_SLAB_NO_USER_FLAGS,
  51:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
ARM GAS  /tmp/ccz04fb7.s 			page 6


  52:./include/linux/slab.h **** 	_SLAB_SKIP_KFENCE,
  53:./include/linux/slab.h **** #endif
  54:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
  55:./include/linux/slab.h **** 	_SLAB_RECLAIM_ACCOUNT,
  56:./include/linux/slab.h **** #endif
  57:./include/linux/slab.h **** 	_SLAB_OBJECT_POISON,
  58:./include/linux/slab.h **** 	_SLAB_CMPXCHG_DOUBLE,
  59:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
  60:./include/linux/slab.h **** 	_SLAB_NO_OBJ_EXT,
  61:./include/linux/slab.h **** #endif
  62:./include/linux/slab.h **** 	_SLAB_FLAGS_LAST_BIT
  63:./include/linux/slab.h **** };
  64:./include/linux/slab.h **** 
  65:./include/linux/slab.h **** 
  66:./include/linux/slab.h **** 
  67:./include/linux/slab.h **** #define __SLAB_FLAG_BIT(nr)	((slab_flags_t __force)(1U << (nr)))
  68:./include/linux/slab.h **** #define __SLAB_FLAG_UNUSED	((slab_flags_t __force)(0U))
  69:./include/linux/slab.h **** 
  70:./include/linux/slab.h **** /*
  71:./include/linux/slab.h ****  * Flags to pass to kmem_cache_create().
  72:./include/linux/slab.h ****  * The ones marked DEBUG need CONFIG_SLUB_DEBUG enabled, otherwise are no-op
  73:./include/linux/slab.h ****  */
  74:./include/linux/slab.h **** /* DEBUG: Perform (expensive) checks on alloc/free */
  75:./include/linux/slab.h **** #define SLAB_CONSISTENCY_CHECKS	__SLAB_FLAG_BIT(_SLAB_CONSISTENCY_CHECKS)
  76:./include/linux/slab.h **** /* DEBUG: Red zone objs in a cache */
  77:./include/linux/slab.h **** #define SLAB_RED_ZONE		__SLAB_FLAG_BIT(_SLAB_RED_ZONE)
  78:./include/linux/slab.h **** /* DEBUG: Poison objects */
  79:./include/linux/slab.h **** #define SLAB_POISON		__SLAB_FLAG_BIT(_SLAB_POISON)
  80:./include/linux/slab.h **** /* Indicate a kmalloc slab */
  81:./include/linux/slab.h **** #define SLAB_KMALLOC		__SLAB_FLAG_BIT(_SLAB_KMALLOC)
  82:./include/linux/slab.h **** /**
  83:./include/linux/slab.h ****  * define SLAB_HWCACHE_ALIGN - Align objects on cache line boundaries.
  84:./include/linux/slab.h ****  *
  85:./include/linux/slab.h ****  * Sufficiently large objects are aligned on cache line boundary. For object
  86:./include/linux/slab.h ****  * size smaller than a half of cache line size, the alignment is on the half of
  87:./include/linux/slab.h ****  * cache line size. In general, if object size is smaller than 1/2^n of cache
  88:./include/linux/slab.h ****  * line size, the alignment is adjusted to 1/2^n.
  89:./include/linux/slab.h ****  *
  90:./include/linux/slab.h ****  * If explicit alignment is also requested by the respective
  91:./include/linux/slab.h ****  * &struct kmem_cache_args field, the greater of both is alignments is applied.
  92:./include/linux/slab.h ****  */
  93:./include/linux/slab.h **** #define SLAB_HWCACHE_ALIGN	__SLAB_FLAG_BIT(_SLAB_HWCACHE_ALIGN)
  94:./include/linux/slab.h **** /* Use GFP_DMA memory */
  95:./include/linux/slab.h **** #define SLAB_CACHE_DMA		__SLAB_FLAG_BIT(_SLAB_CACHE_DMA)
  96:./include/linux/slab.h **** /* Use GFP_DMA32 memory */
  97:./include/linux/slab.h **** #define SLAB_CACHE_DMA32	__SLAB_FLAG_BIT(_SLAB_CACHE_DMA32)
  98:./include/linux/slab.h **** /* DEBUG: Store the last owner for bug hunting */
  99:./include/linux/slab.h **** #define SLAB_STORE_USER		__SLAB_FLAG_BIT(_SLAB_STORE_USER)
 100:./include/linux/slab.h **** /* Panic if kmem_cache_create() fails */
 101:./include/linux/slab.h **** #define SLAB_PANIC		__SLAB_FLAG_BIT(_SLAB_PANIC)
 102:./include/linux/slab.h **** /**
 103:./include/linux/slab.h ****  * define SLAB_TYPESAFE_BY_RCU - **WARNING** READ THIS!
 104:./include/linux/slab.h ****  *
 105:./include/linux/slab.h ****  * This delays freeing the SLAB page by a grace period, it does _NOT_
 106:./include/linux/slab.h ****  * delay object freeing. This means that if you do kmem_cache_free()
 107:./include/linux/slab.h ****  * that memory location is free to be reused at any time. Thus it may
 108:./include/linux/slab.h ****  * be possible to see another object there in the same RCU grace period.
ARM GAS  /tmp/ccz04fb7.s 			page 7


 109:./include/linux/slab.h ****  *
 110:./include/linux/slab.h ****  * This feature only ensures the memory location backing the object
 111:./include/linux/slab.h ****  * stays valid, the trick to using this is relying on an independent
 112:./include/linux/slab.h ****  * object validation pass. Something like:
 113:./include/linux/slab.h ****  *
 114:./include/linux/slab.h ****  * ::
 115:./include/linux/slab.h ****  *
 116:./include/linux/slab.h ****  *  begin:
 117:./include/linux/slab.h ****  *   rcu_read_lock();
 118:./include/linux/slab.h ****  *   obj = lockless_lookup(key);
 119:./include/linux/slab.h ****  *   if (obj) {
 120:./include/linux/slab.h ****  *     if (!try_get_ref(obj)) // might fail for free objects
 121:./include/linux/slab.h ****  *       rcu_read_unlock();
 122:./include/linux/slab.h ****  *       goto begin;
 123:./include/linux/slab.h ****  *
 124:./include/linux/slab.h ****  *     if (obj->key != key) { // not the object we expected
 125:./include/linux/slab.h ****  *       put_ref(obj);
 126:./include/linux/slab.h ****  *       rcu_read_unlock();
 127:./include/linux/slab.h ****  *       goto begin;
 128:./include/linux/slab.h ****  *     }
 129:./include/linux/slab.h ****  *   }
 130:./include/linux/slab.h ****  *  rcu_read_unlock();
 131:./include/linux/slab.h ****  *
 132:./include/linux/slab.h ****  * This is useful if we need to approach a kernel structure obliquely,
 133:./include/linux/slab.h ****  * from its address obtained without the usual locking. We can lock
 134:./include/linux/slab.h ****  * the structure to stabilize it and check it's still at the given address,
 135:./include/linux/slab.h ****  * only if we can be sure that the memory has not been meanwhile reused
 136:./include/linux/slab.h ****  * for some other kind of object (which our subsystem's lock might corrupt).
 137:./include/linux/slab.h ****  *
 138:./include/linux/slab.h ****  * rcu_read_lock before reading the address, then rcu_read_unlock after
 139:./include/linux/slab.h ****  * taking the spinlock within the structure expected at that address.
 140:./include/linux/slab.h ****  *
 141:./include/linux/slab.h ****  * Note that it is not possible to acquire a lock within a structure
 142:./include/linux/slab.h ****  * allocated with SLAB_TYPESAFE_BY_RCU without first acquiring a reference
 143:./include/linux/slab.h ****  * as described above.  The reason is that SLAB_TYPESAFE_BY_RCU pages
 144:./include/linux/slab.h ****  * are not zeroed before being given to the slab, which means that any
 145:./include/linux/slab.h ****  * locks must be initialized after each and every kmem_struct_alloc().
 146:./include/linux/slab.h ****  * Alternatively, make the ctor passed to kmem_cache_create() initialize
 147:./include/linux/slab.h ****  * the locks at page-allocation time, as is done in __i915_request_ctor(),
 148:./include/linux/slab.h ****  * sighand_ctor(), and anon_vma_ctor().  Such a ctor permits readers
 149:./include/linux/slab.h ****  * to safely acquire those ctor-initialized locks under rcu_read_lock()
 150:./include/linux/slab.h ****  * protection.
 151:./include/linux/slab.h ****  *
 152:./include/linux/slab.h ****  * Note that SLAB_TYPESAFE_BY_RCU was originally named SLAB_DESTROY_BY_RCU.
 153:./include/linux/slab.h ****  */
 154:./include/linux/slab.h **** #define SLAB_TYPESAFE_BY_RCU	__SLAB_FLAG_BIT(_SLAB_TYPESAFE_BY_RCU)
 155:./include/linux/slab.h **** /* Trace allocations and frees */
 156:./include/linux/slab.h **** #define SLAB_TRACE		__SLAB_FLAG_BIT(_SLAB_TRACE)
 157:./include/linux/slab.h **** 
 158:./include/linux/slab.h **** /* Flag to prevent checks on free */
 159:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
 160:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_BIT(_SLAB_DEBUG_OBJECTS)
 161:./include/linux/slab.h **** #else
 162:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_UNUSED
 163:./include/linux/slab.h **** #endif
 164:./include/linux/slab.h **** 
 165:./include/linux/slab.h **** /* Avoid kmemleak tracing */
ARM GAS  /tmp/ccz04fb7.s 			page 8


 166:./include/linux/slab.h **** #define SLAB_NOLEAKTRACE	__SLAB_FLAG_BIT(_SLAB_NOLEAKTRACE)
 167:./include/linux/slab.h **** 
 168:./include/linux/slab.h **** /*
 169:./include/linux/slab.h ****  * Prevent merging with compatible kmem caches. This flag should be used
 170:./include/linux/slab.h ****  * cautiously. Valid use cases:
 171:./include/linux/slab.h ****  *
 172:./include/linux/slab.h ****  * - caches created for self-tests (e.g. kunit)
 173:./include/linux/slab.h ****  * - general caches created and used by a subsystem, only when a
 174:./include/linux/slab.h ****  *   (subsystem-specific) debug option is enabled
 175:./include/linux/slab.h ****  * - performance critical caches, should be very rare and consulted with slab
 176:./include/linux/slab.h ****  *   maintainers, and not used together with CONFIG_SLUB_TINY
 177:./include/linux/slab.h ****  */
 178:./include/linux/slab.h **** #define SLAB_NO_MERGE		__SLAB_FLAG_BIT(_SLAB_NO_MERGE)
 179:./include/linux/slab.h **** 
 180:./include/linux/slab.h **** /* Fault injection mark */
 181:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
 182:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_BIT(_SLAB_FAILSLAB)
 183:./include/linux/slab.h **** #else
 184:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_UNUSED
 185:./include/linux/slab.h **** #endif
 186:./include/linux/slab.h **** /**
 187:./include/linux/slab.h ****  * define SLAB_ACCOUNT - Account allocations to memcg.
 188:./include/linux/slab.h ****  *
 189:./include/linux/slab.h ****  * All object allocations from this cache will be memcg accounted, regardless of
 190:./include/linux/slab.h ****  * __GFP_ACCOUNT being or not being passed to individual allocations.
 191:./include/linux/slab.h ****  */
 192:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
 193:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_BIT(_SLAB_ACCOUNT)
 194:./include/linux/slab.h **** #else
 195:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_UNUSED
 196:./include/linux/slab.h **** #endif
 197:./include/linux/slab.h **** 
 198:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
 199:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_BIT(_SLAB_KASAN)
 200:./include/linux/slab.h **** #else
 201:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_UNUSED
 202:./include/linux/slab.h **** #endif
 203:./include/linux/slab.h **** 
 204:./include/linux/slab.h **** /*
 205:./include/linux/slab.h ****  * Ignore user specified debugging flags.
 206:./include/linux/slab.h ****  * Intended for caches created for self-tests so they have only flags
 207:./include/linux/slab.h ****  * specified in the code and other flags are ignored.
 208:./include/linux/slab.h ****  */
 209:./include/linux/slab.h **** #define SLAB_NO_USER_FLAGS	__SLAB_FLAG_BIT(_SLAB_NO_USER_FLAGS)
 210:./include/linux/slab.h **** 
 211:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
 212:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_BIT(_SLAB_SKIP_KFENCE)
 213:./include/linux/slab.h **** #else
 214:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_UNUSED
 215:./include/linux/slab.h **** #endif
 216:./include/linux/slab.h **** 
 217:./include/linux/slab.h **** /* The following flags affect the page allocator grouping pages by mobility */
 218:./include/linux/slab.h **** /**
 219:./include/linux/slab.h ****  * define SLAB_RECLAIM_ACCOUNT - Objects are reclaimable.
 220:./include/linux/slab.h ****  *
 221:./include/linux/slab.h ****  * Use this flag for caches that have an associated shrinker. As a result, slab
 222:./include/linux/slab.h ****  * pages are allocated with __GFP_RECLAIMABLE, which affects grouping pages by
ARM GAS  /tmp/ccz04fb7.s 			page 9


 223:./include/linux/slab.h ****  * mobility, and are accounted in SReclaimable counter in /proc/meminfo
 224:./include/linux/slab.h ****  */
 225:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
 226:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_BIT(_SLAB_RECLAIM_ACCOUNT)
 227:./include/linux/slab.h **** #else
 228:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_UNUSED
 229:./include/linux/slab.h **** #endif
 230:./include/linux/slab.h **** #define SLAB_TEMPORARY		SLAB_RECLAIM_ACCOUNT	/* Objects are short-lived */
 231:./include/linux/slab.h **** 
 232:./include/linux/slab.h **** /* Slab created using create_boot_cache */
 233:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
 234:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_BIT(_SLAB_NO_OBJ_EXT)
 235:./include/linux/slab.h **** #else
 236:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_UNUSED
 237:./include/linux/slab.h **** #endif
 238:./include/linux/slab.h **** 
 239:./include/linux/slab.h **** /*
 240:./include/linux/slab.h ****  * freeptr_t represents a SLUB freelist pointer, which might be encoded
 241:./include/linux/slab.h ****  * and not dereferenceable if CONFIG_SLAB_FREELIST_HARDENED is enabled.
 242:./include/linux/slab.h ****  */
 243:./include/linux/slab.h **** typedef struct { unsigned long v; } freeptr_t;
 244:./include/linux/slab.h **** 
 245:./include/linux/slab.h **** /*
 246:./include/linux/slab.h ****  * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.
 247:./include/linux/slab.h ****  *
 248:./include/linux/slab.h ****  * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault.
 249:./include/linux/slab.h ****  *
 250:./include/linux/slab.h ****  * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.
 251:./include/linux/slab.h ****  * Both make kfree a no-op.
 252:./include/linux/slab.h ****  */
 253:./include/linux/slab.h **** #define ZERO_SIZE_PTR ((void *)16)
 254:./include/linux/slab.h **** 
 255:./include/linux/slab.h **** #define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) <= \
 256:./include/linux/slab.h **** 				(unsigned long)ZERO_SIZE_PTR)
 257:./include/linux/slab.h **** 
 258:./include/linux/slab.h **** 
 259:./include/linux/slab.h **** 
 260:./include/linux/slab.h **** 
 261:./include/linux/slab.h **** 
 262:./include/linux/slab.h **** #ifdef CONFIG_SLUB_CPU_PARTIAL
 263:./include/linux/slab.h **** #define slub_percpu_partial(c)			((c)->partial)
 264:./include/linux/slab.h **** 
 265:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)		\
 266:./include/linux/slab.h **** ({						\
 267:./include/linux/slab.h **** 	slub_percpu_partial(c) = (p)->next;	\
 268:./include/linux/slab.h **** })
 269:./include/linux/slab.h **** 
 270:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	READ_ONCE(slub_percpu_partial(c))
 271:./include/linux/slab.h **** #else
 272:./include/linux/slab.h **** #define slub_percpu_partial(c)			NULL
 273:./include/linux/slab.h **** 
 274:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)
 275:./include/linux/slab.h **** 
 276:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	NULL
 277:./include/linux/slab.h **** 
 278:./include/linux/slab.h **** 
 279:./include/linux/slab.h **** #endif // CONFIG_SLUB_CPU_PARTIAL
ARM GAS  /tmp/ccz04fb7.s 			page 10


 280:./include/linux/slab.h **** 
 281:./include/linux/slab.h **** /*
 282:./include/linux/slab.h **** 	* Word size structure that can be atomically updated or read and that
 283:./include/linux/slab.h **** 	* contains both the order and the number of objects that a slab of the
 284:./include/linux/slab.h **** 	* given order would contain.
 285:./include/linux/slab.h **** 	*/				
 286:./include/linux/slab.h **** struct kmem_cache_order_objects {
 287:./include/linux/slab.h **** 	unsigned int x;
 288:./include/linux/slab.h **** };
 289:./include/linux/slab.h **** 
 290:./include/linux/slab.h **** struct kmem_cache_node {
 291:./include/linux/slab.h **** 	spinlock_t list_lock;
 292:./include/linux/slab.h **** 	unsigned long nr_partial;
 293:./include/linux/slab.h **** 	struct list_head partial;
 294:./include/linux/slab.h **** #ifdef CONFIG_SLUB_DEBUG
 295:./include/linux/slab.h **** 	atomic_long_t nr_slabs;
 296:./include/linux/slab.h **** 	atomic_long_t total_objects;
 297:./include/linux/slab.h **** 	struct list_head full;
 298:./include/linux/slab.h **** #endif
 299:./include/linux/slab.h **** };
 300:./include/linux/slab.h **** 
 301:./include/linux/slab.h **** struct kmem_cache {
 302:./include/linux/slab.h **** 	#ifndef CONFIG_SLUB_TINY
 303:./include/linux/slab.h **** 	//	struct kmem_cache_cpu __percpu *cpu_slab;
 304:./include/linux/slab.h **** 	#endif
 305:./include/linux/slab.h **** 		/* Used for retrieving partial slabs, etc. */
 306:./include/linux/slab.h **** 		slab_flags_t flags;
 307:./include/linux/slab.h **** 		unsigned long min_partial;
 308:./include/linux/slab.h **** 		unsigned int size;		/* Object size including metadata */
 309:./include/linux/slab.h **** 		unsigned int object_size;	/* Object size without metadata */
 310:./include/linux/slab.h **** 		struct reciprocal_value reciprocal_size;
 311:./include/linux/slab.h **** 		unsigned int offset;		/* Free pointer offset */
 312:./include/linux/slab.h **** 	#ifdef CONFIG_SLUB_CPU_PARTIAL
 313:./include/linux/slab.h **** 		/* Number of per cpu partial objects to keep around */
 314:./include/linux/slab.h **** 		unsigned int cpu_partial;
 315:./include/linux/slab.h **** 		/* Number of per cpu partial slabs to keep around */
 316:./include/linux/slab.h **** 		unsigned int cpu_partial_slabs;
 317:./include/linux/slab.h **** 	#endif
 318:./include/linux/slab.h **** 		struct kmem_cache_order_objects oo;
 319:./include/linux/slab.h **** 	
 320:./include/linux/slab.h **** 		/* Allocation and freeing of slabs */
 321:./include/linux/slab.h **** 		struct kmem_cache_order_objects min;
 322:./include/linux/slab.h **** 		gfp_t allocflags;		/* gfp flags to use on each alloc */
 323:./include/linux/slab.h **** 		int refcount;			/* Refcount for slab cache destroy */
 324:./include/linux/slab.h **** 		void (*ctor)(void *object);	/* Object constructor */
 325:./include/linux/slab.h **** 		unsigned int inuse;		/* Offset to metadata */
 326:./include/linux/slab.h **** 		unsigned int align;		/* Alignment */
 327:./include/linux/slab.h **** 		unsigned int red_left_pad;	/* Left redzone padding size */
 328:./include/linux/slab.h **** 		const char *name;		/* Name (only for display!) */
 329:./include/linux/slab.h **** 		struct list_head list;		/* List of slab caches */
 330:./include/linux/slab.h **** 	#ifdef CONFIG_SYSFS
 331:./include/linux/slab.h **** 		struct kobject kobj;		/* For sysfs */
 332:./include/linux/slab.h **** 	#endif
 333:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_HARDENED
 334:./include/linux/slab.h **** 		unsigned long random;
 335:./include/linux/slab.h **** 	#endif
 336:./include/linux/slab.h **** 	
ARM GAS  /tmp/ccz04fb7.s 			page 11


 337:./include/linux/slab.h **** 	#ifdef CONFIG_NUMA
 338:./include/linux/slab.h **** 		/*
 339:./include/linux/slab.h **** 			* Defragmentation by allocating from a remote node.
 340:./include/linux/slab.h **** 			*/
 341:./include/linux/slab.h **** 		unsigned int remote_node_defrag_ratio;
 342:./include/linux/slab.h **** 	#endif
 343:./include/linux/slab.h **** 	
 344:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_RANDOM
 345:./include/linux/slab.h **** 		unsigned int *random_seq;
 346:./include/linux/slab.h **** 	#endif
 347:./include/linux/slab.h **** 	
 348:./include/linux/slab.h **** 	#ifdef CONFIG_KASAN_GENERIC
 349:./include/linux/slab.h **** 		struct kasan_cache kasan_info;
 350:./include/linux/slab.h **** 	#endif
 351:./include/linux/slab.h **** 	
 352:./include/linux/slab.h **** 	#ifdef CONFIG_HARDENED_USERCOPY
 353:./include/linux/slab.h **** 		unsigned int useroffset;	/* Usercopy region offset */
 354:./include/linux/slab.h **** 		unsigned int usersize;		/* Usercopy region size */
 355:./include/linux/slab.h **** 	#endif
 356:./include/linux/slab.h **** 	
 357:./include/linux/slab.h **** 		struct kmem_cache_node *node[MAX_NUMNODES];
 358:./include/linux/slab.h **** 	};
 359:./include/linux/slab.h **** 					
 360:./include/linux/slab.h **** 
 361:./include/linux/slab.h **** 
 362:./include/linux/slab.h **** 
 363:./include/linux/slab.h **** 
 364:./include/linux/slab.h **** #define KMALLOC_WAIT 1
 365:./include/linux/slab.h **** 
 366:./include/linux/slab.h **** 
 367:./include/linux/slab.h **** extern void* __smalloc__(u32 size, gfp_t flags);
 368:./include/linux/slab.h **** extern void  __sfree__(void* addr);
 369:./include/linux/slab.h **** 
 370:./include/linux/slab.h **** 
 371:./include/linux/slab.h **** static void inline *vmalloc(unsigned long size){
 372:./include/linux/slab.h **** 	return __smalloc__(size,GFP_TRANSHUGE_LIGHT);
 373:./include/linux/slab.h **** }
 374:./include/linux/slab.h **** 
 375:./include/linux/slab.h **** static void inline vfree(void *addr){
 376:./include/linux/slab.h **** 	__sfree__(addr);
 377:./include/linux/slab.h **** }
 378:./include/linux/slab.h **** 
 379:./include/linux/slab.h **** static void inline *kmalloc(size_t size, gfp_t flags){
  46              		.loc 3 379 21 view .LVU3
  47              	.LBB68:
 380:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
  48              		.loc 3 380 2 view .LVU4
  49              		.loc 3 380 9 is_stmt 0 view .LVU5
  50 0004 2020     		movs	r0, #32
  51              	.LVL2:
  52              		.loc 3 380 9 view .LVU6
  53 0006 FFF7FEFF 		bl	__smalloc__
  54              	.LVL3:
  55              		.loc 3 380 9 view .LVU7
  56              	.LBE68:
  57              	.LBE67:
 191:./include/linux/mm_type.h ****     if (page == NULL)
ARM GAS  /tmp/ccz04fb7.s 			page 12


  58              		.loc 2 191 5 is_stmt 1 view .LVU8
  59              		.loc 2 191 8 is_stmt 0 view .LVU9
  60 000a 0346     		mov	r3, r0
  61 000c 20B1     		cbz	r0, .L1
 192:./include/linux/mm_type.h ****         return NULL;
 193:./include/linux/mm_type.h ****     page->flags = 0;
  62              		.loc 2 193 5 is_stmt 1 view .LVU10
  63              		.loc 2 193 17 is_stmt 0 view .LVU11
  64 000e 0022     		movs	r2, #0
  65 0010 0260     		str	r2, [r0]
 194:./include/linux/mm_type.h ****     atomic_set(&page->_mapcount, 0);
  66              		.loc 2 194 5 is_stmt 1 view .LVU12
  67              	.LVL4:
  68              	.LBB69:
  69              	.LBI69:
  70              		.file 4 "./include/linux/atomic/atomic-instrumented.h"
   1:./include/linux/atomic/atomic-instrumented.h **** // SPDX-License-Identifier: GPL-2.0
   2:./include/linux/atomic/atomic-instrumented.h **** 
   3:./include/linux/atomic/atomic-instrumented.h **** // Generated by scripts/atomic/gen-atomic-instrumented.sh 
   4:./include/linux/atomic/atomic-instrumented.h **** // DO NOT MODIFY THIS FILE DIRECTLY
   5:./include/linux/atomic/atomic-instrumented.h **** 
   6:./include/linux/atomic/atomic-instrumented.h **** /*
   7:./include/linux/atomic/atomic-instrumented.h ****  * This file provoides atomic operations with explicit instrumentation (e.g.
   8:./include/linux/atomic/atomic-instrumented.h ****  * KASAN, KCSAN), which should be used unless it is necessary to avoid
   9:./include/linux/atomic/atomic-instrumented.h ****  * instrumentation. Where it is necessary to aovid instrumenation, the
  10:./include/linux/atomic/atomic-instrumented.h ****  * raw_atomic*() operations should be used.
  11:./include/linux/atomic/atomic-instrumented.h ****  */
  12:./include/linux/atomic/atomic-instrumented.h **** #ifndef _LINUX_ATOMIC_INSTRUMENTED_H
  13:./include/linux/atomic/atomic-instrumented.h **** #define _LINUX_ATOMIC_INSTRUMENTED_H
  14:./include/linux/atomic/atomic-instrumented.h **** 
  15:./include/linux/atomic/atomic-instrumented.h **** #include <linux/build_bug.h>
  16:./include/linux/atomic/atomic-instrumented.h **** #include <linux/compiler.h>
  17:./include/linux/atomic/atomic-instrumented.h **** #include <linux/instrumented.h>
  18:./include/linux/atomic/atomic-instrumented.h **** 
  19:./include/linux/atomic/atomic-instrumented.h **** /**
  20:./include/linux/atomic/atomic-instrumented.h ****  * atomic_read() - atomic load with relaxed ordering
  21:./include/linux/atomic/atomic-instrumented.h ****  * @v: pointer to atomic_t
  22:./include/linux/atomic/atomic-instrumented.h ****  *
  23:./include/linux/atomic/atomic-instrumented.h ****  * Atomically loads the value of @v with relaxed ordering.
  24:./include/linux/atomic/atomic-instrumented.h ****  *
  25:./include/linux/atomic/atomic-instrumented.h ****  * Unsafe to use in noinstr code; use raw_atomic_read() there.
  26:./include/linux/atomic/atomic-instrumented.h ****  *
  27:./include/linux/atomic/atomic-instrumented.h ****  * Return: The value loaded from @v.
  28:./include/linux/atomic/atomic-instrumented.h ****  */
  29:./include/linux/atomic/atomic-instrumented.h **** static __always_inline int
  30:./include/linux/atomic/atomic-instrumented.h **** atomic_read(const atomic_t *v)
  31:./include/linux/atomic/atomic-instrumented.h **** {
  32:./include/linux/atomic/atomic-instrumented.h **** 	instrument_atomic_read(v, sizeof(*v));
  33:./include/linux/atomic/atomic-instrumented.h **** 	return raw_atomic_read(v);
  34:./include/linux/atomic/atomic-instrumented.h **** }
  35:./include/linux/atomic/atomic-instrumented.h **** 
  36:./include/linux/atomic/atomic-instrumented.h **** /**
  37:./include/linux/atomic/atomic-instrumented.h ****  * atomic_read_acquire() - atomic load with acquire ordering
  38:./include/linux/atomic/atomic-instrumented.h ****  * @v: pointer to atomic_t
  39:./include/linux/atomic/atomic-instrumented.h ****  *
  40:./include/linux/atomic/atomic-instrumented.h ****  * Atomically loads the value of @v with acquire ordering.
  41:./include/linux/atomic/atomic-instrumented.h ****  *
ARM GAS  /tmp/ccz04fb7.s 			page 13


  42:./include/linux/atomic/atomic-instrumented.h ****  * Unsafe to use in noinstr code; use raw_atomic_read_acquire() there.
  43:./include/linux/atomic/atomic-instrumented.h ****  *
  44:./include/linux/atomic/atomic-instrumented.h ****  * Return: The value loaded from @v.
  45:./include/linux/atomic/atomic-instrumented.h ****  */
  46:./include/linux/atomic/atomic-instrumented.h **** static __always_inline int
  47:./include/linux/atomic/atomic-instrumented.h **** atomic_read_acquire(const atomic_t *v)
  48:./include/linux/atomic/atomic-instrumented.h **** {
  49:./include/linux/atomic/atomic-instrumented.h **** 	instrument_atomic_read(v, sizeof(*v));
  50:./include/linux/atomic/atomic-instrumented.h **** 	return raw_atomic_read_acquire(v);
  51:./include/linux/atomic/atomic-instrumented.h **** }
  52:./include/linux/atomic/atomic-instrumented.h **** 
  53:./include/linux/atomic/atomic-instrumented.h **** /**
  54:./include/linux/atomic/atomic-instrumented.h ****  * atomic_set() - atomic set with relaxed ordering
  55:./include/linux/atomic/atomic-instrumented.h ****  * @v: pointer to atomic_t
  56:./include/linux/atomic/atomic-instrumented.h ****  * @i: int value to assign
  57:./include/linux/atomic/atomic-instrumented.h ****  *
  58:./include/linux/atomic/atomic-instrumented.h ****  * Atomically sets @v to @i with relaxed ordering.
  59:./include/linux/atomic/atomic-instrumented.h ****  *
  60:./include/linux/atomic/atomic-instrumented.h ****  * Unsafe to use in noinstr code; use raw_atomic_set() there.
  61:./include/linux/atomic/atomic-instrumented.h ****  *
  62:./include/linux/atomic/atomic-instrumented.h ****  * Return: Nothing.
  63:./include/linux/atomic/atomic-instrumented.h ****  */
  64:./include/linux/atomic/atomic-instrumented.h **** static __always_inline void
  65:./include/linux/atomic/atomic-instrumented.h **** atomic_set(atomic_t *v, int i)
  71              		.loc 4 65 1 view .LVU13
  66:./include/linux/atomic/atomic-instrumented.h **** {
  67:./include/linux/atomic/atomic-instrumented.h **** 	instrument_atomic_write(v, sizeof(*v));
  72              		.loc 4 67 2 view .LVU14
  68:./include/linux/atomic/atomic-instrumented.h **** 	raw_atomic_set(v, i);
  73              		.loc 4 68 2 view .LVU15
  74              	.LBB70:
  75              	.LBI70:
  76              		.file 5 "./include/linux/atomic/atomic-arch-fallback.h"
   1:./include/linux/atomic/atomic-arch-fallback.h **** // SPDX-License-Identifier: GPL-2.0
   2:./include/linux/atomic/atomic-arch-fallback.h **** 
   3:./include/linux/atomic/atomic-arch-fallback.h **** // Generated by scripts/atomic/gen-atomic-fallback.sh
   4:./include/linux/atomic/atomic-arch-fallback.h **** // DO NOT MODIFY THIS FILE DIRECTLY
   5:./include/linux/atomic/atomic-arch-fallback.h **** 
   6:./include/linux/atomic/atomic-arch-fallback.h **** #ifndef _LINUX_ATOMIC_FALLBACK_H
   7:./include/linux/atomic/atomic-arch-fallback.h **** #define _LINUX_ATOMIC_FALLBACK_H
   8:./include/linux/atomic/atomic-arch-fallback.h **** 
   9:./include/linux/atomic/atomic-arch-fallback.h **** #include <linux/compiler.h>
  10:./include/linux/atomic/atomic-arch-fallback.h **** 
  11:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_xchg)
  12:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg arch_xchg
  13:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg_relaxed)
  14:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg(...) \
  15:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_xchg, __VA_ARGS__)
  16:./include/linux/atomic/atomic-arch-fallback.h **** #else
  17:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_xchg_not_implemented(void);
  18:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg(...) raw_xchg_not_implemented()
  19:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  20:./include/linux/atomic/atomic-arch-fallback.h **** 
  21:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_xchg_acquire)
  22:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_acquire arch_xchg_acquire
  23:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg_relaxed)
  24:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_acquire(...) \
ARM GAS  /tmp/ccz04fb7.s 			page 14


  25:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_xchg, __VA_ARGS__)
  26:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg)
  27:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_acquire arch_xchg
  28:./include/linux/atomic/atomic-arch-fallback.h **** #else
  29:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_xchg_acquire_not_implemented(void);
  30:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_acquire(...) raw_xchg_acquire_not_implemented()
  31:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  32:./include/linux/atomic/atomic-arch-fallback.h **** 
  33:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_xchg_release)
  34:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_release arch_xchg_release
  35:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg_relaxed)
  36:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_release(...) \
  37:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_xchg, __VA_ARGS__)
  38:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg)
  39:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_release arch_xchg
  40:./include/linux/atomic/atomic-arch-fallback.h **** #else
  41:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_xchg_release_not_implemented(void);
  42:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_release(...) raw_xchg_release_not_implemented()
  43:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  44:./include/linux/atomic/atomic-arch-fallback.h **** 
  45:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_xchg_relaxed)
  46:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_relaxed arch_xchg_relaxed
  47:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg)
  48:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_relaxed arch_xchg
  49:./include/linux/atomic/atomic-arch-fallback.h **** #else
  50:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_xchg_relaxed_not_implemented(void);
  51:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_relaxed(...) raw_xchg_relaxed_not_implemented()
  52:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  53:./include/linux/atomic/atomic-arch-fallback.h **** 
  54:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg)
  55:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg arch_cmpxchg
  56:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg_relaxed)
  57:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg(...) \
  58:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_cmpxchg, __VA_ARGS__)
  59:./include/linux/atomic/atomic-arch-fallback.h **** #else
  60:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg_not_implemented(void);
  61:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg(...) raw_cmpxchg_not_implemented()
  62:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  63:./include/linux/atomic/atomic-arch-fallback.h **** 
  64:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg_acquire)
  65:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_acquire arch_cmpxchg_acquire
  66:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg_relaxed)
  67:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_acquire(...) \
  68:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_cmpxchg, __VA_ARGS__)
  69:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg)
  70:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_acquire arch_cmpxchg
  71:./include/linux/atomic/atomic-arch-fallback.h **** #else
  72:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg_acquire_not_implemented(void);
  73:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_acquire(...) raw_cmpxchg_acquire_not_implemented()
  74:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  75:./include/linux/atomic/atomic-arch-fallback.h **** 
  76:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg_release)
  77:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_release arch_cmpxchg_release
  78:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg_relaxed)
  79:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_release(...) \
  80:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_cmpxchg, __VA_ARGS__)
  81:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg)
ARM GAS  /tmp/ccz04fb7.s 			page 15


  82:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_release arch_cmpxchg
  83:./include/linux/atomic/atomic-arch-fallback.h **** #else
  84:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg_release_not_implemented(void);
  85:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_release(...) raw_cmpxchg_release_not_implemented()
  86:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  87:./include/linux/atomic/atomic-arch-fallback.h **** 
  88:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg_relaxed)
  89:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_relaxed arch_cmpxchg_relaxed
  90:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg)
  91:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_relaxed arch_cmpxchg
  92:./include/linux/atomic/atomic-arch-fallback.h **** #else
  93:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg_relaxed_not_implemented(void);
  94:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_relaxed(...) raw_cmpxchg_relaxed_not_implemented()
  95:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  96:./include/linux/atomic/atomic-arch-fallback.h **** 
  97:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg64)
  98:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64 arch_cmpxchg64
  99:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64_relaxed)
 100:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64(...) \
 101:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_cmpxchg64, __VA_ARGS__)
 102:./include/linux/atomic/atomic-arch-fallback.h **** #else
 103:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg64_not_implemented(void);
 104:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64(...) raw_cmpxchg64_not_implemented()
 105:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 106:./include/linux/atomic/atomic-arch-fallback.h **** 
 107:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg64_acquire)
 108:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_acquire arch_cmpxchg64_acquire
 109:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64_relaxed)
 110:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_acquire(...) \
 111:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_cmpxchg64, __VA_ARGS__)
 112:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64)
 113:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_acquire arch_cmpxchg64
 114:./include/linux/atomic/atomic-arch-fallback.h **** #else
 115:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg64_acquire_not_implemented(void);
 116:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_acquire(...) raw_cmpxchg64_acquire_not_implemented()
 117:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 118:./include/linux/atomic/atomic-arch-fallback.h **** 
 119:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg64_release)
 120:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_release arch_cmpxchg64_release
 121:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64_relaxed)
 122:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_release(...) \
 123:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_cmpxchg64, __VA_ARGS__)
 124:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64)
 125:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_release arch_cmpxchg64
 126:./include/linux/atomic/atomic-arch-fallback.h **** #else
 127:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg64_release_not_implemented(void);
 128:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_release(...) raw_cmpxchg64_release_not_implemented()
 129:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 130:./include/linux/atomic/atomic-arch-fallback.h **** 
 131:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg64_relaxed)
 132:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_relaxed arch_cmpxchg64_relaxed
 133:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64)
 134:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_relaxed arch_cmpxchg64
 135:./include/linux/atomic/atomic-arch-fallback.h **** #else
 136:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg64_relaxed_not_implemented(void);
 137:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_relaxed(...) raw_cmpxchg64_relaxed_not_implemented()
 138:./include/linux/atomic/atomic-arch-fallback.h **** #endif
ARM GAS  /tmp/ccz04fb7.s 			page 16


 139:./include/linux/atomic/atomic-arch-fallback.h **** 
 140:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg128)
 141:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128 arch_cmpxchg128
 142:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128_relaxed)
 143:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128(...) \
 144:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_cmpxchg128, __VA_ARGS__)
 145:./include/linux/atomic/atomic-arch-fallback.h **** #else
 146:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg128_not_implemented(void);
 147:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128(...) raw_cmpxchg128_not_implemented()
 148:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 149:./include/linux/atomic/atomic-arch-fallback.h **** 
 150:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg128_acquire)
 151:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_acquire arch_cmpxchg128_acquire
 152:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128_relaxed)
 153:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_acquire(...) \
 154:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_cmpxchg128, __VA_ARGS__)
 155:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128)
 156:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_acquire arch_cmpxchg128
 157:./include/linux/atomic/atomic-arch-fallback.h **** #else
 158:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg128_acquire_not_implemented(void);
 159:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_acquire(...) raw_cmpxchg128_acquire_not_implemented()
 160:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 161:./include/linux/atomic/atomic-arch-fallback.h **** 
 162:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg128_release)
 163:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_release arch_cmpxchg128_release
 164:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128_relaxed)
 165:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_release(...) \
 166:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_cmpxchg128, __VA_ARGS__)
 167:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128)
 168:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_release arch_cmpxchg128
 169:./include/linux/atomic/atomic-arch-fallback.h **** #else
 170:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg128_release_not_implemented(void);
 171:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_release(...) raw_cmpxchg128_release_not_implemented()
 172:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 173:./include/linux/atomic/atomic-arch-fallback.h **** 
 174:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg128_relaxed)
 175:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_relaxed arch_cmpxchg128_relaxed
 176:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128)
 177:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_relaxed arch_cmpxchg128
 178:./include/linux/atomic/atomic-arch-fallback.h **** #else
 179:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg128_relaxed_not_implemented(void);
 180:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_relaxed(...) raw_cmpxchg128_relaxed_not_implemented()
 181:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 182:./include/linux/atomic/atomic-arch-fallback.h **** 
 183:./include/linux/atomic/atomic-arch-fallback.h **** 
 184:./include/linux/atomic/atomic-arch-fallback.h **** 
 185:./include/linux/atomic/atomic-arch-fallback.h **** 
 186:./include/linux/atomic/atomic-arch-fallback.h **** 
 187:./include/linux/atomic/atomic-arch-fallback.h **** 
 188:./include/linux/atomic/atomic-arch-fallback.h **** 
 189:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg)
 190:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg arch_try_cmpxchg
 191:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg_relaxed)
 192:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg(...) \
 193:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_try_cmpxchg, __VA_ARGS__)
 194:./include/linux/atomic/atomic-arch-fallback.h **** #else
 195:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg(_ptr, _oldp, _new) \
ARM GAS  /tmp/ccz04fb7.s 			page 17


 196:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 197:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 198:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg((_ptr), ___o, (_new)); \
 199:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 200:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 201:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 202:./include/linux/atomic/atomic-arch-fallback.h **** })
 203:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 204:./include/linux/atomic/atomic-arch-fallback.h **** 
 205:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg_acquire)
 206:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_acquire arch_try_cmpxchg_acquire
 207:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg_relaxed)
 208:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_acquire(...) \
 209:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_try_cmpxchg, __VA_ARGS__)
 210:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg)
 211:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_acquire arch_try_cmpxchg
 212:./include/linux/atomic/atomic-arch-fallback.h **** #else
 213:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_acquire(_ptr, _oldp, _new) \
 214:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 215:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 216:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg_acquire((_ptr), ___o, (_new)); \
 217:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 218:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 219:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 220:./include/linux/atomic/atomic-arch-fallback.h **** })
 221:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 222:./include/linux/atomic/atomic-arch-fallback.h **** 
 223:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg_release)
 224:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_release arch_try_cmpxchg_release
 225:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg_relaxed)
 226:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_release(...) \
 227:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_try_cmpxchg, __VA_ARGS__)
 228:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg)
 229:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_release arch_try_cmpxchg
 230:./include/linux/atomic/atomic-arch-fallback.h **** #else
 231:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_release(_ptr, _oldp, _new) \
 232:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 233:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 234:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg_release((_ptr), ___o, (_new)); \
 235:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 236:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 237:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 238:./include/linux/atomic/atomic-arch-fallback.h **** })
 239:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 240:./include/linux/atomic/atomic-arch-fallback.h **** 
 241:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg_relaxed)
 242:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_relaxed arch_try_cmpxchg_relaxed
 243:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg)
 244:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_relaxed arch_try_cmpxchg
 245:./include/linux/atomic/atomic-arch-fallback.h **** #else
 246:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_relaxed(_ptr, _oldp, _new) \
 247:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 248:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 249:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg_relaxed((_ptr), ___o, (_new)); \
 250:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 251:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 252:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
ARM GAS  /tmp/ccz04fb7.s 			page 18


 253:./include/linux/atomic/atomic-arch-fallback.h **** })
 254:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 255:./include/linux/atomic/atomic-arch-fallback.h **** 
 256:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg64)
 257:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64 arch_try_cmpxchg64
 258:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64_relaxed)
 259:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64(...) \
 260:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_try_cmpxchg64, __VA_ARGS__)
 261:./include/linux/atomic/atomic-arch-fallback.h **** #else
 262:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64(_ptr, _oldp, _new) \
 263:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 264:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 265:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64((_ptr), ___o, (_new)); \
 266:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 267:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 268:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 269:./include/linux/atomic/atomic-arch-fallback.h **** })
 270:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 271:./include/linux/atomic/atomic-arch-fallback.h **** 
 272:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg64_acquire)
 273:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_acquire arch_try_cmpxchg64_acquire
 274:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64_relaxed)
 275:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_acquire(...) \
 276:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_try_cmpxchg64, __VA_ARGS__)
 277:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64)
 278:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_acquire arch_try_cmpxchg64
 279:./include/linux/atomic/atomic-arch-fallback.h **** #else
 280:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_acquire(_ptr, _oldp, _new) \
 281:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 282:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 283:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64_acquire((_ptr), ___o, (_new)); \
 284:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 285:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 286:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 287:./include/linux/atomic/atomic-arch-fallback.h **** })
 288:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 289:./include/linux/atomic/atomic-arch-fallback.h **** 
 290:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg64_release)
 291:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_release arch_try_cmpxchg64_release
 292:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64_relaxed)
 293:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_release(...) \
 294:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_try_cmpxchg64, __VA_ARGS__)
 295:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64)
 296:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_release arch_try_cmpxchg64
 297:./include/linux/atomic/atomic-arch-fallback.h **** #else
 298:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_release(_ptr, _oldp, _new) \
 299:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 300:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 301:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64_release((_ptr), ___o, (_new)); \
 302:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 303:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 304:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 305:./include/linux/atomic/atomic-arch-fallback.h **** })
 306:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 307:./include/linux/atomic/atomic-arch-fallback.h **** 
 308:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg64_relaxed)
 309:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_relaxed arch_try_cmpxchg64_relaxed
ARM GAS  /tmp/ccz04fb7.s 			page 19


 310:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64)
 311:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_relaxed arch_try_cmpxchg64
 312:./include/linux/atomic/atomic-arch-fallback.h **** #else
 313:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_relaxed(_ptr, _oldp, _new) \
 314:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 315:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 316:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64_relaxed((_ptr), ___o, (_new)); \
 317:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 318:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 319:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 320:./include/linux/atomic/atomic-arch-fallback.h **** })
 321:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 322:./include/linux/atomic/atomic-arch-fallback.h **** 
 323:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg128)
 324:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128 arch_try_cmpxchg128
 325:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128_relaxed)
 326:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128(...) \
 327:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_try_cmpxchg128, __VA_ARGS__)
 328:./include/linux/atomic/atomic-arch-fallback.h **** #else
 329:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128(_ptr, _oldp, _new) \
 330:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 331:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 332:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128((_ptr), ___o, (_new)); \
 333:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 334:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 335:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 336:./include/linux/atomic/atomic-arch-fallback.h **** })
 337:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 338:./include/linux/atomic/atomic-arch-fallback.h **** 
 339:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg128_acquire)
 340:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_acquire arch_try_cmpxchg128_acquire
 341:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128_relaxed)
 342:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_acquire(...) \
 343:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_try_cmpxchg128, __VA_ARGS__)
 344:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128)
 345:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_acquire arch_try_cmpxchg128
 346:./include/linux/atomic/atomic-arch-fallback.h **** #else
 347:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_acquire(_ptr, _oldp, _new) \
 348:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 349:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 350:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128_acquire((_ptr), ___o, (_new)); \
 351:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 352:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 353:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 354:./include/linux/atomic/atomic-arch-fallback.h **** })
 355:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 356:./include/linux/atomic/atomic-arch-fallback.h **** 
 357:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg128_release)
 358:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_release arch_try_cmpxchg128_release
 359:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128_relaxed)
 360:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_release(...) \
 361:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_try_cmpxchg128, __VA_ARGS__)
 362:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128)
 363:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_release arch_try_cmpxchg128
 364:./include/linux/atomic/atomic-arch-fallback.h **** #else
 365:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_release(_ptr, _oldp, _new) \
 366:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
ARM GAS  /tmp/ccz04fb7.s 			page 20


 367:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 368:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128_release((_ptr), ___o, (_new)); \
 369:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 370:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 371:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 372:./include/linux/atomic/atomic-arch-fallback.h **** })
 373:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 374:./include/linux/atomic/atomic-arch-fallback.h **** 
 375:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg128_relaxed)
 376:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_relaxed arch_try_cmpxchg128_relaxed
 377:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128)
 378:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_relaxed arch_try_cmpxchg128
 379:./include/linux/atomic/atomic-arch-fallback.h **** #else
 380:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_relaxed(_ptr, _oldp, _new) \
 381:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 382:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 383:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128_relaxed((_ptr), ___o, (_new)); \
 384:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 385:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 386:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 387:./include/linux/atomic/atomic-arch-fallback.h **** })
 388:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 389:./include/linux/atomic/atomic-arch-fallback.h **** 
 390:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_local arch_cmpxchg_local
 391:./include/linux/atomic/atomic-arch-fallback.h **** 
 392:./include/linux/atomic/atomic-arch-fallback.h **** #ifdef arch_try_cmpxchg_local
 393:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_local arch_try_cmpxchg_local
 394:./include/linux/atomic/atomic-arch-fallback.h **** #else
 395:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_local(_ptr, _oldp, _new) \
 396:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 397:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 398:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg_local((_ptr), ___o, (_new)); \
 399:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 400:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 401:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 402:./include/linux/atomic/atomic-arch-fallback.h **** })
 403:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 404:./include/linux/atomic/atomic-arch-fallback.h **** 
 405:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_local arch_cmpxchg64_local
 406:./include/linux/atomic/atomic-arch-fallback.h **** 
 407:./include/linux/atomic/atomic-arch-fallback.h **** #ifdef arch_try_cmpxchg64_local
 408:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_local arch_try_cmpxchg64_local
 409:./include/linux/atomic/atomic-arch-fallback.h **** #else
 410:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_local(_ptr, _oldp, _new) \
 411:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 412:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 413:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64_local((_ptr), ___o, (_new)); \
 414:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 415:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 416:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 417:./include/linux/atomic/atomic-arch-fallback.h **** })
 418:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 419:./include/linux/atomic/atomic-arch-fallback.h **** 
 420:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_local arch_cmpxchg128_local
 421:./include/linux/atomic/atomic-arch-fallback.h **** 
 422:./include/linux/atomic/atomic-arch-fallback.h **** #ifdef arch_try_cmpxchg128_local
 423:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_local arch_try_cmpxchg128_local
ARM GAS  /tmp/ccz04fb7.s 			page 21


 424:./include/linux/atomic/atomic-arch-fallback.h **** #else
 425:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_local(_ptr, _oldp, _new) \
 426:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 427:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 428:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128_local((_ptr), ___o, (_new)); \
 429:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 430:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 431:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 432:./include/linux/atomic/atomic-arch-fallback.h **** })
 433:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 434:./include/linux/atomic/atomic-arch-fallback.h **** 
 435:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_sync_cmpxchg arch_sync_cmpxchg
 436:./include/linux/atomic/atomic-arch-fallback.h **** 
 437:./include/linux/atomic/atomic-arch-fallback.h **** #ifdef arch_sync_try_cmpxchg
 438:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_sync_try_cmpxchg arch_sync_try_cmpxchg
 439:./include/linux/atomic/atomic-arch-fallback.h **** #else
 440:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_sync_try_cmpxchg(_ptr, _oldp, _new) \
 441:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 442:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 443:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_sync_cmpxchg((_ptr), ___o, (_new)); \
 444:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 445:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 446:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 447:./include/linux/atomic/atomic-arch-fallback.h **** })
 448:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 449:./include/linux/atomic/atomic-arch-fallback.h **** 
 450:./include/linux/atomic/atomic-arch-fallback.h **** /**
 451:./include/linux/atomic/atomic-arch-fallback.h ****  * raw_atomic_read() - atomic load with relaxed ordering
 452:./include/linux/atomic/atomic-arch-fallback.h ****  * @v: pointer to atomic_t
 453:./include/linux/atomic/atomic-arch-fallback.h ****  *
 454:./include/linux/atomic/atomic-arch-fallback.h ****  * Atomically loads the value of @v with relaxed ordering.
 455:./include/linux/atomic/atomic-arch-fallback.h ****  *
 456:./include/linux/atomic/atomic-arch-fallback.h ****  * Safe to use in noinstr code; prefer atomic_read() elsewhere.
 457:./include/linux/atomic/atomic-arch-fallback.h ****  *
 458:./include/linux/atomic/atomic-arch-fallback.h ****  * Return: The value loaded from @v.
 459:./include/linux/atomic/atomic-arch-fallback.h ****  */
 460:./include/linux/atomic/atomic-arch-fallback.h **** static __always_inline int
 461:./include/linux/atomic/atomic-arch-fallback.h **** raw_atomic_read(const atomic_t *v)
 462:./include/linux/atomic/atomic-arch-fallback.h **** {
 463:./include/linux/atomic/atomic-arch-fallback.h **** 	return arch_atomic_read(v);
 464:./include/linux/atomic/atomic-arch-fallback.h **** }
 465:./include/linux/atomic/atomic-arch-fallback.h **** 
 466:./include/linux/atomic/atomic-arch-fallback.h **** /**
 467:./include/linux/atomic/atomic-arch-fallback.h ****  * raw_atomic_read_acquire() - atomic load with acquire ordering
 468:./include/linux/atomic/atomic-arch-fallback.h ****  * @v: pointer to atomic_t
 469:./include/linux/atomic/atomic-arch-fallback.h ****  *
 470:./include/linux/atomic/atomic-arch-fallback.h ****  * Atomically loads the value of @v with acquire ordering.
 471:./include/linux/atomic/atomic-arch-fallback.h ****  *
 472:./include/linux/atomic/atomic-arch-fallback.h ****  * Safe to use in noinstr code; prefer atomic_read_acquire() elsewhere.
 473:./include/linux/atomic/atomic-arch-fallback.h ****  *
 474:./include/linux/atomic/atomic-arch-fallback.h ****  * Return: The value loaded from @v.
 475:./include/linux/atomic/atomic-arch-fallback.h ****  */
 476:./include/linux/atomic/atomic-arch-fallback.h **** static __always_inline int
 477:./include/linux/atomic/atomic-arch-fallback.h **** raw_atomic_read_acquire(const atomic_t *v)
 478:./include/linux/atomic/atomic-arch-fallback.h **** {
 479:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_atomic_read_acquire)
 480:./include/linux/atomic/atomic-arch-fallback.h **** 	return arch_atomic_read_acquire(v);
ARM GAS  /tmp/ccz04fb7.s 			page 22


 481:./include/linux/atomic/atomic-arch-fallback.h **** #else
 482:./include/linux/atomic/atomic-arch-fallback.h **** 	int ret;
 483:./include/linux/atomic/atomic-arch-fallback.h **** 
 484:./include/linux/atomic/atomic-arch-fallback.h **** 	if (__native_word(atomic_t)) {
 485:./include/linux/atomic/atomic-arch-fallback.h **** 		ret = smp_load_acquire(&(v)->counter);
 486:./include/linux/atomic/atomic-arch-fallback.h **** 	} else {
 487:./include/linux/atomic/atomic-arch-fallback.h **** 		ret = raw_atomic_read(v);
 488:./include/linux/atomic/atomic-arch-fallback.h **** 		__atomic_acquire_fence();
 489:./include/linux/atomic/atomic-arch-fallback.h **** 	}
 490:./include/linux/atomic/atomic-arch-fallback.h **** 
 491:./include/linux/atomic/atomic-arch-fallback.h **** 	return ret;
 492:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 493:./include/linux/atomic/atomic-arch-fallback.h **** }
 494:./include/linux/atomic/atomic-arch-fallback.h **** 
 495:./include/linux/atomic/atomic-arch-fallback.h **** /**
 496:./include/linux/atomic/atomic-arch-fallback.h ****  * raw_atomic_set() - atomic set with relaxed ordering
 497:./include/linux/atomic/atomic-arch-fallback.h ****  * @v: pointer to atomic_t
 498:./include/linux/atomic/atomic-arch-fallback.h ****  * @i: int value to assign
 499:./include/linux/atomic/atomic-arch-fallback.h ****  *
 500:./include/linux/atomic/atomic-arch-fallback.h ****  * Atomically sets @v to @i with relaxed ordering.
 501:./include/linux/atomic/atomic-arch-fallback.h ****  *
 502:./include/linux/atomic/atomic-arch-fallback.h ****  * Safe to use in noinstr code; prefer atomic_set() elsewhere.
 503:./include/linux/atomic/atomic-arch-fallback.h ****  *
 504:./include/linux/atomic/atomic-arch-fallback.h ****  * Return: Nothing.
 505:./include/linux/atomic/atomic-arch-fallback.h ****  */
 506:./include/linux/atomic/atomic-arch-fallback.h **** static __always_inline void
 507:./include/linux/atomic/atomic-arch-fallback.h **** raw_atomic_set(atomic_t *v, int i)
  77              		.loc 5 507 1 view .LVU16
  78              	.LBB71:
 508:./include/linux/atomic/atomic-arch-fallback.h **** {
 509:./include/linux/atomic/atomic-arch-fallback.h **** 	arch_atomic_set(v, i);
  79              		.loc 5 509 2 view .LVU17
  80              		.loc 5 509 2 view .LVU18
  81              	.LBB72:
  82              		.loc 5 509 2 view .LVU19
  83              		.loc 5 509 2 view .LVU20
  84              	.LBE72:
  85              		.loc 5 509 2 discriminator 2 view .LVU21
  86              		.loc 5 509 2 discriminator 2 view .LVU22
  87              		.loc 5 509 2 discriminator 2 view .LVU23
  88 0012 8261     		str	r2, [r0, #24]
  89              		.loc 5 509 2 discriminator 2 view .LVU24
  90              		.loc 5 509 2 discriminator 2 view .LVU25
  91              	.LVL5:
  92              		.loc 5 509 2 is_stmt 0 discriminator 2 view .LVU26
  93              	.LBE71:
  94              	.LBE70:
  95              	.LBE69:
 195:./include/linux/mm_type.h ****     atomic_set(&page->_refcount, 0); // 1
  96              		.loc 2 195 5 is_stmt 1 view .LVU27
  97              	.LBB73:
  98              	.LBI73:
  65:./include/linux/atomic/atomic-instrumented.h **** {
  99              		.loc 4 65 1 view .LVU28
  67:./include/linux/atomic/atomic-instrumented.h **** 	raw_atomic_set(v, i);
 100              		.loc 4 67 2 view .LVU29
 101              		.loc 4 68 2 view .LVU30
ARM GAS  /tmp/ccz04fb7.s 			page 23


 102              	.LBB74:
 103              	.LBI74:
 507:./include/linux/atomic/atomic-arch-fallback.h **** {
 104              		.loc 5 507 1 view .LVU31
 105              	.LBB75:
 106              		.loc 5 509 2 view .LVU32
 107              		.loc 5 509 2 view .LVU33
 108              	.LBB76:
 109              		.loc 5 509 2 view .LVU34
 110              		.loc 5 509 2 view .LVU35
 111              	.LBE76:
 112              		.loc 5 509 2 discriminator 2 view .LVU36
 113              		.loc 5 509 2 discriminator 2 view .LVU37
 114              		.loc 5 509 2 discriminator 2 view .LVU38
 115 0014 C261     		str	r2, [r0, #28]
 116              		.loc 5 509 2 discriminator 2 view .LVU39
 117              		.loc 5 509 2 discriminator 2 view .LVU40
 118              	.LVL6:
 119              		.loc 5 509 2 is_stmt 0 discriminator 2 view .LVU41
 120              	.LBE75:
 121              	.LBE74:
 122              	.LBE73:
 196:./include/linux/mm_type.h ****     page->zone_device_data = NULL;
 123              		.loc 2 196 5 is_stmt 1 view .LVU42
 124              		.loc 2 196 28 is_stmt 0 view .LVU43
 125 0016 4260     		str	r2, [r0, #4]
 197:./include/linux/mm_type.h ****     return page;
 126              		.loc 2 197 5 is_stmt 1 view .LVU44
 127              	.L1:
 198:./include/linux/mm_type.h **** }
 128              		.loc 2 198 1 is_stmt 0 view .LVU45
 129 0018 1846     		mov	r0, r3
 130              	.LVL7:
 131              		.loc 2 198 1 view .LVU46
 132 001a 08BD     		pop	{r3, pc}
 133              		.loc 2 198 1 view .LVU47
 134              		.cfi_endproc
 135              	.LFE910:
 137              		.section	.rodata.MBR_partition_table_create.str1.4,"aMS",%progbits,1
 138              		.align	2
 139              	.LC0:
 140 0000 63726561 		.ascii	"creating new mbr partition: boot_ind = %d, start_ad"
 140      74696E67 
 140      206E6577 
 140      206D6272 
 140      20706172 
 141 0033 64726573 		.ascii	"dress = %d, size = %d,sys_ind = %d\012\015\000"
 141      73203D20 
 141      25642C20 
 141      73697A65 
 141      203D2025 
 142              		.section	.text.MBR_partition_table_create,"ax",%progbits
 143              		.align	1
 144              		.syntax unified
 145              		.thumb
 146              		.thumb_func
 148              	MBR_partition_table_create:
ARM GAS  /tmp/ccz04fb7.s 			page 24


 149              	.LVL8:
 150              	.LFB1042:
   1:./block/partition.c **** #include <linux/kernel.h>
   2:./block/partition.c **** #include <linux/slab.h>
   3:./block/partition.c **** #include <linux/fs.h>
   4:./block/partition.c **** #include <linux/blkdev.h>
   5:./block/partition.c **** #include <linux/spinlock.h>
   6:./block/partition.c **** #include <linux/string.h>
   7:./block/partition.c **** #include <asm/byteorder.h>
   8:./block/partition.c **** 
   9:./block/partition.c **** 
  10:./block/partition.c **** static void my_end_io(struct bio *bio){
  11:./block/partition.c ****     bio_put(bio);
  12:./block/partition.c **** }
  13:./block/partition.c **** static char * trans_data_to_blk_dev(struct block_device *bdev, sector_t block, unsigned size, char 
  14:./block/partition.c ****     struct page *page = virt_to_page((uint32_t)data);  
  15:./block/partition.c ****     struct bio *bio = bio_alloc(bdev,1,mod,GFP_KERNEL);
  16:./block/partition.c ****     bio_set_dev(bio,bdev);                                           //
  17:./block/partition.c ****     bio->bi_iter.bi_sector = block;
  18:./block/partition.c ****     bio->bi_end_io = my_end_io;
  19:./block/partition.c ****     if(bio_add_page(bio, page, size, offset_in_page(data)) < 0 ){
  20:./block/partition.c ****         bio_put(bio);
  21:./block/partition.c ****         return NULL;
  22:./block/partition.c ****     }
  23:./block/partition.c ****     submit_bio_wait(bio);
  24:./block/partition.c ****     return data;
  25:./block/partition.c **** }
  26:./block/partition.c **** 
  27:./block/partition.c **** 
  28:./block/partition.c **** 
  29:./block/partition.c **** 
  30:./block/partition.c **** static uint8_t gpt_head[8] = {0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54};
  31:./block/partition.c **** 
  32:./block/partition.c **** static int detect_partition_table(struct block_device *device,char *block_buffer, enum block_device
  33:./block/partition.c **** {
  34:./block/partition.c ****     *flags = BLOCK_DEVICE_FLAG_NOT_INITIALIZED;                           //
  35:./block/partition.c ****     char *data =  trans_data_to_blk_dev(device,0,512,block_buffer,REQ_OP_READ);
  36:./block/partition.c ****     if(data[0x01FE] == 0x55 && data[0x01FF] == 0xAA)
  37:./block/partition.c ****         *flags = BLOCK_DEVICE_FLAG_MBR;                                    //LBA 0
  38:./block/partition.c ****     data =  trans_data_to_blk_dev(device,1,512,block_buffer,REQ_OP_READ);//LBA 1
  39:./block/partition.c ****     if (memcmp(data, gpt_head, 8) == 0)
  40:./block/partition.c ****     {
  41:./block/partition.c ****         if(*flags == BLOCK_DEVICE_FLAG_MBR)
  42:./block/partition.c ****             *flags = BLOCK_DEVICE_FLAG_PROTECTIVE_MBR;
  43:./block/partition.c ****         else
  44:./block/partition.c ****             *flags = BLOCK_DEVICE_FLAG_GPT;
  45:./block/partition.c ****     }
  46:./block/partition.c ****     return 0;
  47:./block/partition.c **** }
  48:./block/partition.c **** 
  49:./block/partition.c **** #define INVALID_PARTITION 0xFFFFFFFF
  50:./block/partition.c **** 
  51:./block/partition.c **** static void MBR_partition_table_fix_endian(struct mbr_partition *mbr_header) 
  52:./block/partition.c **** {
  53:./block/partition.c ****      #ifndef BIG_ENDIAN
  54:./block/partition.c ****       mbr_header->start_lba  = le32_to_cpu(mbr_header->start_lba);
  55:./block/partition.c ****       mbr_header->nr_sectors = le32_to_cpu(mbr_header->nr_sectors);
ARM GAS  /tmp/ccz04fb7.s 			page 25


  56:./block/partition.c ****      #endif
  57:./block/partition.c **** }
  58:./block/partition.c **** 
  59:./block/partition.c **** int check_empty_MBR_Table(struct partition *partition,int number)
  60:./block/partition.c **** {
  61:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
  62:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
  63:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
  64:./block/partition.c ****             return 0;
  65:./block/partition.c ****     }
  66:./block/partition.c ****     return 1;
  67:./block/partition.c **** }
  68:./block/partition.c **** static void clear_MBR_Table(struct partition *partition,int number)
  69:./block/partition.c **** {
  70:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
  71:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
  72:./block/partition.c ****         ((char *)mbr_partition)[i] = 0x00;
  73:./block/partition.c ****     }
  74:./block/partition.c **** }
  75:./block/partition.c **** static struct mbr_partition * get_empty_MBR_Table(struct partition *partition,int *number) //number
  76:./block/partition.c **** {
  77:./block/partition.c ****     for(int i = 0 ; i <4 ; i++){
  78:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
  79:./block/partition.c ****             number[0] = i;
  80:./block/partition.c ****             return &partition->mbr_partition[i];
  81:./block/partition.c ****         }
  82:./block/partition.c ****     }
  83:./block/partition.c ****     return NULL;
  84:./block/partition.c **** }
  85:./block/partition.c **** 
  86:./block/partition.c **** 
  87:./block/partition.c **** static void MBR_partition_table_create(struct mbr_partition * mbr_partition,uint8_t type,uint32_t s
  88:./block/partition.c **** {
 151              		.loc 1 88 1 is_stmt 1 view -0
 152              		.cfi_startproc
 153              		@ args = 4, pretend = 0, frame = 0
 154              		@ frame_needed = 0, uses_anonymous_args = 0
 155              		.loc 1 88 1 is_stmt 0 view .LVU49
 156 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 157              	.LCFI1:
 158              		.cfi_def_cfa_offset 24
 159              		.cfi_offset 4, -24
 160              		.cfi_offset 5, -20
 161              		.cfi_offset 6, -16
 162              		.cfi_offset 7, -12
 163              		.cfi_offset 8, -8
 164              		.cfi_offset 14, -4
 165 0004 82B0     		sub	sp, sp, #8
 166              	.LCFI2:
 167              		.cfi_def_cfa_offset 32
 168 0006 0446     		mov	r4, r0
 169 0008 0F46     		mov	r7, r1
 170 000a 1646     		mov	r6, r2
 171 000c 1D46     		mov	r5, r3
 172 000e 9DF82080 		ldrb	r8, [sp, #32]	@ zero_extendqisi2
  89:./block/partition.c ****     printk("creating new mbr partition: boot_ind = %d, start_address = %d, size = %d,sys_ind = %d\n
 173              		.loc 1 89 5 is_stmt 1 view .LVU50
ARM GAS  /tmp/ccz04fb7.s 			page 26


 174 0012 CDF80080 		str	r8, [sp]
 175 0016 0B48     		ldr	r0, .L6
 176              	.LVL9:
 177              		.loc 1 89 5 is_stmt 0 view .LVU51
 178 0018 FFF7FEFF 		bl	printk
 179              	.LVL10:
  90:./block/partition.c **** 
  91:./block/partition.c ****     mbr_partition->boot_ind     = type; 
 180              		.loc 1 91 5 is_stmt 1 view .LVU52
 181              		.loc 1 91 33 is_stmt 0 view .LVU53
 182 001c 2770     		strb	r7, [r4]
  92:./block/partition.c **** 
  93:./block/partition.c ****     mbr_partition->start_head   = 0x20;     //
 183              		.loc 1 93 5 is_stmt 1 view .LVU54
 184              		.loc 1 93 33 is_stmt 0 view .LVU55
 185 001e 2023     		movs	r3, #32
 186 0020 6370     		strb	r3, [r4, #1]
  94:./block/partition.c ****     mbr_partition->start_sector = 0X21;
 187              		.loc 1 94 5 is_stmt 1 view .LVU56
 188              		.loc 1 94 33 is_stmt 0 view .LVU57
 189 0022 2123     		movs	r3, #33
 190 0024 A370     		strb	r3, [r4, #2]
  95:./block/partition.c ****     mbr_partition->start_cyl    = 0x00;
 191              		.loc 1 95 5 is_stmt 1 view .LVU58
 192              		.loc 1 95 33 is_stmt 0 view .LVU59
 193 0026 0023     		movs	r3, #0
 194 0028 E370     		strb	r3, [r4, #3]
  96:./block/partition.c ****     mbr_partition->sys_ind = flag;
 195              		.loc 1 96 5 is_stmt 1 view .LVU60
 196              		.loc 1 96 28 is_stmt 0 view .LVU61
 197 002a 84F80480 		strb	r8, [r4, #4]
  97:./block/partition.c ****     mbr_partition->end_head     = 0xfe;
 198              		.loc 1 97 5 is_stmt 1 view .LVU62
 199              		.loc 1 97 33 is_stmt 0 view .LVU63
 200 002e FE23     		movs	r3, #254
 201 0030 6371     		strb	r3, [r4, #5]
  98:./block/partition.c ****     mbr_partition->end_sector   = 0x3f;
 202              		.loc 1 98 5 is_stmt 1 view .LVU64
 203              		.loc 1 98 33 is_stmt 0 view .LVU65
 204 0032 3F23     		movs	r3, #63
 205 0034 A371     		strb	r3, [r4, #6]
  99:./block/partition.c ****     mbr_partition->end_cyl      = 0x01;
 206              		.loc 1 99 5 is_stmt 1 view .LVU66
 207              		.loc 1 99 33 is_stmt 0 view .LVU67
 208 0036 0123     		movs	r3, #1
 209 0038 E371     		strb	r3, [r4, #7]
 100:./block/partition.c ****     mbr_partition->start_lba = start_address;
 210              		.loc 1 100 5 is_stmt 1 view .LVU68
 211              		.loc 1 100 30 is_stmt 0 view .LVU69
 212 003a A660     		str	r6, [r4, #8]	@ unaligned
 101:./block/partition.c ****     mbr_partition->nr_sectors = size;
 213              		.loc 1 101 5 is_stmt 1 view .LVU70
 214              		.loc 1 101 31 is_stmt 0 view .LVU71
 215 003c E560     		str	r5, [r4, #12]	@ unaligned
 102:./block/partition.c **** }
 216              		.loc 1 102 1 view .LVU72
 217 003e 02B0     		add	sp, sp, #8
ARM GAS  /tmp/ccz04fb7.s 			page 27


 218              	.LCFI3:
 219              		.cfi_def_cfa_offset 24
 220              		@ sp needed
 221 0040 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 222              	.LVL11:
 223              	.L7:
 224              		.loc 1 102 1 view .LVU73
 225              		.align	2
 226              	.L6:
 227 0044 00000000 		.word	.LC0
 228              		.cfi_endproc
 229              	.LFE1042:
 231              		.section	.text.my_end_io,"ax",%progbits
 232              		.align	1
 233              		.syntax unified
 234              		.thumb
 235              		.thumb_func
 237              	my_end_io:
 238              	.LVL12:
 239              	.LFB1035:
  10:./block/partition.c ****     bio_put(bio);
 240              		.loc 1 10 39 is_stmt 1 view -0
 241              		.cfi_startproc
 242              		@ args = 0, pretend = 0, frame = 0
 243              		@ frame_needed = 0, uses_anonymous_args = 0
  10:./block/partition.c ****     bio_put(bio);
 244              		.loc 1 10 39 is_stmt 0 view .LVU75
 245 0000 08B5     		push	{r3, lr}
 246              	.LCFI4:
 247              		.cfi_def_cfa_offset 8
 248              		.cfi_offset 3, -8
 249              		.cfi_offset 14, -4
  11:./block/partition.c **** }
 250              		.loc 1 11 5 is_stmt 1 view .LVU76
 251 0002 FFF7FEFF 		bl	bio_put
 252              	.LVL13:
  12:./block/partition.c **** static char * trans_data_to_blk_dev(struct block_device *bdev, sector_t block, unsigned size, char 
 253              		.loc 1 12 1 is_stmt 0 view .LVU77
 254 0006 08BD     		pop	{r3, pc}
 255              		.cfi_endproc
 256              	.LFE1035:
 258              		.section	.text.trans_data_to_blk_dev,"ax",%progbits
 259              		.align	1
 260              		.syntax unified
 261              		.thumb
 262              		.thumb_func
 264              	trans_data_to_blk_dev:
 265              	.LVL14:
 266              	.LFB1036:
  13:./block/partition.c ****     struct page *page = virt_to_page((uint32_t)data);  
 267              		.loc 1 13 115 is_stmt 1 view -0
 268              		.cfi_startproc
 269              		@ args = 4, pretend = 0, frame = 0
 270              		@ frame_needed = 0, uses_anonymous_args = 0
  13:./block/partition.c ****     struct page *page = virt_to_page((uint32_t)data);  
 271              		.loc 1 13 115 is_stmt 0 view .LVU79
 272 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
ARM GAS  /tmp/ccz04fb7.s 			page 28


 273              	.LCFI5:
 274              		.cfi_def_cfa_offset 28
 275              		.cfi_offset 4, -28
 276              		.cfi_offset 5, -24
 277              		.cfi_offset 6, -20
 278              		.cfi_offset 7, -16
 279              		.cfi_offset 8, -12
 280              		.cfi_offset 9, -8
 281              		.cfi_offset 14, -4
 282 0004 83B0     		sub	sp, sp, #12
 283              	.LCFI6:
 284              		.cfi_def_cfa_offset 40
 285 0006 0646     		mov	r6, r0
 286 0008 8846     		mov	r8, r1
 287 000a 1746     		mov	r7, r2
 288 000c 1D46     		mov	r5, r3
  14:./block/partition.c ****     struct bio *bio = bio_alloc(bdev,1,mod,GFP_KERNEL);
 289              		.loc 1 14 5 is_stmt 1 view .LVU80
 290              	.LVL15:
 291              	.LBB77:
 292              	.LBI77:
 199:./include/linux/mm_type.h **** static inline void __page_destroy(struct page *page){
 200:./include/linux/mm_type.h ****     if (page) 
 201:./include/linux/mm_type.h **** 	{
 202:./include/linux/mm_type.h ****         kfree(page);
 203:./include/linux/mm_type.h **** 		page = NULL;
 204:./include/linux/mm_type.h ****     }
 205:./include/linux/mm_type.h **** }
 206:./include/linux/mm_type.h **** 
 207:./include/linux/mm_type.h **** 
 208:./include/linux/mm_type.h **** static inline void *__page_address(struct page *page){
 209:./include/linux/mm_type.h ****     return page ? page->zone_device_data : NULL; 
 210:./include/linux/mm_type.h **** }
 211:./include/linux/mm_type.h **** static inline void __set_page_dirty(struct page *page){
 212:./include/linux/mm_type.h ****     if (page)
 213:./include/linux/mm_type.h **** 	__set_page_flag(page, PG_dirty);
 214:./include/linux/mm_type.h **** }
 215:./include/linux/mm_type.h **** 
 216:./include/linux/mm_type.h **** static inline void __clear_page_dirty(struct page *page){
 217:./include/linux/mm_type.h ****     if (page)
 218:./include/linux/mm_type.h **** 	__clear_page_flag(page, PG_dirty);
 219:./include/linux/mm_type.h **** }
 220:./include/linux/mm_type.h **** 
 221:./include/linux/mm_type.h **** static inline struct page *__alloc_pages( gfp_t flags , unsigned int order ){
 222:./include/linux/mm_type.h **** 	struct page *page = __page_create(flags);
 223:./include/linux/mm_type.h **** 	if(page == NULL)
 224:./include/linux/mm_type.h **** 		return -ENOMEM ;
 225:./include/linux/mm_type.h **** 	void *data = (void *)kmalloc(PAGE_SIZE, flags);
 226:./include/linux/mm_type.h **** 	if(data == NULL){
 227:./include/linux/mm_type.h **** 		__page_destroy(page);
 228:./include/linux/mm_type.h **** 		return -ENOMEM ;
 229:./include/linux/mm_type.h **** 	}
 230:./include/linux/mm_type.h **** 	page->zone_device_data = data;
 231:./include/linux/mm_type.h **** 	return page;
 232:./include/linux/mm_type.h **** }
 233:./include/linux/mm_type.h **** 
 234:./include/linux/mm_type.h **** static inline void __free_pages(struct page *page, unsigned int order){
ARM GAS  /tmp/ccz04fb7.s 			page 29


 235:./include/linux/mm_type.h ****     if (page) {
 236:./include/linux/mm_type.h ****         __page_destroy(page);
 237:./include/linux/mm_type.h ****     }
 238:./include/linux/mm_type.h **** }
 239:./include/linux/mm_type.h **** 
 240:./include/linux/mm_type.h **** static inline struct page *__pfn_to_page(unsigned long pfn){
 293              		.loc 2 240 28 view .LVU81
 294              	.LBB78:
 241:./include/linux/mm_type.h **** 	struct page *page = __page_create(GFP_KERNEL);
 295              		.loc 2 241 2 view .LVU82
 296              		.loc 2 241 22 is_stmt 0 view .LVU83
 297 000e 4FF44C60 		mov	r0, #3264
 298              	.LVL16:
 299              		.loc 2 241 22 view .LVU84
 300 0012 FFF7FEFF 		bl	__page_create
 301              	.LVL17:
 242:./include/linux/mm_type.h **** 	if(page == NULL)
 302              		.loc 2 242 2 is_stmt 1 view .LVU85
 303              		.loc 2 242 4 is_stmt 0 view .LVU86
 304 0016 48B3     		cbz	r0, .L15
 305 0018 8146     		mov	r9, r0
 243:./include/linux/mm_type.h **** 		return -ENOMEM ;
 244:./include/linux/mm_type.h **** 	page->zone_device_data = (void *)(pfn << 0 );
 306              		.loc 2 244 2 is_stmt 1 view .LVU87
 307              		.loc 2 244 25 is_stmt 0 view .LVU88
 308 001a 4560     		str	r5, [r0, #4]
 245:./include/linux/mm_type.h **** 	return page;
 309              		.loc 2 245 2 is_stmt 1 view .LVU89
 310              	.L11:
 311              	.LVL18:
 312              		.loc 2 245 2 is_stmt 0 view .LVU90
 313              	.LBE78:
 314              	.LBE77:
  15:./block/partition.c ****     bio_set_dev(bio,bdev);                                           //
 315              		.loc 1 15 5 is_stmt 1 view .LVU91
 316              	.LBB80:
 317              	.LBI80:
 318              		.file 6 "./include/linux/bio.h"
   1:./include/linux/bio.h **** #ifndef _LINUX_BIO_H
   2:./include/linux/bio.h **** #define _LINUX_BIO_H
   3:./include/linux/bio.h **** 
   4:./include/linux/bio.h **** #include <linux/blk_types.h>
   5:./include/linux/bio.h **** #include <linux/slab.h>
   6:./include/linux/bio.h **** #include <linux/mempool.h>
   7:./include/linux/bio.h **** #include <linux/workqueue_types.h>
   8:./include/linux/bio.h **** 
   9:./include/linux/bio.h **** /* struct bio, bio_vec and BIO_* flags are defined in blk_types.h */
  10:./include/linux/bio.h **** #include <linux/uio.h>
  11:./include/linux/bio.h **** #include <linux/bvec.h>
  12:./include/linux/bio.h **** #include <linux/atomic.h>
  13:./include/linux/bio.h **** 
  14:./include/linux/bio.h **** struct bio ;
  15:./include/linux/bio.h **** 
  16:./include/linux/bio.h **** #define page_address(x) x
  17:./include/linux/bio.h **** 
  18:./include/linux/bio.h **** #define BIO_MAX_VECS		256u
  19:./include/linux/bio.h **** 
ARM GAS  /tmp/ccz04fb7.s 			page 30


  20:./include/linux/bio.h **** struct queue_limits;
  21:./include/linux/bio.h **** 
  22:./include/linux/bio.h **** static inline unsigned int bio_max_segs(unsigned int nr_segs)
  23:./include/linux/bio.h **** {
  24:./include/linux/bio.h **** 	return min(nr_segs, BIO_MAX_VECS);
  25:./include/linux/bio.h **** }
  26:./include/linux/bio.h **** 
  27:./include/linux/bio.h **** #define bio_prio(bio)			(bio)->bi_ioprio
  28:./include/linux/bio.h **** #define bio_set_prio(bio, prio)		((bio)->bi_ioprio = prio)
  29:./include/linux/bio.h **** 
  30:./include/linux/bio.h **** #define bio_iter_iovec(bio, iter)				\
  31:./include/linux/bio.h **** 	bvec_iter_bvec((bio)->bi_io_vec, (iter))
  32:./include/linux/bio.h **** 
  33:./include/linux/bio.h **** #define bio_iter_page(bio, iter)				\
  34:./include/linux/bio.h **** 	bvec_iter_page((bio)->bi_io_vec, (iter))
  35:./include/linux/bio.h **** #define bio_iter_len(bio, iter)					\
  36:./include/linux/bio.h **** 	bvec_iter_len((bio)->bi_io_vec, (iter))
  37:./include/linux/bio.h **** #define bio_iter_offset(bio, iter)				\
  38:./include/linux/bio.h **** 	bvec_iter_offset((bio)->bi_io_vec, (iter))
  39:./include/linux/bio.h **** 
  40:./include/linux/bio.h **** 
  41:./include/linux/bio.h **** #define bio_page(bio)		bio_iter_page((bio), (bio)->bi_iter)
  42:./include/linux/bio.h **** #define bio_offset(bio)		bio_iter_offset((bio), (bio)->bi_iter)
  43:./include/linux/bio.h **** #define bio_iovec(bio)		bio_iter_iovec((bio), (bio)->bi_iter)
  44:./include/linux/bio.h **** 
  45:./include/linux/bio.h **** #define bvec_iter_sectors(iter)	((iter).bi_size >> 9)
  46:./include/linux/bio.h **** #define bvec_iter_end_sector(iter) ((iter).bi_sector + bvec_iter_sectors((iter)))
  47:./include/linux/bio.h **** 
  48:./include/linux/bio.h **** #define bio_sectors(bio)	bvec_iter_sectors((bio)->bi_iter)
  49:./include/linux/bio.h **** #define bio_end_sector(bio)	bvec_iter_end_sector((bio)->bi_iter)
  50:./include/linux/bio.h **** 
  51:./include/linux/bio.h **** /*
  52:./include/linux/bio.h ****  * Return the data direction, READ or WRITE.
  53:./include/linux/bio.h ****  */
  54:./include/linux/bio.h **** #define bio_data_dir(bio) \
  55:./include/linux/bio.h **** 	(op_is_write(bio_op(bio)) ? WRITE : READ)
  56:./include/linux/bio.h **** 
  57:./include/linux/bio.h **** 
  58:./include/linux/bio.h **** /*
  59:./include/linux/bio.h ****  * Check whether this bio carries any data or not. A NULL bio is allowed.
  60:./include/linux/bio.h ****  */
  61:./include/linux/bio.h **** static inline bool bio_has_data(struct bio *bio)
  62:./include/linux/bio.h **** {
  63:./include/linux/bio.h **** 	if (bio &&
  64:./include/linux/bio.h **** 	    bio->bi_iter.bi_size &&
  65:./include/linux/bio.h **** 	    bio_op(bio) != REQ_OP_DISCARD &&
  66:./include/linux/bio.h **** 	    bio_op(bio) != REQ_OP_SECURE_ERASE &&
  67:./include/linux/bio.h **** 	    bio_op(bio) != REQ_OP_WRITE_ZEROES)
  68:./include/linux/bio.h **** 		return true;
  69:./include/linux/bio.h **** 
  70:./include/linux/bio.h **** 	return false;
  71:./include/linux/bio.h **** }
  72:./include/linux/bio.h **** 
  73:./include/linux/bio.h **** static inline bool bio_no_advance_iter(const struct bio *bio)
  74:./include/linux/bio.h **** {
  75:./include/linux/bio.h **** 	return bio_op(bio) == REQ_OP_DISCARD ||
  76:./include/linux/bio.h **** 	       bio_op(bio) == REQ_OP_SECURE_ERASE ||
ARM GAS  /tmp/ccz04fb7.s 			page 31


  77:./include/linux/bio.h **** 	       bio_op(bio) == REQ_OP_WRITE_ZEROES;
  78:./include/linux/bio.h **** }
  79:./include/linux/bio.h **** 
  80:./include/linux/bio.h **** 
  81:./include/linux/bio.h **** static inline void * bio_data(struct bio *bio)
  82:./include/linux/bio.h **** {
  83:./include/linux/bio.h **** 	#if (MMU == _ENABLE_)
  84:./include/linux/bio.h **** 	if (bio_has_data(bio)){
  85:./include/linux/bio.h **** 		return page_address(bio_page(bio)) + bio_offset(bio);		
  86:./include/linux/bio.h **** 	}
  87:./include/linux/bio.h **** 	#else
  88:./include/linux/bio.h **** 		struct bio_vec *bv = &bio->bi_io_vec[bio->bi_iter.bi_idx];
  89:./include/linux/bio.h **** 		return kmap(bv->bv_page);
  90:./include/linux/bio.h **** 	#endif	
  91:./include/linux/bio.h **** 	return NULL;
  92:./include/linux/bio.h **** }
  93:./include/linux/bio.h **** 
  94:./include/linux/bio.h **** 
  95:./include/linux/bio.h **** 	
  96:./include/linux/bio.h **** 
  97:./include/linux/bio.h **** 
  98:./include/linux/bio.h **** 
  99:./include/linux/bio.h **** 
 100:./include/linux/bio.h **** static inline bool bio_flagged(struct bio *bio, unsigned int bit)
 101:./include/linux/bio.h **** {
 102:./include/linux/bio.h **** 	return bio->bi_flags & (1U << bit);
 103:./include/linux/bio.h **** }
 104:./include/linux/bio.h **** 
 105:./include/linux/bio.h **** static inline void bio_set_flag(struct bio *bio, unsigned int bit)
 106:./include/linux/bio.h **** {
 107:./include/linux/bio.h **** 	bio->bi_flags |= (1U << bit);
 108:./include/linux/bio.h **** }
 109:./include/linux/bio.h **** 
 110:./include/linux/bio.h **** static inline void bio_clear_flag(struct bio *bio, unsigned int bit)
 111:./include/linux/bio.h **** {
 112:./include/linux/bio.h **** 	bio->bi_flags &= ~(1U << bit);
 113:./include/linux/bio.h **** }
 114:./include/linux/bio.h **** 
 115:./include/linux/bio.h **** /**
 116:./include/linux/bio.h ****  * struct folio_iter - State for iterating all folios in a bio.
 117:./include/linux/bio.h ****  * @folio: The current folio we're iterating.  NULL after the last folio.
 118:./include/linux/bio.h ****  * @offset: The byte offset within the current folio.
 119:./include/linux/bio.h ****  * @length: The number of bytes in this iteration (will not cross folio
 120:./include/linux/bio.h ****  *	boundary).
 121:./include/linux/bio.h ****  */
 122:./include/linux/bio.h **** struct folio_iter {
 123:./include/linux/bio.h **** 	struct folio *folio;
 124:./include/linux/bio.h **** 	size_t offset;
 125:./include/linux/bio.h **** 	size_t length;
 126:./include/linux/bio.h **** 	/* private: for use by the iterator */
 127:./include/linux/bio.h **** 	struct folio *_next;
 128:./include/linux/bio.h **** 	size_t _seg_count;
 129:./include/linux/bio.h **** 	int _i;
 130:./include/linux/bio.h **** };
 131:./include/linux/bio.h **** 
 132:./include/linux/bio.h **** 
 133:./include/linux/bio.h **** 
ARM GAS  /tmp/ccz04fb7.s 			page 32


 134:./include/linux/bio.h **** void submit_bio(struct bio *bio);
 135:./include/linux/bio.h **** void submit_bio_wait(struct bio *bio);
 136:./include/linux/bio.h **** 
 137:./include/linux/bio.h **** int __must_check bio_add_page(struct bio *bio, struct page *page,
 138:./include/linux/bio.h ****     unsigned int len, unsigned int offset);
 139:./include/linux/bio.h **** 
 140:./include/linux/bio.h **** int __bio_add_page(struct bio *bio, struct page *page,
 141:./include/linux/bio.h ****     unsigned int len, unsigned int off);
 142:./include/linux/bio.h **** 
 143:./include/linux/bio.h **** extern struct bio_set fs_bio_set;
 144:./include/linux/bio.h **** 
 145:./include/linux/bio.h **** struct bio *bio_alloc_bioset(struct block_device *bdev, unsigned short nr_iovecs,
 146:./include/linux/bio.h ****     blk_opf_t opf, gfp_t gfp_mask,
 147:./include/linux/bio.h ****     struct bio_set *bs);
 148:./include/linux/bio.h **** 
 149:./include/linux/bio.h **** static inline struct bio *bio_alloc(struct block_device	*bi_bdev,
 319              		.loc 6 149 27 view .LVU92
 320              	.LBB81:
 150:./include/linux/bio.h **** 		 unsigned short nr_iovecs , blk_opf_t opf, gfp_t gfp_mask)
 151:./include/linux/bio.h **** {
 152:./include/linux/bio.h **** 	return bio_alloc_bioset(bi_bdev,nr_iovecs,opf,gfp_mask,&fs_bio_set);
 321              		.loc 6 152 2 view .LVU93
 322              		.loc 6 152 9 is_stmt 0 view .LVU94
 323 001c 174B     		ldr	r3, .L18
 324 001e 0093     		str	r3, [sp]
 325 0020 4FF44C63 		mov	r3, #3264
 326 0024 0A9A     		ldr	r2, [sp, #40]
 327 0026 0121     		movs	r1, #1
 328 0028 3046     		mov	r0, r6
 329 002a FFF7FEFF 		bl	bio_alloc_bioset
 330              	.LVL19:
 331 002e 0446     		mov	r4, r0
 332              	.LVL20:
 333              		.loc 6 152 9 view .LVU95
 334              	.LBE81:
 335              	.LBE80:
  16:./block/partition.c ****     bio->bi_iter.bi_sector = block;
 336              		.loc 1 16 5 is_stmt 1 view .LVU96
 337              	.LBB82:
 338              	.LBI82:
 153:./include/linux/bio.h **** }
 154:./include/linux/bio.h **** 
 155:./include/linux/bio.h **** extern void bio_put(struct bio *);
 156:./include/linux/bio.h **** 
 157:./include/linux/bio.h **** 
 158:./include/linux/bio.h **** 
 159:./include/linux/bio.h **** static inline void bio_associate_blkg(struct bio *bio) { }
 160:./include/linux/bio.h **** 
 161:./include/linux/bio.h **** static inline void bio_set_dev(struct bio *bio, struct block_device *bdev)
 339              		.loc 6 161 20 view .LVU97
 340              	.LBB83:
 162:./include/linux/bio.h **** {
 163:./include/linux/bio.h **** 	bio_clear_flag(bio, BIO_REMAPPED);
 341              		.loc 6 163 2 view .LVU98
 342              	.LBB84:
 343              	.LBI84:
 110:./include/linux/bio.h **** {
ARM GAS  /tmp/ccz04fb7.s 			page 33


 344              		.loc 6 110 20 view .LVU99
 345              	.LBB85:
 112:./include/linux/bio.h **** }
 346              		.loc 6 112 2 view .LVU100
 112:./include/linux/bio.h **** }
 347              		.loc 6 112 5 is_stmt 0 view .LVU101
 348 0030 8389     		ldrh	r3, [r0, #12]
 112:./include/linux/bio.h **** }
 349              		.loc 6 112 16 view .LVU102
 350 0032 23F40062 		bic	r2, r3, #2048
 351 0036 8281     		strh	r2, [r0, #12]	@ movhi
 352              	.LVL21:
 112:./include/linux/bio.h **** }
 353              		.loc 6 112 16 view .LVU103
 354              	.LBE85:
 355              	.LBE84:
 164:./include/linux/bio.h **** 	if (bio->bi_bdev != bdev)
 356              		.loc 6 164 2 is_stmt 1 view .LVU104
 357              		.loc 6 164 9 is_stmt 0 view .LVU105
 358 0038 4268     		ldr	r2, [r0, #4]
 359              		.loc 6 164 5 view .LVU106
 360 003a 9642     		cmp	r6, r2
 361 003c 02D0     		beq	.L12
 165:./include/linux/bio.h **** 		bio_clear_flag(bio, BIO_BPS_THROTTLED);
 362              		.loc 6 165 3 is_stmt 1 view .LVU107
 363              	.LVL22:
 364              	.LBB86:
 365              	.LBI86:
 110:./include/linux/bio.h **** {
 366              		.loc 6 110 20 view .LVU108
 367              	.LBB87:
 112:./include/linux/bio.h **** }
 368              		.loc 6 112 2 view .LVU109
 112:./include/linux/bio.h **** }
 369              		.loc 6 112 16 is_stmt 0 view .LVU110
 370 003e 23F40463 		bic	r3, r3, #2112
 371 0042 8381     		strh	r3, [r0, #12]	@ movhi
 372              	.LVL23:
 373              	.L12:
 112:./include/linux/bio.h **** }
 374              		.loc 6 112 16 view .LVU111
 375              	.LBE87:
 376              	.LBE86:
 166:./include/linux/bio.h **** 	bio->bi_bdev = bdev;
 377              		.loc 6 166 2 is_stmt 1 view .LVU112
 378              		.loc 6 166 15 is_stmt 0 view .LVU113
 379 0044 6660     		str	r6, [r4, #4]
 167:./include/linux/bio.h **** 	bio_associate_blkg(bio);
 380              		.loc 6 167 2 is_stmt 1 view .LVU114
 381              	.LVL24:
 382              		.loc 6 167 2 is_stmt 0 view .LVU115
 383              	.LBE83:
 384              	.LBE82:
  17:./block/partition.c ****     bio->bi_end_io = my_end_io;
 385              		.loc 1 17 5 is_stmt 1 view .LVU116
  17:./block/partition.c ****     bio->bi_end_io = my_end_io;
 386              		.loc 1 17 28 is_stmt 0 view .LVU117
ARM GAS  /tmp/ccz04fb7.s 			page 34


 387 0046 C4F81880 		str	r8, [r4, #24]
  18:./block/partition.c ****     if(bio_add_page(bio, page, size, offset_in_page(data)) < 0 ){
 388              		.loc 1 18 5 is_stmt 1 view .LVU118
  18:./block/partition.c ****     if(bio_add_page(bio, page, size, offset_in_page(data)) < 0 ){
 389              		.loc 1 18 20 is_stmt 0 view .LVU119
 390 004a 0D4B     		ldr	r3, .L18+4
 391 004c E362     		str	r3, [r4, #44]
  19:./block/partition.c ****         bio_put(bio);
 392              		.loc 1 19 5 is_stmt 1 view .LVU120
  19:./block/partition.c ****         bio_put(bio);
 393              		.loc 1 19 8 is_stmt 0 view .LVU121
 394 004e 0023     		movs	r3, #0
 395 0050 3A46     		mov	r2, r7
 396 0052 4946     		mov	r1, r9
 397 0054 2046     		mov	r0, r4
 398              	.LVL25:
  19:./block/partition.c ****         bio_put(bio);
 399              		.loc 1 19 8 view .LVU122
 400 0056 FFF7FEFF 		bl	bio_add_page
 401              	.LVL26:
  19:./block/partition.c ****         bio_put(bio);
 402              		.loc 1 19 7 discriminator 1 view .LVU123
 403 005a 0028     		cmp	r0, #0
 404 005c 09DB     		blt	.L17
  23:./block/partition.c ****     return data;
 405              		.loc 1 23 5 is_stmt 1 view .LVU124
 406 005e 2046     		mov	r0, r4
 407 0060 FFF7FEFF 		bl	submit_bio_wait
 408              	.LVL27:
  24:./block/partition.c **** }
 409              		.loc 1 24 5 view .LVU125
  24:./block/partition.c **** }
 410              		.loc 1 24 12 is_stmt 0 view .LVU126
 411 0064 2846     		mov	r0, r5
 412              	.L10:
  25:./block/partition.c **** 
 413              		.loc 1 25 1 view .LVU127
 414 0066 03B0     		add	sp, sp, #12
 415              	.LCFI7:
 416              		.cfi_remember_state
 417              		.cfi_def_cfa_offset 28
 418              		@ sp needed
 419 0068 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 420              	.LVL28:
 421              	.L15:
 422              	.LCFI8:
 423              		.cfi_restore_state
 424              	.LBB88:
 425              	.LBB79:
 243:./include/linux/mm_type.h **** 	page->zone_device_data = (void *)(pfn << 0 );
 426              		.loc 2 243 10 view .LVU128
 427 006c 6FF00B09 		mvn	r9, #11
 428 0070 D4E7     		b	.L11
 429              	.LVL29:
 430              	.L17:
 243:./include/linux/mm_type.h **** 	page->zone_device_data = (void *)(pfn << 0 );
 431              		.loc 2 243 10 view .LVU129
ARM GAS  /tmp/ccz04fb7.s 			page 35


 432              	.LBE79:
 433              	.LBE88:
  20:./block/partition.c ****         return NULL;
 434              		.loc 1 20 9 is_stmt 1 view .LVU130
 435 0072 2046     		mov	r0, r4
 436 0074 FFF7FEFF 		bl	bio_put
 437              	.LVL30:
  21:./block/partition.c ****     }
 438              		.loc 1 21 9 view .LVU131
  21:./block/partition.c ****     }
 439              		.loc 1 21 16 is_stmt 0 view .LVU132
 440 0078 0020     		movs	r0, #0
 441 007a F4E7     		b	.L10
 442              	.L19:
 443              		.align	2
 444              	.L18:
 445 007c 00000000 		.word	fs_bio_set
 446 0080 00000000 		.word	my_end_io
 447              		.cfi_endproc
 448              	.LFE1036:
 450              		.section	.rodata.mbr_partition_table_load.str1.4,"aMS",%progbits,1
 451              		.align	2
 452              	.LC1:
 453 0000 6E6F206D 		.ascii	"no memory,need size %d\012\000"
 453      656D6F72 
 453      792C6E65 
 453      65642073 
 453      697A6520 
 454              		.align	2
 455              	.LC2:
 456 0018 63616E20 		.ascii	"can not get data from disk\012\000"
 456      6E6F7420 
 456      67657420 
 456      64617461 
 456      2066726F 
 457              		.section	.text.mbr_partition_table_load,"ax",%progbits
 458              		.align	1
 459              		.syntax unified
 460              		.thumb
 461              		.thumb_func
 463              	mbr_partition_table_load:
 464              	.LVL31:
 465              	.LFB1051:
 103:./block/partition.c **** 
 104:./block/partition.c **** static uint32_t get_mbr_partition_size(struct partition *partition,int number){
 105:./block/partition.c ****     if(number < 0 || number > 3)
 106:./block/partition.c ****         return INVALID_PARTITION;
 107:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 108:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 109:./block/partition.c ****         return INVALID_PARTITION;
 110:./block/partition.c ****     return mbr_partition->nr_sectors;
 111:./block/partition.c **** }
 112:./block/partition.c **** 
 113:./block/partition.c **** static uint32_t get_mbr_partition_start_address(struct partition *partition,int number){
 114:./block/partition.c ****     if(number < 0 || number > 3)
 115:./block/partition.c ****         return INVALID_PARTITION;
 116:./block/partition.c ****     
ARM GAS  /tmp/ccz04fb7.s 			page 36


 117:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 118:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1){
 119:./block/partition.c ****          printk("This is a empty partition table slot\n\r");
 120:./block/partition.c ****          return INVALID_PARTITION;
 121:./block/partition.c ****     }
 122:./block/partition.c ****     return mbr_partition->start_lba;
 123:./block/partition.c **** }
 124:./block/partition.c **** 
 125:./block/partition.c **** static uint8_t get_mbr_partition_type(struct partition *partition,int number){
 126:./block/partition.c ****     if(number < 0 || number > 3)
 127:./block/partition.c ****         return 0xff;
 128:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 129:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 130:./block/partition.c ****         return 0xff;
 131:./block/partition.c ****     return mbr_partition->sys_ind;
 132:./block/partition.c **** }
 133:./block/partition.c **** 
 134:./block/partition.c **** static int set_mbr_partition_size(struct partition *partition,int number,uint32_t size)
 135:./block/partition.c **** {
 136:./block/partition.c ****     if(number < 0 || number > 3)
 137:./block/partition.c ****         return -1;
 138:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 139:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 140:./block/partition.c ****         return -1;
 141:./block/partition.c ****     mbr_partition->nr_sectors = size;
 142:./block/partition.c ****     return 0;
 143:./block/partition.c **** }
 144:./block/partition.c **** 
 145:./block/partition.c **** static int set_mbr_partition_start_address(struct partition *partition,int number,uint32_t start_ad
 146:./block/partition.c **** {
 147:./block/partition.c ****     if(number < 0 || number > 3)
 148:./block/partition.c ****         return -1;
 149:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 150:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 151:./block/partition.c ****         return -1;
 152:./block/partition.c ****     mbr_partition->start_lba = start_address;
 153:./block/partition.c ****     return 0;
 154:./block/partition.c **** }
 155:./block/partition.c **** 
 156:./block/partition.c **** static int set_mbr_partition_type(struct partition *partition,int number,uint8_t type)
 157:./block/partition.c **** {
 158:./block/partition.c ****     if(number < 0 || number > 3)
 159:./block/partition.c ****         return -1;
 160:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 161:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 162:./block/partition.c ****         return -1;
 163:./block/partition.c ****     mbr_partition->sys_ind = type;
 164:./block/partition.c ****     return 0;
 165:./block/partition.c **** }
 166:./block/partition.c **** 
 167:./block/partition.c **** static void move_MBR_Table(struct mbr_partition *from ,struct mbr_partition *to)
 168:./block/partition.c **** {
 169:./block/partition.c ****     memcpy(to, from, sizeof(struct mbr_partition));
 170:./block/partition.c ****     memset(from, 0x00, sizeof(struct mbr_partition));
 171:./block/partition.c **** }
 172:./block/partition.c **** 
 173:./block/partition.c **** static void tidy_up_MBR_Table(struct partition *partition)
ARM GAS  /tmp/ccz04fb7.s 			page 37


 174:./block/partition.c **** {
 175:./block/partition.c ****     uint8_t state[4];
 176:./block/partition.c ****     for(int i = 0; i < 4; i++)
 177:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 178:./block/partition.c **** 
 179:./block/partition.c ****     for(int j = 0; j < 3; j++){
 180:./block/partition.c ****         for(int k = 0; k < 3; k++){
 181:./block/partition.c ****             if(state[k] == 0 && state[k+1] == 1){
 182:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 183:./block/partition.c ****                 state[k]   = 1;
 184:./block/partition.c ****                 state[k+1] = 0;
 185:./block/partition.c ****             }
 186:./block/partition.c ****         }
 187:./block/partition.c ****     }
 188:./block/partition.c **** }
 189:./block/partition.c **** 
 190:./block/partition.c **** static int mbr_partition_table_load(struct block_device *device,struct partition *partition) 
 191:./block/partition.c **** {
 466              		.loc 1 191 1 is_stmt 1 view -0
 467              		.cfi_startproc
 468              		@ args = 0, pretend = 0, frame = 0
 469              		@ frame_needed = 0, uses_anonymous_args = 0
 192:./block/partition.c ****     if (device == NULL || partition == NULL) return -1;
 470              		.loc 1 192 5 view .LVU134
 471              		.loc 1 192 8 is_stmt 0 view .LVU135
 472 0000 0028     		cmp	r0, #0
 473 0002 46D0     		beq	.L27
 191:./block/partition.c ****     if (device == NULL || partition == NULL) return -1;
 474              		.loc 1 191 1 view .LVU136
 475 0004 70B5     		push	{r4, r5, r6, lr}
 476              	.LCFI9:
 477              		.cfi_def_cfa_offset 16
 478              		.cfi_offset 4, -16
 479              		.cfi_offset 5, -12
 480              		.cfi_offset 6, -8
 481              		.cfi_offset 14, -4
 482 0006 82B0     		sub	sp, sp, #8
 483              	.LCFI10:
 484              		.cfi_def_cfa_offset 24
 485 0008 0C46     		mov	r4, r1
 486 000a 0646     		mov	r6, r0
 487              		.loc 1 192 24 discriminator 2 view .LVU137
 488 000c 0029     		cmp	r1, #0
 489 000e 43D0     		beq	.L28
 193:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 490              		.loc 1 193 5 is_stmt 1 view .LVU138
 491              	.LVL32:
 492              	.LBB89:
 493              	.LBI89:
 379:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 494              		.loc 3 379 21 view .LVU139
 495              	.LBB90:
 496              		.loc 3 380 2 view .LVU140
 497              		.loc 3 380 9 is_stmt 0 view .LVU141
 498 0010 4FF44C61 		mov	r1, #3264
 499              	.LVL33:
 500              		.loc 3 380 9 view .LVU142
ARM GAS  /tmp/ccz04fb7.s 			page 38


 501 0014 4FF40070 		mov	r0, #512
 502              	.LVL34:
 503              		.loc 3 380 9 view .LVU143
 504 0018 FFF7FEFF 		bl	__smalloc__
 505              	.LVL35:
 506              		.loc 3 380 9 view .LVU144
 507              	.LBE90:
 508              	.LBE89:
 194:./block/partition.c ****     if(data == NULL){
 509              		.loc 1 194 5 is_stmt 1 view .LVU145
 510              		.loc 1 194 7 is_stmt 0 view .LVU146
 511 001c 0546     		mov	r5, r0
 512 001e F0B1     		cbz	r0, .L33
 195:./block/partition.c ****         printk(KERN_INFO "no memory,need size %d\n",512);
 196:./block/partition.c ****          return -1;
 197:./block/partition.c ****     }
 198:./block/partition.c ****     if(trans_data_to_blk_dev(device,0,512,data,REQ_OP_READ) == NULL){
 513              		.loc 1 198 5 is_stmt 1 view .LVU147
 514              		.loc 1 198 8 is_stmt 0 view .LVU148
 515 0020 0021     		movs	r1, #0
 516 0022 0091     		str	r1, [sp]
 517 0024 0346     		mov	r3, r0
 518 0026 4FF40072 		mov	r2, #512
 519 002a 3046     		mov	r0, r6
 520              	.LVL36:
 521              		.loc 1 198 8 view .LVU149
 522 002c FFF7FEFF 		bl	trans_data_to_blk_dev
 523              	.LVL37:
 524              		.loc 1 198 7 discriminator 1 view .LVU150
 525 0030 E8B1     		cbz	r0, .L34
 199:./block/partition.c ****         printk(KERN_INFO "can not get data from disk\n");
 200:./block/partition.c ****         kfree(data);
 201:./block/partition.c ****         return -1;
 202:./block/partition.c ****     }
 203:./block/partition.c ****     memcpy(&partition->mbr_partition[0] , data + 446, sizeof(struct mbr_partition)*4); // 
 526              		.loc 1 203 5 is_stmt 1 view .LVU151
 527              		.loc 1 203 48 is_stmt 0 view .LVU152
 528 0032 05F5DF73 		add	r3, r5, #446
 529              		.loc 1 203 5 view .LVU153
 530 0036 04F57971 		add	r1, r4, #996
 531 003a 05F5FF7E 		add	lr, r5, #510
 532              	.LVL38:
 533              	.L24:
 534              		.loc 1 203 5 view .LVU154
 535 003e D3F800C0 		ldr	ip, [r3]	@ unaligned
 536 0042 5C68     		ldr	r4, [r3, #4]	@ unaligned
 537 0044 9868     		ldr	r0, [r3, #8]	@ unaligned
 538 0046 DA68     		ldr	r2, [r3, #12]	@ unaligned
 539 0048 C1F800C0 		str	ip, [r1]	@ unaligned
 540 004c 4C60     		str	r4, [r1, #4]	@ unaligned
 541 004e 8860     		str	r0, [r1, #8]	@ unaligned
 542 0050 CA60     		str	r2, [r1, #12]	@ unaligned
 543 0052 1033     		adds	r3, r3, #16
 544 0054 1031     		adds	r1, r1, #16
 545 0056 7345     		cmp	r3, lr
 546 0058 F1D1     		bne	.L24
 204:./block/partition.c ****     for(int i =0;i<4;i++){
ARM GAS  /tmp/ccz04fb7.s 			page 39


 547              		.loc 1 204 5 is_stmt 1 view .LVU155
 548              	.LBB91:
 549              		.loc 1 204 9 view .LVU156
 550              	.LVL39:
 551              		.loc 1 204 13 is_stmt 0 view .LVU157
 552 005a 0023     		movs	r3, #0
 553              		.loc 1 204 5 view .LVU158
 554 005c 11E0     		b	.L25
 555              	.LVL40:
 556              	.L33:
 557              		.loc 1 204 5 view .LVU159
 558              	.LBE91:
 195:./block/partition.c ****         printk(KERN_INFO "no memory,need size %d\n",512);
 559              		.loc 1 195 9 is_stmt 1 view .LVU160
 560 005e 4FF40071 		mov	r1, #512
 561 0062 0F48     		ldr	r0, .L35
 562              	.LVL41:
 195:./block/partition.c ****         printk(KERN_INFO "no memory,need size %d\n",512);
 563              		.loc 1 195 9 is_stmt 0 view .LVU161
 564 0064 FFF7FEFF 		bl	printk
 565              	.LVL42:
 196:./block/partition.c ****     }
 566              		.loc 1 196 10 is_stmt 1 view .LVU162
 196:./block/partition.c ****     }
 567              		.loc 1 196 17 is_stmt 0 view .LVU163
 568 0068 4FF0FF30 		mov	r0, #-1
 569 006c 0FE0     		b	.L20
 570              	.L34:
 199:./block/partition.c ****         printk(KERN_INFO "can not get data from disk\n");
 571              		.loc 1 199 9 is_stmt 1 view .LVU164
 572 006e 0D48     		ldr	r0, .L35+4
 573 0070 FFF7FEFF 		bl	printk
 574              	.LVL43:
 200:./block/partition.c ****         return -1;
 575              		.loc 1 200 9 view .LVU165
 576              	.LBB92:
 577              	.LBI92:
 381:./include/linux/slab.h **** }
 382:./include/linux/slab.h **** 
 383:./include/linux/slab.h **** static void inline kfree(const void *ptr){
 578              		.loc 3 383 20 view .LVU166
 579              	.LBB93:
 384:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 580              		.loc 3 384 2 view .LVU167
 581 0074 2846     		mov	r0, r5
 582 0076 FFF7FEFF 		bl	__sfree__
 583              	.LVL44:
 584              		.loc 3 384 2 is_stmt 0 view .LVU168
 585              	.LBE93:
 586              	.LBE92:
 201:./block/partition.c ****     }
 587              		.loc 1 201 9 is_stmt 1 view .LVU169
 201:./block/partition.c ****     }
 588              		.loc 1 201 16 is_stmt 0 view .LVU170
 589 007a 4FF0FF30 		mov	r0, #-1
 590 007e 06E0     		b	.L20
 591              	.LVL45:
ARM GAS  /tmp/ccz04fb7.s 			page 40


 592              	.L26:
 593              	.LBB94:
 205:./block/partition.c ****         MBR_partition_table_fix_endian(&partition->mbr_partition[i]);
 594              		.loc 1 205 9 is_stmt 1 view .LVU171
 204:./block/partition.c ****         MBR_partition_table_fix_endian(&partition->mbr_partition[i]);
 595              		.loc 1 204 23 discriminator 3 view .LVU172
 596 0080 0133     		adds	r3, r3, #1
 597              	.LVL46:
 598              	.L25:
 204:./block/partition.c ****         MBR_partition_table_fix_endian(&partition->mbr_partition[i]);
 599              		.loc 1 204 19 discriminator 1 view .LVU173
 600 0082 032B     		cmp	r3, #3
 601 0084 FCDD     		ble	.L26
 602              	.LBE94:
 206:./block/partition.c ****     }
 207:./block/partition.c ****     kfree(data);
 603              		.loc 1 207 5 view .LVU174
 604              	.LVL47:
 605              	.LBB95:
 606              	.LBI95:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 607              		.loc 3 383 20 view .LVU175
 608              	.LBB96:
 609              		.loc 3 384 2 view .LVU176
 610 0086 2846     		mov	r0, r5
 611 0088 FFF7FEFF 		bl	__sfree__
 612              	.LVL48:
 613              		.loc 3 384 2 is_stmt 0 view .LVU177
 614              	.LBE96:
 615              	.LBE95:
 208:./block/partition.c ****     return 0;
 616              		.loc 1 208 5 is_stmt 1 view .LVU178
 617              		.loc 1 208 12 is_stmt 0 view .LVU179
 618 008c 0020     		movs	r0, #0
 619              	.LVL49:
 620              	.L20:
 209:./block/partition.c **** }
 621              		.loc 1 209 1 view .LVU180
 622 008e 02B0     		add	sp, sp, #8
 623              	.LCFI11:
 624              		.cfi_def_cfa_offset 16
 625              		@ sp needed
 626 0090 70BD     		pop	{r4, r5, r6, pc}
 627              	.LVL50:
 628              	.L27:
 629              	.LCFI12:
 630              		.cfi_def_cfa_offset 0
 631              		.cfi_restore 4
 632              		.cfi_restore 5
 633              		.cfi_restore 6
 634              		.cfi_restore 14
 192:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 635              		.loc 1 192 53 discriminator 3 view .LVU181
 636 0092 4FF0FF30 		mov	r0, #-1
 637              	.LVL51:
 638              		.loc 1 209 1 view .LVU182
 639 0096 7047     		bx	lr
ARM GAS  /tmp/ccz04fb7.s 			page 41


 640              	.LVL52:
 641              	.L28:
 642              	.LCFI13:
 643              		.cfi_def_cfa_offset 24
 644              		.cfi_offset 4, -16
 645              		.cfi_offset 5, -12
 646              		.cfi_offset 6, -8
 647              		.cfi_offset 14, -4
 192:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 648              		.loc 1 192 53 discriminator 3 view .LVU183
 649 0098 4FF0FF30 		mov	r0, #-1
 650              	.LVL53:
 192:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 651              		.loc 1 192 53 discriminator 3 view .LVU184
 652 009c F7E7     		b	.L20
 653              	.L36:
 654 009e 00BF     		.align	2
 655              	.L35:
 656 00a0 00000000 		.word	.LC1
 657 00a4 18000000 		.word	.LC2
 658              		.cfi_endproc
 659              	.LFE1051:
 661              		.section	.text.mbr_partition_table_update,"ax",%progbits
 662              		.align	1
 663              		.syntax unified
 664              		.thumb
 665              		.thumb_func
 667              	mbr_partition_table_update:
 668              	.LVL54:
 669              	.LFB1052:
 210:./block/partition.c **** 
 211:./block/partition.c **** static int mbr_partition_table_update(struct block_device *device,struct partition *partition) 
 212:./block/partition.c **** {
 670              		.loc 1 212 1 is_stmt 1 view -0
 671              		.cfi_startproc
 672              		@ args = 0, pretend = 0, frame = 0
 673              		@ frame_needed = 0, uses_anonymous_args = 0
 213:./block/partition.c ****     if(device == NULL || partition == NULL) return -1;
 674              		.loc 1 213 5 view .LVU186
 675              		.loc 1 213 7 is_stmt 0 view .LVU187
 676 0000 0028     		cmp	r0, #0
 677 0002 44D0     		beq	.L43
 212:./block/partition.c ****     if(device == NULL || partition == NULL) return -1;
 678              		.loc 1 212 1 view .LVU188
 679 0004 70B5     		push	{r4, r5, r6, lr}
 680              	.LCFI14:
 681              		.cfi_def_cfa_offset 16
 682              		.cfi_offset 4, -16
 683              		.cfi_offset 5, -12
 684              		.cfi_offset 6, -8
 685              		.cfi_offset 14, -4
 686 0006 82B0     		sub	sp, sp, #8
 687              	.LCFI15:
 688              		.cfi_def_cfa_offset 24
 689 0008 0C46     		mov	r4, r1
 690 000a 0646     		mov	r6, r0
 691              		.loc 1 213 23 discriminator 2 view .LVU189
ARM GAS  /tmp/ccz04fb7.s 			page 42


 692 000c 0029     		cmp	r1, #0
 693 000e 41D0     		beq	.L44
 214:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 694              		.loc 1 214 5 is_stmt 1 view .LVU190
 695              	.LVL55:
 696              	.LBB97:
 697              	.LBI97:
 379:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 698              		.loc 3 379 21 view .LVU191
 699              	.LBB98:
 380:./include/linux/slab.h **** }
 700              		.loc 3 380 2 view .LVU192
 380:./include/linux/slab.h **** }
 701              		.loc 3 380 9 is_stmt 0 view .LVU193
 702 0010 4FF44C61 		mov	r1, #3264
 703              	.LVL56:
 380:./include/linux/slab.h **** }
 704              		.loc 3 380 9 view .LVU194
 705 0014 4FF40070 		mov	r0, #512
 706              	.LVL57:
 380:./include/linux/slab.h **** }
 707              		.loc 3 380 9 view .LVU195
 708 0018 FFF7FEFF 		bl	__smalloc__
 709              	.LVL58:
 380:./include/linux/slab.h **** }
 710              		.loc 3 380 9 view .LVU196
 711              	.LBE98:
 712              	.LBE97:
 215:./block/partition.c ****     if(data == NULL) return -1;
 713              		.loc 1 215 5 is_stmt 1 view .LVU197
 714              		.loc 1 215 7 is_stmt 0 view .LVU198
 715 001c 0546     		mov	r5, r0
 716 001e E0B3     		cbz	r0, .L45
 717              	.LBB99:
 216:./block/partition.c ****     for(int i =0;i<4;i++){
 718              		.loc 1 216 13 view .LVU199
 719 0020 0023     		movs	r3, #0
 720 0022 00E0     		b	.L39
 721              	.LVL59:
 722              	.L40:
 217:./block/partition.c ****         MBR_partition_table_fix_endian(&partition->mbr_partition[i]);
 723              		.loc 1 217 9 is_stmt 1 view .LVU200
 216:./block/partition.c ****     for(int i =0;i<4;i++){
 724              		.loc 1 216 23 discriminator 3 view .LVU201
 725 0024 0133     		adds	r3, r3, #1
 726              	.LVL60:
 727              	.L39:
 216:./block/partition.c ****     for(int i =0;i<4;i++){
 728              		.loc 1 216 19 discriminator 1 view .LVU202
 729 0026 032B     		cmp	r3, #3
 730 0028 FCDD     		ble	.L40
 731              	.LBE99:
 218:./block/partition.c ****     }
 219:./block/partition.c ****     memcpy(data + 446, &partition->mbr_partition[0], sizeof(struct mbr_partition)*4);
 732              		.loc 1 219 5 view .LVU203
 733              		.loc 1 219 24 is_stmt 0 view .LVU204
 734 002a 04F57973 		add	r3, r4, #996
ARM GAS  /tmp/ccz04fb7.s 			page 43


 735              	.LVL61:
 736              		.loc 1 219 5 view .LVU205
 737 002e 05F5DF72 		add	r2, r5, #446
 738 0032 04F22444 		addw	r4, r4, #1060
 739              	.LVL62:
 740              	.L41:
 741              		.loc 1 219 5 view .LVU206
 742 0036 D3F800E0 		ldr	lr, [r3]	@ unaligned
 743 003a D3F804C0 		ldr	ip, [r3, #4]	@ unaligned
 744 003e 9868     		ldr	r0, [r3, #8]	@ unaligned
 745 0040 D968     		ldr	r1, [r3, #12]	@ unaligned
 746 0042 C2F800E0 		str	lr, [r2]	@ unaligned
 747 0046 C2F804C0 		str	ip, [r2, #4]	@ unaligned
 748 004a 9060     		str	r0, [r2, #8]	@ unaligned
 749 004c D160     		str	r1, [r2, #12]	@ unaligned
 750 004e 1033     		adds	r3, r3, #16
 751 0050 1032     		adds	r2, r2, #16
 752 0052 A342     		cmp	r3, r4
 753 0054 EFD1     		bne	.L41
 220:./block/partition.c ****     data[0x01FE] = 0x55;
 754              		.loc 1 220 5 is_stmt 1 view .LVU207
 755              		.loc 1 220 18 is_stmt 0 view .LVU208
 756 0056 5523     		movs	r3, #85
 757 0058 85F8FE31 		strb	r3, [r5, #510]
 221:./block/partition.c ****     data[0x01FF] = 0xAA;                                                                //
 758              		.loc 1 221 5 is_stmt 1 view .LVU209
 759              		.loc 1 221 18 is_stmt 0 view .LVU210
 760 005c AA23     		movs	r3, #170
 761 005e 85F8FF31 		strb	r3, [r5, #511]
 222:./block/partition.c ****     if(trans_data_to_blk_dev(device,0,512,data,REQ_OP_WRITE) == NULL){
 762              		.loc 1 222 5 is_stmt 1 view .LVU211
 763              		.loc 1 222 8 is_stmt 0 view .LVU212
 764 0062 0123     		movs	r3, #1
 765 0064 0093     		str	r3, [sp]
 766 0066 2B46     		mov	r3, r5
 767 0068 4FF40072 		mov	r2, #512
 768 006c 0021     		movs	r1, #0
 769 006e 3046     		mov	r0, r6
 770 0070 FFF7FEFF 		bl	trans_data_to_blk_dev
 771              	.LVL63:
 772              		.loc 1 222 7 discriminator 1 view .LVU213
 773 0074 28B9     		cbnz	r0, .L42
 223:./block/partition.c ****         kfree(data);
 774              		.loc 1 223 9 is_stmt 1 view .LVU214
 775              	.LVL64:
 776              	.LBB100:
 777              	.LBI100:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 778              		.loc 3 383 20 view .LVU215
 779              	.LBB101:
 780              		.loc 3 384 2 view .LVU216
 781 0076 2846     		mov	r0, r5
 782 0078 FFF7FEFF 		bl	__sfree__
 783              	.LVL65:
 784              		.loc 3 384 2 is_stmt 0 view .LVU217
 785              	.LBE101:
 786              	.LBE100:
ARM GAS  /tmp/ccz04fb7.s 			page 44


 224:./block/partition.c ****          return 0;
 787              		.loc 1 224 10 is_stmt 1 view .LVU218
 788              		.loc 1 224 17 is_stmt 0 view .LVU219
 789 007c 0020     		movs	r0, #0
 790              	.LVL66:
 791              	.L37:
 225:./block/partition.c ****     }
 226:./block/partition.c ****     else{
 227:./block/partition.c ****         kfree(data);
 228:./block/partition.c ****         return -1;        
 229:./block/partition.c ****     }
 230:./block/partition.c **** }
 792              		.loc 1 230 1 view .LVU220
 793 007e 02B0     		add	sp, sp, #8
 794              	.LCFI16:
 795              		.cfi_remember_state
 796              		.cfi_def_cfa_offset 16
 797              		@ sp needed
 798 0080 70BD     		pop	{r4, r5, r6, pc}
 799              	.LVL67:
 800              	.L42:
 801              	.LCFI17:
 802              		.cfi_restore_state
 227:./block/partition.c ****         return -1;        
 803              		.loc 1 227 9 is_stmt 1 view .LVU221
 804              	.LBB102:
 805              	.LBI102:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 806              		.loc 3 383 20 view .LVU222
 807              	.LBB103:
 808              		.loc 3 384 2 view .LVU223
 809 0082 2846     		mov	r0, r5
 810 0084 FFF7FEFF 		bl	__sfree__
 811              	.LVL68:
 812              		.loc 3 384 2 is_stmt 0 view .LVU224
 813              	.LBE103:
 814              	.LBE102:
 228:./block/partition.c ****     }
 815              		.loc 1 228 9 is_stmt 1 view .LVU225
 228:./block/partition.c ****     }
 816              		.loc 1 228 16 is_stmt 0 view .LVU226
 817 0088 4FF0FF30 		mov	r0, #-1
 818 008c F7E7     		b	.L37
 819              	.LVL69:
 820              	.L43:
 821              	.LCFI18:
 822              		.cfi_def_cfa_offset 0
 823              		.cfi_restore 4
 824              		.cfi_restore 5
 825              		.cfi_restore 6
 826              		.cfi_restore 14
 213:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 827              		.loc 1 213 52 discriminator 3 view .LVU227
 828 008e 4FF0FF30 		mov	r0, #-1
 829              	.LVL70:
 830              		.loc 1 230 1 view .LVU228
 831 0092 7047     		bx	lr
ARM GAS  /tmp/ccz04fb7.s 			page 45


 832              	.LVL71:
 833              	.L44:
 834              	.LCFI19:
 835              		.cfi_def_cfa_offset 24
 836              		.cfi_offset 4, -16
 837              		.cfi_offset 5, -12
 838              		.cfi_offset 6, -8
 839              		.cfi_offset 14, -4
 213:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 840              		.loc 1 213 52 discriminator 3 view .LVU229
 841 0094 4FF0FF30 		mov	r0, #-1
 842              	.LVL72:
 213:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 843              		.loc 1 213 52 discriminator 3 view .LVU230
 844 0098 F1E7     		b	.L37
 845              	.LVL73:
 846              	.L45:
 215:./block/partition.c ****     for(int i =0;i<4;i++){
 847              		.loc 1 215 29 discriminator 1 view .LVU231
 848 009a 4FF0FF30 		mov	r0, #-1
 849              	.LVL74:
 215:./block/partition.c ****     for(int i =0;i<4;i++){
 850              		.loc 1 215 29 discriminator 1 view .LVU232
 851 009e EEE7     		b	.L37
 852              		.cfi_endproc
 853              	.LFE1052:
 855              		.section	.text.move_MBR_Table,"ax",%progbits
 856              		.align	1
 857              		.syntax unified
 858              		.thumb
 859              		.thumb_func
 861              	move_MBR_Table:
 862              	.LVL75:
 863              	.LFB1049:
 168:./block/partition.c ****     memcpy(to, from, sizeof(struct mbr_partition));
 864              		.loc 1 168 1 is_stmt 1 view -0
 865              		.cfi_startproc
 866              		@ args = 0, pretend = 0, frame = 0
 867              		@ frame_needed = 0, uses_anonymous_args = 0
 168:./block/partition.c ****     memcpy(to, from, sizeof(struct mbr_partition));
 868              		.loc 1 168 1 is_stmt 0 view .LVU234
 869 0000 00B5     		push	{lr}
 870              	.LCFI20:
 871              		.cfi_def_cfa_offset 4
 872              		.cfi_offset 14, -4
 169:./block/partition.c ****     memset(from, 0x00, sizeof(struct mbr_partition));
 873              		.loc 1 169 5 is_stmt 1 view .LVU235
 874 0002 D0F800E0 		ldr	lr, [r0]	@ unaligned
 875 0006 D0F804C0 		ldr	ip, [r0, #4]	@ unaligned
 876 000a 8268     		ldr	r2, [r0, #8]	@ unaligned
 877 000c C368     		ldr	r3, [r0, #12]	@ unaligned
 878 000e C1F800E0 		str	lr, [r1]	@ unaligned
 879 0012 C1F804C0 		str	ip, [r1, #4]	@ unaligned
 880 0016 8A60     		str	r2, [r1, #8]	@ unaligned
 881 0018 CB60     		str	r3, [r1, #12]	@ unaligned
 170:./block/partition.c **** }
 882              		.loc 1 170 5 view .LVU236
ARM GAS  /tmp/ccz04fb7.s 			page 46


 883 001a 0023     		movs	r3, #0
 884 001c 0360     		str	r3, [r0]	@ unaligned
 885 001e 4360     		str	r3, [r0, #4]	@ unaligned
 886 0020 8360     		str	r3, [r0, #8]	@ unaligned
 887 0022 C360     		str	r3, [r0, #12]	@ unaligned
 171:./block/partition.c **** 
 888              		.loc 1 171 1 is_stmt 0 view .LVU237
 889 0024 5DF804FB 		ldr	pc, [sp], #4
 890              		.cfi_endproc
 891              	.LFE1049:
 893              		.section	.text.detect_partition_table,"ax",%progbits
 894              		.align	1
 895              		.syntax unified
 896              		.thumb
 897              		.thumb_func
 899              	detect_partition_table:
 900              	.LVL76:
 901              	.LFB1037:
  33:./block/partition.c ****     *flags = BLOCK_DEVICE_FLAG_NOT_INITIALIZED;                           //
 902              		.loc 1 33 1 is_stmt 1 view -0
 903              		.cfi_startproc
 904              		@ args = 0, pretend = 0, frame = 0
 905              		@ frame_needed = 0, uses_anonymous_args = 0
  33:./block/partition.c ****     *flags = BLOCK_DEVICE_FLAG_NOT_INITIALIZED;                           //
 906              		.loc 1 33 1 is_stmt 0 view .LVU239
 907 0000 70B5     		push	{r4, r5, r6, lr}
 908              	.LCFI21:
 909              		.cfi_def_cfa_offset 16
 910              		.cfi_offset 4, -16
 911              		.cfi_offset 5, -12
 912              		.cfi_offset 6, -8
 913              		.cfi_offset 14, -4
 914 0002 82B0     		sub	sp, sp, #8
 915              	.LCFI22:
 916              		.cfi_def_cfa_offset 24
 917 0004 0646     		mov	r6, r0
 918 0006 0D46     		mov	r5, r1
 919 0008 1446     		mov	r4, r2
  34:./block/partition.c ****     char *data =  trans_data_to_blk_dev(device,0,512,block_buffer,REQ_OP_READ);
 920              		.loc 1 34 5 is_stmt 1 view .LVU240
  34:./block/partition.c ****     char *data =  trans_data_to_blk_dev(device,0,512,block_buffer,REQ_OP_READ);
 921              		.loc 1 34 12 is_stmt 0 view .LVU241
 922 000a 0021     		movs	r1, #0
 923              	.LVL77:
  34:./block/partition.c ****     char *data =  trans_data_to_blk_dev(device,0,512,block_buffer,REQ_OP_READ);
 924              		.loc 1 34 12 view .LVU242
 925 000c 1170     		strb	r1, [r2]
  35:./block/partition.c ****     if(data[0x01FE] == 0x55 && data[0x01FF] == 0xAA)
 926              		.loc 1 35 5 is_stmt 1 view .LVU243
  35:./block/partition.c ****     if(data[0x01FE] == 0x55 && data[0x01FF] == 0xAA)
 927              		.loc 1 35 19 is_stmt 0 view .LVU244
 928 000e 0091     		str	r1, [sp]
 929 0010 2B46     		mov	r3, r5
 930 0012 4FF40072 		mov	r2, #512
 931              	.LVL78:
  35:./block/partition.c ****     if(data[0x01FE] == 0x55 && data[0x01FF] == 0xAA)
 932              		.loc 1 35 19 view .LVU245
ARM GAS  /tmp/ccz04fb7.s 			page 47


 933 0016 FFF7FEFF 		bl	trans_data_to_blk_dev
 934              	.LVL79:
  36:./block/partition.c ****         *flags = BLOCK_DEVICE_FLAG_MBR;                                    //LBA 0
 935              		.loc 1 36 5 is_stmt 1 view .LVU246
  36:./block/partition.c ****         *flags = BLOCK_DEVICE_FLAG_MBR;                                    //LBA 0
 936              		.loc 1 36 12 is_stmt 0 view .LVU247
 937 001a 90F8FE31 		ldrb	r3, [r0, #510]	@ zero_extendqisi2
  36:./block/partition.c ****         *flags = BLOCK_DEVICE_FLAG_MBR;                                    //LBA 0
 938              		.loc 1 36 7 view .LVU248
 939 001e 552B     		cmp	r3, #85
 940 0020 15D0     		beq	.L57
 941              	.L53:
  38:./block/partition.c ****     if (memcmp(data, gpt_head, 8) == 0)
 942              		.loc 1 38 5 is_stmt 1 view .LVU249
  38:./block/partition.c ****     if (memcmp(data, gpt_head, 8) == 0)
 943              		.loc 1 38 13 is_stmt 0 view .LVU250
 944 0022 0023     		movs	r3, #0
 945 0024 0093     		str	r3, [sp]
 946 0026 2B46     		mov	r3, r5
 947 0028 4FF40072 		mov	r2, #512
 948 002c 0121     		movs	r1, #1
 949 002e 3046     		mov	r0, r6
 950              	.LVL80:
  38:./block/partition.c ****     if (memcmp(data, gpt_head, 8) == 0)
 951              		.loc 1 38 13 view .LVU251
 952 0030 FFF7FEFF 		bl	trans_data_to_blk_dev
 953              	.LVL81:
  39:./block/partition.c ****     {
 954              		.loc 1 39 5 is_stmt 1 view .LVU252
  39:./block/partition.c ****     {
 955              		.loc 1 39 9 is_stmt 0 view .LVU253
 956 0034 0822     		movs	r2, #8
 957 0036 0B49     		ldr	r1, .L59
 958 0038 FFF7FEFF 		bl	memcmp
 959              	.LVL82:
  39:./block/partition.c ****     {
 960              		.loc 1 39 8 discriminator 1 view .LVU254
 961 003c 20B9     		cbnz	r0, .L54
  41:./block/partition.c ****             *flags = BLOCK_DEVICE_FLAG_PROTECTIVE_MBR;
 962              		.loc 1 41 9 is_stmt 1 view .LVU255
  41:./block/partition.c ****             *flags = BLOCK_DEVICE_FLAG_PROTECTIVE_MBR;
 963              		.loc 1 41 12 is_stmt 0 view .LVU256
 964 003e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
  41:./block/partition.c ****             *flags = BLOCK_DEVICE_FLAG_PROTECTIVE_MBR;
 965              		.loc 1 41 11 view .LVU257
 966 0040 012B     		cmp	r3, #1
 967 0042 0BD0     		beq	.L58
  44:./block/partition.c ****     }
 968              		.loc 1 44 13 is_stmt 1 view .LVU258
  44:./block/partition.c ****     }
 969              		.loc 1 44 20 is_stmt 0 view .LVU259
 970 0044 0223     		movs	r3, #2
 971 0046 2370     		strb	r3, [r4]
 972              	.L54:
  46:./block/partition.c **** }
 973              		.loc 1 46 5 is_stmt 1 view .LVU260
  47:./block/partition.c **** 
ARM GAS  /tmp/ccz04fb7.s 			page 48


 974              		.loc 1 47 1 is_stmt 0 view .LVU261
 975 0048 0020     		movs	r0, #0
 976 004a 02B0     		add	sp, sp, #8
 977              	.LCFI23:
 978              		.cfi_remember_state
 979              		.cfi_def_cfa_offset 16
 980              		@ sp needed
 981 004c 70BD     		pop	{r4, r5, r6, pc}
 982              	.LVL83:
 983              	.L57:
 984              	.LCFI24:
 985              		.cfi_restore_state
  36:./block/partition.c ****         *flags = BLOCK_DEVICE_FLAG_MBR;                                    //LBA 0
 986              		.loc 1 36 36 discriminator 1 view .LVU262
 987 004e 90F8FF31 		ldrb	r3, [r0, #511]	@ zero_extendqisi2
  36:./block/partition.c ****         *flags = BLOCK_DEVICE_FLAG_MBR;                                    //LBA 0
 988              		.loc 1 36 29 discriminator 1 view .LVU263
 989 0052 AA2B     		cmp	r3, #170
 990 0054 E5D1     		bne	.L53
  37:./block/partition.c ****     data =  trans_data_to_blk_dev(device,1,512,block_buffer,REQ_OP_READ);//LBA 1
 991              		.loc 1 37 9 is_stmt 1 view .LVU264
  37:./block/partition.c ****     data =  trans_data_to_blk_dev(device,1,512,block_buffer,REQ_OP_READ);//LBA 1
 992              		.loc 1 37 16 is_stmt 0 view .LVU265
 993 0056 0123     		movs	r3, #1
 994 0058 2370     		strb	r3, [r4]
 995 005a E2E7     		b	.L53
 996              	.LVL84:
 997              	.L58:
  42:./block/partition.c ****         else
 998              		.loc 1 42 13 is_stmt 1 view .LVU266
  42:./block/partition.c ****         else
 999              		.loc 1 42 20 is_stmt 0 view .LVU267
 1000 005c 0323     		movs	r3, #3
 1001 005e 2370     		strb	r3, [r4]
 1002 0060 F2E7     		b	.L54
 1003              	.L60:
 1004 0062 00BF     		.align	2
 1005              	.L59:
 1006 0064 00000000 		.word	gpt_head
 1007              		.cfi_endproc
 1008              	.LFE1037:
 1010              		.section	.text.check_empty_MBR_Table,"ax",%progbits
 1011              		.align	1
 1012              		.global	check_empty_MBR_Table
 1013              		.syntax unified
 1014              		.thumb
 1015              		.thumb_func
 1017              	check_empty_MBR_Table:
 1018              	.LVL85:
 1019              	.LFB1039:
  60:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1020              		.loc 1 60 1 is_stmt 1 view -0
 1021              		.cfi_startproc
 1022              		@ args = 0, pretend = 0, frame = 0
 1023              		@ frame_needed = 0, uses_anonymous_args = 0
 1024              		@ link register save eliminated.
  61:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
ARM GAS  /tmp/ccz04fb7.s 			page 49


 1025              		.loc 1 61 5 view .LVU269
  61:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
 1026              		.loc 1 61 27 is_stmt 0 view .LVU270
 1027 0000 3E31     		adds	r1, r1, #62
 1028              	.LVL86:
  61:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
 1029              		.loc 1 61 27 view .LVU271
 1030 0002 00EB0110 		add	r0, r0, r1, lsl #4
 1031              	.LVL87:
  61:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
 1032              		.loc 1 61 27 view .LVU272
 1033 0006 0430     		adds	r0, r0, #4
 1034              	.LVL88:
  62:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1035              		.loc 1 62 5 is_stmt 1 view .LVU273
 1036              	.LBB104:
  62:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1037              		.loc 1 62 9 view .LVU274
  62:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1038              		.loc 1 62 13 is_stmt 0 view .LVU275
 1039 0008 0023     		movs	r3, #0
 1040              	.LVL89:
 1041              	.L62:
  62:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1042              		.loc 1 62 21 is_stmt 1 discriminator 1 view .LVU276
 1043 000a 0F2B     		cmp	r3, #15
 1044 000c 03D8     		bhi	.L66
  63:./block/partition.c ****             return 0;
 1045              		.loc 1 63 9 view .LVU277
  63:./block/partition.c ****             return 0;
 1046              		.loc 1 63 35 is_stmt 0 view .LVU278
 1047 000e C25C     		ldrb	r2, [r0, r3]	@ zero_extendqisi2
  63:./block/partition.c ****             return 0;
 1048              		.loc 1 63 11 view .LVU279
 1049 0010 1AB9     		cbnz	r2, .L65
  62:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1050              		.loc 1 62 53 is_stmt 1 discriminator 2 view .LVU280
 1051 0012 0133     		adds	r3, r3, #1
 1052              	.LVL90:
  62:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1053              		.loc 1 62 53 is_stmt 0 discriminator 2 view .LVU281
 1054 0014 F9E7     		b	.L62
 1055              	.L66:
  62:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1056              		.loc 1 62 53 discriminator 2 view .LVU282
 1057              	.LBE104:
  66:./block/partition.c **** }
 1058              		.loc 1 66 12 view .LVU283
 1059 0016 0120     		movs	r0, #1
 1060              	.LVL91:
 1061              	.LBB105:
  66:./block/partition.c **** }
 1062              		.loc 1 66 12 view .LVU284
 1063 0018 7047     		bx	lr
 1064              	.LVL92:
 1065              	.L65:
  64:./block/partition.c ****     }
ARM GAS  /tmp/ccz04fb7.s 			page 50


 1066              		.loc 1 64 20 view .LVU285
 1067 001a 0020     		movs	r0, #0
 1068              	.LVL93:
  64:./block/partition.c ****     }
 1069              		.loc 1 64 20 view .LVU286
 1070              	.LBE105:
  67:./block/partition.c **** static void clear_MBR_Table(struct partition *partition,int number)
 1071              		.loc 1 67 1 view .LVU287
 1072 001c 7047     		bx	lr
 1073              		.cfi_endproc
 1074              	.LFE1039:
 1076              		.section	.rodata.get_mbr_partition_start_address.str1.4,"aMS",%progbits,1
 1077              		.align	2
 1078              	.LC3:
 1079 0000 54686973 		.ascii	"This is a empty partition table slot\012\015\000"
 1079      20697320 
 1079      6120656D 
 1079      70747920 
 1079      70617274 
 1080              		.section	.text.get_mbr_partition_start_address,"ax",%progbits
 1081              		.align	1
 1082              		.syntax unified
 1083              		.thumb
 1084              		.thumb_func
 1086              	get_mbr_partition_start_address:
 1087              	.LVL94:
 1088              	.LFB1044:
 113:./block/partition.c ****     if(number < 0 || number > 3)
 1089              		.loc 1 113 88 is_stmt 1 view -0
 1090              		.cfi_startproc
 1091              		@ args = 0, pretend = 0, frame = 0
 1092              		@ frame_needed = 0, uses_anonymous_args = 0
 114:./block/partition.c ****         return INVALID_PARTITION;
 1093              		.loc 1 114 5 view .LVU289
 114:./block/partition.c ****         return INVALID_PARTITION;
 1094              		.loc 1 114 7 is_stmt 0 view .LVU290
 1095 0000 0329     		cmp	r1, #3
 1096 0002 11D8     		bhi	.L70
 113:./block/partition.c ****     if(number < 0 || number > 3)
 1097              		.loc 1 113 88 view .LVU291
 1098 0004 38B5     		push	{r3, r4, r5, lr}
 1099              	.LCFI25:
 1100              		.cfi_def_cfa_offset 16
 1101              		.cfi_offset 3, -16
 1102              		.cfi_offset 4, -12
 1103              		.cfi_offset 5, -8
 1104              		.cfi_offset 14, -4
 1105 0006 0446     		mov	r4, r0
 1106 0008 0D46     		mov	r5, r1
 117:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1){
 1107              		.loc 1 117 5 is_stmt 1 view .LVU292
 1108              	.LVL95:
 118:./block/partition.c ****          printk("This is a empty partition table slot\n\r");
 1109              		.loc 1 118 5 view .LVU293
 118:./block/partition.c ****          printk("This is a empty partition table slot\n\r");
 1110              		.loc 1 118 8 is_stmt 0 view .LVU294
 1111 000a FFF7FEFF 		bl	check_empty_MBR_Table
ARM GAS  /tmp/ccz04fb7.s 			page 51


 1112              	.LVL96:
 118:./block/partition.c ****          printk("This is a empty partition table slot\n\r");
 1113              		.loc 1 118 7 discriminator 1 view .LVU295
 1114 000e 0128     		cmp	r0, #1
 1115 0010 04D0     		beq	.L75
 122:./block/partition.c **** }
 1116              		.loc 1 122 5 is_stmt 1 view .LVU296
 122:./block/partition.c **** }
 1117              		.loc 1 122 25 is_stmt 0 view .LVU297
 1118 0012 04EB0514 		add	r4, r4, r5, lsl #4
 1119              	.LVL97:
 122:./block/partition.c **** }
 1120              		.loc 1 122 25 view .LVU298
 1121 0016 D4F8EC03 		ldr	r0, [r4, #1004]	@ unaligned
 1122              	.L67:
 123:./block/partition.c **** 
 1123              		.loc 1 123 1 view .LVU299
 1124 001a 38BD     		pop	{r3, r4, r5, pc}
 1125              	.LVL98:
 1126              	.L75:
 119:./block/partition.c ****          return INVALID_PARTITION;
 1127              		.loc 1 119 10 is_stmt 1 view .LVU300
 1128 001c 0448     		ldr	r0, .L76
 1129 001e FFF7FEFF 		bl	printk
 1130              	.LVL99:
 120:./block/partition.c ****     }
 1131              		.loc 1 120 10 view .LVU301
 120:./block/partition.c ****     }
 1132              		.loc 1 120 17 is_stmt 0 view .LVU302
 1133 0022 4FF0FF30 		mov	r0, #-1
 1134 0026 F8E7     		b	.L67
 1135              	.LVL100:
 1136              	.L70:
 1137              	.LCFI26:
 1138              		.cfi_def_cfa_offset 0
 1139              		.cfi_restore 3
 1140              		.cfi_restore 4
 1141              		.cfi_restore 5
 1142              		.cfi_restore 14
 115:./block/partition.c ****     
 1143              		.loc 1 115 16 view .LVU303
 1144 0028 4FF0FF30 		mov	r0, #-1
 1145              	.LVL101:
 123:./block/partition.c **** 
 1146              		.loc 1 123 1 view .LVU304
 1147 002c 7047     		bx	lr
 1148              	.L77:
 1149 002e 00BF     		.align	2
 1150              	.L76:
 1151 0030 00000000 		.word	.LC3
 1152              		.cfi_endproc
 1153              	.LFE1044:
 1155              		.section	.text.get_mbr_partition_size,"ax",%progbits
 1156              		.align	1
 1157              		.syntax unified
 1158              		.thumb
 1159              		.thumb_func
ARM GAS  /tmp/ccz04fb7.s 			page 52


 1161              	get_mbr_partition_size:
 1162              	.LVL102:
 1163              	.LFB1043:
 104:./block/partition.c ****     if(number < 0 || number > 3)
 1164              		.loc 1 104 79 is_stmt 1 view -0
 1165              		.cfi_startproc
 1166              		@ args = 0, pretend = 0, frame = 0
 1167              		@ frame_needed = 0, uses_anonymous_args = 0
 105:./block/partition.c ****         return INVALID_PARTITION;
 1168              		.loc 1 105 5 view .LVU306
 105:./block/partition.c ****         return INVALID_PARTITION;
 1169              		.loc 1 105 7 is_stmt 0 view .LVU307
 1170 0000 0329     		cmp	r1, #3
 1171 0002 0BD8     		bhi	.L80
 104:./block/partition.c ****     if(number < 0 || number > 3)
 1172              		.loc 1 104 79 view .LVU308
 1173 0004 38B5     		push	{r3, r4, r5, lr}
 1174              	.LCFI27:
 1175              		.cfi_def_cfa_offset 16
 1176              		.cfi_offset 3, -16
 1177              		.cfi_offset 4, -12
 1178              		.cfi_offset 5, -8
 1179              		.cfi_offset 14, -4
 1180 0006 0446     		mov	r4, r0
 1181 0008 0D46     		mov	r5, r1
 107:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 1182              		.loc 1 107 5 is_stmt 1 view .LVU309
 1183              	.LVL103:
 108:./block/partition.c ****         return INVALID_PARTITION;
 1184              		.loc 1 108 5 view .LVU310
 108:./block/partition.c ****         return INVALID_PARTITION;
 1185              		.loc 1 108 8 is_stmt 0 view .LVU311
 1186 000a FFF7FEFF 		bl	check_empty_MBR_Table
 1187              	.LVL104:
 108:./block/partition.c ****         return INVALID_PARTITION;
 1188              		.loc 1 108 7 discriminator 1 view .LVU312
 1189 000e 0128     		cmp	r0, #1
 1190 0010 07D0     		beq	.L81
 110:./block/partition.c **** }
 1191              		.loc 1 110 5 is_stmt 1 view .LVU313
 110:./block/partition.c **** }
 1192              		.loc 1 110 25 is_stmt 0 view .LVU314
 1193 0012 04EB0514 		add	r4, r4, r5, lsl #4
 1194              	.LVL105:
 110:./block/partition.c **** }
 1195              		.loc 1 110 25 view .LVU315
 1196 0016 D4F8F003 		ldr	r0, [r4, #1008]	@ unaligned
 1197              	.L78:
 111:./block/partition.c **** 
 1198              		.loc 1 111 1 view .LVU316
 1199 001a 38BD     		pop	{r3, r4, r5, pc}
 1200              	.LVL106:
 1201              	.L80:
 1202              	.LCFI28:
 1203              		.cfi_def_cfa_offset 0
 1204              		.cfi_restore 3
 1205              		.cfi_restore 4
ARM GAS  /tmp/ccz04fb7.s 			page 53


 1206              		.cfi_restore 5
 1207              		.cfi_restore 14
 106:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1208              		.loc 1 106 16 view .LVU317
 1209 001c 4FF0FF30 		mov	r0, #-1
 1210              	.LVL107:
 111:./block/partition.c **** 
 1211              		.loc 1 111 1 view .LVU318
 1212 0020 7047     		bx	lr
 1213              	.LVL108:
 1214              	.L81:
 1215              	.LCFI29:
 1216              		.cfi_def_cfa_offset 16
 1217              		.cfi_offset 3, -16
 1218              		.cfi_offset 4, -12
 1219              		.cfi_offset 5, -8
 1220              		.cfi_offset 14, -4
 109:./block/partition.c ****     return mbr_partition->nr_sectors;
 1221              		.loc 1 109 16 view .LVU319
 1222 0022 4FF0FF30 		mov	r0, #-1
 1223 0026 F8E7     		b	.L78
 1224              		.cfi_endproc
 1225              	.LFE1043:
 1227              		.section	.text.get_mbr_partition_type,"ax",%progbits
 1228              		.align	1
 1229              		.syntax unified
 1230              		.thumb
 1231              		.thumb_func
 1233              	get_mbr_partition_type:
 1234              	.LVL109:
 1235              	.LFB1045:
 125:./block/partition.c ****     if(number < 0 || number > 3)
 1236              		.loc 1 125 78 is_stmt 1 view -0
 1237              		.cfi_startproc
 1238              		@ args = 0, pretend = 0, frame = 0
 1239              		@ frame_needed = 0, uses_anonymous_args = 0
 126:./block/partition.c ****         return 0xff;
 1240              		.loc 1 126 5 view .LVU321
 126:./block/partition.c ****         return 0xff;
 1241              		.loc 1 126 7 is_stmt 0 view .LVU322
 1242 0000 0329     		cmp	r1, #3
 1243 0002 0BD8     		bhi	.L88
 125:./block/partition.c ****     if(number < 0 || number > 3)
 1244              		.loc 1 125 78 view .LVU323
 1245 0004 38B5     		push	{r3, r4, r5, lr}
 1246              	.LCFI30:
 1247              		.cfi_def_cfa_offset 16
 1248              		.cfi_offset 3, -16
 1249              		.cfi_offset 4, -12
 1250              		.cfi_offset 5, -8
 1251              		.cfi_offset 14, -4
 1252 0006 0546     		mov	r5, r0
 1253 0008 0C46     		mov	r4, r1
 128:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 1254              		.loc 1 128 5 is_stmt 1 view .LVU324
 1255              	.LVL110:
 129:./block/partition.c ****         return 0xff;
ARM GAS  /tmp/ccz04fb7.s 			page 54


 1256              		.loc 1 129 5 view .LVU325
 129:./block/partition.c ****         return 0xff;
 1257              		.loc 1 129 8 is_stmt 0 view .LVU326
 1258 000a FFF7FEFF 		bl	check_empty_MBR_Table
 1259              	.LVL111:
 129:./block/partition.c ****         return 0xff;
 1260              		.loc 1 129 7 discriminator 1 view .LVU327
 1261 000e 0128     		cmp	r0, #1
 1262 0010 06D0     		beq	.L89
 131:./block/partition.c **** }
 1263              		.loc 1 131 5 is_stmt 1 view .LVU328
 131:./block/partition.c **** }
 1264              		.loc 1 131 25 is_stmt 0 view .LVU329
 1265 0012 3E34     		adds	r4, r4, #62
 1266              	.LVL112:
 131:./block/partition.c **** }
 1267              		.loc 1 131 25 view .LVU330
 1268 0014 05EB0415 		add	r5, r5, r4, lsl #4
 1269              	.LVL113:
 131:./block/partition.c **** }
 1270              		.loc 1 131 25 view .LVU331
 1271 0018 287A     		ldrb	r0, [r5, #8]	@ zero_extendqisi2
 1272              	.LVL114:
 1273              	.L87:
 132:./block/partition.c **** 
 1274              		.loc 1 132 1 view .LVU332
 1275 001a 38BD     		pop	{r3, r4, r5, pc}
 1276              	.LVL115:
 1277              	.L88:
 1278              	.LCFI31:
 1279              		.cfi_def_cfa_offset 0
 1280              		.cfi_restore 3
 1281              		.cfi_restore 4
 1282              		.cfi_restore 5
 1283              		.cfi_restore 14
 127:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1284              		.loc 1 127 16 view .LVU333
 1285 001c FF20     		movs	r0, #255
 1286              	.LVL116:
 132:./block/partition.c **** 
 1287              		.loc 1 132 1 view .LVU334
 1288 001e 7047     		bx	lr
 1289              	.LVL117:
 1290              	.L89:
 1291              	.LCFI32:
 1292              		.cfi_def_cfa_offset 16
 1293              		.cfi_offset 3, -16
 1294              		.cfi_offset 4, -12
 1295              		.cfi_offset 5, -8
 1296              		.cfi_offset 14, -4
 130:./block/partition.c ****     return mbr_partition->sys_ind;
 1297              		.loc 1 130 16 view .LVU335
 1298 0020 FF20     		movs	r0, #255
 1299 0022 FAE7     		b	.L87
 1300              		.cfi_endproc
 1301              	.LFE1045:
 1303              		.section	.text.get_empty_MBR_Table,"ax",%progbits
ARM GAS  /tmp/ccz04fb7.s 			page 55


 1304              		.align	1
 1305              		.syntax unified
 1306              		.thumb
 1307              		.thumb_func
 1309              	get_empty_MBR_Table:
 1310              	.LVL118:
 1311              	.LFB1041:
  76:./block/partition.c ****     for(int i = 0 ; i <4 ; i++){
 1312              		.loc 1 76 1 is_stmt 1 view -0
 1313              		.cfi_startproc
 1314              		@ args = 0, pretend = 0, frame = 0
 1315              		@ frame_needed = 0, uses_anonymous_args = 0
  76:./block/partition.c ****     for(int i = 0 ; i <4 ; i++){
 1316              		.loc 1 76 1 is_stmt 0 view .LVU337
 1317 0000 70B5     		push	{r4, r5, r6, lr}
 1318              	.LCFI33:
 1319              		.cfi_def_cfa_offset 16
 1320              		.cfi_offset 4, -16
 1321              		.cfi_offset 5, -12
 1322              		.cfi_offset 6, -8
 1323              		.cfi_offset 14, -4
 1324 0002 0546     		mov	r5, r0
 1325 0004 0E46     		mov	r6, r1
  77:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1326              		.loc 1 77 5 is_stmt 1 view .LVU338
 1327              	.LBB106:
  77:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1328              		.loc 1 77 9 view .LVU339
 1329              	.LVL119:
  77:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1330              		.loc 1 77 13 is_stmt 0 view .LVU340
 1331 0006 0024     		movs	r4, #0
 1332              	.LVL120:
 1333              	.L95:
  77:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1334              		.loc 1 77 23 is_stmt 1 discriminator 1 view .LVU341
 1335 0008 032C     		cmp	r4, #3
 1336 000a 0CDC     		bgt	.L100
  78:./block/partition.c ****             number[0] = i;
 1337              		.loc 1 78 9 view .LVU342
  78:./block/partition.c ****             number[0] = i;
 1338              		.loc 1 78 12 is_stmt 0 view .LVU343
 1339 000c 2146     		mov	r1, r4
 1340 000e 2846     		mov	r0, r5
 1341 0010 FFF7FEFF 		bl	check_empty_MBR_Table
 1342              	.LVL121:
  78:./block/partition.c ****             number[0] = i;
 1343              		.loc 1 78 11 discriminator 1 view .LVU344
 1344 0014 08B9     		cbnz	r0, .L101
  77:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1345              		.loc 1 77 29 is_stmt 1 discriminator 2 view .LVU345
 1346 0016 0134     		adds	r4, r4, #1
 1347              	.LVL122:
  77:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1348              		.loc 1 77 29 is_stmt 0 discriminator 2 view .LVU346
 1349 0018 F6E7     		b	.L95
 1350              	.L101:
ARM GAS  /tmp/ccz04fb7.s 			page 56


  79:./block/partition.c ****             return &partition->mbr_partition[i];
 1351              		.loc 1 79 13 is_stmt 1 view .LVU347
  79:./block/partition.c ****             return &partition->mbr_partition[i];
 1352              		.loc 1 79 23 is_stmt 0 view .LVU348
 1353 001a 3460     		str	r4, [r6]
  80:./block/partition.c ****         }
 1354              		.loc 1 80 13 is_stmt 1 view .LVU349
  80:./block/partition.c ****         }
 1355              		.loc 1 80 20 is_stmt 0 view .LVU350
 1356 001c 3E34     		adds	r4, r4, #62
 1357              	.LVL123:
  80:./block/partition.c ****         }
 1358              		.loc 1 80 20 view .LVU351
 1359 001e 05EB0410 		add	r0, r5, r4, lsl #4
 1360 0022 0430     		adds	r0, r0, #4
 1361 0024 00E0     		b	.L94
 1362              	.LVL124:
 1363              	.L100:
  80:./block/partition.c ****         }
 1364              		.loc 1 80 20 view .LVU352
 1365              	.LBE106:
  83:./block/partition.c **** }
 1366              		.loc 1 83 12 view .LVU353
 1367 0026 0020     		movs	r0, #0
 1368              	.LVL125:
 1369              	.L94:
  84:./block/partition.c **** 
 1370              		.loc 1 84 1 view .LVU354
 1371 0028 70BD     		pop	{r4, r5, r6, pc}
  84:./block/partition.c **** 
 1372              		.loc 1 84 1 view .LVU355
 1373              		.cfi_endproc
 1374              	.LFE1041:
 1376              		.section	.text.tidy_up_MBR_Table,"ax",%progbits
 1377              		.align	1
 1378              		.syntax unified
 1379              		.thumb
 1380              		.thumb_func
 1382              	tidy_up_MBR_Table:
 1383              	.LVL126:
 1384              	.LFB1050:
 174:./block/partition.c ****     uint8_t state[4];
 1385              		.loc 1 174 1 is_stmt 1 view -0
 1386              		.cfi_startproc
 1387              		@ args = 0, pretend = 0, frame = 8
 1388              		@ frame_needed = 0, uses_anonymous_args = 0
 174:./block/partition.c ****     uint8_t state[4];
 1389              		.loc 1 174 1 is_stmt 0 view .LVU357
 1390 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1391              	.LCFI34:
 1392              		.cfi_def_cfa_offset 20
 1393              		.cfi_offset 4, -20
 1394              		.cfi_offset 5, -16
 1395              		.cfi_offset 6, -12
 1396              		.cfi_offset 7, -8
 1397              		.cfi_offset 14, -4
 1398 0002 83B0     		sub	sp, sp, #12
ARM GAS  /tmp/ccz04fb7.s 			page 57


 1399              	.LCFI35:
 1400              		.cfi_def_cfa_offset 32
 1401 0004 0646     		mov	r6, r0
 175:./block/partition.c ****     for(int i = 0; i < 4; i++)
 1402              		.loc 1 175 5 is_stmt 1 view .LVU358
 176:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1403              		.loc 1 176 5 view .LVU359
 1404              	.LBB107:
 176:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1405              		.loc 1 176 9 view .LVU360
 1406              	.LVL127:
 176:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1407              		.loc 1 176 13 is_stmt 0 view .LVU361
 1408 0006 0024     		movs	r4, #0
 176:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1409              		.loc 1 176 5 view .LVU362
 1410 0008 0BE0     		b	.L103
 1411              	.LVL128:
 1412              	.L104:
 177:./block/partition.c **** 
 1413              		.loc 1 177 9 is_stmt 1 view .LVU363
 177:./block/partition.c **** 
 1414              		.loc 1 177 24 is_stmt 0 view .LVU364
 1415 000a 2146     		mov	r1, r4
 1416 000c 3046     		mov	r0, r6
 1417 000e FFF7FEFF 		bl	check_empty_MBR_Table
 1418              	.LVL129:
 177:./block/partition.c **** 
 1419              		.loc 1 177 22 discriminator 1 view .LVU365
 1420 0012 C0F10103 		rsb	r3, r0, #1
 177:./block/partition.c **** 
 1421              		.loc 1 177 18 discriminator 1 view .LVU366
 1422 0016 04F10802 		add	r2, r4, #8
 1423 001a 6A44     		add	r2, sp, r2
 1424 001c 02F8043C 		strb	r3, [r2, #-4]
 176:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1425              		.loc 1 176 28 is_stmt 1 discriminator 3 view .LVU367
 1426 0020 0134     		adds	r4, r4, #1
 1427              	.LVL130:
 1428              	.L103:
 176:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1429              		.loc 1 176 22 discriminator 1 view .LVU368
 1430 0022 032C     		cmp	r4, #3
 1431 0024 F1DD     		ble	.L104
 1432              	.LBE107:
 1433              	.LBB108:
 179:./block/partition.c ****         for(int k = 0; k < 3; k++){
 1434              		.loc 1 179 13 is_stmt 0 view .LVU369
 1435 0026 0027     		movs	r7, #0
 1436 0028 2BE0     		b	.L105
 1437              	.LVL131:
 1438              	.L106:
 1439              	.LBB109:
 180:./block/partition.c ****             if(state[k] == 0 && state[k+1] == 1){
 1440              		.loc 1 180 32 is_stmt 1 discriminator 2 view .LVU370
 1441 002a 0134     		adds	r4, r4, #1
 1442              	.LVL132:
ARM GAS  /tmp/ccz04fb7.s 			page 58


 1443              	.L108:
 180:./block/partition.c ****             if(state[k] == 0 && state[k+1] == 1){
 1444              		.loc 1 180 26 discriminator 1 view .LVU371
 1445 002c 022C     		cmp	r4, #2
 1446 002e 27DC     		bgt	.L111
 181:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1447              		.loc 1 181 13 view .LVU372
 181:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1448              		.loc 1 181 21 is_stmt 0 view .LVU373
 1449 0030 04F10803 		add	r3, r4, #8
 1450 0034 6B44     		add	r3, sp, r3
 1451 0036 13F8043C 		ldrb	r3, [r3, #-4]	@ zero_extendqisi2
 181:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1452              		.loc 1 181 15 view .LVU374
 1453 003a 002B     		cmp	r3, #0
 1454 003c F5D1     		bne	.L106
 181:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1455              		.loc 1 181 38 discriminator 1 view .LVU375
 1456 003e 04F10903 		add	r3, r4, #9
 1457 0042 6B44     		add	r3, sp, r3
 1458 0044 13F8043C 		ldrb	r3, [r3, #-4]	@ zero_extendqisi2
 181:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1459              		.loc 1 181 30 discriminator 1 view .LVU376
 1460 0048 012B     		cmp	r3, #1
 1461 004a EED1     		bne	.L106
 182:./block/partition.c ****                 state[k]   = 1;
 1462              		.loc 1 182 17 is_stmt 1 view .LVU377
 1463 004c 04F13E01 		add	r1, r4, #62
 1464 0050 06EB0111 		add	r1, r6, r1, lsl #4
 1465 0054 04F13F00 		add	r0, r4, #63
 1466 0058 06EB0010 		add	r0, r6, r0, lsl #4
 1467 005c 0431     		adds	r1, r1, #4
 1468 005e 0430     		adds	r0, r0, #4
 1469 0060 FFF7FEFF 		bl	move_MBR_Table
 1470              	.LVL133:
 183:./block/partition.c ****                 state[k+1] = 0;
 1471              		.loc 1 183 17 view .LVU378
 183:./block/partition.c ****                 state[k+1] = 0;
 1472              		.loc 1 183 28 is_stmt 0 view .LVU379
 1473 0064 0122     		movs	r2, #1
 1474 0066 04F10803 		add	r3, r4, #8
 1475 006a 6B44     		add	r3, sp, r3
 1476 006c 03F8042C 		strb	r2, [r3, #-4]
 184:./block/partition.c ****             }
 1477              		.loc 1 184 17 is_stmt 1 view .LVU380
 184:./block/partition.c ****             }
 1478              		.loc 1 184 28 is_stmt 0 view .LVU381
 1479 0070 04F10903 		add	r3, r4, #9
 1480 0074 0DEB0305 		add	r5, sp, r3
 1481 0078 0023     		movs	r3, #0
 1482 007a 05F8043C 		strb	r3, [r5, #-4]
 1483 007e D4E7     		b	.L106
 1484              	.L111:
 184:./block/partition.c ****             }
 1485              		.loc 1 184 28 view .LVU382
 1486              	.LBE109:
 179:./block/partition.c ****         for(int k = 0; k < 3; k++){
ARM GAS  /tmp/ccz04fb7.s 			page 59


 1487              		.loc 1 179 28 is_stmt 1 discriminator 2 view .LVU383
 1488 0080 0137     		adds	r7, r7, #1
 1489              	.LVL134:
 1490              	.L105:
 179:./block/partition.c ****         for(int k = 0; k < 3; k++){
 1491              		.loc 1 179 22 discriminator 1 view .LVU384
 1492 0082 022F     		cmp	r7, #2
 1493 0084 01DC     		bgt	.L112
 1494              	.LBB110:
 180:./block/partition.c ****             if(state[k] == 0 && state[k+1] == 1){
 1495              		.loc 1 180 17 is_stmt 0 view .LVU385
 1496 0086 0024     		movs	r4, #0
 1497 0088 D0E7     		b	.L108
 1498              	.L112:
 1499              	.LBE110:
 1500              	.LBE108:
 188:./block/partition.c **** 
 1501              		.loc 1 188 1 view .LVU386
 1502 008a 03B0     		add	sp, sp, #12
 1503              	.LCFI36:
 1504              		.cfi_def_cfa_offset 20
 1505              		@ sp needed
 1506 008c F0BD     		pop	{r4, r5, r6, r7, pc}
 188:./block/partition.c **** 
 1507              		.loc 1 188 1 view .LVU387
 1508              		.cfi_endproc
 1509              	.LFE1050:
 1511              		.section	.rodata.mbr_partition_table_format.str1.4,"aMS",%progbits,1
 1512              		.align	2
 1513              	.LC4:
 1514 0000 54686973 		.ascii	"This device has not init\012\000"
 1514      20646576 
 1514      69636520 
 1514      68617320 
 1514      6E6F7420 
 1515 001a 0000     		.align	2
 1516              	.LC5:
 1517 001c 63616E20 		.ascii	"can not load mbr partition\012\000"
 1517      6E6F7420 
 1517      6C6F6164 
 1517      206D6272 
 1517      20706172 
 1518              		.align	2
 1519              	.LC6:
 1520 0038 74686973 		.ascii	"this storage device can not builded more partition "
 1520      2073746F 
 1520      72616765 
 1520      20646576 
 1520      69636520 
 1521 006b 7461626C 		.ascii	"table any more\012\000"
 1521      6520616E 
 1521      79206D6F 
 1521      72650A00 
 1522 007b 00       		.align	2
 1523              	.LC7:
 1524 007c 47455420 		.ascii	"GET last table start address = %d last_size\012\000"
 1524      6C617374 
ARM GAS  /tmp/ccz04fb7.s 			page 60


 1524      20746162 
 1524      6C652073 
 1524      74617274 
 1525 00a9 000000   		.align	2
 1526              	.LC8:
 1527 00ac 6E6F206C 		.ascii	"no last table\012\000"
 1527      61737420 
 1527      7461626C 
 1527      650A00
 1528 00bb 00       		.align	2
 1529              	.LC9:
 1530 00bc 69742773 		.ascii	"it's the first partition\012\000"
 1530      20746865 
 1530      20666972 
 1530      73742070 
 1530      61727469 
 1531 00d6 0000     		.align	2
 1532              	.LC10:
 1533 00d8 74686973 		.ascii	"this disk size is too small\000"
 1533      20646973 
 1533      6B207369 
 1533      7A652069 
 1533      7320746F 
 1534              		.align	2
 1535              	.LC11:
 1536 00f4 64656374 		.ascii	"dected stand storage device,use 2048 as start addre"
 1536      65642073 
 1536      74616E64 
 1536      2073746F 
 1536      72616765 
 1537 0127 73730A00 		.ascii	"ss\012\000"
 1538 012b 00       		.align	2
 1539              	.LC12:
 1540 012c 47455420 		.ascii	"GET last table size = %d block\012\000"
 1540      6C617374 
 1540      20746162 
 1540      6C652073 
 1540      697A6520 
 1541              		.align	2
 1542              	.LC13:
 1543 014c 6E6F7420 		.ascii	"not support this storage device,storage siz is too "
 1543      73757070 
 1543      6F727420 
 1543      74686973 
 1543      2073746F 
 1544 017f 736D616C 		.ascii	"small\012\000"
 1544      6C0A00
 1545 0186 0000     		.align	2
 1546              	.LC14:
 1547 0188 50617274 		.ascii	"Partition size %d is too large, adjusting to fit av"
 1547      6974696F 
 1547      6E207369 
 1547      7A652025 
 1547      64206973 
 1548 01bb 61696C61 		.ascii	"ailable space.\012\000"
 1548      626C6520 
 1548      73706163 
ARM GAS  /tmp/ccz04fb7.s 			page 61


 1548      652E0A00 
 1549 01cb 00       		.align	2
 1550              	.LC15:
 1551 01cc 4E657720 		.ascii	"New partition size: %d\012\000"
 1551      70617274 
 1551      6974696F 
 1551      6E207369 
 1551      7A653A20 
 1552              		.align	2
 1553              	.LC16:
 1554 01e4 74686973 		.ascii	"this size: %d of block  is not work\012\000"
 1554      2073697A 
 1554      653A2025 
 1554      64206F66 
 1554      20626C6F 
 1555              		.section	.text.mbr_partition_table_format,"ax",%progbits
 1556              		.align	1
 1557              		.syntax unified
 1558              		.thumb
 1559              		.thumb_func
 1561              	mbr_partition_table_format:
 1562              	.LVL135:
 1563              	.LFB1054:
 231:./block/partition.c **** 
 232:./block/partition.c **** static int mbr_table_delete(struct block_device *device,struct partition *partition,int number,enum
 233:./block/partition.c **** {
 234:./block/partition.c ****     if(device == NULL || partition == NULL) {
 235:./block/partition.c ****         printk("This device has not init\n\r");
 236:./block/partition.c ****         return -1;
 237:./block/partition.c ****     }
 238:./block/partition.c ****     if(flags != BLOCK_DEVICE_FLAG_MBR && flags!= BLOCK_DEVICE_FLAG_PROTECTIVE_MBR){
 239:./block/partition.c ****         printk("It's not a mbr device\n\r");
 240:./block/partition.c ****         return -1;
 241:./block/partition.c ****     }
 242:./block/partition.c ****     if(number < 0 || number > 3){
 243:./block/partition.c ****         printk("partition number is out of range\n\r");
 244:./block/partition.c ****         return -1;
 245:./block/partition.c ****     }
 246:./block/partition.c ****     if(mbr_partition_table_load(device,partition) < 0) return -1;           //mbr
 247:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 248:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1){
 249:./block/partition.c ****         printk("This is a empty partition table slot\n\r");
 250:./block/partition.c ****         return -1;
 251:./block/partition.c ****     }
 252:./block/partition.c ****     else
 253:./block/partition.c ****         memset(mbr_partition, 0x00, sizeof(struct mbr_partition));
 254:./block/partition.c ****     tidy_up_MBR_Table(partition);
 255:./block/partition.c ****     mbr_partition_table_update(device,partition);
 256:./block/partition.c ****     return 0;
 257:./block/partition.c **** }
 258:./block/partition.c **** 
 259:./block/partition.c **** 
 260:./block/partition.c **** 
 261:./block/partition.c **** static int mbr_partition_table_format(struct block_device *device,struct partition *partition,uint3
 262:./block/partition.c **** {
 1564              		.loc 1 262 1 is_stmt 1 view -0
 1565              		.cfi_startproc
ARM GAS  /tmp/ccz04fb7.s 			page 62


 1566              		@ args = 0, pretend = 0, frame = 8
 1567              		@ frame_needed = 0, uses_anonymous_args = 0
 1568              		.loc 1 262 1 is_stmt 0 view .LVU389
 1569 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1570              	.LCFI37:
 1571              		.cfi_def_cfa_offset 32
 1572              		.cfi_offset 4, -32
 1573              		.cfi_offset 5, -28
 1574              		.cfi_offset 6, -24
 1575              		.cfi_offset 7, -20
 1576              		.cfi_offset 8, -16
 1577              		.cfi_offset 9, -12
 1578              		.cfi_offset 10, -8
 1579              		.cfi_offset 14, -4
 1580 0004 84B0     		sub	sp, sp, #16
 1581              	.LCFI38:
 1582              		.cfi_def_cfa_offset 48
 263:./block/partition.c ****     if(device == NULL || partition == NULL) {
 1583              		.loc 1 263 5 is_stmt 1 view .LVU390
 1584              		.loc 1 263 7 is_stmt 0 view .LVU391
 1585 0006 60B3     		cbz	r0, .L114
 1586 0008 0E46     		mov	r6, r1
 1587 000a 1546     		mov	r5, r2
 1588 000c 9946     		mov	r9, r3
 1589 000e 8046     		mov	r8, r0
 1590              		.loc 1 263 23 discriminator 1 view .LVU392
 1591 0010 39B3     		cbz	r1, .L114
 264:./block/partition.c ****         printk(KERN_INFO "This device has not init\n");
 265:./block/partition.c ****         return -1;
 266:./block/partition.c ****     }
 267:./block/partition.c ****     if(mbr_partition_table_load(device,partition) < 0) 
 1592              		.loc 1 267 5 is_stmt 1 view .LVU393
 1593              		.loc 1 267 8 is_stmt 0 view .LVU394
 1594 0012 FFF7FEFF 		bl	mbr_partition_table_load
 1595              	.LVL136:
 1596              		.loc 1 267 7 discriminator 1 view .LVU395
 1597 0016 0028     		cmp	r0, #0
 1598 0018 29DB     		blt	.L132
 268:./block/partition.c ****     {
 269:./block/partition.c ****         printk(KERN_INFO "can not load mbr partition\n");
 270:./block/partition.c ****         return -1;           //mbr
 271:./block/partition.c ****     }
 272:./block/partition.c ****     size = size /8 *8;  
 1599              		.loc 1 272 5 is_stmt 1 view .LVU396
 1600              		.loc 1 272 10 is_stmt 0 view .LVU397
 1601 001a 25F00705 		bic	r5, r5, #7
 1602              	.LVL137:
 273:./block/partition.c ****     if(size < 0) return -1;
 1603              		.loc 1 273 5 is_stmt 1 view .LVU398
 274:./block/partition.c ****     
 275:./block/partition.c ****     int partition_number = 0;
 1604              		.loc 1 275 5 view .LVU399
 1605              		.loc 1 275 9 is_stmt 0 view .LVU400
 1606 001e 0023     		movs	r3, #0
 1607 0020 0393     		str	r3, [sp, #12]
 276:./block/partition.c ****     struct mbr_partition *mbr_partition = get_empty_MBR_Table(partition,&partition_number);   //
 1608              		.loc 1 276 5 is_stmt 1 view .LVU401
ARM GAS  /tmp/ccz04fb7.s 			page 63


 1609              		.loc 1 276 43 is_stmt 0 view .LVU402
 1610 0022 03A9     		add	r1, sp, #12
 1611 0024 3046     		mov	r0, r6
 1612 0026 FFF7FEFF 		bl	get_empty_MBR_Table
 1613              	.LVL138:
 277:./block/partition.c ****     if(mbr_partition == NULL){
 1614              		.loc 1 277 5 is_stmt 1 view .LVU403
 1615              		.loc 1 277 7 is_stmt 0 view .LVU404
 1616 002a 8246     		mov	r10, r0
 1617 002c 28B3     		cbz	r0, .L133
 278:./block/partition.c ****         printk(KERN_INFO "this storage device can not builded more partition table any more\n");
 279:./block/partition.c ****         return -1;
 280:./block/partition.c ****     }
 281:./block/partition.c ****     //
 282:./block/partition.c ****     uint32_t start_address;
 1618              		.loc 1 282 5 is_stmt 1 view .LVU405
 283:./block/partition.c ****     if(partition_number - 1 >= 0){     
 1619              		.loc 1 283 5 view .LVU406
 1620              		.loc 1 283 29 is_stmt 0 view .LVU407
 1621 002e 0399     		ldr	r1, [sp, #12]
 1622              		.loc 1 283 7 view .LVU408
 1623 0030 0029     		cmp	r1, #0
 1624 0032 28DD     		ble	.L119
 284:./block/partition.c ****         start_address = get_mbr_partition_start_address(partition,partition_number - 1);
 1625              		.loc 1 284 9 is_stmt 1 view .LVU409
 1626              		.loc 1 284 25 is_stmt 0 view .LVU410
 1627 0034 0139     		subs	r1, r1, #1
 1628 0036 3046     		mov	r0, r6
 1629              	.LVL139:
 1630              		.loc 1 284 25 view .LVU411
 1631 0038 FFF7FEFF 		bl	get_mbr_partition_start_address
 1632              	.LVL140:
 1633 003c 0446     		mov	r4, r0
 1634              	.LVL141:
 285:./block/partition.c ****         printk(KERN_INFO "GET last table start address = %d last_size\n",start_address);
 1635              		.loc 1 285 9 is_stmt 1 view .LVU412
 1636 003e 0146     		mov	r1, r0
 1637 0040 3E48     		ldr	r0, .L139
 1638              	.LVL142:
 1639              		.loc 1 285 9 is_stmt 0 view .LVU413
 1640 0042 FFF7FEFF 		bl	printk
 1641              	.LVL143:
 286:./block/partition.c ****     }
 287:./block/partition.c ****     else{
 288:./block/partition.c ****         printk(KERN_INFO "no last table\n");
 289:./block/partition.c ****         start_address = INVALID_PARTITION;
 290:./block/partition.c ****     }
 291:./block/partition.c ****     if (start_address == INVALID_PARTITION){
 1642              		.loc 1 291 5 is_stmt 1 view .LVU414
 1643              		.loc 1 291 8 is_stmt 0 view .LVU415
 1644 0046 B4F1FF3F 		cmp	r4, #-1
 1645 004a 1FD0     		beq	.L120
 1646              	.LBB111:
 292:./block/partition.c ****         printk(KERN_INFO "it's the first partition\n");
 293:./block/partition.c ****         if(device->bd_nr_sectors  < 2048){
 294:./block/partition.c ****            printk(KERN_INFO "this disk size is too small");
 295:./block/partition.c ****             return -1;
ARM GAS  /tmp/ccz04fb7.s 			page 64


 296:./block/partition.c ****         }
 297:./block/partition.c ****         else {
 298:./block/partition.c ****             start_address = 2048  ;                                                             //
 299:./block/partition.c ****             printk(KERN_INFO "dected stand storage device,use 2048 as start address\n");
 300:./block/partition.c ****         }
 301:./block/partition.c ****     }
 302:./block/partition.c ****     else {
 303:./block/partition.c ****         uint32_t last_size = get_mbr_partition_size(partition,partition_number - 1);               
 1647              		.loc 1 303 9 is_stmt 1 view .LVU416
 1648              		.loc 1 303 30 is_stmt 0 view .LVU417
 1649 004c 0399     		ldr	r1, [sp, #12]
 1650 004e 0139     		subs	r1, r1, #1
 1651 0050 3046     		mov	r0, r6
 1652 0052 FFF7FEFF 		bl	get_mbr_partition_size
 1653              	.LVL144:
 1654 0056 0146     		mov	r1, r0
 1655              	.LVL145:
 304:./block/partition.c ****         start_address += last_size;               
 1656              		.loc 1 304 9 is_stmt 1 view .LVU418
 1657              		.loc 1 304 23 is_stmt 0 view .LVU419
 1658 0058 0444     		add	r4, r4, r0
 1659              	.LVL146:
 305:./block/partition.c ****         printk(KERN_INFO "GET last table size = %d block\n",last_size);
 1660              		.loc 1 305 9 is_stmt 1 view .LVU420
 1661 005a 3948     		ldr	r0, .L139+4
 1662              	.LVL147:
 1663              		.loc 1 305 9 is_stmt 0 view .LVU421
 1664 005c FFF7FEFF 		bl	printk
 1665              	.LVL148:
 1666              		.loc 1 305 9 view .LVU422
 1667 0060 21E0     		b	.L123
 1668              	.LVL149:
 1669              	.L114:
 1670              		.loc 1 305 9 view .LVU423
 1671              	.LBE111:
 264:./block/partition.c ****         return -1;
 1672              		.loc 1 264 9 is_stmt 1 view .LVU424
 1673 0062 3848     		ldr	r0, .L139+8
 1674              	.LVL150:
 264:./block/partition.c ****         return -1;
 1675              		.loc 1 264 9 is_stmt 0 view .LVU425
 1676 0064 FFF7FEFF 		bl	printk
 1677              	.LVL151:
 265:./block/partition.c ****     }
 1678              		.loc 1 265 9 is_stmt 1 view .LVU426
 265:./block/partition.c ****     }
 1679              		.loc 1 265 16 is_stmt 0 view .LVU427
 1680 0068 4FF0FF30 		mov	r0, #-1
 1681 006c 3DE0     		b	.L113
 1682              	.LVL152:
 1683              	.L132:
 269:./block/partition.c ****         return -1;           //mbr
 1684              		.loc 1 269 9 is_stmt 1 view .LVU428
 1685 006e 3648     		ldr	r0, .L139+12
 1686 0070 FFF7FEFF 		bl	printk
 1687              	.LVL153:
 270:./block/partition.c ****     }
ARM GAS  /tmp/ccz04fb7.s 			page 65


 1688              		.loc 1 270 9 view .LVU429
 270:./block/partition.c ****     }
 1689              		.loc 1 270 16 is_stmt 0 view .LVU430
 1690 0074 4FF0FF30 		mov	r0, #-1
 1691 0078 37E0     		b	.L113
 1692              	.LVL154:
 1693              	.L133:
 278:./block/partition.c ****         return -1;
 1694              		.loc 1 278 9 is_stmt 1 view .LVU431
 1695 007a 3448     		ldr	r0, .L139+16
 1696              	.LVL155:
 278:./block/partition.c ****         return -1;
 1697              		.loc 1 278 9 is_stmt 0 view .LVU432
 1698 007c FFF7FEFF 		bl	printk
 1699              	.LVL156:
 279:./block/partition.c ****     }
 1700              		.loc 1 279 9 is_stmt 1 view .LVU433
 279:./block/partition.c ****     }
 1701              		.loc 1 279 16 is_stmt 0 view .LVU434
 1702 0080 4FF0FF30 		mov	r0, #-1
 1703 0084 31E0     		b	.L113
 1704              	.LVL157:
 1705              	.L119:
 288:./block/partition.c ****         start_address = INVALID_PARTITION;
 1706              		.loc 1 288 9 is_stmt 1 view .LVU435
 1707 0086 3248     		ldr	r0, .L139+20
 1708              	.LVL158:
 288:./block/partition.c ****         start_address = INVALID_PARTITION;
 1709              		.loc 1 288 9 is_stmt 0 view .LVU436
 1710 0088 FFF7FEFF 		bl	printk
 1711              	.LVL159:
 289:./block/partition.c ****     }
 1712              		.loc 1 289 9 is_stmt 1 view .LVU437
 291:./block/partition.c ****         printk(KERN_INFO "it's the first partition\n");
 1713              		.loc 1 291 5 view .LVU438
 1714              	.L120:
 292:./block/partition.c ****         if(device->bd_nr_sectors  < 2048){
 1715              		.loc 1 292 9 view .LVU439
 1716 008c 3148     		ldr	r0, .L139+24
 1717 008e FFF7FEFF 		bl	printk
 1718              	.LVL160:
 293:./block/partition.c ****            printk(KERN_INFO "this disk size is too small");
 1719              		.loc 1 293 9 view .LVU440
 293:./block/partition.c ****            printk(KERN_INFO "this disk size is too small");
 1720              		.loc 1 293 18 is_stmt 0 view .LVU441
 1721 0092 D8F80430 		ldr	r3, [r8, #4]
 293:./block/partition.c ****            printk(KERN_INFO "this disk size is too small");
 1722              		.loc 1 293 11 view .LVU442
 1723 0096 B3F5006F 		cmp	r3, #2048
 1724 009a 29D3     		bcc	.L134
 298:./block/partition.c ****             printk(KERN_INFO "dected stand storage device,use 2048 as start address\n");
 1725              		.loc 1 298 13 is_stmt 1 view .LVU443
 1726              	.LVL161:
 299:./block/partition.c ****         }
 1727              		.loc 1 299 13 view .LVU444
 1728 009c 2E48     		ldr	r0, .L139+28
 1729 009e FFF7FEFF 		bl	printk
ARM GAS  /tmp/ccz04fb7.s 			page 66


 1730              	.LVL162:
 298:./block/partition.c ****             printk(KERN_INFO "dected stand storage device,use 2048 as start address\n");
 1731              		.loc 1 298 27 is_stmt 0 view .LVU445
 1732 00a2 4FF40064 		mov	r4, #2048
 1733              	.LVL163:
 1734              	.L123:
 306:./block/partition.c ****     }
 307:./block/partition.c **** 
 308:./block/partition.c ****     if(start_address%8 > 0) //4k
 1735              		.loc 1 308 5 is_stmt 1 view .LVU446
 1736              		.loc 1 308 7 is_stmt 0 view .LVU447
 1737 00a6 14F0070F 		tst	r4, #7
 1738 00aa 02D0     		beq	.L124
 309:./block/partition.c ****     start_address = start_address - (start_address%8) + 8;
 1739              		.loc 1 309 5 is_stmt 1 view .LVU448
 1740              		.loc 1 309 35 is_stmt 0 view .LVU449
 1741 00ac 24F00704 		bic	r4, r4, #7
 1742              	.LVL164:
 1743              		.loc 1 309 19 view .LVU450
 1744 00b0 0834     		adds	r4, r4, #8
 1745              	.LVL165:
 1746              	.L124:
 310:./block/partition.c **** 
 311:./block/partition.c **** 
 312:./block/partition.c ****     //
 313:./block/partition.c ****     uint32_t end_address;
 1747              		.loc 1 313 5 is_stmt 1 view .LVU451
 314:./block/partition.c ****     if(partition_number + 1 < 4)
 1748              		.loc 1 314 5 view .LVU452
 1749              		.loc 1 314 29 is_stmt 0 view .LVU453
 1750 00b2 0399     		ldr	r1, [sp, #12]
 1751              		.loc 1 314 7 view .LVU454
 1752 00b4 0229     		cmp	r1, #2
 1753 00b6 21DD     		ble	.L135
 1754              	.L125:
 315:./block/partition.c ****         end_address = get_mbr_partition_start_address(device,partition_number + 1);        //
 316:./block/partition.c ****     else 
 317:./block/partition.c ****         end_address = INVALID_PARTITION;
 318:./block/partition.c ****     if(end_address == INVALID_PARTITION){
 319:./block/partition.c ****         end_address =device->bd_nr_sectors - 33 -1;                                          //
 1755              		.loc 1 319 9 is_stmt 1 view .LVU455
 1756              		.loc 1 319 28 is_stmt 0 view .LVU456
 1757 00b8 D8F80470 		ldr	r7, [r8, #4]
 1758              		.loc 1 319 21 view .LVU457
 1759 00bc 223F     		subs	r7, r7, #34
 1760              	.LVL166:
 1761              	.L126:
 320:./block/partition.c ****     }
 321:./block/partition.c ****     if(end_address < start_address){
 1762              		.loc 1 321 5 is_stmt 1 view .LVU458
 1763              		.loc 1 321 7 is_stmt 0 view .LVU459
 1764 00be BC42     		cmp	r4, r7
 1765 00c0 25D8     		bhi	.L136
 322:./block/partition.c ****         printk(KERN_INFO "not support this storage device,storage siz is too small\n");
 323:./block/partition.c ****         return -1;
 324:./block/partition.c ****     }
 325:./block/partition.c ****     if (end_address <= start_address + size) {                                                 
ARM GAS  /tmp/ccz04fb7.s 			page 67


 1766              		.loc 1 325 5 is_stmt 1 view .LVU460
 1767              		.loc 1 325 38 is_stmt 0 view .LVU461
 1768 00c2 6319     		adds	r3, r4, r5
 1769              		.loc 1 325 8 view .LVU462
 1770 00c4 BB42     		cmp	r3, r7
 1771 00c6 28D2     		bcs	.L137
 1772              	.L128:
 326:./block/partition.c ****         printk(KERN_INFO "Partition size %d is too large, adjusting to fit available space.\n", siz
 327:./block/partition.c ****         size = end_address - start_address;
 328:./block/partition.c ****         printk(KERN_INFO "New partition size: %d\n", size);
 329:./block/partition.c ****     }
 330:./block/partition.c ****     if(size <= 0 ){
 1773              		.loc 1 330 5 is_stmt 1 view .LVU463
 1774              		.loc 1 330 7 is_stmt 0 view .LVU464
 1775 00c8 8DB3     		cbz	r5, .L138
 331:./block/partition.c ****         printk(KERN_INFO "this size: %d of block  is not work\n",size);
 332:./block/partition.c ****         return -1;
 333:./block/partition.c ****     }
 334:./block/partition.c ****     MBR_partition_table_create(mbr_partition, 0x00, start_address, size, type);              //
 1776              		.loc 1 334 5 is_stmt 1 view .LVU465
 1777 00ca CDF80090 		str	r9, [sp]
 1778 00ce 2B46     		mov	r3, r5
 1779 00d0 2246     		mov	r2, r4
 1780 00d2 0021     		movs	r1, #0
 1781 00d4 5046     		mov	r0, r10
 1782 00d6 FFF7FEFF 		bl	MBR_partition_table_create
 1783              	.LVL167:
 335:./block/partition.c ****     tidy_up_MBR_Table(partition);                                                               //
 1784              		.loc 1 335 5 view .LVU466
 1785 00da 3046     		mov	r0, r6
 1786 00dc FFF7FEFF 		bl	tidy_up_MBR_Table
 1787              	.LVL168:
 336:./block/partition.c ****     mbr_partition_table_update(device,partition);                                                  
 1788              		.loc 1 336 5 view .LVU467
 1789 00e0 3146     		mov	r1, r6
 1790 00e2 4046     		mov	r0, r8
 1791 00e4 FFF7FEFF 		bl	mbr_partition_table_update
 1792              	.LVL169:
 337:./block/partition.c ****     return 0;
 1793              		.loc 1 337 5 view .LVU468
 1794              		.loc 1 337 12 is_stmt 0 view .LVU469
 1795 00e8 0020     		movs	r0, #0
 1796              	.LVL170:
 1797              	.L113:
 338:./block/partition.c **** }
 1798              		.loc 1 338 1 view .LVU470
 1799 00ea 04B0     		add	sp, sp, #16
 1800              	.LCFI39:
 1801              		.cfi_remember_state
 1802              		.cfi_def_cfa_offset 32
 1803              		@ sp needed
 1804 00ec BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1805              	.LVL171:
 1806              	.L134:
 1807              	.LCFI40:
 1808              		.cfi_restore_state
 294:./block/partition.c ****             return -1;
ARM GAS  /tmp/ccz04fb7.s 			page 68


 1809              		.loc 1 294 12 is_stmt 1 view .LVU471
 1810 00f0 1A48     		ldr	r0, .L139+32
 1811 00f2 FFF7FEFF 		bl	printk
 1812              	.LVL172:
 295:./block/partition.c ****         }
 1813              		.loc 1 295 13 view .LVU472
 295:./block/partition.c ****         }
 1814              		.loc 1 295 20 is_stmt 0 view .LVU473
 1815 00f6 4FF0FF30 		mov	r0, #-1
 1816 00fa F6E7     		b	.L113
 1817              	.LVL173:
 1818              	.L135:
 315:./block/partition.c ****     else 
 1819              		.loc 1 315 9 is_stmt 1 view .LVU474
 315:./block/partition.c ****     else 
 1820              		.loc 1 315 23 is_stmt 0 view .LVU475
 1821 00fc 0131     		adds	r1, r1, #1
 1822 00fe 4046     		mov	r0, r8
 1823 0100 FFF7FEFF 		bl	get_mbr_partition_start_address
 1824              	.LVL174:
 1825 0104 0746     		mov	r7, r0
 1826              	.LVL175:
 318:./block/partition.c ****         end_address =device->bd_nr_sectors - 33 -1;                                          //
 1827              		.loc 1 318 5 is_stmt 1 view .LVU476
 318:./block/partition.c ****         end_address =device->bd_nr_sectors - 33 -1;                                          //
 1828              		.loc 1 318 7 is_stmt 0 view .LVU477
 1829 0106 B0F1FF3F 		cmp	r0, #-1
 1830 010a D8D1     		bne	.L126
 1831 010c D4E7     		b	.L125
 1832              	.LVL176:
 1833              	.L136:
 322:./block/partition.c ****         return -1;
 1834              		.loc 1 322 9 is_stmt 1 view .LVU478
 1835 010e 1448     		ldr	r0, .L139+36
 1836 0110 FFF7FEFF 		bl	printk
 1837              	.LVL177:
 323:./block/partition.c ****     }
 1838              		.loc 1 323 9 view .LVU479
 323:./block/partition.c ****     }
 1839              		.loc 1 323 16 is_stmt 0 view .LVU480
 1840 0114 4FF0FF30 		mov	r0, #-1
 1841 0118 E7E7     		b	.L113
 1842              	.L137:
 326:./block/partition.c ****         size = end_address - start_address;
 1843              		.loc 1 326 9 is_stmt 1 view .LVU481
 1844 011a 2946     		mov	r1, r5
 1845 011c 1148     		ldr	r0, .L139+40
 1846 011e FFF7FEFF 		bl	printk
 1847              	.LVL178:
 327:./block/partition.c ****         printk(KERN_INFO "New partition size: %d\n", size);
 1848              		.loc 1 327 9 view .LVU482
 327:./block/partition.c ****         printk(KERN_INFO "New partition size: %d\n", size);
 1849              		.loc 1 327 14 is_stmt 0 view .LVU483
 1850 0122 3D1B     		subs	r5, r7, r4
 1851              	.LVL179:
 328:./block/partition.c ****     }
 1852              		.loc 1 328 9 is_stmt 1 view .LVU484
ARM GAS  /tmp/ccz04fb7.s 			page 69


 1853 0124 2946     		mov	r1, r5
 1854 0126 1048     		ldr	r0, .L139+44
 1855 0128 FFF7FEFF 		bl	printk
 1856              	.LVL180:
 1857 012c CCE7     		b	.L128
 1858              	.L138:
 331:./block/partition.c ****         return -1;
 1859              		.loc 1 331 9 view .LVU485
 1860 012e 2946     		mov	r1, r5
 1861 0130 0E48     		ldr	r0, .L139+48
 1862 0132 FFF7FEFF 		bl	printk
 1863              	.LVL181:
 332:./block/partition.c ****     }
 1864              		.loc 1 332 9 view .LVU486
 332:./block/partition.c ****     }
 1865              		.loc 1 332 16 is_stmt 0 view .LVU487
 1866 0136 4FF0FF30 		mov	r0, #-1
 1867 013a D6E7     		b	.L113
 1868              	.L140:
 1869              		.align	2
 1870              	.L139:
 1871 013c 7C000000 		.word	.LC7
 1872 0140 2C010000 		.word	.LC12
 1873 0144 00000000 		.word	.LC4
 1874 0148 1C000000 		.word	.LC5
 1875 014c 38000000 		.word	.LC6
 1876 0150 AC000000 		.word	.LC8
 1877 0154 BC000000 		.word	.LC9
 1878 0158 F4000000 		.word	.LC11
 1879 015c D8000000 		.word	.LC10
 1880 0160 4C010000 		.word	.LC13
 1881 0164 88010000 		.word	.LC14
 1882 0168 CC010000 		.word	.LC15
 1883 016c E4010000 		.word	.LC16
 1884              		.cfi_endproc
 1885              	.LFE1054:
 1887              		.section	.text.get_partition_from_device,"ax",%progbits
 1888              		.align	1
 1889              		.global	get_partition_from_device
 1890              		.syntax unified
 1891              		.thumb
 1892              		.thumb_func
 1894              	get_partition_from_device:
 1895              	.LVL182:
 1896              	.LFB1056:
 339:./block/partition.c **** 
 340:./block/partition.c **** static void  show_mbr_partition_table_info(struct mbr_partition *mbr_partition)
 341:./block/partition.c **** {
 342:./block/partition.c ****     if(mbr_partition == NULL) return;
 343:./block/partition.c **** 
 344:./block/partition.c ****     if(mbr_partition->boot_ind == 0x80)
 345:./block/partition.c ****         printk(KERN_INFO"bootable\n\r");
 346:./block/partition.c ****     else
 347:./block/partition.c ****         printk(KERN_INFO"not bootable\n\r");
 348:./block/partition.c ****     printk(KERN_INFO"start_address = %d\n\r",mbr_partition->start_lba);
 349:./block/partition.c ****     printk(KERN_INFO"size          = %d(%dKB)(%dMB)\n\r",mbr_partition->nr_sectors,mbr_partition->n
 350:./block/partition.c ****     
ARM GAS  /tmp/ccz04fb7.s 			page 70


 351:./block/partition.c ****     if(mbr_partition->sys_ind == 0x0B)
 352:./block/partition.c ****     printk(KERN_INFO"type          = FAT\n\r");
 353:./block/partition.c ****     else if(mbr_partition->sys_ind == 0x83)
 354:./block/partition.c ****     printk(KERN_INFO"type          = EXT\n\r");
 355:./block/partition.c ****     else if(mbr_partition->sys_ind == 0x07)
 356:./block/partition.c ****     printk(KERN_INFO"type          = NTFS\n\r");
 357:./block/partition.c ****     else
 358:./block/partition.c ****     printk(KERN_INFO"type          = unknown\n\r");
 359:./block/partition.c **** }
 360:./block/partition.c **** 
 361:./block/partition.c **** 
 362:./block/partition.c **** 
 363:./block/partition.c **** 
 364:./block/partition.c **** 
 365:./block/partition.c **** 
 366:./block/partition.c **** 
 367:./block/partition.c **** 
 368:./block/partition.c **** 
 369:./block/partition.c **** 
 370:./block/partition.c **** 
 371:./block/partition.c **** 
 372:./block/partition.c **** 
 373:./block/partition.c **** 
 374:./block/partition.c **** struct partition* get_partition_from_device(struct block_device *bdev){
 1897              		.loc 1 374 71 is_stmt 1 view -0
 1898              		.cfi_startproc
 1899              		@ args = 0, pretend = 0, frame = 0
 1900              		@ frame_needed = 0, uses_anonymous_args = 0
 1901              		.loc 1 374 71 is_stmt 0 view .LVU489
 1902 0000 38B5     		push	{r3, r4, r5, lr}
 1903              	.LCFI41:
 1904              		.cfi_def_cfa_offset 16
 1905              		.cfi_offset 3, -16
 1906              		.cfi_offset 4, -12
 1907              		.cfi_offset 5, -8
 1908              		.cfi_offset 14, -4
 375:./block/partition.c ****     if(bdev == NULL) return NULL;
 1909              		.loc 1 375 5 is_stmt 1 view .LVU490
 1910              		.loc 1 375 7 is_stmt 0 view .LVU491
 1911 0002 0546     		mov	r5, r0
 1912 0004 A8B1     		cbz	r0, .L143
 376:./block/partition.c ****     struct partition *device_partition = kmalloc(sizeof(struct partition),GFP_KERNEL);
 1913              		.loc 1 376 5 is_stmt 1 view .LVU492
 1914              	.LVL183:
 1915              	.LBB112:
 1916              	.LBI112:
 379:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 1917              		.loc 3 379 21 view .LVU493
 1918              	.LBB113:
 380:./include/linux/slab.h **** }
 1919              		.loc 3 380 2 view .LVU494
 380:./include/linux/slab.h **** }
 1920              		.loc 3 380 9 is_stmt 0 view .LVU495
 1921 0006 4FF44C61 		mov	r1, #3264
 1922 000a 40F22440 		movw	r0, #1060
 1923              	.LVL184:
 380:./include/linux/slab.h **** }
ARM GAS  /tmp/ccz04fb7.s 			page 71


 1924              		.loc 3 380 9 view .LVU496
 1925 000e FFF7FEFF 		bl	__smalloc__
 1926              	.LVL185:
 380:./include/linux/slab.h **** }
 1927              		.loc 3 380 9 view .LVU497
 1928              	.LBE113:
 1929              	.LBE112:
 377:./block/partition.c ****     if(device_partition == NULL) return -ENOMEM;
 1930              		.loc 1 377 5 is_stmt 1 view .LVU498
 1931              		.loc 1 377 7 is_stmt 0 view .LVU499
 1932 0012 0446     		mov	r4, r0
 1933 0014 78B1     		cbz	r0, .L144
 378:./block/partition.c ****     if(mbr_partition_table_load(bdev,device_partition) < 0){
 1934              		.loc 1 378 5 is_stmt 1 view .LVU500
 1935              		.loc 1 378 8 is_stmt 0 view .LVU501
 1936 0016 0146     		mov	r1, r0
 1937 0018 2846     		mov	r0, r5
 1938              	.LVL186:
 1939              		.loc 1 378 8 view .LVU502
 1940 001a FFF7FEFF 		bl	mbr_partition_table_load
 1941              	.LVL187:
 1942              		.loc 1 378 7 discriminator 1 view .LVU503
 1943 001e 0028     		cmp	r0, #0
 1944 0020 01DB     		blt	.L146
 1945              	.LVL188:
 1946              	.L141:
 379:./block/partition.c ****         kfree(device_partition);
 380:./block/partition.c ****         return -EIO;
 381:./block/partition.c ****     }
 382:./block/partition.c ****     return device_partition;
 383:./block/partition.c **** }
 1947              		.loc 1 383 1 view .LVU504
 1948 0022 2046     		mov	r0, r4
 1949 0024 38BD     		pop	{r3, r4, r5, pc}
 1950              	.LVL189:
 1951              	.L146:
 379:./block/partition.c ****         kfree(device_partition);
 1952              		.loc 1 379 9 is_stmt 1 view .LVU505
 1953              	.LBB114:
 1954              	.LBI114:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 1955              		.loc 3 383 20 view .LVU506
 1956              	.LBB115:
 1957              		.loc 3 384 2 view .LVU507
 1958 0026 2046     		mov	r0, r4
 1959 0028 FFF7FEFF 		bl	__sfree__
 1960              	.LVL190:
 1961              		.loc 3 384 2 is_stmt 0 view .LVU508
 1962              	.LBE115:
 1963              	.LBE114:
 380:./block/partition.c ****     }
 1964              		.loc 1 380 9 is_stmt 1 view .LVU509
 380:./block/partition.c ****     }
 1965              		.loc 1 380 16 is_stmt 0 view .LVU510
 1966 002c 6FF00404 		mvn	r4, #4
 1967              	.LVL191:
 380:./block/partition.c ****     }
ARM GAS  /tmp/ccz04fb7.s 			page 72


 1968              		.loc 1 380 16 view .LVU511
 1969 0030 F7E7     		b	.L141
 1970              	.LVL192:
 1971              	.L143:
 375:./block/partition.c ****     struct partition *device_partition = kmalloc(sizeof(struct partition),GFP_KERNEL);
 1972              		.loc 1 375 29 discriminator 1 view .LVU512
 1973 0032 0446     		mov	r4, r0
 1974 0034 F5E7     		b	.L141
 1975              	.LVL193:
 1976              	.L144:
 377:./block/partition.c ****     if(mbr_partition_table_load(bdev,device_partition) < 0){
 1977              		.loc 1 377 41 discriminator 1 view .LVU513
 1978 0036 6FF00B04 		mvn	r4, #11
 1979 003a F2E7     		b	.L141
 1980              		.cfi_endproc
 1981              	.LFE1056:
 1983              		.section	.text.get_partiton_data,"ax",%progbits
 1984              		.align	1
 1985              		.global	get_partiton_data
 1986              		.syntax unified
 1987              		.thumb
 1988              		.thumb_func
 1990              	get_partiton_data:
 1991              	.LVL194:
 1992              	.LFB1057:
 384:./block/partition.c **** 
 385:./block/partition.c **** #define mbr_partiton_startaddress 0x01
 386:./block/partition.c **** #define mbr_partiton_size         0x02
 387:./block/partition.c **** #define mbr_partiton_magic        0x03
 388:./block/partition.c **** 
 389:./block/partition.c **** uint32_t get_partiton_data(struct partition* partition,int number,uint32_t flag)
 390:./block/partition.c **** {
 1993              		.loc 1 390 1 is_stmt 1 view -0
 1994              		.cfi_startproc
 1995              		@ args = 0, pretend = 0, frame = 0
 1996              		@ frame_needed = 0, uses_anonymous_args = 0
 391:./block/partition.c ****     if(partition == NULL) return 0;
 1997              		.loc 1 391 5 view .LVU515
 1998              		.loc 1 391 7 is_stmt 0 view .LVU516
 1999 0000 80B1     		cbz	r0, .L152
 390:./block/partition.c ****     if(partition == NULL) return 0;
 2000              		.loc 1 390 1 view .LVU517
 2001 0002 08B5     		push	{r3, lr}
 2002              	.LCFI42:
 2003              		.cfi_def_cfa_offset 8
 2004              		.cfi_offset 3, -8
 2005              		.cfi_offset 14, -4
 392:./block/partition.c ****     if(flag == mbr_partiton_startaddress)
 2006              		.loc 1 392 5 is_stmt 1 view .LVU518
 2007              		.loc 1 392 7 is_stmt 0 view .LVU519
 2008 0004 012A     		cmp	r2, #1
 2009 0006 04D0     		beq	.L157
 393:./block/partition.c ****         return get_mbr_partition_start_address(partition, number);
 394:./block/partition.c ****     if(flag == mbr_partiton_size)
 2010              		.loc 1 394 5 is_stmt 1 view .LVU520
 2011              		.loc 1 394 7 is_stmt 0 view .LVU521
 2012 0008 022A     		cmp	r2, #2
ARM GAS  /tmp/ccz04fb7.s 			page 73


 2013 000a 05D0     		beq	.L158
 395:./block/partition.c ****         return get_mbr_partition_size(partition,number);
 396:./block/partition.c ****     if(flag == mbr_partiton_magic)
 2014              		.loc 1 396 5 is_stmt 1 view .LVU522
 2015              		.loc 1 396 7 is_stmt 0 view .LVU523
 2016 000c 032A     		cmp	r2, #3
 2017 000e 06D0     		beq	.L159
 2018              	.LVL195:
 2019              	.L147:
 397:./block/partition.c ****         return get_mbr_partition_type(partition,number);
 398:./block/partition.c **** }
 2020              		.loc 1 398 1 view .LVU524
 2021 0010 08BD     		pop	{r3, pc}
 2022              	.LVL196:
 2023              	.L157:
 393:./block/partition.c ****     if(flag == mbr_partiton_size)
 2024              		.loc 1 393 9 is_stmt 1 view .LVU525
 393:./block/partition.c ****     if(flag == mbr_partiton_size)
 2025              		.loc 1 393 16 is_stmt 0 view .LVU526
 2026 0012 FFF7FEFF 		bl	get_mbr_partition_start_address
 2027              	.LVL197:
 393:./block/partition.c ****     if(flag == mbr_partiton_size)
 2028              		.loc 1 393 16 view .LVU527
 2029 0016 FBE7     		b	.L147
 2030              	.LVL198:
 2031              	.L158:
 395:./block/partition.c ****         return get_mbr_partition_size(partition,number);
 2032              		.loc 1 395 9 is_stmt 1 view .LVU528
 395:./block/partition.c ****         return get_mbr_partition_size(partition,number);
 2033              		.loc 1 395 16 is_stmt 0 view .LVU529
 2034 0018 FFF7FEFF 		bl	get_mbr_partition_size
 2035              	.LVL199:
 395:./block/partition.c ****         return get_mbr_partition_size(partition,number);
 2036              		.loc 1 395 16 view .LVU530
 2037 001c F8E7     		b	.L147
 2038              	.LVL200:
 2039              	.L159:
 397:./block/partition.c ****         return get_mbr_partition_type(partition,number);
 2040              		.loc 1 397 9 is_stmt 1 view .LVU531
 397:./block/partition.c ****         return get_mbr_partition_type(partition,number);
 2041              		.loc 1 397 16 is_stmt 0 view .LVU532
 2042 001e FFF7FEFF 		bl	get_mbr_partition_type
 2043              	.LVL201:
 397:./block/partition.c ****         return get_mbr_partition_type(partition,number);
 2044              		.loc 1 397 16 view .LVU533
 2045 0022 F5E7     		b	.L147
 2046              	.LVL202:
 2047              	.L152:
 2048              	.LCFI43:
 2049              		.cfi_def_cfa_offset 0
 2050              		.cfi_restore 3
 2051              		.cfi_restore 14
 391:./block/partition.c ****     if(flag == mbr_partiton_startaddress)
 2052              		.loc 1 391 34 discriminator 1 view .LVU534
 2053 0024 0020     		movs	r0, #0
 2054              	.LVL203:
 2055              		.loc 1 398 1 view .LVU535
ARM GAS  /tmp/ccz04fb7.s 			page 74


 2056 0026 7047     		bx	lr
 2057              		.cfi_endproc
 2058              	.LFE1057:
 2060              		.section	.text.create_mbr_artiton,"ax",%progbits
 2061              		.align	1
 2062              		.global	create_mbr_artiton
 2063              		.syntax unified
 2064              		.thumb
 2065              		.thumb_func
 2067              	create_mbr_artiton:
 2068              	.LVL204:
 2069              	.LFB1058:
 399:./block/partition.c **** 
 400:./block/partition.c **** #define  FAT32 0x0B
 401:./block/partition.c **** #define  EXT   0x83
 402:./block/partition.c **** #define  NTFS  0x07
 403:./block/partition.c **** 
 404:./block/partition.c **** int create_mbr_artiton(struct block_device *bdev,size_t size,uint8_t type)
 405:./block/partition.c **** {
 2070              		.loc 1 405 1 is_stmt 1 view -0
 2071              		.cfi_startproc
 2072              		@ args = 0, pretend = 0, frame = 1064
 2073              		@ frame_needed = 0, uses_anonymous_args = 0
 2074              		.loc 1 405 1 is_stmt 0 view .LVU537
 2075 0000 00B5     		push	{lr}
 2076              	.LCFI44:
 2077              		.cfi_def_cfa_offset 4
 2078              		.cfi_offset 14, -4
 2079 0002 ADF22C4D 		subw	sp, sp, #1068
 2080              	.LCFI45:
 2081              		.cfi_def_cfa_offset 1072
 2082 0006 1346     		mov	r3, r2
 406:./block/partition.c ****     struct partition device_partition;
 2083              		.loc 1 406 5 is_stmt 1 view .LVU538
 407:./block/partition.c ****     return mbr_partition_table_format(bdev,&device_partition,size,type); 
 2084              		.loc 1 407 5 view .LVU539
 2085              		.loc 1 407 12 is_stmt 0 view .LVU540
 2086 0008 0A46     		mov	r2, r1
 2087              	.LVL205:
 2088              		.loc 1 407 12 view .LVU541
 2089 000a 01A9     		add	r1, sp, #4
 2090              	.LVL206:
 2091              		.loc 1 407 12 view .LVU542
 2092 000c FFF7FEFF 		bl	mbr_partition_table_format
 2093              	.LVL207:
 408:./block/partition.c **** }
 2094              		.loc 1 408 1 view .LVU543
 2095 0010 0DF22C4D 		addw	sp, sp, #1068
 2096              	.LCFI46:
 2097              		.cfi_def_cfa_offset 4
 2098              		@ sp needed
 2099 0014 5DF804FB 		ldr	pc, [sp], #4
 2100              		.cfi_endproc
 2101              	.LFE1058:
 2103              		.section	.text.get_partition_type,"ax",%progbits
 2104              		.align	1
 2105              		.global	get_partition_type
ARM GAS  /tmp/ccz04fb7.s 			page 75


 2106              		.syntax unified
 2107              		.thumb
 2108              		.thumb_func
 2110              	get_partition_type:
 2111              	.LVL208:
 2112              	.LFB1059:
 409:./block/partition.c **** 
 410:./block/partition.c **** int get_partition_type(struct block_device *bdev)
 411:./block/partition.c **** {
 2113              		.loc 1 411 1 is_stmt 1 view -0
 2114              		.cfi_startproc
 2115              		@ args = 0, pretend = 0, frame = 8
 2116              		@ frame_needed = 0, uses_anonymous_args = 0
 2117              		.loc 1 411 1 is_stmt 0 view .LVU545
 2118 0000 30B5     		push	{r4, r5, lr}
 2119              	.LCFI47:
 2120              		.cfi_def_cfa_offset 12
 2121              		.cfi_offset 4, -12
 2122              		.cfi_offset 5, -8
 2123              		.cfi_offset 14, -4
 2124 0002 83B0     		sub	sp, sp, #12
 2125              	.LCFI48:
 2126              		.cfi_def_cfa_offset 24
 2127 0004 0446     		mov	r4, r0
 412:./block/partition.c ****     enum block_device_flags_t flags;
 2128              		.loc 1 412 5 is_stmt 1 view .LVU546
 413:./block/partition.c ****     char *buffer = kmalloc(512,GFP_KERNEL);
 2129              		.loc 1 413 5 view .LVU547
 2130              	.LVL209:
 2131              	.LBB116:
 2132              	.LBI116:
 379:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 2133              		.loc 3 379 21 view .LVU548
 2134              	.LBB117:
 380:./include/linux/slab.h **** }
 2135              		.loc 3 380 2 view .LVU549
 380:./include/linux/slab.h **** }
 2136              		.loc 3 380 9 is_stmt 0 view .LVU550
 2137 0006 4FF44C61 		mov	r1, #3264
 2138 000a 4FF40070 		mov	r0, #512
 2139              	.LVL210:
 380:./include/linux/slab.h **** }
 2140              		.loc 3 380 9 view .LVU551
 2141 000e FFF7FEFF 		bl	__smalloc__
 2142              	.LVL211:
 380:./include/linux/slab.h **** }
 2143              		.loc 3 380 9 view .LVU552
 2144              	.LBE117:
 2145              	.LBE116:
 414:./block/partition.c ****     if(buffer == NULL) return -ENOMEM;
 2146              		.loc 1 414 5 is_stmt 1 view .LVU553
 2147              		.loc 1 414 7 is_stmt 0 view .LVU554
 2148 0012 68B1     		cbz	r0, .L164
 2149 0014 0546     		mov	r5, r0
 415:./block/partition.c ****     detect_partition_table(bdev,buffer,&flags);
 2150              		.loc 1 415 5 is_stmt 1 view .LVU555
 2151 0016 0DF10702 		add	r2, sp, #7
ARM GAS  /tmp/ccz04fb7.s 			page 76


 2152 001a 0146     		mov	r1, r0
 2153 001c 2046     		mov	r0, r4
 2154              	.LVL212:
 2155              		.loc 1 415 5 is_stmt 0 view .LVU556
 2156 001e FFF7FEFF 		bl	detect_partition_table
 2157              	.LVL213:
 416:./block/partition.c ****     kfree(buffer);
 2158              		.loc 1 416 5 is_stmt 1 view .LVU557
 2159              	.LBB118:
 2160              	.LBI118:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 2161              		.loc 3 383 20 view .LVU558
 2162              	.LBB119:
 2163              		.loc 3 384 2 view .LVU559
 2164 0022 2846     		mov	r0, r5
 2165 0024 FFF7FEFF 		bl	__sfree__
 2166              	.LVL214:
 2167              		.loc 3 384 2 is_stmt 0 view .LVU560
 2168              	.LBE119:
 2169              	.LBE118:
 417:./block/partition.c ****     return flags;
 2170              		.loc 1 417 5 is_stmt 1 view .LVU561
 2171              		.loc 1 417 12 is_stmt 0 view .LVU562
 2172 0028 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 2173              	.LVL215:
 2174              	.L162:
 418:./block/partition.c **** }
 2175              		.loc 1 418 1 view .LVU563
 2176 002c 03B0     		add	sp, sp, #12
 2177              	.LCFI49:
 2178              		.cfi_remember_state
 2179              		.cfi_def_cfa_offset 12
 2180              		@ sp needed
 2181 002e 30BD     		pop	{r4, r5, pc}
 2182              	.LVL216:
 2183              	.L164:
 2184              	.LCFI50:
 2185              		.cfi_restore_state
 414:./block/partition.c ****     detect_partition_table(bdev,buffer,&flags);
 2186              		.loc 1 414 31 discriminator 1 view .LVU564
 2187 0030 6FF00B00 		mvn	r0, #11
 2188              	.LVL217:
 414:./block/partition.c ****     detect_partition_table(bdev,buffer,&flags);
 2189              		.loc 1 414 31 discriminator 1 view .LVU565
 2190 0034 FAE7     		b	.L162
 2191              		.cfi_endproc
 2192              	.LFE1059:
 2194              		.section	.data.gpt_head,"aw"
 2195              		.align	2
 2198              	gpt_head:
 2199 0000 45464920 		.ascii	"EFI PART"
 2199      50415254 
 2200              		.text
 2201              	.Letext0:
 2202              		.file 7 "./include/asm-generic/int-l64.h"
 2203              		.file 8 "./include/asm-generic/posix_types.h"
 2204              		.file 9 "./include/uapi/linux/types.h"
ARM GAS  /tmp/ccz04fb7.s 			page 77


 2205              		.file 10 "./include/linux/types.h"
 2206              		.file 11 "./include/linux/stddef.h"
 2207              		.file 12 "./include/linux/gfp_types.h"
 2208              		.file 13 "./include/linux/reciprocal_div.h"
 2209              		.file 14 "./include/linux/time64.h"
 2210              		.file 15 "./arch/arm_m/include/asm/spinlock.h"
 2211              		.file 16 "./include/linux/spinlock_types_raw.h"
 2212              		.file 17 "./include/linux/spinlock_types.h"
 2213              		.file 18 "./include/linux/errseq.h"
 2214              		.file 19 "./include/linux/rbtree_types.h"
 2215              		.file 20 "./include/linux/uidgid_types.h"
 2216              		.file 21 "./include/linux/projid.h"
 2217              		.file 22 "./include/linux/fs.h"
 2218              		.file 23 "./include/linux/mnt_idmapping.h"
 2219              		.file 24 "./include/linux/mutex.h"
 2220              		.file 25 "./include/linux/uio.h"
 2221              		.file 26 "./include/linux/wait.h"
 2222              		.file 27 "./include/linux/xarray.h"
 2223              		.file 28 "./include/linux/migrate_mode.h"
 2224              		.file 29 "./include/linux/rw_hint.h"
 2225              		.file 30 "./include/linux/bvec.h"
 2226              		.file 31 "./include/linux/blk_types.h"
 2227              		.file 32 "./include/linux/blkdev.h"
 2228              		.file 33 "./include/linux/mempool_super_haper.h"
 2229              		.file 34 "./include/linux/mempool.h"
 2230              		.file 35 "./include/linux/lockdep_types.h"
 2231              		.file 36 "./include/linux/workqueue_types.h"
 2232              		.file 37 "./include/linux/blk-mq.h"
 2233              		.file 38 "./include/linux/dcache.h"
 2234              		.file 39 "./include/uapi/linux/pr.h"
 2235              		.file 40 "./include/linux/pr.h"
 2236              		.file 41 "./include/linux/hdreg.h"
 2237              		.file 42 "./include/linux/lockref.h"
 2238              		.file 43 "./include/linux/path.h"
 2239              		.file 44 "./include/linux/statfs.h"
 2240              		.file 45 "./include/linux/stat.h"
 2241              		.file 46 "./arch/arm_m/include/asm/string.h"
 2242              		.file 47 "./include/linux/printk.h"
 2243              		.file 48 "./include/linux/instrumented.h"
 2244              		.file 49 "./include/linux/kcsan-checks.h"
 2245              		.file 50 "./include/linux/kasan-checks.h"
ARM GAS  /tmp/ccz04fb7.s 			page 78


DEFINED SYMBOLS
                            *ABS*:00000000 partition.c
     /tmp/ccz04fb7.s:21     .text.__page_create:00000000 $t
     /tmp/ccz04fb7.s:26     .text.__page_create:00000000 __page_create
     /tmp/ccz04fb7.s:138    .rodata.MBR_partition_table_create.str1.4:00000000 $d
     /tmp/ccz04fb7.s:143    .text.MBR_partition_table_create:00000000 $t
     /tmp/ccz04fb7.s:148    .text.MBR_partition_table_create:00000000 MBR_partition_table_create
     /tmp/ccz04fb7.s:227    .text.MBR_partition_table_create:00000044 $d
     /tmp/ccz04fb7.s:232    .text.my_end_io:00000000 $t
     /tmp/ccz04fb7.s:237    .text.my_end_io:00000000 my_end_io
     /tmp/ccz04fb7.s:259    .text.trans_data_to_blk_dev:00000000 $t
     /tmp/ccz04fb7.s:264    .text.trans_data_to_blk_dev:00000000 trans_data_to_blk_dev
     /tmp/ccz04fb7.s:445    .text.trans_data_to_blk_dev:0000007c $d
     /tmp/ccz04fb7.s:451    .rodata.mbr_partition_table_load.str1.4:00000000 $d
     /tmp/ccz04fb7.s:458    .text.mbr_partition_table_load:00000000 $t
     /tmp/ccz04fb7.s:463    .text.mbr_partition_table_load:00000000 mbr_partition_table_load
     /tmp/ccz04fb7.s:656    .text.mbr_partition_table_load:000000a0 $d
     /tmp/ccz04fb7.s:662    .text.mbr_partition_table_update:00000000 $t
     /tmp/ccz04fb7.s:667    .text.mbr_partition_table_update:00000000 mbr_partition_table_update
     /tmp/ccz04fb7.s:856    .text.move_MBR_Table:00000000 $t
     /tmp/ccz04fb7.s:861    .text.move_MBR_Table:00000000 move_MBR_Table
     /tmp/ccz04fb7.s:894    .text.detect_partition_table:00000000 $t
     /tmp/ccz04fb7.s:899    .text.detect_partition_table:00000000 detect_partition_table
     /tmp/ccz04fb7.s:1006   .text.detect_partition_table:00000064 $d
     /tmp/ccz04fb7.s:2198   .data.gpt_head:00000000 gpt_head
     /tmp/ccz04fb7.s:1011   .text.check_empty_MBR_Table:00000000 $t
     /tmp/ccz04fb7.s:1017   .text.check_empty_MBR_Table:00000000 check_empty_MBR_Table
     /tmp/ccz04fb7.s:1077   .rodata.get_mbr_partition_start_address.str1.4:00000000 $d
     /tmp/ccz04fb7.s:1081   .text.get_mbr_partition_start_address:00000000 $t
     /tmp/ccz04fb7.s:1086   .text.get_mbr_partition_start_address:00000000 get_mbr_partition_start_address
     /tmp/ccz04fb7.s:1151   .text.get_mbr_partition_start_address:00000030 $d
     /tmp/ccz04fb7.s:1156   .text.get_mbr_partition_size:00000000 $t
     /tmp/ccz04fb7.s:1161   .text.get_mbr_partition_size:00000000 get_mbr_partition_size
     /tmp/ccz04fb7.s:1228   .text.get_mbr_partition_type:00000000 $t
     /tmp/ccz04fb7.s:1233   .text.get_mbr_partition_type:00000000 get_mbr_partition_type
     /tmp/ccz04fb7.s:1304   .text.get_empty_MBR_Table:00000000 $t
     /tmp/ccz04fb7.s:1309   .text.get_empty_MBR_Table:00000000 get_empty_MBR_Table
     /tmp/ccz04fb7.s:1377   .text.tidy_up_MBR_Table:00000000 $t
     /tmp/ccz04fb7.s:1382   .text.tidy_up_MBR_Table:00000000 tidy_up_MBR_Table
     /tmp/ccz04fb7.s:1512   .rodata.mbr_partition_table_format.str1.4:00000000 $d
     /tmp/ccz04fb7.s:1556   .text.mbr_partition_table_format:00000000 $t
     /tmp/ccz04fb7.s:1561   .text.mbr_partition_table_format:00000000 mbr_partition_table_format
     /tmp/ccz04fb7.s:1871   .text.mbr_partition_table_format:0000013c $d
     /tmp/ccz04fb7.s:1888   .text.get_partition_from_device:00000000 $t
     /tmp/ccz04fb7.s:1894   .text.get_partition_from_device:00000000 get_partition_from_device
     /tmp/ccz04fb7.s:1984   .text.get_partiton_data:00000000 $t
     /tmp/ccz04fb7.s:1990   .text.get_partiton_data:00000000 get_partiton_data
     /tmp/ccz04fb7.s:2061   .text.create_mbr_artiton:00000000 $t
     /tmp/ccz04fb7.s:2067   .text.create_mbr_artiton:00000000 create_mbr_artiton
     /tmp/ccz04fb7.s:2104   .text.get_partition_type:00000000 $t
     /tmp/ccz04fb7.s:2110   .text.get_partition_type:00000000 get_partition_type
     /tmp/ccz04fb7.s:2195   .data.gpt_head:00000000 $d

UNDEFINED SYMBOLS
__smalloc__
printk
bio_put
ARM GAS  /tmp/ccz04fb7.s 			page 79


bio_alloc_bioset
bio_add_page
submit_bio_wait
fs_bio_set
__sfree__
memcmp
