ARM GAS  /tmp/ccgt6wcN.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"partition.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./block/partition.c"
  20              		.section	.text.my_end_io,"ax",%progbits
  21              		.align	1
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	my_end_io:
  27              	.LVL0:
  28              	.LFB1033:
   1:./block/partition.c **** #include <linux/kernel.h>
   2:./block/partition.c **** #include <linux/slab.h>
   3:./block/partition.c **** #include <linux/fs.h>
   4:./block/partition.c **** #include <linux/blkdev.h>
   5:./block/partition.c **** #include <linux/spinlock.h>
   6:./block/partition.c **** #include <linux/string.h>
   7:./block/partition.c **** #include <asm/byteorder.h>
   8:./block/partition.c **** 
   9:./block/partition.c **** 
  10:./block/partition.c **** static void my_end_io(struct bio *bio){
  29              		.loc 1 10 39 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		.loc 1 10 39 is_stmt 0 view .LVU1
  34 0000 08B5     		push	{r3, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 8
  37              		.cfi_offset 3, -8
  38              		.cfi_offset 14, -4
  11:./block/partition.c ****     bio_put(bio);
  39              		.loc 1 11 5 is_stmt 1 view .LVU2
  40 0002 FFF7FEFF 		bl	bio_put
  41              	.LVL1:
  12:./block/partition.c **** }
  42              		.loc 1 12 1 is_stmt 0 view .LVU3
  43 0006 08BD     		pop	{r3, pc}
  44              		.cfi_endproc
  45              	.LFE1033:
  47              		.section	.text.__page_create,"ax",%progbits
ARM GAS  /tmp/ccgt6wcN.s 			page 2


  48              		.align	1
  49              		.syntax unified
  50              		.thumb
  51              		.thumb_func
  53              	__page_create:
  54              	.LVL2:
  55              	.LFB908:
  56              		.file 2 "./include/linux/mm_type.h"
   1:./include/linux/mm_type.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/mm_type.h **** #ifndef _LINUX_MM_TYPES_H
   3:./include/linux/mm_type.h **** #define _LINUX_MM_TYPES_H
   4:./include/linux/mm_type.h **** 
   5:./include/linux/mm_type.h **** #include <linux/list.h>
   6:./include/linux/mm_type.h **** #include <linux/spinlock.h>
   7:./include/linux/mm_type.h **** #include <linux/slab.h>
   8:./include/linux/mm_type.h **** #include <linux/atomic.h>
   9:./include/linux/mm_type.h **** #include <linux/errno.h>
  10:./include/linux/mm_type.h **** 
  11:./include/linux/mm_type.h **** 
  12:./include/linux/mm_type.h **** 
  13:./include/linux/mm_type.h **** struct page {
  14:./include/linux/mm_type.h **** 	unsigned long flags;		/* Atomic flags, some possibly
  15:./include/linux/mm_type.h **** 					 * updated asynchronously */
  16:./include/linux/mm_type.h **** 	/*
  17:./include/linux/mm_type.h **** 	 * Five words (20/40 bytes) are available in this union.
  18:./include/linux/mm_type.h **** 	 * WARNING: bit 0 of the first word is used for PageTail(). That
  19:./include/linux/mm_type.h **** 	 * means the other users of this union MUST NOT use the bit to
  20:./include/linux/mm_type.h **** 	 * avoid collision and false-positive PageTail().
  21:./include/linux/mm_type.h **** 	 */
  22:./include/linux/mm_type.h **** 	union {
  23:./include/linux/mm_type.h **** 		struct {	/* Page cache and anonymous pages */
  24:./include/linux/mm_type.h **** 			/**
  25:./include/linux/mm_type.h **** 			 * @lru: Pageout list, eg. active_list protected by
  26:./include/linux/mm_type.h **** 			 * lruvec->lru_lock.  Sometimes used as a generic list
  27:./include/linux/mm_type.h **** 			 * by the page owner.
  28:./include/linux/mm_type.h **** 			 */
  29:./include/linux/mm_type.h **** 			union {
  30:./include/linux/mm_type.h **** 				struct list_head lru;
  31:./include/linux/mm_type.h **** 
  32:./include/linux/mm_type.h **** 				/* Or, for the Unevictable "LRU list" slot */
  33:./include/linux/mm_type.h **** 				struct {
  34:./include/linux/mm_type.h **** 					/* Always even, to negate PageTail */
  35:./include/linux/mm_type.h **** 					void *__filler;
  36:./include/linux/mm_type.h **** 					/* Count page's or folio's mlocks */
  37:./include/linux/mm_type.h **** 					unsigned int mlock_count;
  38:./include/linux/mm_type.h **** 				};
  39:./include/linux/mm_type.h **** 
  40:./include/linux/mm_type.h **** 				/* Or, free page */
  41:./include/linux/mm_type.h **** 				struct list_head buddy_list;
  42:./include/linux/mm_type.h **** 				struct list_head pcp_list;
  43:./include/linux/mm_type.h **** 			};
  44:./include/linux/mm_type.h **** 			/* See page-flags.h for PAGE_MAPPING_FLAGS */
  45:./include/linux/mm_type.h **** 			struct address_space *mapping;
  46:./include/linux/mm_type.h **** 			union {
  47:./include/linux/mm_type.h **** 				pgoff_t index;		/* Our offset within mapping. */
  48:./include/linux/mm_type.h **** 				unsigned long share;	/* share count for fsdax */
  49:./include/linux/mm_type.h **** 			};
ARM GAS  /tmp/ccgt6wcN.s 			page 3


  50:./include/linux/mm_type.h **** 			/**
  51:./include/linux/mm_type.h **** 			 * @private: Mapping-private opaque data.
  52:./include/linux/mm_type.h **** 			 * Usually used for buffer_heads if PagePrivate.
  53:./include/linux/mm_type.h **** 			 * Used for swp_entry_t if swapcache flag set.
  54:./include/linux/mm_type.h **** 			 * Indicates order in the buddy system if PageBuddy.
  55:./include/linux/mm_type.h **** 			 */
  56:./include/linux/mm_type.h **** 			unsigned long private;
  57:./include/linux/mm_type.h **** 		};
  58:./include/linux/mm_type.h **** 		struct {	/* page_pool used by netstack */
  59:./include/linux/mm_type.h **** 			/**
  60:./include/linux/mm_type.h **** 			 * @pp_magic: magic value to avoid recycling non
  61:./include/linux/mm_type.h **** 			 * page_pool allocated pages.
  62:./include/linux/mm_type.h **** 			 */
  63:./include/linux/mm_type.h **** 			unsigned long pp_magic;
  64:./include/linux/mm_type.h **** 		//	struct page_pool *pp; 
  65:./include/linux/mm_type.h **** 			unsigned long _pp_mapping_pad;
  66:./include/linux/mm_type.h **** 			unsigned long dma_addr;
  67:./include/linux/mm_type.h **** 		//	atomic_long_t pp_ref_count;
  68:./include/linux/mm_type.h **** 		};
  69:./include/linux/mm_type.h **** 		struct {	/* Tail pages of compound page */
  70:./include/linux/mm_type.h **** 			unsigned long compound_head;	/* Bit zero is set */
  71:./include/linux/mm_type.h **** 		};
  72:./include/linux/mm_type.h **** 		struct {	/* ZONE_DEVICE pages */
  73:./include/linux/mm_type.h **** 			/** @pgmap: Points to the hosting device page map. */
  74:./include/linux/mm_type.h **** 			// struct dev_pagemap *pgmap;
  75:./include/linux/mm_type.h **** 			void *zone_device_data;
  76:./include/linux/mm_type.h **** 			/*
  77:./include/linux/mm_type.h **** 			 * ZONE_DEVICE private pages are counted as being
  78:./include/linux/mm_type.h **** 			 * mapped so the next 3 words hold the mapping, index,
  79:./include/linux/mm_type.h **** 			 * and private fields from the source anonymous or
  80:./include/linux/mm_type.h **** 			 * page cache page while the page is migrated to device
  81:./include/linux/mm_type.h **** 			 * private memory.
  82:./include/linux/mm_type.h **** 			 * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also
  83:./include/linux/mm_type.h **** 			 * use the mapping, index, and private fields when
  84:./include/linux/mm_type.h **** 			 * pmem backed DAX files are mapped.
  85:./include/linux/mm_type.h **** 			 */
  86:./include/linux/mm_type.h **** 		};
  87:./include/linux/mm_type.h **** 
  88:./include/linux/mm_type.h **** 		/** @rcu_head: You can use this to free a page by RCU. */
  89:./include/linux/mm_type.h **** 		struct rcu_head rcu_head;
  90:./include/linux/mm_type.h **** 	};
  91:./include/linux/mm_type.h **** 
  92:./include/linux/mm_type.h **** 	union {		/* This union is 4 bytes in size. */
  93:./include/linux/mm_type.h **** 		/*
  94:./include/linux/mm_type.h **** 		 * For head pages of typed folios, the value stored here
  95:./include/linux/mm_type.h **** 		 * allows for determining what this page is used for. The
  96:./include/linux/mm_type.h **** 		 * tail pages of typed folios will not store a type
  97:./include/linux/mm_type.h **** 		 * (page_type == _mapcount == -1).
  98:./include/linux/mm_type.h **** 		 *
  99:./include/linux/mm_type.h **** 		 * See page-flags.h for a list of page types which are currently
 100:./include/linux/mm_type.h **** 		 * stored here.
 101:./include/linux/mm_type.h **** 		 *
 102:./include/linux/mm_type.h **** 		 * Owners of typed folios may reuse the lower 16 bit of the
 103:./include/linux/mm_type.h **** 		 * head page page_type field after setting the page type,
 104:./include/linux/mm_type.h **** 		 * but must reset these 16 bit to -1 before clearing the
 105:./include/linux/mm_type.h **** 		 * page type.
 106:./include/linux/mm_type.h **** 		 */
ARM GAS  /tmp/ccgt6wcN.s 			page 4


 107:./include/linux/mm_type.h **** 		unsigned int page_type;
 108:./include/linux/mm_type.h **** 
 109:./include/linux/mm_type.h **** 		/*
 110:./include/linux/mm_type.h **** 		 * For pages that are part of non-typed folios for which mappings
 111:./include/linux/mm_type.h **** 		 * are tracked via the RMAP, encodes the number of times this page
 112:./include/linux/mm_type.h **** 		 * is directly referenced by a page table.
 113:./include/linux/mm_type.h **** 		 *
 114:./include/linux/mm_type.h **** 		 * Note that the mapcount is always initialized to -1, so that
 115:./include/linux/mm_type.h **** 		 * transitions both from it and to it can be tracked, using
 116:./include/linux/mm_type.h **** 		 * atomic_inc_and_test() and atomic_add_negative(-1).
 117:./include/linux/mm_type.h **** 		 */
 118:./include/linux/mm_type.h **** 		atomic_t _mapcount;
 119:./include/linux/mm_type.h **** 	};
 120:./include/linux/mm_type.h **** 
 121:./include/linux/mm_type.h **** 	/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */
 122:./include/linux/mm_type.h **** 	atomic_t _refcount;
 123:./include/linux/mm_type.h **** 
 124:./include/linux/mm_type.h **** #ifdef CONFIG_MEMCG
 125:./include/linux/mm_type.h **** 	unsigned long memcg_data;
 126:./include/linux/mm_type.h **** #elif defined(CONFIG_SLAB_OBJ_EXT)
 127:./include/linux/mm_type.h **** 	unsigned long _unused_slab_obj_exts;
 128:./include/linux/mm_type.h **** #endif
 129:./include/linux/mm_type.h **** 
 130:./include/linux/mm_type.h **** 	/*
 131:./include/linux/mm_type.h **** 	 * On machines where all RAM is mapped into kernel address space,
 132:./include/linux/mm_type.h **** 	 * we can simply calculate the virtual address. On machines with
 133:./include/linux/mm_type.h **** 	 * highmem some memory is mapped into kernel virtual memory
 134:./include/linux/mm_type.h **** 	 * dynamically, so we need a place to store that address.
 135:./include/linux/mm_type.h **** 	 * Note that this field could be 16 bits on x86 ... ;)
 136:./include/linux/mm_type.h **** 	 *
 137:./include/linux/mm_type.h **** 	 * Architectures with slow multiplication can define
 138:./include/linux/mm_type.h **** 	 * WANT_PAGE_VIRTUAL in asm/page.h
 139:./include/linux/mm_type.h **** 	 */
 140:./include/linux/mm_type.h **** #if defined(WANT_PAGE_VIRTUAL)
 141:./include/linux/mm_type.h **** 	void *virtual;			/* Kernel virtual address (NULL if
 142:./include/linux/mm_type.h **** 					   not kmapped, ie. highmem) */
 143:./include/linux/mm_type.h **** #endif /* WANT_PAGE_VIRTUAL */
 144:./include/linux/mm_type.h **** 
 145:./include/linux/mm_type.h **** #ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS
 146:./include/linux/mm_type.h **** 	int _last_cpupid;
 147:./include/linux/mm_type.h **** #endif
 148:./include/linux/mm_type.h **** 
 149:./include/linux/mm_type.h **** #ifdef CONFIG_KMSAN
 150:./include/linux/mm_type.h **** 	/*
 151:./include/linux/mm_type.h **** 	 * KMSAN metadata for this page:
 152:./include/linux/mm_type.h **** 	 *  - shadow page: every bit indicates whether the corresponding
 153:./include/linux/mm_type.h **** 	 *    bit of the original page is initialized (0) or not (1);
 154:./include/linux/mm_type.h **** 	 *  - origin page: every 4 bytes contain an id of the stack trace
 155:./include/linux/mm_type.h **** 	 *    where the uninitialized value was created.
 156:./include/linux/mm_type.h **** 	 */
 157:./include/linux/mm_type.h **** 	struct page *kmsan_shadow;
 158:./include/linux/mm_type.h **** 	struct page *kmsan_origin;
 159:./include/linux/mm_type.h **** #endif
 160:./include/linux/mm_type.h **** };
 161:./include/linux/mm_type.h **** 
 162:./include/linux/mm_type.h **** #if CONFIG_MMU 
 163:./include/linux/mm_type.h ****   #include <mm_page.h>
ARM GAS  /tmp/ccgt6wcN.s 			page 5


 164:./include/linux/mm_type.h **** 
 165:./include/linux/mm_type.h **** #else
 166:./include/linux/mm_type.h **** 
 167:./include/linux/mm_type.h **** 
 168:./include/linux/mm_type.h **** 
 169:./include/linux/mm_type.h **** 
 170:./include/linux/mm_type.h **** #define PG_locked       (1 << 0)
 171:./include/linux/mm_type.h **** #define PG_referenced   (1 << 1)
 172:./include/linux/mm_type.h **** #define PG_uptodate     (1 << 2)
 173:./include/linux/mm_type.h **** #define PG_dirty        (1 << 11)
 174:./include/linux/mm_type.h **** #define PG_active       (1 << 12)
 175:./include/linux/mm_type.h **** 
 176:./include/linux/mm_type.h **** static inline void __set_page_flag(struct page *page, unsigned long flag){
 177:./include/linux/mm_type.h ****     if (page)
 178:./include/linux/mm_type.h ****         page->flags |= flag;
 179:./include/linux/mm_type.h **** }
 180:./include/linux/mm_type.h **** static inline void __clear_page_flag(struct page *page, unsigned long flag){
 181:./include/linux/mm_type.h ****     if (page)
 182:./include/linux/mm_type.h ****         page->flags &= ~flag;
 183:./include/linux/mm_type.h **** }
 184:./include/linux/mm_type.h **** 
 185:./include/linux/mm_type.h **** static inline int __test_page_flag(struct page *page, unsigned long flag){
 186:./include/linux/mm_type.h ****     return (page && (page->flags & flag)) ? 1 : 0;
 187:./include/linux/mm_type.h **** }
 188:./include/linux/mm_type.h **** 
 189:./include/linux/mm_type.h **** static inline struct page *__page_create(gfp_t flags ){
  57              		.loc 2 189 55 is_stmt 1 view -0
  58              		.cfi_startproc
  59              		@ args = 0, pretend = 0, frame = 0
  60              		@ frame_needed = 0, uses_anonymous_args = 0
  61              		.loc 2 189 55 is_stmt 0 view .LVU5
  62 0000 08B5     		push	{r3, lr}
  63              	.LCFI1:
  64              		.cfi_def_cfa_offset 8
  65              		.cfi_offset 3, -8
  66              		.cfi_offset 14, -4
  67 0002 0146     		mov	r1, r0
 190:./include/linux/mm_type.h ****     struct page *page = (struct page *)kmalloc(sizeof(struct page), flags);
  68              		.loc 2 190 5 is_stmt 1 view .LVU6
  69              	.LVL3:
  70              	.LBB67:
  71              	.LBI67:
  72              		.file 3 "./include/linux/slab.h"
   1:./include/linux/slab.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/slab.h **** /*
   3:./include/linux/slab.h ****  * Written by Mark Hemment, 1996 (markhe@nextd.demon.co.uk).
   4:./include/linux/slab.h ****  *
   5:./include/linux/slab.h ****  * (C) SGI 2006, Christoph Lameter
   6:./include/linux/slab.h ****  * 	Cleaned up and restructured to ease the addition of alternative
   7:./include/linux/slab.h ****  * 	implementations of SLAB allocators.
   8:./include/linux/slab.h ****  * (C) Linux Foundation 2008-2013
   9:./include/linux/slab.h ****  *      Unified interface for all slab allocators
  10:./include/linux/slab.h ****  */
  11:./include/linux/slab.h **** 
  12:./include/linux/slab.h **** #ifndef _LINUX_SLAB_H
  13:./include/linux/slab.h **** #define	_LINUX_SLAB_H
  14:./include/linux/slab.h **** 
ARM GAS  /tmp/ccgt6wcN.s 			page 6


  15:./include/linux/slab.h **** #include <linux/cache.h>
  16:./include/linux/slab.h **** #include <linux/overflow.h>
  17:./include/linux/slab.h **** #include <linux/types.h>
  18:./include/linux/slab.h **** #include <linux/raid/pq.h>
  19:./include/linux/slab.h **** #include <linux/gfp_types.h>
  20:./include/linux/slab.h **** #include <linux/numa.h>
  21:./include/linux/slab.h **** #include <linux/reciprocal_div.h>
  22:./include/linux/slab.h **** #include <linux/spinlock.h>
  23:./include/linux/slab.h **** 
  24:./include/linux/slab.h **** enum _slab_flag_bits {
  25:./include/linux/slab.h **** 	_SLAB_CONSISTENCY_CHECKS,
  26:./include/linux/slab.h **** 	_SLAB_RED_ZONE,
  27:./include/linux/slab.h **** 	_SLAB_POISON,
  28:./include/linux/slab.h **** 	_SLAB_KMALLOC,
  29:./include/linux/slab.h **** 	_SLAB_HWCACHE_ALIGN,
  30:./include/linux/slab.h **** 	_SLAB_CACHE_DMA,
  31:./include/linux/slab.h **** 	_SLAB_CACHE_DMA32,
  32:./include/linux/slab.h **** 	_SLAB_STORE_USER,
  33:./include/linux/slab.h **** 	_SLAB_PANIC,
  34:./include/linux/slab.h **** 	_SLAB_TYPESAFE_BY_RCU,
  35:./include/linux/slab.h **** 	_SLAB_TRACE,
  36:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
  37:./include/linux/slab.h **** 	_SLAB_DEBUG_OBJECTS,
  38:./include/linux/slab.h **** #endif
  39:./include/linux/slab.h **** 	_SLAB_NOLEAKTRACE,
  40:./include/linux/slab.h **** 	_SLAB_NO_MERGE,
  41:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
  42:./include/linux/slab.h **** 	_SLAB_FAILSLAB,
  43:./include/linux/slab.h **** #endif
  44:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
  45:./include/linux/slab.h **** 	_SLAB_ACCOUNT,
  46:./include/linux/slab.h **** #endif
  47:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
  48:./include/linux/slab.h **** 	_SLAB_KASAN,
  49:./include/linux/slab.h **** #endif
  50:./include/linux/slab.h **** 	_SLAB_NO_USER_FLAGS,
  51:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
  52:./include/linux/slab.h **** 	_SLAB_SKIP_KFENCE,
  53:./include/linux/slab.h **** #endif
  54:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
  55:./include/linux/slab.h **** 	_SLAB_RECLAIM_ACCOUNT,
  56:./include/linux/slab.h **** #endif
  57:./include/linux/slab.h **** 	_SLAB_OBJECT_POISON,
  58:./include/linux/slab.h **** 	_SLAB_CMPXCHG_DOUBLE,
  59:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
  60:./include/linux/slab.h **** 	_SLAB_NO_OBJ_EXT,
  61:./include/linux/slab.h **** #endif
  62:./include/linux/slab.h **** 	_SLAB_FLAGS_LAST_BIT
  63:./include/linux/slab.h **** };
  64:./include/linux/slab.h **** 
  65:./include/linux/slab.h **** 
  66:./include/linux/slab.h **** 
  67:./include/linux/slab.h **** #define __SLAB_FLAG_BIT(nr)	((slab_flags_t __force)(1U << (nr)))
  68:./include/linux/slab.h **** #define __SLAB_FLAG_UNUSED	((slab_flags_t __force)(0U))
  69:./include/linux/slab.h **** 
  70:./include/linux/slab.h **** /*
  71:./include/linux/slab.h ****  * Flags to pass to kmem_cache_create().
ARM GAS  /tmp/ccgt6wcN.s 			page 7


  72:./include/linux/slab.h ****  * The ones marked DEBUG need CONFIG_SLUB_DEBUG enabled, otherwise are no-op
  73:./include/linux/slab.h ****  */
  74:./include/linux/slab.h **** /* DEBUG: Perform (expensive) checks on alloc/free */
  75:./include/linux/slab.h **** #define SLAB_CONSISTENCY_CHECKS	__SLAB_FLAG_BIT(_SLAB_CONSISTENCY_CHECKS)
  76:./include/linux/slab.h **** /* DEBUG: Red zone objs in a cache */
  77:./include/linux/slab.h **** #define SLAB_RED_ZONE		__SLAB_FLAG_BIT(_SLAB_RED_ZONE)
  78:./include/linux/slab.h **** /* DEBUG: Poison objects */
  79:./include/linux/slab.h **** #define SLAB_POISON		__SLAB_FLAG_BIT(_SLAB_POISON)
  80:./include/linux/slab.h **** /* Indicate a kmalloc slab */
  81:./include/linux/slab.h **** #define SLAB_KMALLOC		__SLAB_FLAG_BIT(_SLAB_KMALLOC)
  82:./include/linux/slab.h **** /**
  83:./include/linux/slab.h ****  * define SLAB_HWCACHE_ALIGN - Align objects on cache line boundaries.
  84:./include/linux/slab.h ****  *
  85:./include/linux/slab.h ****  * Sufficiently large objects are aligned on cache line boundary. For object
  86:./include/linux/slab.h ****  * size smaller than a half of cache line size, the alignment is on the half of
  87:./include/linux/slab.h ****  * cache line size. In general, if object size is smaller than 1/2^n of cache
  88:./include/linux/slab.h ****  * line size, the alignment is adjusted to 1/2^n.
  89:./include/linux/slab.h ****  *
  90:./include/linux/slab.h ****  * If explicit alignment is also requested by the respective
  91:./include/linux/slab.h ****  * &struct kmem_cache_args field, the greater of both is alignments is applied.
  92:./include/linux/slab.h ****  */
  93:./include/linux/slab.h **** #define SLAB_HWCACHE_ALIGN	__SLAB_FLAG_BIT(_SLAB_HWCACHE_ALIGN)
  94:./include/linux/slab.h **** /* Use GFP_DMA memory */
  95:./include/linux/slab.h **** #define SLAB_CACHE_DMA		__SLAB_FLAG_BIT(_SLAB_CACHE_DMA)
  96:./include/linux/slab.h **** /* Use GFP_DMA32 memory */
  97:./include/linux/slab.h **** #define SLAB_CACHE_DMA32	__SLAB_FLAG_BIT(_SLAB_CACHE_DMA32)
  98:./include/linux/slab.h **** /* DEBUG: Store the last owner for bug hunting */
  99:./include/linux/slab.h **** #define SLAB_STORE_USER		__SLAB_FLAG_BIT(_SLAB_STORE_USER)
 100:./include/linux/slab.h **** /* Panic if kmem_cache_create() fails */
 101:./include/linux/slab.h **** #define SLAB_PANIC		__SLAB_FLAG_BIT(_SLAB_PANIC)
 102:./include/linux/slab.h **** /**
 103:./include/linux/slab.h ****  * define SLAB_TYPESAFE_BY_RCU - **WARNING** READ THIS!
 104:./include/linux/slab.h ****  *
 105:./include/linux/slab.h ****  * This delays freeing the SLAB page by a grace period, it does _NOT_
 106:./include/linux/slab.h ****  * delay object freeing. This means that if you do kmem_cache_free()
 107:./include/linux/slab.h ****  * that memory location is free to be reused at any time. Thus it may
 108:./include/linux/slab.h ****  * be possible to see another object there in the same RCU grace period.
 109:./include/linux/slab.h ****  *
 110:./include/linux/slab.h ****  * This feature only ensures the memory location backing the object
 111:./include/linux/slab.h ****  * stays valid, the trick to using this is relying on an independent
 112:./include/linux/slab.h ****  * object validation pass. Something like:
 113:./include/linux/slab.h ****  *
 114:./include/linux/slab.h ****  * ::
 115:./include/linux/slab.h ****  *
 116:./include/linux/slab.h ****  *  begin:
 117:./include/linux/slab.h ****  *   rcu_read_lock();
 118:./include/linux/slab.h ****  *   obj = lockless_lookup(key);
 119:./include/linux/slab.h ****  *   if (obj) {
 120:./include/linux/slab.h ****  *     if (!try_get_ref(obj)) // might fail for free objects
 121:./include/linux/slab.h ****  *       rcu_read_unlock();
 122:./include/linux/slab.h ****  *       goto begin;
 123:./include/linux/slab.h ****  *
 124:./include/linux/slab.h ****  *     if (obj->key != key) { // not the object we expected
 125:./include/linux/slab.h ****  *       put_ref(obj);
 126:./include/linux/slab.h ****  *       rcu_read_unlock();
 127:./include/linux/slab.h ****  *       goto begin;
 128:./include/linux/slab.h ****  *     }
ARM GAS  /tmp/ccgt6wcN.s 			page 8


 129:./include/linux/slab.h ****  *   }
 130:./include/linux/slab.h ****  *  rcu_read_unlock();
 131:./include/linux/slab.h ****  *
 132:./include/linux/slab.h ****  * This is useful if we need to approach a kernel structure obliquely,
 133:./include/linux/slab.h ****  * from its address obtained without the usual locking. We can lock
 134:./include/linux/slab.h ****  * the structure to stabilize it and check it's still at the given address,
 135:./include/linux/slab.h ****  * only if we can be sure that the memory has not been meanwhile reused
 136:./include/linux/slab.h ****  * for some other kind of object (which our subsystem's lock might corrupt).
 137:./include/linux/slab.h ****  *
 138:./include/linux/slab.h ****  * rcu_read_lock before reading the address, then rcu_read_unlock after
 139:./include/linux/slab.h ****  * taking the spinlock within the structure expected at that address.
 140:./include/linux/slab.h ****  *
 141:./include/linux/slab.h ****  * Note that it is not possible to acquire a lock within a structure
 142:./include/linux/slab.h ****  * allocated with SLAB_TYPESAFE_BY_RCU without first acquiring a reference
 143:./include/linux/slab.h ****  * as described above.  The reason is that SLAB_TYPESAFE_BY_RCU pages
 144:./include/linux/slab.h ****  * are not zeroed before being given to the slab, which means that any
 145:./include/linux/slab.h ****  * locks must be initialized after each and every kmem_struct_alloc().
 146:./include/linux/slab.h ****  * Alternatively, make the ctor passed to kmem_cache_create() initialize
 147:./include/linux/slab.h ****  * the locks at page-allocation time, as is done in __i915_request_ctor(),
 148:./include/linux/slab.h ****  * sighand_ctor(), and anon_vma_ctor().  Such a ctor permits readers
 149:./include/linux/slab.h ****  * to safely acquire those ctor-initialized locks under rcu_read_lock()
 150:./include/linux/slab.h ****  * protection.
 151:./include/linux/slab.h ****  *
 152:./include/linux/slab.h ****  * Note that SLAB_TYPESAFE_BY_RCU was originally named SLAB_DESTROY_BY_RCU.
 153:./include/linux/slab.h ****  */
 154:./include/linux/slab.h **** #define SLAB_TYPESAFE_BY_RCU	__SLAB_FLAG_BIT(_SLAB_TYPESAFE_BY_RCU)
 155:./include/linux/slab.h **** /* Trace allocations and frees */
 156:./include/linux/slab.h **** #define SLAB_TRACE		__SLAB_FLAG_BIT(_SLAB_TRACE)
 157:./include/linux/slab.h **** 
 158:./include/linux/slab.h **** /* Flag to prevent checks on free */
 159:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
 160:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_BIT(_SLAB_DEBUG_OBJECTS)
 161:./include/linux/slab.h **** #else
 162:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_UNUSED
 163:./include/linux/slab.h **** #endif
 164:./include/linux/slab.h **** 
 165:./include/linux/slab.h **** /* Avoid kmemleak tracing */
 166:./include/linux/slab.h **** #define SLAB_NOLEAKTRACE	__SLAB_FLAG_BIT(_SLAB_NOLEAKTRACE)
 167:./include/linux/slab.h **** 
 168:./include/linux/slab.h **** /*
 169:./include/linux/slab.h ****  * Prevent merging with compatible kmem caches. This flag should be used
 170:./include/linux/slab.h ****  * cautiously. Valid use cases:
 171:./include/linux/slab.h ****  *
 172:./include/linux/slab.h ****  * - caches created for self-tests (e.g. kunit)
 173:./include/linux/slab.h ****  * - general caches created and used by a subsystem, only when a
 174:./include/linux/slab.h ****  *   (subsystem-specific) debug option is enabled
 175:./include/linux/slab.h ****  * - performance critical caches, should be very rare and consulted with slab
 176:./include/linux/slab.h ****  *   maintainers, and not used together with CONFIG_SLUB_TINY
 177:./include/linux/slab.h ****  */
 178:./include/linux/slab.h **** #define SLAB_NO_MERGE		__SLAB_FLAG_BIT(_SLAB_NO_MERGE)
 179:./include/linux/slab.h **** 
 180:./include/linux/slab.h **** /* Fault injection mark */
 181:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
 182:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_BIT(_SLAB_FAILSLAB)
 183:./include/linux/slab.h **** #else
 184:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_UNUSED
 185:./include/linux/slab.h **** #endif
ARM GAS  /tmp/ccgt6wcN.s 			page 9


 186:./include/linux/slab.h **** /**
 187:./include/linux/slab.h ****  * define SLAB_ACCOUNT - Account allocations to memcg.
 188:./include/linux/slab.h ****  *
 189:./include/linux/slab.h ****  * All object allocations from this cache will be memcg accounted, regardless of
 190:./include/linux/slab.h ****  * __GFP_ACCOUNT being or not being passed to individual allocations.
 191:./include/linux/slab.h ****  */
 192:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
 193:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_BIT(_SLAB_ACCOUNT)
 194:./include/linux/slab.h **** #else
 195:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_UNUSED
 196:./include/linux/slab.h **** #endif
 197:./include/linux/slab.h **** 
 198:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
 199:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_BIT(_SLAB_KASAN)
 200:./include/linux/slab.h **** #else
 201:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_UNUSED
 202:./include/linux/slab.h **** #endif
 203:./include/linux/slab.h **** 
 204:./include/linux/slab.h **** /*
 205:./include/linux/slab.h ****  * Ignore user specified debugging flags.
 206:./include/linux/slab.h ****  * Intended for caches created for self-tests so they have only flags
 207:./include/linux/slab.h ****  * specified in the code and other flags are ignored.
 208:./include/linux/slab.h ****  */
 209:./include/linux/slab.h **** #define SLAB_NO_USER_FLAGS	__SLAB_FLAG_BIT(_SLAB_NO_USER_FLAGS)
 210:./include/linux/slab.h **** 
 211:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
 212:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_BIT(_SLAB_SKIP_KFENCE)
 213:./include/linux/slab.h **** #else
 214:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_UNUSED
 215:./include/linux/slab.h **** #endif
 216:./include/linux/slab.h **** 
 217:./include/linux/slab.h **** /* The following flags affect the page allocator grouping pages by mobility */
 218:./include/linux/slab.h **** /**
 219:./include/linux/slab.h ****  * define SLAB_RECLAIM_ACCOUNT - Objects are reclaimable.
 220:./include/linux/slab.h ****  *
 221:./include/linux/slab.h ****  * Use this flag for caches that have an associated shrinker. As a result, slab
 222:./include/linux/slab.h ****  * pages are allocated with __GFP_RECLAIMABLE, which affects grouping pages by
 223:./include/linux/slab.h ****  * mobility, and are accounted in SReclaimable counter in /proc/meminfo
 224:./include/linux/slab.h ****  */
 225:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
 226:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_BIT(_SLAB_RECLAIM_ACCOUNT)
 227:./include/linux/slab.h **** #else
 228:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_UNUSED
 229:./include/linux/slab.h **** #endif
 230:./include/linux/slab.h **** #define SLAB_TEMPORARY		SLAB_RECLAIM_ACCOUNT	/* Objects are short-lived */
 231:./include/linux/slab.h **** 
 232:./include/linux/slab.h **** /* Slab created using create_boot_cache */
 233:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
 234:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_BIT(_SLAB_NO_OBJ_EXT)
 235:./include/linux/slab.h **** #else
 236:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_UNUSED
 237:./include/linux/slab.h **** #endif
 238:./include/linux/slab.h **** 
 239:./include/linux/slab.h **** /*
 240:./include/linux/slab.h ****  * freeptr_t represents a SLUB freelist pointer, which might be encoded
 241:./include/linux/slab.h ****  * and not dereferenceable if CONFIG_SLAB_FREELIST_HARDENED is enabled.
 242:./include/linux/slab.h ****  */
ARM GAS  /tmp/ccgt6wcN.s 			page 10


 243:./include/linux/slab.h **** typedef struct { unsigned long v; } freeptr_t;
 244:./include/linux/slab.h **** 
 245:./include/linux/slab.h **** /*
 246:./include/linux/slab.h ****  * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.
 247:./include/linux/slab.h ****  *
 248:./include/linux/slab.h ****  * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault.
 249:./include/linux/slab.h ****  *
 250:./include/linux/slab.h ****  * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.
 251:./include/linux/slab.h ****  * Both make kfree a no-op.
 252:./include/linux/slab.h ****  */
 253:./include/linux/slab.h **** #define ZERO_SIZE_PTR ((void *)16)
 254:./include/linux/slab.h **** 
 255:./include/linux/slab.h **** #define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) <= \
 256:./include/linux/slab.h **** 				(unsigned long)ZERO_SIZE_PTR)
 257:./include/linux/slab.h **** 
 258:./include/linux/slab.h **** 
 259:./include/linux/slab.h **** 
 260:./include/linux/slab.h **** 
 261:./include/linux/slab.h **** 
 262:./include/linux/slab.h **** #ifdef CONFIG_SLUB_CPU_PARTIAL
 263:./include/linux/slab.h **** #define slub_percpu_partial(c)			((c)->partial)
 264:./include/linux/slab.h **** 
 265:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)		\
 266:./include/linux/slab.h **** ({						\
 267:./include/linux/slab.h **** 	slub_percpu_partial(c) = (p)->next;	\
 268:./include/linux/slab.h **** })
 269:./include/linux/slab.h **** 
 270:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	READ_ONCE(slub_percpu_partial(c))
 271:./include/linux/slab.h **** #else
 272:./include/linux/slab.h **** #define slub_percpu_partial(c)			NULL
 273:./include/linux/slab.h **** 
 274:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)
 275:./include/linux/slab.h **** 
 276:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	NULL
 277:./include/linux/slab.h **** 
 278:./include/linux/slab.h **** 
 279:./include/linux/slab.h **** #endif // CONFIG_SLUB_CPU_PARTIAL
 280:./include/linux/slab.h **** 
 281:./include/linux/slab.h **** /*
 282:./include/linux/slab.h **** 	* Word size structure that can be atomically updated or read and that
 283:./include/linux/slab.h **** 	* contains both the order and the number of objects that a slab of the
 284:./include/linux/slab.h **** 	* given order would contain.
 285:./include/linux/slab.h **** 	*/				
 286:./include/linux/slab.h **** struct kmem_cache_order_objects {
 287:./include/linux/slab.h **** 	unsigned int x;
 288:./include/linux/slab.h **** };
 289:./include/linux/slab.h **** 
 290:./include/linux/slab.h **** struct kmem_cache_node {
 291:./include/linux/slab.h **** 	spinlock_t list_lock;
 292:./include/linux/slab.h **** 	unsigned long nr_partial;
 293:./include/linux/slab.h **** 	struct list_head partial;
 294:./include/linux/slab.h **** #ifdef CONFIG_SLUB_DEBUG
 295:./include/linux/slab.h **** 	atomic_long_t nr_slabs;
 296:./include/linux/slab.h **** 	atomic_long_t total_objects;
 297:./include/linux/slab.h **** 	struct list_head full;
 298:./include/linux/slab.h **** #endif
 299:./include/linux/slab.h **** };
ARM GAS  /tmp/ccgt6wcN.s 			page 11


 300:./include/linux/slab.h **** 
 301:./include/linux/slab.h **** struct kmem_cache {
 302:./include/linux/slab.h **** 	#ifndef CONFIG_SLUB_TINY
 303:./include/linux/slab.h **** 	//	struct kmem_cache_cpu __percpu *cpu_slab;
 304:./include/linux/slab.h **** 	#endif
 305:./include/linux/slab.h **** 		/* Used for retrieving partial slabs, etc. */
 306:./include/linux/slab.h **** 		slab_flags_t flags;
 307:./include/linux/slab.h **** 		unsigned long min_partial;
 308:./include/linux/slab.h **** 		unsigned int size;		/* Object size including metadata */
 309:./include/linux/slab.h **** 		unsigned int object_size;	/* Object size without metadata */
 310:./include/linux/slab.h **** 		struct reciprocal_value reciprocal_size;
 311:./include/linux/slab.h **** 		unsigned int offset;		/* Free pointer offset */
 312:./include/linux/slab.h **** 	#ifdef CONFIG_SLUB_CPU_PARTIAL
 313:./include/linux/slab.h **** 		/* Number of per cpu partial objects to keep around */
 314:./include/linux/slab.h **** 		unsigned int cpu_partial;
 315:./include/linux/slab.h **** 		/* Number of per cpu partial slabs to keep around */
 316:./include/linux/slab.h **** 		unsigned int cpu_partial_slabs;
 317:./include/linux/slab.h **** 	#endif
 318:./include/linux/slab.h **** 		struct kmem_cache_order_objects oo;
 319:./include/linux/slab.h **** 	
 320:./include/linux/slab.h **** 		/* Allocation and freeing of slabs */
 321:./include/linux/slab.h **** 		struct kmem_cache_order_objects min;
 322:./include/linux/slab.h **** 		gfp_t allocflags;		/* gfp flags to use on each alloc */
 323:./include/linux/slab.h **** 		int refcount;			/* Refcount for slab cache destroy */
 324:./include/linux/slab.h **** 		void (*ctor)(void *object);	/* Object constructor */
 325:./include/linux/slab.h **** 		unsigned int inuse;		/* Offset to metadata */
 326:./include/linux/slab.h **** 		unsigned int align;		/* Alignment */
 327:./include/linux/slab.h **** 		unsigned int red_left_pad;	/* Left redzone padding size */
 328:./include/linux/slab.h **** 		const char *name;		/* Name (only for display!) */
 329:./include/linux/slab.h **** 		struct list_head list;		/* List of slab caches */
 330:./include/linux/slab.h **** 	#ifdef CONFIG_SYSFS
 331:./include/linux/slab.h **** 		struct kobject kobj;		/* For sysfs */
 332:./include/linux/slab.h **** 	#endif
 333:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_HARDENED
 334:./include/linux/slab.h **** 		unsigned long random;
 335:./include/linux/slab.h **** 	#endif
 336:./include/linux/slab.h **** 	
 337:./include/linux/slab.h **** 	#ifdef CONFIG_NUMA
 338:./include/linux/slab.h **** 		/*
 339:./include/linux/slab.h **** 			* Defragmentation by allocating from a remote node.
 340:./include/linux/slab.h **** 			*/
 341:./include/linux/slab.h **** 		unsigned int remote_node_defrag_ratio;
 342:./include/linux/slab.h **** 	#endif
 343:./include/linux/slab.h **** 	
 344:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_RANDOM
 345:./include/linux/slab.h **** 		unsigned int *random_seq;
 346:./include/linux/slab.h **** 	#endif
 347:./include/linux/slab.h **** 	
 348:./include/linux/slab.h **** 	#ifdef CONFIG_KASAN_GENERIC
 349:./include/linux/slab.h **** 		struct kasan_cache kasan_info;
 350:./include/linux/slab.h **** 	#endif
 351:./include/linux/slab.h **** 	
 352:./include/linux/slab.h **** 	#ifdef CONFIG_HARDENED_USERCOPY
 353:./include/linux/slab.h **** 		unsigned int useroffset;	/* Usercopy region offset */
 354:./include/linux/slab.h **** 		unsigned int usersize;		/* Usercopy region size */
 355:./include/linux/slab.h **** 	#endif
 356:./include/linux/slab.h **** 	
ARM GAS  /tmp/ccgt6wcN.s 			page 12


 357:./include/linux/slab.h **** 		struct kmem_cache_node *node[MAX_NUMNODES];
 358:./include/linux/slab.h **** 	};
 359:./include/linux/slab.h **** 					
 360:./include/linux/slab.h **** 
 361:./include/linux/slab.h **** 
 362:./include/linux/slab.h **** 
 363:./include/linux/slab.h **** 
 364:./include/linux/slab.h **** #define KMALLOC_WAIT 1
 365:./include/linux/slab.h **** 
 366:./include/linux/slab.h **** 
 367:./include/linux/slab.h **** extern void* __smalloc__(u32 size, gfp_t flags);
 368:./include/linux/slab.h **** extern void  __sfree__(void* addr);
 369:./include/linux/slab.h **** 
 370:./include/linux/slab.h **** 
 371:./include/linux/slab.h **** static void inline *vmalloc(unsigned long size){
 372:./include/linux/slab.h **** 	return __smalloc__(size,GFP_TRANSHUGE_LIGHT);
 373:./include/linux/slab.h **** }
 374:./include/linux/slab.h **** 
 375:./include/linux/slab.h **** static void inline vfree(void *addr){
 376:./include/linux/slab.h **** 	__sfree__(addr);
 377:./include/linux/slab.h **** }
 378:./include/linux/slab.h **** 
 379:./include/linux/slab.h **** static void inline *kmalloc(size_t size, gfp_t flags){
  73              		.loc 3 379 21 view .LVU7
  74              	.LBB68:
 380:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
  75              		.loc 3 380 2 view .LVU8
  76              		.loc 3 380 9 is_stmt 0 view .LVU9
  77 0004 2020     		movs	r0, #32
  78              	.LVL4:
  79              		.loc 3 380 9 view .LVU10
  80 0006 FFF7FEFF 		bl	__smalloc__
  81              	.LVL5:
  82              		.loc 3 380 9 view .LVU11
  83              	.LBE68:
  84              	.LBE67:
 191:./include/linux/mm_type.h ****     if (page == NULL)
  85              		.loc 2 191 5 is_stmt 1 view .LVU12
  86              		.loc 2 191 8 is_stmt 0 view .LVU13
  87 000a 0346     		mov	r3, r0
  88 000c 20B1     		cbz	r0, .L3
 192:./include/linux/mm_type.h ****         return NULL;
 193:./include/linux/mm_type.h ****     page->flags = 0;
  89              		.loc 2 193 5 is_stmt 1 view .LVU14
  90              		.loc 2 193 17 is_stmt 0 view .LVU15
  91 000e 0022     		movs	r2, #0
  92 0010 0260     		str	r2, [r0]
 194:./include/linux/mm_type.h ****     atomic_set(&page->_mapcount, 0);
  93              		.loc 2 194 5 is_stmt 1 view .LVU16
  94              	.LVL6:
  95              	.LBB69:
  96              	.LBI69:
  97              		.file 4 "./include/linux/atomic/atomic-instrumented.h"
   1:./include/linux/atomic/atomic-instrumented.h **** // SPDX-License-Identifier: GPL-2.0
   2:./include/linux/atomic/atomic-instrumented.h **** 
   3:./include/linux/atomic/atomic-instrumented.h **** // Generated by scripts/atomic/gen-atomic-instrumented.sh 
   4:./include/linux/atomic/atomic-instrumented.h **** // DO NOT MODIFY THIS FILE DIRECTLY
ARM GAS  /tmp/ccgt6wcN.s 			page 13


   5:./include/linux/atomic/atomic-instrumented.h **** 
   6:./include/linux/atomic/atomic-instrumented.h **** /*
   7:./include/linux/atomic/atomic-instrumented.h ****  * This file provoides atomic operations with explicit instrumentation (e.g.
   8:./include/linux/atomic/atomic-instrumented.h ****  * KASAN, KCSAN), which should be used unless it is necessary to avoid
   9:./include/linux/atomic/atomic-instrumented.h ****  * instrumentation. Where it is necessary to aovid instrumenation, the
  10:./include/linux/atomic/atomic-instrumented.h ****  * raw_atomic*() operations should be used.
  11:./include/linux/atomic/atomic-instrumented.h ****  */
  12:./include/linux/atomic/atomic-instrumented.h **** #ifndef _LINUX_ATOMIC_INSTRUMENTED_H
  13:./include/linux/atomic/atomic-instrumented.h **** #define _LINUX_ATOMIC_INSTRUMENTED_H
  14:./include/linux/atomic/atomic-instrumented.h **** 
  15:./include/linux/atomic/atomic-instrumented.h **** #include <linux/build_bug.h>
  16:./include/linux/atomic/atomic-instrumented.h **** #include <linux/compiler.h>
  17:./include/linux/atomic/atomic-instrumented.h **** #include <linux/instrumented.h>
  18:./include/linux/atomic/atomic-instrumented.h **** 
  19:./include/linux/atomic/atomic-instrumented.h **** /**
  20:./include/linux/atomic/atomic-instrumented.h ****  * atomic_read() - atomic load with relaxed ordering
  21:./include/linux/atomic/atomic-instrumented.h ****  * @v: pointer to atomic_t
  22:./include/linux/atomic/atomic-instrumented.h ****  *
  23:./include/linux/atomic/atomic-instrumented.h ****  * Atomically loads the value of @v with relaxed ordering.
  24:./include/linux/atomic/atomic-instrumented.h ****  *
  25:./include/linux/atomic/atomic-instrumented.h ****  * Unsafe to use in noinstr code; use raw_atomic_read() there.
  26:./include/linux/atomic/atomic-instrumented.h ****  *
  27:./include/linux/atomic/atomic-instrumented.h ****  * Return: The value loaded from @v.
  28:./include/linux/atomic/atomic-instrumented.h ****  */
  29:./include/linux/atomic/atomic-instrumented.h **** static __always_inline int
  30:./include/linux/atomic/atomic-instrumented.h **** atomic_read(const atomic_t *v)
  31:./include/linux/atomic/atomic-instrumented.h **** {
  32:./include/linux/atomic/atomic-instrumented.h **** 	instrument_atomic_read(v, sizeof(*v));
  33:./include/linux/atomic/atomic-instrumented.h **** 	return raw_atomic_read(v);
  34:./include/linux/atomic/atomic-instrumented.h **** }
  35:./include/linux/atomic/atomic-instrumented.h **** 
  36:./include/linux/atomic/atomic-instrumented.h **** /**
  37:./include/linux/atomic/atomic-instrumented.h ****  * atomic_read_acquire() - atomic load with acquire ordering
  38:./include/linux/atomic/atomic-instrumented.h ****  * @v: pointer to atomic_t
  39:./include/linux/atomic/atomic-instrumented.h ****  *
  40:./include/linux/atomic/atomic-instrumented.h ****  * Atomically loads the value of @v with acquire ordering.
  41:./include/linux/atomic/atomic-instrumented.h ****  *
  42:./include/linux/atomic/atomic-instrumented.h ****  * Unsafe to use in noinstr code; use raw_atomic_read_acquire() there.
  43:./include/linux/atomic/atomic-instrumented.h ****  *
  44:./include/linux/atomic/atomic-instrumented.h ****  * Return: The value loaded from @v.
  45:./include/linux/atomic/atomic-instrumented.h ****  */
  46:./include/linux/atomic/atomic-instrumented.h **** static __always_inline int
  47:./include/linux/atomic/atomic-instrumented.h **** atomic_read_acquire(const atomic_t *v)
  48:./include/linux/atomic/atomic-instrumented.h **** {
  49:./include/linux/atomic/atomic-instrumented.h **** 	instrument_atomic_read(v, sizeof(*v));
  50:./include/linux/atomic/atomic-instrumented.h **** 	return raw_atomic_read_acquire(v);
  51:./include/linux/atomic/atomic-instrumented.h **** }
  52:./include/linux/atomic/atomic-instrumented.h **** 
  53:./include/linux/atomic/atomic-instrumented.h **** /**
  54:./include/linux/atomic/atomic-instrumented.h ****  * atomic_set() - atomic set with relaxed ordering
  55:./include/linux/atomic/atomic-instrumented.h ****  * @v: pointer to atomic_t
  56:./include/linux/atomic/atomic-instrumented.h ****  * @i: int value to assign
  57:./include/linux/atomic/atomic-instrumented.h ****  *
  58:./include/linux/atomic/atomic-instrumented.h ****  * Atomically sets @v to @i with relaxed ordering.
  59:./include/linux/atomic/atomic-instrumented.h ****  *
  60:./include/linux/atomic/atomic-instrumented.h ****  * Unsafe to use in noinstr code; use raw_atomic_set() there.
  61:./include/linux/atomic/atomic-instrumented.h ****  *
ARM GAS  /tmp/ccgt6wcN.s 			page 14


  62:./include/linux/atomic/atomic-instrumented.h ****  * Return: Nothing.
  63:./include/linux/atomic/atomic-instrumented.h ****  */
  64:./include/linux/atomic/atomic-instrumented.h **** static __always_inline void
  65:./include/linux/atomic/atomic-instrumented.h **** atomic_set(atomic_t *v, int i)
  98              		.loc 4 65 1 view .LVU17
  66:./include/linux/atomic/atomic-instrumented.h **** {
  67:./include/linux/atomic/atomic-instrumented.h **** 	instrument_atomic_write(v, sizeof(*v));
  99              		.loc 4 67 2 view .LVU18
  68:./include/linux/atomic/atomic-instrumented.h **** 	raw_atomic_set(v, i);
 100              		.loc 4 68 2 view .LVU19
 101              	.LBB70:
 102              	.LBI70:
 103              		.file 5 "./include/linux/atomic/atomic-arch-fallback.h"
   1:./include/linux/atomic/atomic-arch-fallback.h **** // SPDX-License-Identifier: GPL-2.0
   2:./include/linux/atomic/atomic-arch-fallback.h **** 
   3:./include/linux/atomic/atomic-arch-fallback.h **** // Generated by scripts/atomic/gen-atomic-fallback.sh
   4:./include/linux/atomic/atomic-arch-fallback.h **** // DO NOT MODIFY THIS FILE DIRECTLY
   5:./include/linux/atomic/atomic-arch-fallback.h **** 
   6:./include/linux/atomic/atomic-arch-fallback.h **** #ifndef _LINUX_ATOMIC_FALLBACK_H
   7:./include/linux/atomic/atomic-arch-fallback.h **** #define _LINUX_ATOMIC_FALLBACK_H
   8:./include/linux/atomic/atomic-arch-fallback.h **** 
   9:./include/linux/atomic/atomic-arch-fallback.h **** #include <linux/compiler.h>
  10:./include/linux/atomic/atomic-arch-fallback.h **** 
  11:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_xchg)
  12:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg arch_xchg
  13:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg_relaxed)
  14:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg(...) \
  15:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_xchg, __VA_ARGS__)
  16:./include/linux/atomic/atomic-arch-fallback.h **** #else
  17:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_xchg_not_implemented(void);
  18:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg(...) raw_xchg_not_implemented()
  19:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  20:./include/linux/atomic/atomic-arch-fallback.h **** 
  21:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_xchg_acquire)
  22:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_acquire arch_xchg_acquire
  23:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg_relaxed)
  24:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_acquire(...) \
  25:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_xchg, __VA_ARGS__)
  26:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg)
  27:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_acquire arch_xchg
  28:./include/linux/atomic/atomic-arch-fallback.h **** #else
  29:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_xchg_acquire_not_implemented(void);
  30:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_acquire(...) raw_xchg_acquire_not_implemented()
  31:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  32:./include/linux/atomic/atomic-arch-fallback.h **** 
  33:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_xchg_release)
  34:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_release arch_xchg_release
  35:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg_relaxed)
  36:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_release(...) \
  37:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_xchg, __VA_ARGS__)
  38:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg)
  39:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_release arch_xchg
  40:./include/linux/atomic/atomic-arch-fallback.h **** #else
  41:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_xchg_release_not_implemented(void);
  42:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_release(...) raw_xchg_release_not_implemented()
  43:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  44:./include/linux/atomic/atomic-arch-fallback.h **** 
ARM GAS  /tmp/ccgt6wcN.s 			page 15


  45:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_xchg_relaxed)
  46:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_relaxed arch_xchg_relaxed
  47:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_xchg)
  48:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_relaxed arch_xchg
  49:./include/linux/atomic/atomic-arch-fallback.h **** #else
  50:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_xchg_relaxed_not_implemented(void);
  51:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_xchg_relaxed(...) raw_xchg_relaxed_not_implemented()
  52:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  53:./include/linux/atomic/atomic-arch-fallback.h **** 
  54:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg)
  55:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg arch_cmpxchg
  56:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg_relaxed)
  57:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg(...) \
  58:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_cmpxchg, __VA_ARGS__)
  59:./include/linux/atomic/atomic-arch-fallback.h **** #else
  60:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg_not_implemented(void);
  61:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg(...) raw_cmpxchg_not_implemented()
  62:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  63:./include/linux/atomic/atomic-arch-fallback.h **** 
  64:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg_acquire)
  65:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_acquire arch_cmpxchg_acquire
  66:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg_relaxed)
  67:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_acquire(...) \
  68:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_cmpxchg, __VA_ARGS__)
  69:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg)
  70:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_acquire arch_cmpxchg
  71:./include/linux/atomic/atomic-arch-fallback.h **** #else
  72:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg_acquire_not_implemented(void);
  73:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_acquire(...) raw_cmpxchg_acquire_not_implemented()
  74:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  75:./include/linux/atomic/atomic-arch-fallback.h **** 
  76:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg_release)
  77:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_release arch_cmpxchg_release
  78:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg_relaxed)
  79:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_release(...) \
  80:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_cmpxchg, __VA_ARGS__)
  81:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg)
  82:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_release arch_cmpxchg
  83:./include/linux/atomic/atomic-arch-fallback.h **** #else
  84:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg_release_not_implemented(void);
  85:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_release(...) raw_cmpxchg_release_not_implemented()
  86:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  87:./include/linux/atomic/atomic-arch-fallback.h **** 
  88:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg_relaxed)
  89:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_relaxed arch_cmpxchg_relaxed
  90:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg)
  91:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_relaxed arch_cmpxchg
  92:./include/linux/atomic/atomic-arch-fallback.h **** #else
  93:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg_relaxed_not_implemented(void);
  94:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_relaxed(...) raw_cmpxchg_relaxed_not_implemented()
  95:./include/linux/atomic/atomic-arch-fallback.h **** #endif
  96:./include/linux/atomic/atomic-arch-fallback.h **** 
  97:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg64)
  98:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64 arch_cmpxchg64
  99:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64_relaxed)
 100:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64(...) \
 101:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_cmpxchg64, __VA_ARGS__)
ARM GAS  /tmp/ccgt6wcN.s 			page 16


 102:./include/linux/atomic/atomic-arch-fallback.h **** #else
 103:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg64_not_implemented(void);
 104:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64(...) raw_cmpxchg64_not_implemented()
 105:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 106:./include/linux/atomic/atomic-arch-fallback.h **** 
 107:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg64_acquire)
 108:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_acquire arch_cmpxchg64_acquire
 109:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64_relaxed)
 110:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_acquire(...) \
 111:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_cmpxchg64, __VA_ARGS__)
 112:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64)
 113:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_acquire arch_cmpxchg64
 114:./include/linux/atomic/atomic-arch-fallback.h **** #else
 115:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg64_acquire_not_implemented(void);
 116:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_acquire(...) raw_cmpxchg64_acquire_not_implemented()
 117:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 118:./include/linux/atomic/atomic-arch-fallback.h **** 
 119:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg64_release)
 120:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_release arch_cmpxchg64_release
 121:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64_relaxed)
 122:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_release(...) \
 123:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_cmpxchg64, __VA_ARGS__)
 124:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64)
 125:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_release arch_cmpxchg64
 126:./include/linux/atomic/atomic-arch-fallback.h **** #else
 127:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg64_release_not_implemented(void);
 128:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_release(...) raw_cmpxchg64_release_not_implemented()
 129:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 130:./include/linux/atomic/atomic-arch-fallback.h **** 
 131:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg64_relaxed)
 132:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_relaxed arch_cmpxchg64_relaxed
 133:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg64)
 134:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_relaxed arch_cmpxchg64
 135:./include/linux/atomic/atomic-arch-fallback.h **** #else
 136:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg64_relaxed_not_implemented(void);
 137:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_relaxed(...) raw_cmpxchg64_relaxed_not_implemented()
 138:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 139:./include/linux/atomic/atomic-arch-fallback.h **** 
 140:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg128)
 141:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128 arch_cmpxchg128
 142:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128_relaxed)
 143:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128(...) \
 144:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_cmpxchg128, __VA_ARGS__)
 145:./include/linux/atomic/atomic-arch-fallback.h **** #else
 146:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg128_not_implemented(void);
 147:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128(...) raw_cmpxchg128_not_implemented()
 148:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 149:./include/linux/atomic/atomic-arch-fallback.h **** 
 150:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg128_acquire)
 151:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_acquire arch_cmpxchg128_acquire
 152:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128_relaxed)
 153:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_acquire(...) \
 154:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_cmpxchg128, __VA_ARGS__)
 155:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128)
 156:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_acquire arch_cmpxchg128
 157:./include/linux/atomic/atomic-arch-fallback.h **** #else
 158:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg128_acquire_not_implemented(void);
ARM GAS  /tmp/ccgt6wcN.s 			page 17


 159:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_acquire(...) raw_cmpxchg128_acquire_not_implemented()
 160:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 161:./include/linux/atomic/atomic-arch-fallback.h **** 
 162:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg128_release)
 163:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_release arch_cmpxchg128_release
 164:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128_relaxed)
 165:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_release(...) \
 166:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_cmpxchg128, __VA_ARGS__)
 167:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128)
 168:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_release arch_cmpxchg128
 169:./include/linux/atomic/atomic-arch-fallback.h **** #else
 170:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg128_release_not_implemented(void);
 171:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_release(...) raw_cmpxchg128_release_not_implemented()
 172:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 173:./include/linux/atomic/atomic-arch-fallback.h **** 
 174:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_cmpxchg128_relaxed)
 175:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_relaxed arch_cmpxchg128_relaxed
 176:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_cmpxchg128)
 177:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_relaxed arch_cmpxchg128
 178:./include/linux/atomic/atomic-arch-fallback.h **** #else
 179:./include/linux/atomic/atomic-arch-fallback.h **** extern void raw_cmpxchg128_relaxed_not_implemented(void);
 180:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_relaxed(...) raw_cmpxchg128_relaxed_not_implemented()
 181:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 182:./include/linux/atomic/atomic-arch-fallback.h **** 
 183:./include/linux/atomic/atomic-arch-fallback.h **** 
 184:./include/linux/atomic/atomic-arch-fallback.h **** 
 185:./include/linux/atomic/atomic-arch-fallback.h **** 
 186:./include/linux/atomic/atomic-arch-fallback.h **** 
 187:./include/linux/atomic/atomic-arch-fallback.h **** 
 188:./include/linux/atomic/atomic-arch-fallback.h **** 
 189:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg)
 190:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg arch_try_cmpxchg
 191:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg_relaxed)
 192:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg(...) \
 193:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_try_cmpxchg, __VA_ARGS__)
 194:./include/linux/atomic/atomic-arch-fallback.h **** #else
 195:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg(_ptr, _oldp, _new) \
 196:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 197:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 198:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg((_ptr), ___o, (_new)); \
 199:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 200:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 201:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 202:./include/linux/atomic/atomic-arch-fallback.h **** })
 203:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 204:./include/linux/atomic/atomic-arch-fallback.h **** 
 205:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg_acquire)
 206:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_acquire arch_try_cmpxchg_acquire
 207:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg_relaxed)
 208:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_acquire(...) \
 209:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_try_cmpxchg, __VA_ARGS__)
 210:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg)
 211:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_acquire arch_try_cmpxchg
 212:./include/linux/atomic/atomic-arch-fallback.h **** #else
 213:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_acquire(_ptr, _oldp, _new) \
 214:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 215:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
ARM GAS  /tmp/ccgt6wcN.s 			page 18


 216:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg_acquire((_ptr), ___o, (_new)); \
 217:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 218:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 219:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 220:./include/linux/atomic/atomic-arch-fallback.h **** })
 221:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 222:./include/linux/atomic/atomic-arch-fallback.h **** 
 223:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg_release)
 224:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_release arch_try_cmpxchg_release
 225:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg_relaxed)
 226:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_release(...) \
 227:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_try_cmpxchg, __VA_ARGS__)
 228:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg)
 229:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_release arch_try_cmpxchg
 230:./include/linux/atomic/atomic-arch-fallback.h **** #else
 231:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_release(_ptr, _oldp, _new) \
 232:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 233:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 234:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg_release((_ptr), ___o, (_new)); \
 235:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 236:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 237:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 238:./include/linux/atomic/atomic-arch-fallback.h **** })
 239:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 240:./include/linux/atomic/atomic-arch-fallback.h **** 
 241:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg_relaxed)
 242:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_relaxed arch_try_cmpxchg_relaxed
 243:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg)
 244:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_relaxed arch_try_cmpxchg
 245:./include/linux/atomic/atomic-arch-fallback.h **** #else
 246:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_relaxed(_ptr, _oldp, _new) \
 247:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 248:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 249:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg_relaxed((_ptr), ___o, (_new)); \
 250:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 251:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 252:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 253:./include/linux/atomic/atomic-arch-fallback.h **** })
 254:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 255:./include/linux/atomic/atomic-arch-fallback.h **** 
 256:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg64)
 257:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64 arch_try_cmpxchg64
 258:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64_relaxed)
 259:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64(...) \
 260:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_try_cmpxchg64, __VA_ARGS__)
 261:./include/linux/atomic/atomic-arch-fallback.h **** #else
 262:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64(_ptr, _oldp, _new) \
 263:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 264:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 265:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64((_ptr), ___o, (_new)); \
 266:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 267:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 268:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 269:./include/linux/atomic/atomic-arch-fallback.h **** })
 270:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 271:./include/linux/atomic/atomic-arch-fallback.h **** 
 272:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg64_acquire)
ARM GAS  /tmp/ccgt6wcN.s 			page 19


 273:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_acquire arch_try_cmpxchg64_acquire
 274:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64_relaxed)
 275:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_acquire(...) \
 276:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_try_cmpxchg64, __VA_ARGS__)
 277:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64)
 278:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_acquire arch_try_cmpxchg64
 279:./include/linux/atomic/atomic-arch-fallback.h **** #else
 280:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_acquire(_ptr, _oldp, _new) \
 281:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 282:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 283:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64_acquire((_ptr), ___o, (_new)); \
 284:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 285:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 286:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 287:./include/linux/atomic/atomic-arch-fallback.h **** })
 288:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 289:./include/linux/atomic/atomic-arch-fallback.h **** 
 290:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg64_release)
 291:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_release arch_try_cmpxchg64_release
 292:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64_relaxed)
 293:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_release(...) \
 294:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_try_cmpxchg64, __VA_ARGS__)
 295:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64)
 296:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_release arch_try_cmpxchg64
 297:./include/linux/atomic/atomic-arch-fallback.h **** #else
 298:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_release(_ptr, _oldp, _new) \
 299:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 300:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 301:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64_release((_ptr), ___o, (_new)); \
 302:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 303:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 304:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 305:./include/linux/atomic/atomic-arch-fallback.h **** })
 306:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 307:./include/linux/atomic/atomic-arch-fallback.h **** 
 308:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg64_relaxed)
 309:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_relaxed arch_try_cmpxchg64_relaxed
 310:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg64)
 311:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_relaxed arch_try_cmpxchg64
 312:./include/linux/atomic/atomic-arch-fallback.h **** #else
 313:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_relaxed(_ptr, _oldp, _new) \
 314:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 315:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 316:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64_relaxed((_ptr), ___o, (_new)); \
 317:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 318:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 319:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 320:./include/linux/atomic/atomic-arch-fallback.h **** })
 321:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 322:./include/linux/atomic/atomic-arch-fallback.h **** 
 323:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg128)
 324:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128 arch_try_cmpxchg128
 325:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128_relaxed)
 326:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128(...) \
 327:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_fence(arch_try_cmpxchg128, __VA_ARGS__)
 328:./include/linux/atomic/atomic-arch-fallback.h **** #else
 329:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128(_ptr, _oldp, _new) \
ARM GAS  /tmp/ccgt6wcN.s 			page 20


 330:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 331:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 332:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128((_ptr), ___o, (_new)); \
 333:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 334:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 335:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 336:./include/linux/atomic/atomic-arch-fallback.h **** })
 337:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 338:./include/linux/atomic/atomic-arch-fallback.h **** 
 339:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg128_acquire)
 340:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_acquire arch_try_cmpxchg128_acquire
 341:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128_relaxed)
 342:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_acquire(...) \
 343:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_acquire(arch_try_cmpxchg128, __VA_ARGS__)
 344:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128)
 345:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_acquire arch_try_cmpxchg128
 346:./include/linux/atomic/atomic-arch-fallback.h **** #else
 347:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_acquire(_ptr, _oldp, _new) \
 348:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 349:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 350:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128_acquire((_ptr), ___o, (_new)); \
 351:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 352:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 353:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 354:./include/linux/atomic/atomic-arch-fallback.h **** })
 355:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 356:./include/linux/atomic/atomic-arch-fallback.h **** 
 357:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg128_release)
 358:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_release arch_try_cmpxchg128_release
 359:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128_relaxed)
 360:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_release(...) \
 361:./include/linux/atomic/atomic-arch-fallback.h **** 	__atomic_op_release(arch_try_cmpxchg128, __VA_ARGS__)
 362:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128)
 363:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_release arch_try_cmpxchg128
 364:./include/linux/atomic/atomic-arch-fallback.h **** #else
 365:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_release(_ptr, _oldp, _new) \
 366:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 367:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 368:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128_release((_ptr), ___o, (_new)); \
 369:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 370:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 371:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 372:./include/linux/atomic/atomic-arch-fallback.h **** })
 373:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 374:./include/linux/atomic/atomic-arch-fallback.h **** 
 375:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_try_cmpxchg128_relaxed)
 376:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_relaxed arch_try_cmpxchg128_relaxed
 377:./include/linux/atomic/atomic-arch-fallback.h **** #elif defined(arch_try_cmpxchg128)
 378:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_relaxed arch_try_cmpxchg128
 379:./include/linux/atomic/atomic-arch-fallback.h **** #else
 380:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_relaxed(_ptr, _oldp, _new) \
 381:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 382:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 383:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128_relaxed((_ptr), ___o, (_new)); \
 384:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 385:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 386:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
ARM GAS  /tmp/ccgt6wcN.s 			page 21


 387:./include/linux/atomic/atomic-arch-fallback.h **** })
 388:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 389:./include/linux/atomic/atomic-arch-fallback.h **** 
 390:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg_local arch_cmpxchg_local
 391:./include/linux/atomic/atomic-arch-fallback.h **** 
 392:./include/linux/atomic/atomic-arch-fallback.h **** #ifdef arch_try_cmpxchg_local
 393:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_local arch_try_cmpxchg_local
 394:./include/linux/atomic/atomic-arch-fallback.h **** #else
 395:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg_local(_ptr, _oldp, _new) \
 396:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 397:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 398:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg_local((_ptr), ___o, (_new)); \
 399:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 400:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 401:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 402:./include/linux/atomic/atomic-arch-fallback.h **** })
 403:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 404:./include/linux/atomic/atomic-arch-fallback.h **** 
 405:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg64_local arch_cmpxchg64_local
 406:./include/linux/atomic/atomic-arch-fallback.h **** 
 407:./include/linux/atomic/atomic-arch-fallback.h **** #ifdef arch_try_cmpxchg64_local
 408:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_local arch_try_cmpxchg64_local
 409:./include/linux/atomic/atomic-arch-fallback.h **** #else
 410:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg64_local(_ptr, _oldp, _new) \
 411:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 412:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 413:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg64_local((_ptr), ___o, (_new)); \
 414:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 415:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 416:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 417:./include/linux/atomic/atomic-arch-fallback.h **** })
 418:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 419:./include/linux/atomic/atomic-arch-fallback.h **** 
 420:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_cmpxchg128_local arch_cmpxchg128_local
 421:./include/linux/atomic/atomic-arch-fallback.h **** 
 422:./include/linux/atomic/atomic-arch-fallback.h **** #ifdef arch_try_cmpxchg128_local
 423:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_local arch_try_cmpxchg128_local
 424:./include/linux/atomic/atomic-arch-fallback.h **** #else
 425:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_try_cmpxchg128_local(_ptr, _oldp, _new) \
 426:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 427:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 428:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_cmpxchg128_local((_ptr), ___o, (_new)); \
 429:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 430:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 431:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 432:./include/linux/atomic/atomic-arch-fallback.h **** })
 433:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 434:./include/linux/atomic/atomic-arch-fallback.h **** 
 435:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_sync_cmpxchg arch_sync_cmpxchg
 436:./include/linux/atomic/atomic-arch-fallback.h **** 
 437:./include/linux/atomic/atomic-arch-fallback.h **** #ifdef arch_sync_try_cmpxchg
 438:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_sync_try_cmpxchg arch_sync_try_cmpxchg
 439:./include/linux/atomic/atomic-arch-fallback.h **** #else
 440:./include/linux/atomic/atomic-arch-fallback.h **** #define raw_sync_try_cmpxchg(_ptr, _oldp, _new) \
 441:./include/linux/atomic/atomic-arch-fallback.h **** ({ \
 442:./include/linux/atomic/atomic-arch-fallback.h **** 	typeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \
 443:./include/linux/atomic/atomic-arch-fallback.h **** 	___r = raw_sync_cmpxchg((_ptr), ___o, (_new)); \
ARM GAS  /tmp/ccgt6wcN.s 			page 22


 444:./include/linux/atomic/atomic-arch-fallback.h **** 	if (unlikely(___r != ___o)) \
 445:./include/linux/atomic/atomic-arch-fallback.h **** 		*___op = ___r; \
 446:./include/linux/atomic/atomic-arch-fallback.h **** 	likely(___r == ___o); \
 447:./include/linux/atomic/atomic-arch-fallback.h **** })
 448:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 449:./include/linux/atomic/atomic-arch-fallback.h **** 
 450:./include/linux/atomic/atomic-arch-fallback.h **** /**
 451:./include/linux/atomic/atomic-arch-fallback.h ****  * raw_atomic_read() - atomic load with relaxed ordering
 452:./include/linux/atomic/atomic-arch-fallback.h ****  * @v: pointer to atomic_t
 453:./include/linux/atomic/atomic-arch-fallback.h ****  *
 454:./include/linux/atomic/atomic-arch-fallback.h ****  * Atomically loads the value of @v with relaxed ordering.
 455:./include/linux/atomic/atomic-arch-fallback.h ****  *
 456:./include/linux/atomic/atomic-arch-fallback.h ****  * Safe to use in noinstr code; prefer atomic_read() elsewhere.
 457:./include/linux/atomic/atomic-arch-fallback.h ****  *
 458:./include/linux/atomic/atomic-arch-fallback.h ****  * Return: The value loaded from @v.
 459:./include/linux/atomic/atomic-arch-fallback.h ****  */
 460:./include/linux/atomic/atomic-arch-fallback.h **** static __always_inline int
 461:./include/linux/atomic/atomic-arch-fallback.h **** raw_atomic_read(const atomic_t *v)
 462:./include/linux/atomic/atomic-arch-fallback.h **** {
 463:./include/linux/atomic/atomic-arch-fallback.h **** 	return arch_atomic_read(v);
 464:./include/linux/atomic/atomic-arch-fallback.h **** }
 465:./include/linux/atomic/atomic-arch-fallback.h **** 
 466:./include/linux/atomic/atomic-arch-fallback.h **** /**
 467:./include/linux/atomic/atomic-arch-fallback.h ****  * raw_atomic_read_acquire() - atomic load with acquire ordering
 468:./include/linux/atomic/atomic-arch-fallback.h ****  * @v: pointer to atomic_t
 469:./include/linux/atomic/atomic-arch-fallback.h ****  *
 470:./include/linux/atomic/atomic-arch-fallback.h ****  * Atomically loads the value of @v with acquire ordering.
 471:./include/linux/atomic/atomic-arch-fallback.h ****  *
 472:./include/linux/atomic/atomic-arch-fallback.h ****  * Safe to use in noinstr code; prefer atomic_read_acquire() elsewhere.
 473:./include/linux/atomic/atomic-arch-fallback.h ****  *
 474:./include/linux/atomic/atomic-arch-fallback.h ****  * Return: The value loaded from @v.
 475:./include/linux/atomic/atomic-arch-fallback.h ****  */
 476:./include/linux/atomic/atomic-arch-fallback.h **** static __always_inline int
 477:./include/linux/atomic/atomic-arch-fallback.h **** raw_atomic_read_acquire(const atomic_t *v)
 478:./include/linux/atomic/atomic-arch-fallback.h **** {
 479:./include/linux/atomic/atomic-arch-fallback.h **** #if defined(arch_atomic_read_acquire)
 480:./include/linux/atomic/atomic-arch-fallback.h **** 	return arch_atomic_read_acquire(v);
 481:./include/linux/atomic/atomic-arch-fallback.h **** #else
 482:./include/linux/atomic/atomic-arch-fallback.h **** 	int ret;
 483:./include/linux/atomic/atomic-arch-fallback.h **** 
 484:./include/linux/atomic/atomic-arch-fallback.h **** 	if (__native_word(atomic_t)) {
 485:./include/linux/atomic/atomic-arch-fallback.h **** 		ret = smp_load_acquire(&(v)->counter);
 486:./include/linux/atomic/atomic-arch-fallback.h **** 	} else {
 487:./include/linux/atomic/atomic-arch-fallback.h **** 		ret = raw_atomic_read(v);
 488:./include/linux/atomic/atomic-arch-fallback.h **** 		__atomic_acquire_fence();
 489:./include/linux/atomic/atomic-arch-fallback.h **** 	}
 490:./include/linux/atomic/atomic-arch-fallback.h **** 
 491:./include/linux/atomic/atomic-arch-fallback.h **** 	return ret;
 492:./include/linux/atomic/atomic-arch-fallback.h **** #endif
 493:./include/linux/atomic/atomic-arch-fallback.h **** }
 494:./include/linux/atomic/atomic-arch-fallback.h **** 
 495:./include/linux/atomic/atomic-arch-fallback.h **** /**
 496:./include/linux/atomic/atomic-arch-fallback.h ****  * raw_atomic_set() - atomic set with relaxed ordering
 497:./include/linux/atomic/atomic-arch-fallback.h ****  * @v: pointer to atomic_t
 498:./include/linux/atomic/atomic-arch-fallback.h ****  * @i: int value to assign
 499:./include/linux/atomic/atomic-arch-fallback.h ****  *
 500:./include/linux/atomic/atomic-arch-fallback.h ****  * Atomically sets @v to @i with relaxed ordering.
ARM GAS  /tmp/ccgt6wcN.s 			page 23


 501:./include/linux/atomic/atomic-arch-fallback.h ****  *
 502:./include/linux/atomic/atomic-arch-fallback.h ****  * Safe to use in noinstr code; prefer atomic_set() elsewhere.
 503:./include/linux/atomic/atomic-arch-fallback.h ****  *
 504:./include/linux/atomic/atomic-arch-fallback.h ****  * Return: Nothing.
 505:./include/linux/atomic/atomic-arch-fallback.h ****  */
 506:./include/linux/atomic/atomic-arch-fallback.h **** static __always_inline void
 507:./include/linux/atomic/atomic-arch-fallback.h **** raw_atomic_set(atomic_t *v, int i)
 104              		.loc 5 507 1 view .LVU20
 105              	.LBB71:
 508:./include/linux/atomic/atomic-arch-fallback.h **** {
 509:./include/linux/atomic/atomic-arch-fallback.h **** 	arch_atomic_set(v, i);
 106              		.loc 5 509 2 view .LVU21
 107              		.loc 5 509 2 view .LVU22
 108              	.LBB72:
 109              		.loc 5 509 2 view .LVU23
 110              		.loc 5 509 2 view .LVU24
 111              	.LBE72:
 112              		.loc 5 509 2 discriminator 2 view .LVU25
 113              		.loc 5 509 2 discriminator 2 view .LVU26
 114              		.loc 5 509 2 discriminator 2 view .LVU27
 115 0012 8261     		str	r2, [r0, #24]
 116              		.loc 5 509 2 discriminator 2 view .LVU28
 117              		.loc 5 509 2 discriminator 2 view .LVU29
 118              	.LVL7:
 119              		.loc 5 509 2 is_stmt 0 discriminator 2 view .LVU30
 120              	.LBE71:
 121              	.LBE70:
 122              	.LBE69:
 195:./include/linux/mm_type.h ****     atomic_set(&page->_refcount, 0); 
 123              		.loc 2 195 5 is_stmt 1 view .LVU31
 124              	.LBB73:
 125              	.LBI73:
  65:./include/linux/atomic/atomic-instrumented.h **** {
 126              		.loc 4 65 1 view .LVU32
  67:./include/linux/atomic/atomic-instrumented.h **** 	raw_atomic_set(v, i);
 127              		.loc 4 67 2 view .LVU33
 128              		.loc 4 68 2 view .LVU34
 129              	.LBB74:
 130              	.LBI74:
 507:./include/linux/atomic/atomic-arch-fallback.h **** {
 131              		.loc 5 507 1 view .LVU35
 132              	.LBB75:
 133              		.loc 5 509 2 view .LVU36
 134              		.loc 5 509 2 view .LVU37
 135              	.LBB76:
 136              		.loc 5 509 2 view .LVU38
 137              		.loc 5 509 2 view .LVU39
 138              	.LBE76:
 139              		.loc 5 509 2 discriminator 2 view .LVU40
 140              		.loc 5 509 2 discriminator 2 view .LVU41
 141              		.loc 5 509 2 discriminator 2 view .LVU42
 142 0014 C261     		str	r2, [r0, #28]
 143              		.loc 5 509 2 discriminator 2 view .LVU43
 144              		.loc 5 509 2 discriminator 2 view .LVU44
 145              	.LVL8:
 146              		.loc 5 509 2 is_stmt 0 discriminator 2 view .LVU45
 147              	.LBE75:
ARM GAS  /tmp/ccgt6wcN.s 			page 24


 148              	.LBE74:
 149              	.LBE73:
 196:./include/linux/mm_type.h ****     page->zone_device_data = NULL;
 150              		.loc 2 196 5 is_stmt 1 view .LVU46
 151              		.loc 2 196 28 is_stmt 0 view .LVU47
 152 0016 4260     		str	r2, [r0, #4]
 197:./include/linux/mm_type.h ****     return page;
 153              		.loc 2 197 5 is_stmt 1 view .LVU48
 154              	.L3:
 198:./include/linux/mm_type.h **** }
 155              		.loc 2 198 1 is_stmt 0 view .LVU49
 156 0018 1846     		mov	r0, r3
 157              	.LVL9:
 158              		.loc 2 198 1 view .LVU50
 159 001a 08BD     		pop	{r3, pc}
 160              		.loc 2 198 1 view .LVU51
 161              		.cfi_endproc
 162              	.LFE908:
 164              		.section	.text.trans_data_to_blk_dev,"ax",%progbits
 165              		.align	1
 166              		.syntax unified
 167              		.thumb
 168              		.thumb_func
 170              	trans_data_to_blk_dev:
 171              	.LVL10:
 172              	.LFB1034:
  13:./block/partition.c **** static char * trans_data_to_blk_dev(struct block_device *bdev, sector_t block, unsigned size, char 
 173              		.loc 1 13 115 is_stmt 1 view -0
 174              		.cfi_startproc
 175              		@ args = 4, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		.loc 1 13 115 is_stmt 0 view .LVU53
 178 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 179              	.LCFI2:
 180              		.cfi_def_cfa_offset 28
 181              		.cfi_offset 4, -28
 182              		.cfi_offset 5, -24
 183              		.cfi_offset 6, -20
 184              		.cfi_offset 7, -16
 185              		.cfi_offset 8, -12
 186              		.cfi_offset 9, -8
 187              		.cfi_offset 14, -4
 188 0004 83B0     		sub	sp, sp, #12
 189              	.LCFI3:
 190              		.cfi_def_cfa_offset 40
 191 0006 0646     		mov	r6, r0
 192 0008 8846     		mov	r8, r1
 193 000a 1746     		mov	r7, r2
 194 000c 1D46     		mov	r5, r3
  14:./block/partition.c ****     struct page *page = virt_to_page((uint32_t)data);  
 195              		.loc 1 14 5 is_stmt 1 view .LVU54
 196              	.LVL11:
 197              	.LBB77:
 198              	.LBI77:
 199:./include/linux/mm_type.h **** static inline void __page_destroy(struct page *page){
 200:./include/linux/mm_type.h ****     if (page) 
 201:./include/linux/mm_type.h **** 	{
ARM GAS  /tmp/ccgt6wcN.s 			page 25


 202:./include/linux/mm_type.h ****         kfree(page);
 203:./include/linux/mm_type.h **** 		page = NULL;
 204:./include/linux/mm_type.h ****     }
 205:./include/linux/mm_type.h **** }
 206:./include/linux/mm_type.h **** 
 207:./include/linux/mm_type.h **** 
 208:./include/linux/mm_type.h **** static inline void *__page_address(struct page *page){
 209:./include/linux/mm_type.h ****     return page ? page->zone_device_data : NULL; 
 210:./include/linux/mm_type.h **** }
 211:./include/linux/mm_type.h **** static inline void __set_page_dirty(struct page *page){
 212:./include/linux/mm_type.h ****     if (page)
 213:./include/linux/mm_type.h **** 	__set_page_flag(page, PG_dirty);
 214:./include/linux/mm_type.h **** }
 215:./include/linux/mm_type.h **** 
 216:./include/linux/mm_type.h **** static inline void __clear_page_dirty(struct page *page){
 217:./include/linux/mm_type.h ****     if (page)
 218:./include/linux/mm_type.h **** 	__clear_page_flag(page, PG_dirty);
 219:./include/linux/mm_type.h **** }
 220:./include/linux/mm_type.h **** 
 221:./include/linux/mm_type.h **** static inline struct page *__alloc_pages( gfp_t flags , unsigned int order ){
 222:./include/linux/mm_type.h **** 	struct page *page = __page_create(flags);
 223:./include/linux/mm_type.h **** 	if(page == NULL)
 224:./include/linux/mm_type.h **** 		return -ENOMEM ;
 225:./include/linux/mm_type.h **** 	void *data = (void *)kmalloc(PAGE_SIZE, flags);
 226:./include/linux/mm_type.h **** 	if(data == NULL){
 227:./include/linux/mm_type.h **** 		__page_destroy(page);
 228:./include/linux/mm_type.h **** 		return -ENOMEM ;
 229:./include/linux/mm_type.h **** 	}
 230:./include/linux/mm_type.h **** 	page->page_type = 1234;
 231:./include/linux/mm_type.h **** 	page->zone_device_data = data;
 232:./include/linux/mm_type.h **** 	return page;
 233:./include/linux/mm_type.h **** }
 234:./include/linux/mm_type.h **** 
 235:./include/linux/mm_type.h **** static inline void __free_pages(struct page *page, unsigned int order){
 236:./include/linux/mm_type.h ****     if (page) {
 237:./include/linux/mm_type.h **** 		if(page->page_type == 1234)
 238:./include/linux/mm_type.h **** 		kfree(page->zone_device_data);
 239:./include/linux/mm_type.h ****         __page_destroy(page);
 240:./include/linux/mm_type.h ****     }
 241:./include/linux/mm_type.h **** }
 242:./include/linux/mm_type.h **** 
 243:./include/linux/mm_type.h **** static inline struct page *__pfn_to_page(unsigned long pfn){
 199              		.loc 2 243 28 view .LVU55
 200              	.LBB78:
 244:./include/linux/mm_type.h **** 	struct page *page = __page_create(GFP_KERNEL);
 201              		.loc 2 244 2 view .LVU56
 202              		.loc 2 244 22 is_stmt 0 view .LVU57
 203 000e 4FF44C60 		mov	r0, #3264
 204              	.LVL12:
 205              		.loc 2 244 22 view .LVU58
 206 0012 FFF7FEFF 		bl	__page_create
 207              	.LVL13:
 245:./include/linux/mm_type.h **** 	if(page == NULL)
 208              		.loc 2 245 2 is_stmt 1 view .LVU59
 209              		.loc 2 245 4 is_stmt 0 view .LVU60
 210 0016 48B3     		cbz	r0, .L11
 211 0018 8146     		mov	r9, r0
ARM GAS  /tmp/ccgt6wcN.s 			page 26


 246:./include/linux/mm_type.h **** 		return -ENOMEM ;
 247:./include/linux/mm_type.h **** 	page->zone_device_data = (void *)(pfn << 0 );
 212              		.loc 2 247 2 is_stmt 1 view .LVU61
 213              		.loc 2 247 25 is_stmt 0 view .LVU62
 214 001a 4560     		str	r5, [r0, #4]
 248:./include/linux/mm_type.h **** 	return page;
 215              		.loc 2 248 2 is_stmt 1 view .LVU63
 216              	.L7:
 217              	.LVL14:
 218              		.loc 2 248 2 is_stmt 0 view .LVU64
 219              	.LBE78:
 220              	.LBE77:
  15:./block/partition.c ****     struct bio *bio = bio_alloc(bdev,1,mod,GFP_KERNEL);
 221              		.loc 1 15 5 is_stmt 1 view .LVU65
 222              	.LBB80:
 223              	.LBI80:
 224              		.file 6 "./include/linux/bio.h"
   1:./include/linux/bio.h **** #ifndef _LINUX_BIO_H
   2:./include/linux/bio.h **** #define _LINUX_BIO_H
   3:./include/linux/bio.h **** 
   4:./include/linux/bio.h **** #include <linux/blk_types.h>
   5:./include/linux/bio.h **** #include <linux/slab.h>
   6:./include/linux/bio.h **** #include <linux/mempool.h>
   7:./include/linux/bio.h **** #include <linux/workqueue_types.h>
   8:./include/linux/bio.h **** 
   9:./include/linux/bio.h **** /* struct bio, bio_vec and BIO_* flags are defined in blk_types.h */
  10:./include/linux/bio.h **** #include <linux/uio.h>
  11:./include/linux/bio.h **** #include <linux/bvec.h>
  12:./include/linux/bio.h **** #include <linux/atomic.h>
  13:./include/linux/bio.h **** 
  14:./include/linux/bio.h **** struct bio ;
  15:./include/linux/bio.h **** 
  16:./include/linux/bio.h **** #define page_address(x) x
  17:./include/linux/bio.h **** 
  18:./include/linux/bio.h **** #define BIO_MAX_VECS		256u
  19:./include/linux/bio.h **** 
  20:./include/linux/bio.h **** struct queue_limits;
  21:./include/linux/bio.h **** 
  22:./include/linux/bio.h **** static inline unsigned int bio_max_segs(unsigned int nr_segs)
  23:./include/linux/bio.h **** {
  24:./include/linux/bio.h **** 	return min(nr_segs, BIO_MAX_VECS);
  25:./include/linux/bio.h **** }
  26:./include/linux/bio.h **** 
  27:./include/linux/bio.h **** #define bio_prio(bio)			(bio)->bi_ioprio
  28:./include/linux/bio.h **** #define bio_set_prio(bio, prio)		((bio)->bi_ioprio = prio)
  29:./include/linux/bio.h **** 
  30:./include/linux/bio.h **** #define bio_iter_iovec(bio, iter)				\
  31:./include/linux/bio.h **** 	bvec_iter_bvec((bio)->bi_io_vec, (iter))
  32:./include/linux/bio.h **** 
  33:./include/linux/bio.h **** #define bio_iter_page(bio, iter)				\
  34:./include/linux/bio.h **** 	bvec_iter_page((bio)->bi_io_vec, (iter))
  35:./include/linux/bio.h **** #define bio_iter_len(bio, iter)					\
  36:./include/linux/bio.h **** 	bvec_iter_len((bio)->bi_io_vec, (iter))
  37:./include/linux/bio.h **** #define bio_iter_offset(bio, iter)				\
  38:./include/linux/bio.h **** 	bvec_iter_offset((bio)->bi_io_vec, (iter))
  39:./include/linux/bio.h **** 
  40:./include/linux/bio.h **** 
ARM GAS  /tmp/ccgt6wcN.s 			page 27


  41:./include/linux/bio.h **** #define bio_page(bio)		bio_iter_page((bio), (bio)->bi_iter)
  42:./include/linux/bio.h **** #define bio_offset(bio)		bio_iter_offset((bio), (bio)->bi_iter)
  43:./include/linux/bio.h **** #define bio_iovec(bio)		bio_iter_iovec((bio), (bio)->bi_iter)
  44:./include/linux/bio.h **** 
  45:./include/linux/bio.h **** #define bvec_iter_sectors(iter)	((iter).bi_size >> 9)
  46:./include/linux/bio.h **** #define bvec_iter_end_sector(iter) ((iter).bi_sector + bvec_iter_sectors((iter)))
  47:./include/linux/bio.h **** 
  48:./include/linux/bio.h **** #define bio_sectors(bio)	bvec_iter_sectors((bio)->bi_iter)
  49:./include/linux/bio.h **** #define bio_end_sector(bio)	bvec_iter_end_sector((bio)->bi_iter)
  50:./include/linux/bio.h **** 
  51:./include/linux/bio.h **** /*
  52:./include/linux/bio.h ****  * Return the data direction, READ or WRITE.
  53:./include/linux/bio.h ****  */
  54:./include/linux/bio.h **** #define bio_data_dir(bio) \
  55:./include/linux/bio.h **** 	(op_is_write(bio_op(bio)) ? WRITE : READ)
  56:./include/linux/bio.h **** 
  57:./include/linux/bio.h **** 
  58:./include/linux/bio.h **** /*
  59:./include/linux/bio.h ****  * Check whether this bio carries any data or not. A NULL bio is allowed.
  60:./include/linux/bio.h ****  */
  61:./include/linux/bio.h **** static inline bool bio_has_data(struct bio *bio)
  62:./include/linux/bio.h **** {
  63:./include/linux/bio.h **** 	if (bio &&
  64:./include/linux/bio.h **** 	    bio->bi_iter.bi_size &&
  65:./include/linux/bio.h **** 	    bio_op(bio) != REQ_OP_DISCARD &&
  66:./include/linux/bio.h **** 	    bio_op(bio) != REQ_OP_SECURE_ERASE &&
  67:./include/linux/bio.h **** 	    bio_op(bio) != REQ_OP_WRITE_ZEROES)
  68:./include/linux/bio.h **** 		return true;
  69:./include/linux/bio.h **** 
  70:./include/linux/bio.h **** 	return false;
  71:./include/linux/bio.h **** }
  72:./include/linux/bio.h **** 
  73:./include/linux/bio.h **** static inline bool bio_no_advance_iter(const struct bio *bio)
  74:./include/linux/bio.h **** {
  75:./include/linux/bio.h **** 	return bio_op(bio) == REQ_OP_DISCARD ||
  76:./include/linux/bio.h **** 	       bio_op(bio) == REQ_OP_SECURE_ERASE ||
  77:./include/linux/bio.h **** 	       bio_op(bio) == REQ_OP_WRITE_ZEROES;
  78:./include/linux/bio.h **** }
  79:./include/linux/bio.h **** 
  80:./include/linux/bio.h **** 
  81:./include/linux/bio.h **** static inline void * bio_data(struct bio *bio)
  82:./include/linux/bio.h **** {
  83:./include/linux/bio.h **** 	#if (MMU == _ENABLE_)
  84:./include/linux/bio.h **** 	if (bio_has_data(bio)){
  85:./include/linux/bio.h **** 		return page_address(bio_page(bio)) + bio_offset(bio);		
  86:./include/linux/bio.h **** 	}
  87:./include/linux/bio.h **** 	#else
  88:./include/linux/bio.h **** 		struct bio_vec *bv = &bio->bi_io_vec[bio->bi_iter.bi_idx];
  89:./include/linux/bio.h **** 		return kmap(bv->bv_page);
  90:./include/linux/bio.h **** 	#endif	
  91:./include/linux/bio.h **** 	return NULL;
  92:./include/linux/bio.h **** }
  93:./include/linux/bio.h **** 
  94:./include/linux/bio.h **** 
  95:./include/linux/bio.h **** 	
  96:./include/linux/bio.h **** 
  97:./include/linux/bio.h **** 
ARM GAS  /tmp/ccgt6wcN.s 			page 28


  98:./include/linux/bio.h **** 
  99:./include/linux/bio.h **** 
 100:./include/linux/bio.h **** static inline bool bio_flagged(struct bio *bio, unsigned int bit)
 101:./include/linux/bio.h **** {
 102:./include/linux/bio.h **** 	return bio->bi_flags & (1U << bit);
 103:./include/linux/bio.h **** }
 104:./include/linux/bio.h **** 
 105:./include/linux/bio.h **** static inline void bio_set_flag(struct bio *bio, unsigned int bit)
 106:./include/linux/bio.h **** {
 107:./include/linux/bio.h **** 	bio->bi_flags |= (1U << bit);
 108:./include/linux/bio.h **** }
 109:./include/linux/bio.h **** 
 110:./include/linux/bio.h **** static inline void bio_clear_flag(struct bio *bio, unsigned int bit)
 111:./include/linux/bio.h **** {
 112:./include/linux/bio.h **** 	bio->bi_flags &= ~(1U << bit);
 113:./include/linux/bio.h **** }
 114:./include/linux/bio.h **** 
 115:./include/linux/bio.h **** /**
 116:./include/linux/bio.h ****  * struct folio_iter - State for iterating all folios in a bio.
 117:./include/linux/bio.h ****  * @folio: The current folio we're iterating.  NULL after the last folio.
 118:./include/linux/bio.h ****  * @offset: The byte offset within the current folio.
 119:./include/linux/bio.h ****  * @length: The number of bytes in this iteration (will not cross folio
 120:./include/linux/bio.h ****  *	boundary).
 121:./include/linux/bio.h ****  */
 122:./include/linux/bio.h **** struct folio_iter {
 123:./include/linux/bio.h **** 	struct folio *folio;
 124:./include/linux/bio.h **** 	size_t offset;
 125:./include/linux/bio.h **** 	size_t length;
 126:./include/linux/bio.h **** 	/* private: for use by the iterator */
 127:./include/linux/bio.h **** 	struct folio *_next;
 128:./include/linux/bio.h **** 	size_t _seg_count;
 129:./include/linux/bio.h **** 	int _i;
 130:./include/linux/bio.h **** };
 131:./include/linux/bio.h **** 
 132:./include/linux/bio.h **** 
 133:./include/linux/bio.h **** 
 134:./include/linux/bio.h **** void submit_bio(struct bio *bio);
 135:./include/linux/bio.h **** void submit_bio_wait(struct bio *bio);
 136:./include/linux/bio.h **** 
 137:./include/linux/bio.h **** int __must_check bio_add_page(struct bio *bio, struct page *page,
 138:./include/linux/bio.h ****     unsigned int len, unsigned int offset);
 139:./include/linux/bio.h **** 
 140:./include/linux/bio.h **** int __bio_add_page(struct bio *bio, struct page *page,
 141:./include/linux/bio.h ****     unsigned int len, unsigned int off);
 142:./include/linux/bio.h **** 
 143:./include/linux/bio.h **** extern struct bio_set fs_bio_set;
 144:./include/linux/bio.h **** 
 145:./include/linux/bio.h **** struct bio *bio_alloc_bioset(struct block_device *bdev, unsigned short nr_iovecs,
 146:./include/linux/bio.h ****     blk_opf_t opf, gfp_t gfp_mask,
 147:./include/linux/bio.h ****     struct bio_set *bs);
 148:./include/linux/bio.h **** 
 149:./include/linux/bio.h **** static inline struct bio *bio_alloc(struct block_device	*bi_bdev,
 225              		.loc 6 149 27 view .LVU66
 226              	.LBB81:
 150:./include/linux/bio.h **** 		 unsigned short nr_iovecs , blk_opf_t opf, gfp_t gfp_mask)
 151:./include/linux/bio.h **** {
 152:./include/linux/bio.h **** 	return bio_alloc_bioset(bi_bdev,nr_iovecs,opf,gfp_mask,&fs_bio_set);
ARM GAS  /tmp/ccgt6wcN.s 			page 29


 227              		.loc 6 152 2 view .LVU67
 228              		.loc 6 152 9 is_stmt 0 view .LVU68
 229 001c 174B     		ldr	r3, .L14
 230 001e 0093     		str	r3, [sp]
 231 0020 4FF44C63 		mov	r3, #3264
 232 0024 0A9A     		ldr	r2, [sp, #40]
 233 0026 0121     		movs	r1, #1
 234 0028 3046     		mov	r0, r6
 235 002a FFF7FEFF 		bl	bio_alloc_bioset
 236              	.LVL15:
 237 002e 0446     		mov	r4, r0
 238              	.LVL16:
 239              		.loc 6 152 9 view .LVU69
 240              	.LBE81:
 241              	.LBE80:
  16:./block/partition.c ****     bio_set_dev(bio,bdev);                                           //
 242              		.loc 1 16 5 is_stmt 1 view .LVU70
 243              	.LBB82:
 244              	.LBI82:
 153:./include/linux/bio.h **** }
 154:./include/linux/bio.h **** 
 155:./include/linux/bio.h **** extern void bio_put(struct bio *);
 156:./include/linux/bio.h **** 
 157:./include/linux/bio.h **** 
 158:./include/linux/bio.h **** 
 159:./include/linux/bio.h **** static inline void bio_associate_blkg(struct bio *bio) { }
 160:./include/linux/bio.h **** 
 161:./include/linux/bio.h **** static inline void bio_set_dev(struct bio *bio, struct block_device *bdev)
 245              		.loc 6 161 20 view .LVU71
 246              	.LBB83:
 162:./include/linux/bio.h **** {
 163:./include/linux/bio.h **** 	bio_clear_flag(bio, BIO_REMAPPED);
 247              		.loc 6 163 2 view .LVU72
 248              	.LBB84:
 249              	.LBI84:
 110:./include/linux/bio.h **** {
 250              		.loc 6 110 20 view .LVU73
 251              	.LBB85:
 112:./include/linux/bio.h **** }
 252              		.loc 6 112 2 view .LVU74
 112:./include/linux/bio.h **** }
 253              		.loc 6 112 5 is_stmt 0 view .LVU75
 254 0030 8389     		ldrh	r3, [r0, #12]
 112:./include/linux/bio.h **** }
 255              		.loc 6 112 16 view .LVU76
 256 0032 23F40062 		bic	r2, r3, #2048
 257 0036 8281     		strh	r2, [r0, #12]	@ movhi
 258              	.LVL17:
 112:./include/linux/bio.h **** }
 259              		.loc 6 112 16 view .LVU77
 260              	.LBE85:
 261              	.LBE84:
 164:./include/linux/bio.h **** 	if (bio->bi_bdev != bdev)
 262              		.loc 6 164 2 is_stmt 1 view .LVU78
 263              		.loc 6 164 9 is_stmt 0 view .LVU79
 264 0038 4268     		ldr	r2, [r0, #4]
 265              		.loc 6 164 5 view .LVU80
ARM GAS  /tmp/ccgt6wcN.s 			page 30


 266 003a 9642     		cmp	r6, r2
 267 003c 02D0     		beq	.L8
 165:./include/linux/bio.h **** 		bio_clear_flag(bio, BIO_BPS_THROTTLED);
 268              		.loc 6 165 3 is_stmt 1 view .LVU81
 269              	.LVL18:
 270              	.LBB86:
 271              	.LBI86:
 110:./include/linux/bio.h **** {
 272              		.loc 6 110 20 view .LVU82
 273              	.LBB87:
 112:./include/linux/bio.h **** }
 274              		.loc 6 112 2 view .LVU83
 112:./include/linux/bio.h **** }
 275              		.loc 6 112 16 is_stmt 0 view .LVU84
 276 003e 23F40463 		bic	r3, r3, #2112
 277 0042 8381     		strh	r3, [r0, #12]	@ movhi
 278              	.LVL19:
 279              	.L8:
 112:./include/linux/bio.h **** }
 280              		.loc 6 112 16 view .LVU85
 281              	.LBE87:
 282              	.LBE86:
 166:./include/linux/bio.h **** 	bio->bi_bdev = bdev;
 283              		.loc 6 166 2 is_stmt 1 view .LVU86
 284              		.loc 6 166 15 is_stmt 0 view .LVU87
 285 0044 6660     		str	r6, [r4, #4]
 167:./include/linux/bio.h **** 	bio_associate_blkg(bio);
 286              		.loc 6 167 2 is_stmt 1 view .LVU88
 287              	.LVL20:
 288              		.loc 6 167 2 is_stmt 0 view .LVU89
 289              	.LBE83:
 290              	.LBE82:
  17:./block/partition.c ****     bio->bi_iter.bi_sector = block;
 291              		.loc 1 17 5 is_stmt 1 view .LVU90
 292              		.loc 1 17 28 is_stmt 0 view .LVU91
 293 0046 C4F81880 		str	r8, [r4, #24]
  18:./block/partition.c ****     bio->bi_end_io = my_end_io;
 294              		.loc 1 18 5 is_stmt 1 view .LVU92
 295              		.loc 1 18 20 is_stmt 0 view .LVU93
 296 004a 0D4B     		ldr	r3, .L14+4
 297 004c E362     		str	r3, [r4, #44]
  19:./block/partition.c ****     if(bio_add_page(bio, page, size, offset_in_page(data)) < 0 ){
 298              		.loc 1 19 5 is_stmt 1 view .LVU94
 299              		.loc 1 19 8 is_stmt 0 view .LVU95
 300 004e 0023     		movs	r3, #0
 301 0050 3A46     		mov	r2, r7
 302 0052 4946     		mov	r1, r9
 303 0054 2046     		mov	r0, r4
 304              	.LVL21:
 305              		.loc 1 19 8 view .LVU96
 306 0056 FFF7FEFF 		bl	bio_add_page
 307              	.LVL22:
 308              		.loc 1 19 7 discriminator 1 view .LVU97
 309 005a 0028     		cmp	r0, #0
 310 005c 09DB     		blt	.L13
  20:./block/partition.c ****         bio_put(bio);
  21:./block/partition.c ****         return NULL;
ARM GAS  /tmp/ccgt6wcN.s 			page 31


  22:./block/partition.c ****     }
  23:./block/partition.c ****     submit_bio_wait(bio);
 311              		.loc 1 23 5 is_stmt 1 view .LVU98
 312 005e 2046     		mov	r0, r4
 313 0060 FFF7FEFF 		bl	submit_bio_wait
 314              	.LVL23:
  24:./block/partition.c ****     return data;
 315              		.loc 1 24 5 view .LVU99
 316              		.loc 1 24 12 is_stmt 0 view .LVU100
 317 0064 2846     		mov	r0, r5
 318              	.L6:
  25:./block/partition.c **** }
 319              		.loc 1 25 1 view .LVU101
 320 0066 03B0     		add	sp, sp, #12
 321              	.LCFI4:
 322              		.cfi_remember_state
 323              		.cfi_def_cfa_offset 28
 324              		@ sp needed
 325 0068 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 326              	.LVL24:
 327              	.L11:
 328              	.LCFI5:
 329              		.cfi_restore_state
 330              	.LBB88:
 331              	.LBB79:
 246:./include/linux/mm_type.h **** 	page->zone_device_data = (void *)(pfn << 0 );
 332              		.loc 2 246 10 view .LVU102
 333 006c 6FF00B09 		mvn	r9, #11
 334 0070 D4E7     		b	.L7
 335              	.LVL25:
 336              	.L13:
 246:./include/linux/mm_type.h **** 	page->zone_device_data = (void *)(pfn << 0 );
 337              		.loc 2 246 10 view .LVU103
 338              	.LBE79:
 339              	.LBE88:
  20:./block/partition.c ****         return NULL;
 340              		.loc 1 20 9 is_stmt 1 view .LVU104
 341 0072 2046     		mov	r0, r4
 342 0074 FFF7FEFF 		bl	bio_put
 343              	.LVL26:
  21:./block/partition.c ****     }
 344              		.loc 1 21 9 view .LVU105
  21:./block/partition.c ****     }
 345              		.loc 1 21 16 is_stmt 0 view .LVU106
 346 0078 0020     		movs	r0, #0
 347 007a F4E7     		b	.L6
 348              	.L15:
 349              		.align	2
 350              	.L14:
 351 007c 00000000 		.word	fs_bio_set
 352 0080 00000000 		.word	my_end_io
 353              		.cfi_endproc
 354              	.LFE1034:
 356              		.section	.text.detect_partition_table,"ax",%progbits
 357              		.align	1
 358              		.syntax unified
 359              		.thumb
ARM GAS  /tmp/ccgt6wcN.s 			page 32


 360              		.thumb_func
 362              	detect_partition_table:
 363              	.LVL27:
 364              	.LFB1035:
  26:./block/partition.c **** 
  27:./block/partition.c **** 
  28:./block/partition.c **** 
  29:./block/partition.c **** 
  30:./block/partition.c **** static uint8_t gpt_head[8] = {0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54};
  31:./block/partition.c **** 
  32:./block/partition.c **** /**
  33:./block/partition.c ****  * detect_partition_table - Detect the partition table of the block device
  34:./block/partition.c ****  * @device: pointer to the block device to check
  35:./block/partition.c ****  * @block_buffer: buffer to hold the data read from the block device
  36:./block/partition.c ****  * @flags: pointer to a variable to store the partition table type flags
  37:./block/partition.c ****  *
  38:./block/partition.c ****  * This function attempts to detect the partition table type of a block device
  39:./block/partition.c ****  * by reading the first two Logical Block Addresses (LBA) and checking for 
  40:./block/partition.c ****  * signatures that indicate the partitioning scheme.
  41:./block/partition.c ****  *
  42:./block/partition.c ****  * Steps:
  43:./block/partition.c ****  * 1. Initially, the device is marked as uninitialized (`BLOCK_DEVICE_FLAG_NOT_INITIALIZED`).
  44:./block/partition.c ****  * 2. The first 512 bytes of LBA 0 are read to check for the MBR (Master Boot Record) signature.
  45:./block/partition.c ****  *    If the signature (`0x55AA` at the end of the sector) is found, the device is flagged as MBR.
  46:./block/partition.c ****  * 3. The first 512 bytes of LBA 1 are read to check for the GPT (GUID Partition Table) header.
  47:./block/partition.c ****  *    If the GPT header is found, the partition table type is set to GPT, or if an MBR was detected
  48:./block/partition.c ****  *    it is marked as a protective MBR.
  49:./block/partition.c ****  *
  50:./block/partition.c ****  * 
  51:./block/partition.c ****  * detect_partition_table - 
  52:./block/partition.c ****  * @device: 
  53:./block/partition.c ****  * @block_buffer: 
  54:./block/partition.c ****  * @flags: 
  55:./block/partition.c ****  *
  56:./block/partition.c ****  * LBA
  57:./block/partition.c ****  * 
  58:./block/partition.c ****  *
  59:./block/partition.c ****  * 
  60:./block/partition.c ****  * 1. `BLOCK_DEVICE_FLAG_NOT_INITIALIZED`
  61:./block/partition.c ****  * 2.  LBA 0  512  MBR
  62:./block/partition.c ****  *    LBA  `0x55AA` MBR
  63:./block/partition.c ****  * 3.  LBA 1  512  GPTGUID 
  64:./block/partition.c ****  *     GPT  GPT MBR
  65:./block/partition.c ****  */
  66:./block/partition.c **** static int detect_partition_table(struct block_device *device,char *block_buffer, enum block_device
  67:./block/partition.c **** {
 365              		.loc 1 67 1 is_stmt 1 view -0
 366              		.cfi_startproc
 367              		@ args = 0, pretend = 0, frame = 0
 368              		@ frame_needed = 0, uses_anonymous_args = 0
 369              		.loc 1 67 1 is_stmt 0 view .LVU108
 370 0000 70B5     		push	{r4, r5, r6, lr}
 371              	.LCFI6:
 372              		.cfi_def_cfa_offset 16
 373              		.cfi_offset 4, -16
 374              		.cfi_offset 5, -12
 375              		.cfi_offset 6, -8
ARM GAS  /tmp/ccgt6wcN.s 			page 33


 376              		.cfi_offset 14, -4
 377 0002 82B0     		sub	sp, sp, #8
 378              	.LCFI7:
 379              		.cfi_def_cfa_offset 24
 380 0004 0646     		mov	r6, r0
 381 0006 0D46     		mov	r5, r1
 382 0008 1446     		mov	r4, r2
  68:./block/partition.c ****     *flags = BLOCK_DEVICE_FLAG_NOT_INITIALIZED;                           //
 383              		.loc 1 68 5 is_stmt 1 view .LVU109
 384              		.loc 1 68 12 is_stmt 0 view .LVU110
 385 000a 0021     		movs	r1, #0
 386              	.LVL28:
 387              		.loc 1 68 12 view .LVU111
 388 000c 1170     		strb	r1, [r2]
  69:./block/partition.c ****     char *data =  trans_data_to_blk_dev(device,0,512,block_buffer,REQ_OP_READ);
 389              		.loc 1 69 5 is_stmt 1 view .LVU112
 390              		.loc 1 69 19 is_stmt 0 view .LVU113
 391 000e 0091     		str	r1, [sp]
 392 0010 2B46     		mov	r3, r5
 393 0012 4FF40072 		mov	r2, #512
 394              	.LVL29:
 395              		.loc 1 69 19 view .LVU114
 396 0016 FFF7FEFF 		bl	trans_data_to_blk_dev
 397              	.LVL30:
  70:./block/partition.c ****     if(data[0x01FE] == 0x55 && data[0x01FF] == 0xAA)
 398              		.loc 1 70 5 is_stmt 1 view .LVU115
 399              		.loc 1 70 12 is_stmt 0 view .LVU116
 400 001a 90F8FE31 		ldrb	r3, [r0, #510]	@ zero_extendqisi2
 401              		.loc 1 70 7 view .LVU117
 402 001e 552B     		cmp	r3, #85
 403 0020 15D0     		beq	.L21
 404              	.L17:
  71:./block/partition.c ****         *flags = BLOCK_DEVICE_FLAG_MBR;                                    //LBA 0
  72:./block/partition.c ****     data =  trans_data_to_blk_dev(device,1,512,block_buffer,REQ_OP_READ);//LBA 1
 405              		.loc 1 72 5 is_stmt 1 view .LVU118
 406              		.loc 1 72 13 is_stmt 0 view .LVU119
 407 0022 0023     		movs	r3, #0
 408 0024 0093     		str	r3, [sp]
 409 0026 2B46     		mov	r3, r5
 410 0028 4FF40072 		mov	r2, #512
 411 002c 0121     		movs	r1, #1
 412 002e 3046     		mov	r0, r6
 413              	.LVL31:
 414              		.loc 1 72 13 view .LVU120
 415 0030 FFF7FEFF 		bl	trans_data_to_blk_dev
 416              	.LVL32:
  73:./block/partition.c ****     if (memcmp(data, gpt_head, 8) == 0)
 417              		.loc 1 73 5 is_stmt 1 view .LVU121
 418              		.loc 1 73 9 is_stmt 0 view .LVU122
 419 0034 0822     		movs	r2, #8
 420 0036 0B49     		ldr	r1, .L23
 421 0038 FFF7FEFF 		bl	memcmp
 422              	.LVL33:
 423              		.loc 1 73 8 discriminator 1 view .LVU123
 424 003c 20B9     		cbnz	r0, .L18
  74:./block/partition.c ****     {
  75:./block/partition.c ****         if(*flags == BLOCK_DEVICE_FLAG_MBR)
ARM GAS  /tmp/ccgt6wcN.s 			page 34


 425              		.loc 1 75 9 is_stmt 1 view .LVU124
 426              		.loc 1 75 12 is_stmt 0 view .LVU125
 427 003e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 428              		.loc 1 75 11 view .LVU126
 429 0040 012B     		cmp	r3, #1
 430 0042 0BD0     		beq	.L22
  76:./block/partition.c ****             *flags = BLOCK_DEVICE_FLAG_PROTECTIVE_MBR;
  77:./block/partition.c ****         else
  78:./block/partition.c ****             *flags = BLOCK_DEVICE_FLAG_GPT;
 431              		.loc 1 78 13 is_stmt 1 view .LVU127
 432              		.loc 1 78 20 is_stmt 0 view .LVU128
 433 0044 0223     		movs	r3, #2
 434 0046 2370     		strb	r3, [r4]
 435              	.L18:
  79:./block/partition.c ****     }
  80:./block/partition.c ****     return 0;
 436              		.loc 1 80 5 is_stmt 1 view .LVU129
  81:./block/partition.c **** }
 437              		.loc 1 81 1 is_stmt 0 view .LVU130
 438 0048 0020     		movs	r0, #0
 439 004a 02B0     		add	sp, sp, #8
 440              	.LCFI8:
 441              		.cfi_remember_state
 442              		.cfi_def_cfa_offset 16
 443              		@ sp needed
 444 004c 70BD     		pop	{r4, r5, r6, pc}
 445              	.LVL34:
 446              	.L21:
 447              	.LCFI9:
 448              		.cfi_restore_state
  70:./block/partition.c ****         *flags = BLOCK_DEVICE_FLAG_MBR;                                    //LBA 0
 449              		.loc 1 70 36 discriminator 1 view .LVU131
 450 004e 90F8FF31 		ldrb	r3, [r0, #511]	@ zero_extendqisi2
  70:./block/partition.c ****         *flags = BLOCK_DEVICE_FLAG_MBR;                                    //LBA 0
 451              		.loc 1 70 29 discriminator 1 view .LVU132
 452 0052 AA2B     		cmp	r3, #170
 453 0054 E5D1     		bne	.L17
  71:./block/partition.c ****     data =  trans_data_to_blk_dev(device,1,512,block_buffer,REQ_OP_READ);//LBA 1
 454              		.loc 1 71 9 is_stmt 1 view .LVU133
  71:./block/partition.c ****     data =  trans_data_to_blk_dev(device,1,512,block_buffer,REQ_OP_READ);//LBA 1
 455              		.loc 1 71 16 is_stmt 0 view .LVU134
 456 0056 0123     		movs	r3, #1
 457 0058 2370     		strb	r3, [r4]
 458 005a E2E7     		b	.L17
 459              	.LVL35:
 460              	.L22:
  76:./block/partition.c ****         else
 461              		.loc 1 76 13 is_stmt 1 view .LVU135
  76:./block/partition.c ****         else
 462              		.loc 1 76 20 is_stmt 0 view .LVU136
 463 005c 0323     		movs	r3, #3
 464 005e 2370     		strb	r3, [r4]
 465 0060 F2E7     		b	.L18
 466              	.L24:
 467 0062 00BF     		.align	2
 468              	.L23:
 469 0064 00000000 		.word	gpt_head
ARM GAS  /tmp/ccgt6wcN.s 			page 35


 470              		.cfi_endproc
 471              	.LFE1035:
 473              		.section	.rodata.MBR_partition_table_create.str1.4,"aMS",%progbits,1
 474              		.align	2
 475              	.LC0:
 476 0000 63726561 		.ascii	"creating new mbr partition: boot_ind = %d, start_ad"
 476      74696E67 
 476      206E6577 
 476      206D6272 
 476      20706172 
 477 0033 64726573 		.ascii	"dress = %d, size = %d,sys_ind = %d\012\015\000"
 477      73203D20 
 477      25642C20 
 477      73697A65 
 477      203D2025 
 478              		.section	.text.MBR_partition_table_create,"ax",%progbits
 479              		.align	1
 480              		.syntax unified
 481              		.thumb
 482              		.thumb_func
 484              	MBR_partition_table_create:
 485              	.LVL36:
 486              	.LFB1040:
  82:./block/partition.c **** EXPORT_SYMBOL(detect_partition_table);
  83:./block/partition.c **** 
  84:./block/partition.c **** 
  85:./block/partition.c **** 
  86:./block/partition.c **** 
  87:./block/partition.c **** 
  88:./block/partition.c **** #define INVALID_PARTITION 0xFFFFFFFF
  89:./block/partition.c **** 
  90:./block/partition.c **** static void MBR_partition_table_fix_endian(struct mbr_partition *mbr_header) 
  91:./block/partition.c **** {
  92:./block/partition.c ****      #ifndef BIG_ENDIAN
  93:./block/partition.c ****       mbr_header->start_lba  = le32_to_cpu(mbr_header->start_lba);
  94:./block/partition.c ****       mbr_header->nr_sectors = le32_to_cpu(mbr_header->nr_sectors);
  95:./block/partition.c ****      #endif
  96:./block/partition.c **** }
  97:./block/partition.c **** 
  98:./block/partition.c **** 
  99:./block/partition.c **** int check_empty_MBR_Table(struct partition *partition,int number)
 100:./block/partition.c **** {
 101:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 102:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
 103:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 104:./block/partition.c ****             return 0;
 105:./block/partition.c ****     }
 106:./block/partition.c ****     return 1;
 107:./block/partition.c **** }
 108:./block/partition.c **** static void clear_MBR_Table(struct partition *partition,int number)
 109:./block/partition.c **** {
 110:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 111:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
 112:./block/partition.c ****         ((char *)mbr_partition)[i] = 0x00;
 113:./block/partition.c ****     }
 114:./block/partition.c **** }
 115:./block/partition.c **** static struct mbr_partition * get_empty_MBR_Table(struct partition *partition,int *number) //number
ARM GAS  /tmp/ccgt6wcN.s 			page 36


 116:./block/partition.c **** {
 117:./block/partition.c ****     for(int i = 0 ; i <4 ; i++){
 118:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 119:./block/partition.c ****             number[0] = i;
 120:./block/partition.c ****             return &partition->mbr_partition[i];
 121:./block/partition.c ****         }
 122:./block/partition.c ****     }
 123:./block/partition.c ****     return NULL;
 124:./block/partition.c **** }
 125:./block/partition.c **** 
 126:./block/partition.c **** 
 127:./block/partition.c **** static void MBR_partition_table_create(struct mbr_partition * mbr_partition,uint8_t type,uint32_t s
 128:./block/partition.c **** {
 487              		.loc 1 128 1 is_stmt 1 view -0
 488              		.cfi_startproc
 489              		@ args = 4, pretend = 0, frame = 0
 490              		@ frame_needed = 0, uses_anonymous_args = 0
 491              		.loc 1 128 1 is_stmt 0 view .LVU138
 492 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 493              	.LCFI10:
 494              		.cfi_def_cfa_offset 24
 495              		.cfi_offset 4, -24
 496              		.cfi_offset 5, -20
 497              		.cfi_offset 6, -16
 498              		.cfi_offset 7, -12
 499              		.cfi_offset 8, -8
 500              		.cfi_offset 14, -4
 501 0004 82B0     		sub	sp, sp, #8
 502              	.LCFI11:
 503              		.cfi_def_cfa_offset 32
 504 0006 0446     		mov	r4, r0
 505 0008 0F46     		mov	r7, r1
 506 000a 1646     		mov	r6, r2
 507 000c 1D46     		mov	r5, r3
 508 000e 9DF82080 		ldrb	r8, [sp, #32]	@ zero_extendqisi2
 129:./block/partition.c ****     printk("creating new mbr partition: boot_ind = %d, start_address = %d, size = %d,sys_ind = %d\n
 509              		.loc 1 129 5 is_stmt 1 view .LVU139
 510 0012 CDF80080 		str	r8, [sp]
 511 0016 0B48     		ldr	r0, .L27
 512              	.LVL37:
 513              		.loc 1 129 5 is_stmt 0 view .LVU140
 514 0018 FFF7FEFF 		bl	printk
 515              	.LVL38:
 130:./block/partition.c **** 
 131:./block/partition.c ****     mbr_partition->boot_ind     = type; 
 516              		.loc 1 131 5 is_stmt 1 view .LVU141
 517              		.loc 1 131 33 is_stmt 0 view .LVU142
 518 001c 2770     		strb	r7, [r4]
 132:./block/partition.c **** 
 133:./block/partition.c ****     mbr_partition->start_head   = 0x20;     //
 519              		.loc 1 133 5 is_stmt 1 view .LVU143
 520              		.loc 1 133 33 is_stmt 0 view .LVU144
 521 001e 2023     		movs	r3, #32
 522 0020 6370     		strb	r3, [r4, #1]
 134:./block/partition.c ****     mbr_partition->start_sector = 0X21;
 523              		.loc 1 134 5 is_stmt 1 view .LVU145
 524              		.loc 1 134 33 is_stmt 0 view .LVU146
ARM GAS  /tmp/ccgt6wcN.s 			page 37


 525 0022 2123     		movs	r3, #33
 526 0024 A370     		strb	r3, [r4, #2]
 135:./block/partition.c ****     mbr_partition->start_cyl    = 0x00;
 527              		.loc 1 135 5 is_stmt 1 view .LVU147
 528              		.loc 1 135 33 is_stmt 0 view .LVU148
 529 0026 0023     		movs	r3, #0
 530 0028 E370     		strb	r3, [r4, #3]
 136:./block/partition.c ****     mbr_partition->sys_ind = flag;
 531              		.loc 1 136 5 is_stmt 1 view .LVU149
 532              		.loc 1 136 28 is_stmt 0 view .LVU150
 533 002a 84F80480 		strb	r8, [r4, #4]
 137:./block/partition.c ****     mbr_partition->end_head     = 0xfe;
 534              		.loc 1 137 5 is_stmt 1 view .LVU151
 535              		.loc 1 137 33 is_stmt 0 view .LVU152
 536 002e FE23     		movs	r3, #254
 537 0030 6371     		strb	r3, [r4, #5]
 138:./block/partition.c ****     mbr_partition->end_sector   = 0x3f;
 538              		.loc 1 138 5 is_stmt 1 view .LVU153
 539              		.loc 1 138 33 is_stmt 0 view .LVU154
 540 0032 3F23     		movs	r3, #63
 541 0034 A371     		strb	r3, [r4, #6]
 139:./block/partition.c ****     mbr_partition->end_cyl      = 0x01;
 542              		.loc 1 139 5 is_stmt 1 view .LVU155
 543              		.loc 1 139 33 is_stmt 0 view .LVU156
 544 0036 0123     		movs	r3, #1
 545 0038 E371     		strb	r3, [r4, #7]
 140:./block/partition.c ****     mbr_partition->start_lba = start_address;
 546              		.loc 1 140 5 is_stmt 1 view .LVU157
 547              		.loc 1 140 30 is_stmt 0 view .LVU158
 548 003a A660     		str	r6, [r4, #8]	@ unaligned
 141:./block/partition.c ****     mbr_partition->nr_sectors = size;
 549              		.loc 1 141 5 is_stmt 1 view .LVU159
 550              		.loc 1 141 31 is_stmt 0 view .LVU160
 551 003c E560     		str	r5, [r4, #12]	@ unaligned
 142:./block/partition.c **** }
 552              		.loc 1 142 1 view .LVU161
 553 003e 02B0     		add	sp, sp, #8
 554              	.LCFI12:
 555              		.cfi_def_cfa_offset 24
 556              		@ sp needed
 557 0040 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 558              	.LVL39:
 559              	.L28:
 560              		.loc 1 142 1 view .LVU162
 561              		.align	2
 562              	.L27:
 563 0044 00000000 		.word	.LC0
 564              		.cfi_endproc
 565              	.LFE1040:
 567              		.section	.text.move_MBR_Table,"ax",%progbits
 568              		.align	1
 569              		.syntax unified
 570              		.thumb
 571              		.thumb_func
 573              	move_MBR_Table:
 574              	.LVL40:
 575              	.LFB1047:
ARM GAS  /tmp/ccgt6wcN.s 			page 38


 143:./block/partition.c **** 
 144:./block/partition.c **** static uint32_t get_mbr_partition_size(struct partition *partition,int number){
 145:./block/partition.c ****     if(number < 0 || number > 3)
 146:./block/partition.c ****         return INVALID_PARTITION;
 147:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 148:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 149:./block/partition.c ****         return INVALID_PARTITION;
 150:./block/partition.c ****     return mbr_partition->nr_sectors;
 151:./block/partition.c **** }
 152:./block/partition.c **** 
 153:./block/partition.c **** static uint32_t get_mbr_partition_start_address(struct partition *partition,int number){
 154:./block/partition.c ****     if(number < 0 || number > 3)
 155:./block/partition.c ****         return INVALID_PARTITION;
 156:./block/partition.c ****     
 157:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 158:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1){
 159:./block/partition.c ****          printk("This is a empty partition table slot\n\r");
 160:./block/partition.c ****          return INVALID_PARTITION;
 161:./block/partition.c ****     }
 162:./block/partition.c ****     return mbr_partition->start_lba;
 163:./block/partition.c **** }
 164:./block/partition.c **** 
 165:./block/partition.c **** static uint8_t get_mbr_partition_type(struct partition *partition,int number){
 166:./block/partition.c ****     if(number < 0 || number > 3)
 167:./block/partition.c ****         return 0xff;
 168:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 169:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 170:./block/partition.c ****         return 0xff;
 171:./block/partition.c ****     return mbr_partition->sys_ind;
 172:./block/partition.c **** }
 173:./block/partition.c **** 
 174:./block/partition.c **** static int set_mbr_partition_size(struct partition *partition,int number,uint32_t size)
 175:./block/partition.c **** {
 176:./block/partition.c ****     if(number < 0 || number > 3)
 177:./block/partition.c ****         return -1;
 178:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 179:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 180:./block/partition.c ****         return -1;
 181:./block/partition.c ****     mbr_partition->nr_sectors = size;
 182:./block/partition.c ****     return 0;
 183:./block/partition.c **** }
 184:./block/partition.c **** 
 185:./block/partition.c **** static int set_mbr_partition_start_address(struct partition *partition,int number,uint32_t start_ad
 186:./block/partition.c **** {
 187:./block/partition.c ****     if(number < 0 || number > 3)
 188:./block/partition.c ****         return -1;
 189:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 190:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 191:./block/partition.c ****         return -1;
 192:./block/partition.c ****     mbr_partition->start_lba = start_address;
 193:./block/partition.c ****     return 0;
 194:./block/partition.c **** }
 195:./block/partition.c **** 
 196:./block/partition.c **** static int set_mbr_partition_type(struct partition *partition,int number,uint8_t type)
 197:./block/partition.c **** {
 198:./block/partition.c ****     if(number < 0 || number > 3)
 199:./block/partition.c ****         return -1;
ARM GAS  /tmp/ccgt6wcN.s 			page 39


 200:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 201:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 202:./block/partition.c ****         return -1;
 203:./block/partition.c ****     mbr_partition->sys_ind = type;
 204:./block/partition.c ****     return 0;
 205:./block/partition.c **** }
 206:./block/partition.c **** 
 207:./block/partition.c **** static void move_MBR_Table(struct mbr_partition *from ,struct mbr_partition *to)
 208:./block/partition.c **** {
 576              		.loc 1 208 1 is_stmt 1 view -0
 577              		.cfi_startproc
 578              		@ args = 0, pretend = 0, frame = 0
 579              		@ frame_needed = 0, uses_anonymous_args = 0
 580              		.loc 1 208 1 is_stmt 0 view .LVU164
 581 0000 00B5     		push	{lr}
 582              	.LCFI13:
 583              		.cfi_def_cfa_offset 4
 584              		.cfi_offset 14, -4
 209:./block/partition.c ****     memcpy(to, from, sizeof(struct mbr_partition));
 585              		.loc 1 209 5 is_stmt 1 view .LVU165
 586 0002 D0F800E0 		ldr	lr, [r0]	@ unaligned
 587 0006 D0F804C0 		ldr	ip, [r0, #4]	@ unaligned
 588 000a 8268     		ldr	r2, [r0, #8]	@ unaligned
 589 000c C368     		ldr	r3, [r0, #12]	@ unaligned
 590 000e C1F800E0 		str	lr, [r1]	@ unaligned
 591 0012 C1F804C0 		str	ip, [r1, #4]	@ unaligned
 592 0016 8A60     		str	r2, [r1, #8]	@ unaligned
 593 0018 CB60     		str	r3, [r1, #12]	@ unaligned
 210:./block/partition.c ****     memset(from, 0x00, sizeof(struct mbr_partition));
 594              		.loc 1 210 5 view .LVU166
 595 001a 0023     		movs	r3, #0
 596 001c 0360     		str	r3, [r0]	@ unaligned
 597 001e 4360     		str	r3, [r0, #4]	@ unaligned
 598 0020 8360     		str	r3, [r0, #8]	@ unaligned
 599 0022 C360     		str	r3, [r0, #12]	@ unaligned
 211:./block/partition.c **** }
 600              		.loc 1 211 1 is_stmt 0 view .LVU167
 601 0024 5DF804FB 		ldr	pc, [sp], #4
 602              		.cfi_endproc
 603              	.LFE1047:
 605              		.section	.rodata.mbr_partition_table_load.str1.4,"aMS",%progbits,1
 606              		.align	2
 607              	.LC1:
 608 0000 6E6F206D 		.ascii	"no memory,need size %d\012\000"
 608      656D6F72 
 608      792C6E65 
 608      65642073 
 608      697A6520 
 609              		.align	2
 610              	.LC2:
 611 0018 63616E20 		.ascii	"can not get data from disk\012\000"
 611      6E6F7420 
 611      67657420 
 611      64617461 
 611      2066726F 
 612              		.section	.text.mbr_partition_table_load,"ax",%progbits
 613              		.align	1
ARM GAS  /tmp/ccgt6wcN.s 			page 40


 614              		.syntax unified
 615              		.thumb
 616              		.thumb_func
 618              	mbr_partition_table_load:
 619              	.LVL41:
 620              	.LFB1049:
 212:./block/partition.c **** 
 213:./block/partition.c **** static void tidy_up_MBR_Table(struct partition *partition)
 214:./block/partition.c **** {
 215:./block/partition.c ****     uint8_t state[4];
 216:./block/partition.c ****     for(int i = 0; i < 4; i++)
 217:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 218:./block/partition.c **** 
 219:./block/partition.c ****     for(int j = 0; j < 3; j++){
 220:./block/partition.c ****         for(int k = 0; k < 3; k++){
 221:./block/partition.c ****             if(state[k] == 0 && state[k+1] == 1){
 222:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 223:./block/partition.c ****                 state[k]   = 1;
 224:./block/partition.c ****                 state[k+1] = 0;
 225:./block/partition.c ****             }
 226:./block/partition.c ****         }
 227:./block/partition.c ****     }
 228:./block/partition.c **** }
 229:./block/partition.c **** 
 230:./block/partition.c **** static int mbr_partition_table_load(struct block_device *device,struct partition *partition) 
 231:./block/partition.c **** {
 621              		.loc 1 231 1 is_stmt 1 view -0
 622              		.cfi_startproc
 623              		@ args = 0, pretend = 0, frame = 0
 624              		@ frame_needed = 0, uses_anonymous_args = 0
 232:./block/partition.c ****     if (device == NULL || partition == NULL) return -1;
 625              		.loc 1 232 5 view .LVU169
 626              		.loc 1 232 8 is_stmt 0 view .LVU170
 627 0000 0028     		cmp	r0, #0
 628 0002 46D0     		beq	.L38
 231:./block/partition.c ****     if (device == NULL || partition == NULL) return -1;
 629              		.loc 1 231 1 view .LVU171
 630 0004 70B5     		push	{r4, r5, r6, lr}
 631              	.LCFI14:
 632              		.cfi_def_cfa_offset 16
 633              		.cfi_offset 4, -16
 634              		.cfi_offset 5, -12
 635              		.cfi_offset 6, -8
 636              		.cfi_offset 14, -4
 637 0006 82B0     		sub	sp, sp, #8
 638              	.LCFI15:
 639              		.cfi_def_cfa_offset 24
 640 0008 0C46     		mov	r4, r1
 641 000a 0646     		mov	r6, r0
 642              		.loc 1 232 24 discriminator 2 view .LVU172
 643 000c 0029     		cmp	r1, #0
 644 000e 43D0     		beq	.L39
 233:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 645              		.loc 1 233 5 is_stmt 1 view .LVU173
 646              	.LVL42:
 647              	.LBB89:
 648              	.LBI89:
ARM GAS  /tmp/ccgt6wcN.s 			page 41


 379:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 649              		.loc 3 379 21 view .LVU174
 650              	.LBB90:
 651              		.loc 3 380 2 view .LVU175
 652              		.loc 3 380 9 is_stmt 0 view .LVU176
 653 0010 4FF44C61 		mov	r1, #3264
 654              	.LVL43:
 655              		.loc 3 380 9 view .LVU177
 656 0014 4FF40070 		mov	r0, #512
 657              	.LVL44:
 658              		.loc 3 380 9 view .LVU178
 659 0018 FFF7FEFF 		bl	__smalloc__
 660              	.LVL45:
 661              		.loc 3 380 9 view .LVU179
 662              	.LBE90:
 663              	.LBE89:
 234:./block/partition.c ****     if(data == NULL){
 664              		.loc 1 234 5 is_stmt 1 view .LVU180
 665              		.loc 1 234 7 is_stmt 0 view .LVU181
 666 001c 0546     		mov	r5, r0
 667 001e F0B1     		cbz	r0, .L44
 235:./block/partition.c ****         printk(KERN_INFO "no memory,need size %d\n",512);
 236:./block/partition.c ****          return -1;
 237:./block/partition.c ****     }
 238:./block/partition.c ****     if(trans_data_to_blk_dev(device,0,512,data,REQ_OP_READ) == NULL){
 668              		.loc 1 238 5 is_stmt 1 view .LVU182
 669              		.loc 1 238 8 is_stmt 0 view .LVU183
 670 0020 0021     		movs	r1, #0
 671 0022 0091     		str	r1, [sp]
 672 0024 0346     		mov	r3, r0
 673 0026 4FF40072 		mov	r2, #512
 674 002a 3046     		mov	r0, r6
 675              	.LVL46:
 676              		.loc 1 238 8 view .LVU184
 677 002c FFF7FEFF 		bl	trans_data_to_blk_dev
 678              	.LVL47:
 679              		.loc 1 238 7 discriminator 1 view .LVU185
 680 0030 E8B1     		cbz	r0, .L45
 239:./block/partition.c ****         printk(KERN_INFO "can not get data from disk\n");
 240:./block/partition.c ****         kfree(data);
 241:./block/partition.c ****         return -1;
 242:./block/partition.c ****     }
 243:./block/partition.c ****     memcpy(&partition->mbr_partition[0] , data + 446, sizeof(struct mbr_partition)*4); // 
 681              		.loc 1 243 5 is_stmt 1 view .LVU186
 682              		.loc 1 243 48 is_stmt 0 view .LVU187
 683 0032 05F5DF73 		add	r3, r5, #446
 684              		.loc 1 243 5 view .LVU188
 685 0036 04F57971 		add	r1, r4, #996
 686 003a 05F5FF7E 		add	lr, r5, #510
 687              	.LVL48:
 688              	.L35:
 689              		.loc 1 243 5 view .LVU189
 690 003e D3F800C0 		ldr	ip, [r3]	@ unaligned
 691 0042 5C68     		ldr	r4, [r3, #4]	@ unaligned
 692 0044 9868     		ldr	r0, [r3, #8]	@ unaligned
 693 0046 DA68     		ldr	r2, [r3, #12]	@ unaligned
 694 0048 C1F800C0 		str	ip, [r1]	@ unaligned
ARM GAS  /tmp/ccgt6wcN.s 			page 42


 695 004c 4C60     		str	r4, [r1, #4]	@ unaligned
 696 004e 8860     		str	r0, [r1, #8]	@ unaligned
 697 0050 CA60     		str	r2, [r1, #12]	@ unaligned
 698 0052 1033     		adds	r3, r3, #16
 699 0054 1031     		adds	r1, r1, #16
 700 0056 7345     		cmp	r3, lr
 701 0058 F1D1     		bne	.L35
 244:./block/partition.c ****     for(int i =0;i<4;i++){
 702              		.loc 1 244 5 is_stmt 1 view .LVU190
 703              	.LBB91:
 704              		.loc 1 244 9 view .LVU191
 705              	.LVL49:
 706              		.loc 1 244 13 is_stmt 0 view .LVU192
 707 005a 0023     		movs	r3, #0
 708              		.loc 1 244 5 view .LVU193
 709 005c 11E0     		b	.L36
 710              	.LVL50:
 711              	.L44:
 712              		.loc 1 244 5 view .LVU194
 713              	.LBE91:
 235:./block/partition.c ****         printk(KERN_INFO "no memory,need size %d\n",512);
 714              		.loc 1 235 9 is_stmt 1 view .LVU195
 715 005e 4FF40071 		mov	r1, #512
 716 0062 0F48     		ldr	r0, .L46
 717              	.LVL51:
 235:./block/partition.c ****         printk(KERN_INFO "no memory,need size %d\n",512);
 718              		.loc 1 235 9 is_stmt 0 view .LVU196
 719 0064 FFF7FEFF 		bl	printk
 720              	.LVL52:
 236:./block/partition.c ****     }
 721              		.loc 1 236 10 is_stmt 1 view .LVU197
 236:./block/partition.c ****     }
 722              		.loc 1 236 17 is_stmt 0 view .LVU198
 723 0068 4FF0FF30 		mov	r0, #-1
 724 006c 0FE0     		b	.L31
 725              	.L45:
 239:./block/partition.c ****         printk(KERN_INFO "can not get data from disk\n");
 726              		.loc 1 239 9 is_stmt 1 view .LVU199
 727 006e 0D48     		ldr	r0, .L46+4
 728 0070 FFF7FEFF 		bl	printk
 729              	.LVL53:
 240:./block/partition.c ****         return -1;
 730              		.loc 1 240 9 view .LVU200
 731              	.LBB92:
 732              	.LBI92:
 381:./include/linux/slab.h **** }
 382:./include/linux/slab.h **** 
 383:./include/linux/slab.h **** static void inline kfree(const void *ptr){
 733              		.loc 3 383 20 view .LVU201
 734              	.LBB93:
 384:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 735              		.loc 3 384 2 view .LVU202
 736 0074 2846     		mov	r0, r5
 737 0076 FFF7FEFF 		bl	__sfree__
 738              	.LVL54:
 739              		.loc 3 384 2 is_stmt 0 view .LVU203
 740              	.LBE93:
ARM GAS  /tmp/ccgt6wcN.s 			page 43


 741              	.LBE92:
 241:./block/partition.c ****     }
 742              		.loc 1 241 9 is_stmt 1 view .LVU204
 241:./block/partition.c ****     }
 743              		.loc 1 241 16 is_stmt 0 view .LVU205
 744 007a 4FF0FF30 		mov	r0, #-1
 745 007e 06E0     		b	.L31
 746              	.LVL55:
 747              	.L37:
 748              	.LBB94:
 245:./block/partition.c ****         MBR_partition_table_fix_endian(&partition->mbr_partition[i]);
 749              		.loc 1 245 9 is_stmt 1 view .LVU206
 244:./block/partition.c ****         MBR_partition_table_fix_endian(&partition->mbr_partition[i]);
 750              		.loc 1 244 23 discriminator 3 view .LVU207
 751 0080 0133     		adds	r3, r3, #1
 752              	.LVL56:
 753              	.L36:
 244:./block/partition.c ****         MBR_partition_table_fix_endian(&partition->mbr_partition[i]);
 754              		.loc 1 244 19 discriminator 1 view .LVU208
 755 0082 032B     		cmp	r3, #3
 756 0084 FCDD     		ble	.L37
 757              	.LBE94:
 246:./block/partition.c ****     }
 247:./block/partition.c ****     kfree(data);
 758              		.loc 1 247 5 view .LVU209
 759              	.LVL57:
 760              	.LBB95:
 761              	.LBI95:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 762              		.loc 3 383 20 view .LVU210
 763              	.LBB96:
 764              		.loc 3 384 2 view .LVU211
 765 0086 2846     		mov	r0, r5
 766 0088 FFF7FEFF 		bl	__sfree__
 767              	.LVL58:
 768              		.loc 3 384 2 is_stmt 0 view .LVU212
 769              	.LBE96:
 770              	.LBE95:
 248:./block/partition.c ****     return 0;
 771              		.loc 1 248 5 is_stmt 1 view .LVU213
 772              		.loc 1 248 12 is_stmt 0 view .LVU214
 773 008c 0020     		movs	r0, #0
 774              	.LVL59:
 775              	.L31:
 249:./block/partition.c **** }
 776              		.loc 1 249 1 view .LVU215
 777 008e 02B0     		add	sp, sp, #8
 778              	.LCFI16:
 779              		.cfi_def_cfa_offset 16
 780              		@ sp needed
 781 0090 70BD     		pop	{r4, r5, r6, pc}
 782              	.LVL60:
 783              	.L38:
 784              	.LCFI17:
 785              		.cfi_def_cfa_offset 0
 786              		.cfi_restore 4
 787              		.cfi_restore 5
ARM GAS  /tmp/ccgt6wcN.s 			page 44


 788              		.cfi_restore 6
 789              		.cfi_restore 14
 232:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 790              		.loc 1 232 53 discriminator 3 view .LVU216
 791 0092 4FF0FF30 		mov	r0, #-1
 792              	.LVL61:
 793              		.loc 1 249 1 view .LVU217
 794 0096 7047     		bx	lr
 795              	.LVL62:
 796              	.L39:
 797              	.LCFI18:
 798              		.cfi_def_cfa_offset 24
 799              		.cfi_offset 4, -16
 800              		.cfi_offset 5, -12
 801              		.cfi_offset 6, -8
 802              		.cfi_offset 14, -4
 232:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 803              		.loc 1 232 53 discriminator 3 view .LVU218
 804 0098 4FF0FF30 		mov	r0, #-1
 805              	.LVL63:
 232:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 806              		.loc 1 232 53 discriminator 3 view .LVU219
 807 009c F7E7     		b	.L31
 808              	.L47:
 809 009e 00BF     		.align	2
 810              	.L46:
 811 00a0 00000000 		.word	.LC1
 812 00a4 18000000 		.word	.LC2
 813              		.cfi_endproc
 814              	.LFE1049:
 816              		.section	.text.mbr_partition_table_update,"ax",%progbits
 817              		.align	1
 818              		.syntax unified
 819              		.thumb
 820              		.thumb_func
 822              	mbr_partition_table_update:
 823              	.LVL64:
 824              	.LFB1050:
 250:./block/partition.c **** 
 251:./block/partition.c **** static int mbr_partition_table_update(struct block_device *device,struct partition *partition) 
 252:./block/partition.c **** {
 825              		.loc 1 252 1 is_stmt 1 view -0
 826              		.cfi_startproc
 827              		@ args = 0, pretend = 0, frame = 0
 828              		@ frame_needed = 0, uses_anonymous_args = 0
 253:./block/partition.c ****     if(device == NULL || partition == NULL) return -1;
 829              		.loc 1 253 5 view .LVU221
 830              		.loc 1 253 7 is_stmt 0 view .LVU222
 831 0000 0028     		cmp	r0, #0
 832 0002 44D0     		beq	.L54
 252:./block/partition.c ****     if(device == NULL || partition == NULL) return -1;
 833              		.loc 1 252 1 view .LVU223
 834 0004 70B5     		push	{r4, r5, r6, lr}
 835              	.LCFI19:
 836              		.cfi_def_cfa_offset 16
 837              		.cfi_offset 4, -16
 838              		.cfi_offset 5, -12
ARM GAS  /tmp/ccgt6wcN.s 			page 45


 839              		.cfi_offset 6, -8
 840              		.cfi_offset 14, -4
 841 0006 82B0     		sub	sp, sp, #8
 842              	.LCFI20:
 843              		.cfi_def_cfa_offset 24
 844 0008 0C46     		mov	r4, r1
 845 000a 0646     		mov	r6, r0
 846              		.loc 1 253 23 discriminator 2 view .LVU224
 847 000c 0029     		cmp	r1, #0
 848 000e 41D0     		beq	.L55
 254:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 849              		.loc 1 254 5 is_stmt 1 view .LVU225
 850              	.LVL65:
 851              	.LBB97:
 852              	.LBI97:
 379:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 853              		.loc 3 379 21 view .LVU226
 854              	.LBB98:
 380:./include/linux/slab.h **** }
 855              		.loc 3 380 2 view .LVU227
 380:./include/linux/slab.h **** }
 856              		.loc 3 380 9 is_stmt 0 view .LVU228
 857 0010 4FF44C61 		mov	r1, #3264
 858              	.LVL66:
 380:./include/linux/slab.h **** }
 859              		.loc 3 380 9 view .LVU229
 860 0014 4FF40070 		mov	r0, #512
 861              	.LVL67:
 380:./include/linux/slab.h **** }
 862              		.loc 3 380 9 view .LVU230
 863 0018 FFF7FEFF 		bl	__smalloc__
 864              	.LVL68:
 380:./include/linux/slab.h **** }
 865              		.loc 3 380 9 view .LVU231
 866              	.LBE98:
 867              	.LBE97:
 255:./block/partition.c ****     if(data == NULL) return -1;
 868              		.loc 1 255 5 is_stmt 1 view .LVU232
 869              		.loc 1 255 7 is_stmt 0 view .LVU233
 870 001c 0546     		mov	r5, r0
 871 001e E0B3     		cbz	r0, .L56
 872              	.LBB99:
 256:./block/partition.c ****     for(int i =0;i<4;i++){
 873              		.loc 1 256 13 view .LVU234
 874 0020 0023     		movs	r3, #0
 875 0022 00E0     		b	.L50
 876              	.LVL69:
 877              	.L51:
 257:./block/partition.c ****         MBR_partition_table_fix_endian(&partition->mbr_partition[i]);
 878              		.loc 1 257 9 is_stmt 1 view .LVU235
 256:./block/partition.c ****     for(int i =0;i<4;i++){
 879              		.loc 1 256 23 discriminator 3 view .LVU236
 880 0024 0133     		adds	r3, r3, #1
 881              	.LVL70:
 882              	.L50:
 256:./block/partition.c ****     for(int i =0;i<4;i++){
 883              		.loc 1 256 19 discriminator 1 view .LVU237
ARM GAS  /tmp/ccgt6wcN.s 			page 46


 884 0026 032B     		cmp	r3, #3
 885 0028 FCDD     		ble	.L51
 886              	.LBE99:
 258:./block/partition.c ****     }
 259:./block/partition.c ****     memcpy(data + 446, &partition->mbr_partition[0], sizeof(struct mbr_partition)*4);
 887              		.loc 1 259 5 view .LVU238
 888              		.loc 1 259 24 is_stmt 0 view .LVU239
 889 002a 04F57973 		add	r3, r4, #996
 890              	.LVL71:
 891              		.loc 1 259 5 view .LVU240
 892 002e 05F5DF72 		add	r2, r5, #446
 893 0032 04F22444 		addw	r4, r4, #1060
 894              	.LVL72:
 895              	.L52:
 896              		.loc 1 259 5 view .LVU241
 897 0036 D3F800E0 		ldr	lr, [r3]	@ unaligned
 898 003a D3F804C0 		ldr	ip, [r3, #4]	@ unaligned
 899 003e 9868     		ldr	r0, [r3, #8]	@ unaligned
 900 0040 D968     		ldr	r1, [r3, #12]	@ unaligned
 901 0042 C2F800E0 		str	lr, [r2]	@ unaligned
 902 0046 C2F804C0 		str	ip, [r2, #4]	@ unaligned
 903 004a 9060     		str	r0, [r2, #8]	@ unaligned
 904 004c D160     		str	r1, [r2, #12]	@ unaligned
 905 004e 1033     		adds	r3, r3, #16
 906 0050 1032     		adds	r2, r2, #16
 907 0052 A342     		cmp	r3, r4
 908 0054 EFD1     		bne	.L52
 260:./block/partition.c ****     data[0x01FE] = 0x55;
 909              		.loc 1 260 5 is_stmt 1 view .LVU242
 910              		.loc 1 260 18 is_stmt 0 view .LVU243
 911 0056 5523     		movs	r3, #85
 912 0058 85F8FE31 		strb	r3, [r5, #510]
 261:./block/partition.c ****     data[0x01FF] = 0xAA;                                                                //
 913              		.loc 1 261 5 is_stmt 1 view .LVU244
 914              		.loc 1 261 18 is_stmt 0 view .LVU245
 915 005c AA23     		movs	r3, #170
 916 005e 85F8FF31 		strb	r3, [r5, #511]
 262:./block/partition.c ****     if(trans_data_to_blk_dev(device,0,512,data,REQ_OP_WRITE) == NULL){
 917              		.loc 1 262 5 is_stmt 1 view .LVU246
 918              		.loc 1 262 8 is_stmt 0 view .LVU247
 919 0062 0123     		movs	r3, #1
 920 0064 0093     		str	r3, [sp]
 921 0066 2B46     		mov	r3, r5
 922 0068 4FF40072 		mov	r2, #512
 923 006c 0021     		movs	r1, #0
 924 006e 3046     		mov	r0, r6
 925 0070 FFF7FEFF 		bl	trans_data_to_blk_dev
 926              	.LVL73:
 927              		.loc 1 262 7 discriminator 1 view .LVU248
 928 0074 28B9     		cbnz	r0, .L53
 263:./block/partition.c ****         kfree(data);
 929              		.loc 1 263 9 is_stmt 1 view .LVU249
 930              	.LVL74:
 931              	.LBB100:
 932              	.LBI100:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 933              		.loc 3 383 20 view .LVU250
ARM GAS  /tmp/ccgt6wcN.s 			page 47


 934              	.LBB101:
 935              		.loc 3 384 2 view .LVU251
 936 0076 2846     		mov	r0, r5
 937 0078 FFF7FEFF 		bl	__sfree__
 938              	.LVL75:
 939              		.loc 3 384 2 is_stmt 0 view .LVU252
 940              	.LBE101:
 941              	.LBE100:
 264:./block/partition.c ****          return 0;
 942              		.loc 1 264 10 is_stmt 1 view .LVU253
 943              		.loc 1 264 17 is_stmt 0 view .LVU254
 944 007c 0020     		movs	r0, #0
 945              	.LVL76:
 946              	.L48:
 265:./block/partition.c ****     }
 266:./block/partition.c ****     else{
 267:./block/partition.c ****         kfree(data);
 268:./block/partition.c ****         return -1;        
 269:./block/partition.c ****     }
 270:./block/partition.c **** }
 947              		.loc 1 270 1 view .LVU255
 948 007e 02B0     		add	sp, sp, #8
 949              	.LCFI21:
 950              		.cfi_remember_state
 951              		.cfi_def_cfa_offset 16
 952              		@ sp needed
 953 0080 70BD     		pop	{r4, r5, r6, pc}
 954              	.LVL77:
 955              	.L53:
 956              	.LCFI22:
 957              		.cfi_restore_state
 267:./block/partition.c ****         return -1;        
 958              		.loc 1 267 9 is_stmt 1 view .LVU256
 959              	.LBB102:
 960              	.LBI102:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 961              		.loc 3 383 20 view .LVU257
 962              	.LBB103:
 963              		.loc 3 384 2 view .LVU258
 964 0082 2846     		mov	r0, r5
 965 0084 FFF7FEFF 		bl	__sfree__
 966              	.LVL78:
 967              		.loc 3 384 2 is_stmt 0 view .LVU259
 968              	.LBE103:
 969              	.LBE102:
 268:./block/partition.c ****     }
 970              		.loc 1 268 9 is_stmt 1 view .LVU260
 268:./block/partition.c ****     }
 971              		.loc 1 268 16 is_stmt 0 view .LVU261
 972 0088 4FF0FF30 		mov	r0, #-1
 973 008c F7E7     		b	.L48
 974              	.LVL79:
 975              	.L54:
 976              	.LCFI23:
 977              		.cfi_def_cfa_offset 0
 978              		.cfi_restore 4
 979              		.cfi_restore 5
ARM GAS  /tmp/ccgt6wcN.s 			page 48


 980              		.cfi_restore 6
 981              		.cfi_restore 14
 253:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 982              		.loc 1 253 52 discriminator 3 view .LVU262
 983 008e 4FF0FF30 		mov	r0, #-1
 984              	.LVL80:
 985              		.loc 1 270 1 view .LVU263
 986 0092 7047     		bx	lr
 987              	.LVL81:
 988              	.L55:
 989              	.LCFI24:
 990              		.cfi_def_cfa_offset 24
 991              		.cfi_offset 4, -16
 992              		.cfi_offset 5, -12
 993              		.cfi_offset 6, -8
 994              		.cfi_offset 14, -4
 253:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 995              		.loc 1 253 52 discriminator 3 view .LVU264
 996 0094 4FF0FF30 		mov	r0, #-1
 997              	.LVL82:
 253:./block/partition.c ****     char *data = kmalloc(512,GFP_KERNEL);
 998              		.loc 1 253 52 discriminator 3 view .LVU265
 999 0098 F1E7     		b	.L48
 1000              	.LVL83:
 1001              	.L56:
 255:./block/partition.c ****     for(int i =0;i<4;i++){
 1002              		.loc 1 255 29 discriminator 1 view .LVU266
 1003 009a 4FF0FF30 		mov	r0, #-1
 1004              	.LVL84:
 255:./block/partition.c ****     for(int i =0;i<4;i++){
 1005              		.loc 1 255 29 discriminator 1 view .LVU267
 1006 009e EEE7     		b	.L48
 1007              		.cfi_endproc
 1008              	.LFE1050:
 1010              		.section	.text.get_partition_from_device,"ax",%progbits
 1011              		.align	1
 1012              		.global	get_partition_from_device
 1013              		.syntax unified
 1014              		.thumb
 1015              		.thumb_func
 1017              	get_partition_from_device:
 1018              	.LVL85:
 1019              	.LFB1054:
 271:./block/partition.c **** 
 272:./block/partition.c **** /**
 273:./block/partition.c ****  * mbr_table_delete -  MBR 
 274:./block/partition.c ****  * @device: 
 275:./block/partition.c ****  * @partition: 
 276:./block/partition.c ****  * @number: 0-3
 277:./block/partition.c ****  * @flags:  MBR  PROTECTIVE_MBR
 278:./block/partition.c ****  *
 279:./block/partition.c ****  *  MBR  MBR
 280:./block/partition.c ****  * 
 281:./block/partition.c ****  *
 282:./block/partition.c ****  * 
 283:./block/partition.c ****  * - 0 -1 
 284:./block/partition.c ****  *
ARM GAS  /tmp/ccgt6wcN.s 			page 49


 285:./block/partition.c ****  * 
 286:./block/partition.c ****  * mbr_table_delete -  MBR 
 287:./block/partition.c ****  * @device: 
 288:./block/partition.c ****  * @partition: 
 289:./block/partition.c ****  * @number: 0  3
 290:./block/partition.c ****  * @flags:  MBR  PROTECTIVE_MBR
 291:./block/partition.c ****  *
 292:./block/partition.c ****  *  MBR  MBR 
 293:./block/partition.c ****  * 
 294:./block/partition.c ****  *
 295:./block/partition.c ****  * 
 296:./block/partition.c ****  * -  0 -1
 297:./block/partition.c ****  */
 298:./block/partition.c **** static int mbr_table_delete(struct block_device *device,struct partition *partition,int number,enum
 299:./block/partition.c **** {
 300:./block/partition.c ****     if(device == NULL || partition == NULL) {
 301:./block/partition.c ****         printk("This device has not init\n\r");
 302:./block/partition.c ****         return -1;
 303:./block/partition.c ****     }
 304:./block/partition.c ****     if(flags != BLOCK_DEVICE_FLAG_MBR && flags!= BLOCK_DEVICE_FLAG_PROTECTIVE_MBR){
 305:./block/partition.c ****         printk("It's not a mbr device\n\r");
 306:./block/partition.c ****         return -1;
 307:./block/partition.c ****     }
 308:./block/partition.c ****     if(number < 0 || number > 3){
 309:./block/partition.c ****         printk("partition number is out of range\n\r");
 310:./block/partition.c ****         return -1;
 311:./block/partition.c ****     }
 312:./block/partition.c ****     if(mbr_partition_table_load(device,partition) < 0) return -1;           //mbr
 313:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 314:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1){
 315:./block/partition.c ****         printk("This is a empty partition table slot\n\r");
 316:./block/partition.c ****         return -1;
 317:./block/partition.c ****     }
 318:./block/partition.c ****     else
 319:./block/partition.c ****         memset(mbr_partition, 0x00, sizeof(struct mbr_partition));
 320:./block/partition.c ****     tidy_up_MBR_Table(partition);
 321:./block/partition.c ****     mbr_partition_table_update(device,partition);
 322:./block/partition.c ****     return 0;
 323:./block/partition.c **** }
 324:./block/partition.c **** EXPORT_SYMBOL(mbr_table_delete);
 325:./block/partition.c **** 
 326:./block/partition.c **** 
 327:./block/partition.c **** /**
 328:./block/partition.c ****  * mbr_partition_table_format - Format the partition table on the block device using MBR scheme
 329:./block/partition.c ****  * @device: pointer to the block device
 330:./block/partition.c ****  * @partition: pointer to the partition data structure
 331:./block/partition.c ****  * @size: the size of the partition to create (in sectors)
 332:./block/partition.c ****  * @type: the type of the partition (e.g., primary, logical, etc.)
 333:./block/partition.c ****  *
 334:./block/partition.c ****  * This function attempts to format a partition table on a block device using the MBR (Master Boot 
 335:./block/partition.c ****  * partitioning scheme. It first loads the existing MBR partition table, determines the available s
 336:./block/partition.c ****  * the new partition, and then creates a new partition entry in the MBR partition table. The partit
 337:./block/partition.c ****  * and end addresses are calculated, and the partition is aligned to 4K boundaries.
 338:./block/partition.c ****  * 
 339:./block/partition.c ****  * The partition size is adjusted to fit within the available space on the disk. If the size provid
 340:./block/partition.c ****  * large, it will be reduced to fit. The partition table is then updated and written back to the de
 341:./block/partition.c ****  *
ARM GAS  /tmp/ccgt6wcN.s 			page 50


 342:./block/partition.c ****  * 
 343:./block/partition.c ****  * mbr_partition_table_format -  MBR 
 344:./block/partition.c ****  * @device: 
 345:./block/partition.c ****  * @partition: 
 346:./block/partition.c ****  * @size: 
 347:./block/partition.c ****  * @type: 
 348:./block/partition.c ****  *
 349:./block/partition.c ****  *  MBR
 350:./block/partition.c ****  *  MBR 
 351:./block/partition.c ****  *  4K 
 352:./block/partition.c ****  * 
 353:./block/partition.c ****  * 
 354:./block/partition.c ****  */
 355:./block/partition.c **** static int mbr_partition_table_format(struct block_device *device,struct partition *partition,uint3
 356:./block/partition.c **** {
 357:./block/partition.c ****     if(device == NULL || partition == NULL) {
 358:./block/partition.c ****         printk(KERN_INFO "This device has not init\n");
 359:./block/partition.c ****         return -1;
 360:./block/partition.c ****     }
 361:./block/partition.c ****     if(mbr_partition_table_load(device,partition) < 0) 
 362:./block/partition.c ****     {
 363:./block/partition.c ****         printk(KERN_INFO "can not load mbr partition\n");
 364:./block/partition.c ****         return -1;           //mbr
 365:./block/partition.c ****     }
 366:./block/partition.c ****     size = size /8 *8;  
 367:./block/partition.c ****     if(size < 0) return -1;
 368:./block/partition.c ****     
 369:./block/partition.c ****     int partition_number = 0;
 370:./block/partition.c ****     struct mbr_partition *mbr_partition = get_empty_MBR_Table(partition,&partition_number);   //
 371:./block/partition.c ****     if(mbr_partition == NULL){
 372:./block/partition.c ****         printk(KERN_INFO "this storage device can not builded more partition table any more\n");
 373:./block/partition.c ****         return -1;
 374:./block/partition.c ****     }
 375:./block/partition.c ****     //
 376:./block/partition.c ****     uint32_t start_address;
 377:./block/partition.c ****     if(partition_number - 1 >= 0){     
 378:./block/partition.c ****         start_address = get_mbr_partition_start_address(partition,partition_number - 1);
 379:./block/partition.c ****         printk(KERN_INFO "GET last table start address = %d last_size\n",start_address);
 380:./block/partition.c ****     }
 381:./block/partition.c ****     else{
 382:./block/partition.c ****         printk(KERN_INFO "no last table\n");
 383:./block/partition.c ****         start_address = INVALID_PARTITION;
 384:./block/partition.c ****     }
 385:./block/partition.c ****     if (start_address == INVALID_PARTITION){
 386:./block/partition.c ****         printk(KERN_INFO "it's the first partition\n");
 387:./block/partition.c ****         if(device->bd_nr_sectors  < 2048){
 388:./block/partition.c ****            printk(KERN_INFO "this disk size is too small");
 389:./block/partition.c ****             return -1;
 390:./block/partition.c ****         }
 391:./block/partition.c ****         else {
 392:./block/partition.c ****             start_address = 2048  ;                                                             //
 393:./block/partition.c ****             printk(KERN_INFO "dected stand storage device,use 2048 as start address\n");
 394:./block/partition.c ****         }
 395:./block/partition.c ****     }
 396:./block/partition.c ****     else {
 397:./block/partition.c ****         uint32_t last_size = get_mbr_partition_size(partition,partition_number - 1);               
 398:./block/partition.c ****         start_address += last_size;               
ARM GAS  /tmp/ccgt6wcN.s 			page 51


 399:./block/partition.c ****         printk(KERN_INFO "GET last table size = %d block\n",last_size);
 400:./block/partition.c ****     }
 401:./block/partition.c **** 
 402:./block/partition.c ****     if(start_address%8 > 0) //4k
 403:./block/partition.c ****     start_address = start_address - (start_address%8) + 8;
 404:./block/partition.c ****     //
 405:./block/partition.c ****     uint32_t end_address;
 406:./block/partition.c ****     if(partition_number + 1 < 4)
 407:./block/partition.c ****         end_address = get_mbr_partition_start_address(device,partition_number + 1);        //
 408:./block/partition.c ****     else 
 409:./block/partition.c ****         end_address = INVALID_PARTITION;
 410:./block/partition.c ****     if(end_address == INVALID_PARTITION){
 411:./block/partition.c ****         end_address =device->bd_nr_sectors - 33 -1;                                          //
 412:./block/partition.c ****     }
 413:./block/partition.c ****     if(end_address < start_address){
 414:./block/partition.c ****         printk(KERN_INFO "not support this storage device,storage siz is too small\n");
 415:./block/partition.c ****         return -1;
 416:./block/partition.c ****     }
 417:./block/partition.c ****     if (end_address <= start_address + size) {                                                 
 418:./block/partition.c ****         printk(KERN_INFO "Partition size %d is too large, adjusting to fit available space.\n", siz
 419:./block/partition.c ****         size = end_address - start_address;
 420:./block/partition.c ****         printk(KERN_INFO "New partition size: %d\n", size);
 421:./block/partition.c ****     }
 422:./block/partition.c ****     if(size <= 0 ){
 423:./block/partition.c ****         printk(KERN_INFO "this size: %d of block  is not work\n",size);
 424:./block/partition.c ****         return -1;
 425:./block/partition.c ****     }
 426:./block/partition.c ****     MBR_partition_table_create(mbr_partition, 0x00, start_address, size, type);              //
 427:./block/partition.c ****     tidy_up_MBR_Table(partition);                                                               //
 428:./block/partition.c ****     mbr_partition_table_update(device,partition);                                                  
 429:./block/partition.c ****     return 0;
 430:./block/partition.c **** }
 431:./block/partition.c **** EXPORT_SYMBOL(mbr_partition_table_format);
 432:./block/partition.c **** 
 433:./block/partition.c **** 
 434:./block/partition.c **** /**
 435:./block/partition.c ****  * show_mbr_partition_table_info - Display information about a given MBR partition
 436:./block/partition.c ****  * @mbr_partition: pointer to the MBR partition structure
 437:./block/partition.c ****  *
 438:./block/partition.c ****  * This function prints information about an MBR (Master Boot Record) partition. It displays whethe
 439:./block/partition.c ****  * is bootable, its starting address, size in sectors, size in kilobytes and megabytes, as well as 
 440:./block/partition.c ****  * partition based on its system identifier.
 441:./block/partition.c ****  * 
 442:./block/partition.c ****  * If the partition is bootable (boot_ind == 0x80), it will print "bootable". If it is not, it will
 443:./block/partition.c ****  * The partition's type is determined by the system identifier (sys_ind), with common values being:
 444:./block/partition.c ****  * - 0x0B: FAT type partition
 445:./block/partition.c ****  * - 0x83: EXT type partition
 446:./block/partition.c ****  * - 0x07: NTFS type partition
 447:./block/partition.c ****  * If the partition's system identifier does not match these values, it will be labeled as "unknown
 448:./block/partition.c ****  *
 449:./block/partition.c ****  * 
 450:./block/partition.c ****  * show_mbr_partition_table_info -  MBR 
 451:./block/partition.c ****  * @mbr_partition:  MBR 
 452:./block/partition.c ****  *
 453:./block/partition.c ****  *  MBR
 454:./block/partition.c ****  * 
 455:./block/partition.c ****  * 
ARM GAS  /tmp/ccgt6wcN.s 			page 52


 456:./block/partition.c ****  * boot_ind == 0x80bootable
 457:./block/partition.c ****  * sys_ind
 458:./block/partition.c ****  * - 0x0BFAT 
 459:./block/partition.c ****  * - 0x83EXT 
 460:./block/partition.c ****  * - 0x07NTFS 
 461:./block/partition.c ****  * unknown
 462:./block/partition.c ****  */
 463:./block/partition.c **** static void  show_mbr_partition_table_info(struct mbr_partition *mbr_partition)
 464:./block/partition.c **** {
 465:./block/partition.c ****     if(mbr_partition == NULL) return;
 466:./block/partition.c **** 
 467:./block/partition.c ****     if(mbr_partition->boot_ind == 0x80)
 468:./block/partition.c ****         printk(KERN_INFO"bootable\n\r");
 469:./block/partition.c ****     else
 470:./block/partition.c ****         printk(KERN_INFO"not bootable\n\r");
 471:./block/partition.c ****     printk(KERN_INFO"start_address = %d\n\r",mbr_partition->start_lba);
 472:./block/partition.c ****     printk(KERN_INFO"size          = %d(%dKB)(%dMB)\n\r",mbr_partition->nr_sectors,mbr_partition->n
 473:./block/partition.c ****     
 474:./block/partition.c ****     if(mbr_partition->sys_ind == 0x0B)
 475:./block/partition.c ****     printk(KERN_INFO"type          = FAT\n\r");
 476:./block/partition.c ****     else if(mbr_partition->sys_ind == 0x83)
 477:./block/partition.c ****     printk(KERN_INFO"type          = EXT\n\r");
 478:./block/partition.c ****     else if(mbr_partition->sys_ind == 0x07)
 479:./block/partition.c ****     printk(KERN_INFO"type          = NTFS\n\r");
 480:./block/partition.c ****     else
 481:./block/partition.c ****     printk(KERN_INFO"type          = unknown\n\r");
 482:./block/partition.c **** }
 483:./block/partition.c **** 
 484:./block/partition.c **** 
 485:./block/partition.c **** 
 486:./block/partition.c **** /**
 487:./block/partition.c ****  * get_partition_from_device - Retrieve the partition information from a block device
 488:./block/partition.c ****  * @bdev: pointer to the block device structure
 489:./block/partition.c ****  *
 490:./block/partition.c ****  * This function attempts to load the partition table of the specified block device 
 491:./block/partition.c ****  * and returns a pointer to the partition structure. If the block device is invalid 
 492:./block/partition.c ****  * or if the partition table cannot be loaded, the function will return an error code.
 493:./block/partition.c ****  *
 494:./block/partition.c ****  * Steps:
 495:./block/partition.c ****  * 1. Allocates memory for a partition structure.
 496:./block/partition.c ****  * 2. Loads the MBR (Master Boot Record) partition table for the specified block device.
 497:./block/partition.c ****  * 3. Returns a pointer to the partition structure if successful, otherwise returns an error code.
 498:./block/partition.c ****  *
 499:./block/partition.c ****  * 
 500:./block/partition.c ****  * get_partition_from_device - 
 501:./block/partition.c ****  * @bdev: 
 502:./block/partition.c ****  *
 503:./block/partition.c ****  * 
 504:./block/partition.c ****  * 
 505:./block/partition.c ****  *
 506:./block/partition.c ****  * 
 507:./block/partition.c ****  * 1. 
 508:./block/partition.c ****  * 2.  MBR
 509:./block/partition.c ****  * 3. 
 510:./block/partition.c ****  */
 511:./block/partition.c **** struct partition* get_partition_from_device(struct block_device *bdev){
 1020              		.loc 1 511 71 is_stmt 1 view -0
ARM GAS  /tmp/ccgt6wcN.s 			page 53


 1021              		.cfi_startproc
 1022              		@ args = 0, pretend = 0, frame = 0
 1023              		@ frame_needed = 0, uses_anonymous_args = 0
 1024              		.loc 1 511 71 is_stmt 0 view .LVU269
 1025 0000 38B5     		push	{r3, r4, r5, lr}
 1026              	.LCFI25:
 1027              		.cfi_def_cfa_offset 16
 1028              		.cfi_offset 3, -16
 1029              		.cfi_offset 4, -12
 1030              		.cfi_offset 5, -8
 1031              		.cfi_offset 14, -4
 512:./block/partition.c ****     if(bdev == NULL) return NULL;
 1032              		.loc 1 512 5 is_stmt 1 view .LVU270
 1033              		.loc 1 512 7 is_stmt 0 view .LVU271
 1034 0002 0546     		mov	r5, r0
 1035 0004 A8B1     		cbz	r0, .L63
 513:./block/partition.c ****     struct partition *device_partition = kmalloc(sizeof(struct partition),GFP_KERNEL);
 1036              		.loc 1 513 5 is_stmt 1 view .LVU272
 1037              	.LVL86:
 1038              	.LBB104:
 1039              	.LBI104:
 379:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 1040              		.loc 3 379 21 view .LVU273
 1041              	.LBB105:
 380:./include/linux/slab.h **** }
 1042              		.loc 3 380 2 view .LVU274
 380:./include/linux/slab.h **** }
 1043              		.loc 3 380 9 is_stmt 0 view .LVU275
 1044 0006 4FF44C61 		mov	r1, #3264
 1045 000a 40F22440 		movw	r0, #1060
 1046              	.LVL87:
 380:./include/linux/slab.h **** }
 1047              		.loc 3 380 9 view .LVU276
 1048 000e FFF7FEFF 		bl	__smalloc__
 1049              	.LVL88:
 380:./include/linux/slab.h **** }
 1050              		.loc 3 380 9 view .LVU277
 1051              	.LBE105:
 1052              	.LBE104:
 514:./block/partition.c ****     if(device_partition == NULL) return -ENOMEM;
 1053              		.loc 1 514 5 is_stmt 1 view .LVU278
 1054              		.loc 1 514 7 is_stmt 0 view .LVU279
 1055 0012 0446     		mov	r4, r0
 1056 0014 78B1     		cbz	r0, .L64
 515:./block/partition.c ****     if(mbr_partition_table_load(bdev,device_partition) < 0){
 1057              		.loc 1 515 5 is_stmt 1 view .LVU280
 1058              		.loc 1 515 8 is_stmt 0 view .LVU281
 1059 0016 0146     		mov	r1, r0
 1060 0018 2846     		mov	r0, r5
 1061              	.LVL89:
 1062              		.loc 1 515 8 view .LVU282
 1063 001a FFF7FEFF 		bl	mbr_partition_table_load
 1064              	.LVL90:
 1065              		.loc 1 515 7 discriminator 1 view .LVU283
 1066 001e 0028     		cmp	r0, #0
 1067 0020 01DB     		blt	.L66
 1068              	.LVL91:
ARM GAS  /tmp/ccgt6wcN.s 			page 54


 1069              	.L61:
 516:./block/partition.c ****         kfree(device_partition);
 517:./block/partition.c ****         return -EIO;
 518:./block/partition.c ****     }
 519:./block/partition.c ****     return device_partition;
 520:./block/partition.c **** }
 1070              		.loc 1 520 1 view .LVU284
 1071 0022 2046     		mov	r0, r4
 1072 0024 38BD     		pop	{r3, r4, r5, pc}
 1073              	.LVL92:
 1074              	.L66:
 516:./block/partition.c ****         kfree(device_partition);
 1075              		.loc 1 516 9 is_stmt 1 view .LVU285
 1076              	.LBB106:
 1077              	.LBI106:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 1078              		.loc 3 383 20 view .LVU286
 1079              	.LBB107:
 1080              		.loc 3 384 2 view .LVU287
 1081 0026 2046     		mov	r0, r4
 1082 0028 FFF7FEFF 		bl	__sfree__
 1083              	.LVL93:
 1084              		.loc 3 384 2 is_stmt 0 view .LVU288
 1085              	.LBE107:
 1086              	.LBE106:
 517:./block/partition.c ****     }
 1087              		.loc 1 517 9 is_stmt 1 view .LVU289
 517:./block/partition.c ****     }
 1088              		.loc 1 517 16 is_stmt 0 view .LVU290
 1089 002c 6FF00404 		mvn	r4, #4
 1090              	.LVL94:
 517:./block/partition.c ****     }
 1091              		.loc 1 517 16 view .LVU291
 1092 0030 F7E7     		b	.L61
 1093              	.LVL95:
 1094              	.L63:
 512:./block/partition.c ****     struct partition *device_partition = kmalloc(sizeof(struct partition),GFP_KERNEL);
 1095              		.loc 1 512 29 discriminator 1 view .LVU292
 1096 0032 0446     		mov	r4, r0
 1097 0034 F5E7     		b	.L61
 1098              	.LVL96:
 1099              	.L64:
 514:./block/partition.c ****     if(mbr_partition_table_load(bdev,device_partition) < 0){
 1100              		.loc 1 514 41 discriminator 1 view .LVU293
 1101 0036 6FF00B04 		mvn	r4, #11
 1102 003a F2E7     		b	.L61
 1103              		.cfi_endproc
 1104              	.LFE1054:
 1106              		.section	.text.check_empty_MBR_Table,"ax",%progbits
 1107              		.align	1
 1108              		.global	check_empty_MBR_Table
 1109              		.syntax unified
 1110              		.thumb
 1111              		.thumb_func
 1113              	check_empty_MBR_Table:
 1114              	.LVL97:
 1115              	.LFB1037:
ARM GAS  /tmp/ccgt6wcN.s 			page 55


 100:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1116              		.loc 1 100 1 is_stmt 1 view -0
 1117              		.cfi_startproc
 1118              		@ args = 0, pretend = 0, frame = 0
 1119              		@ frame_needed = 0, uses_anonymous_args = 0
 1120              		@ link register save eliminated.
 101:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
 1121              		.loc 1 101 5 view .LVU295
 101:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
 1122              		.loc 1 101 27 is_stmt 0 view .LVU296
 1123 0000 3E31     		adds	r1, r1, #62
 1124              	.LVL98:
 101:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
 1125              		.loc 1 101 27 view .LVU297
 1126 0002 00EB0110 		add	r0, r0, r1, lsl #4
 1127              	.LVL99:
 101:./block/partition.c ****     for(int i =0 ;i < sizeof(struct mbr_partition);i++){
 1128              		.loc 1 101 27 view .LVU298
 1129 0006 0430     		adds	r0, r0, #4
 1130              	.LVL100:
 102:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1131              		.loc 1 102 5 is_stmt 1 view .LVU299
 1132              	.LBB108:
 102:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1133              		.loc 1 102 9 view .LVU300
 102:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1134              		.loc 1 102 13 is_stmt 0 view .LVU301
 1135 0008 0023     		movs	r3, #0
 1136              	.LVL101:
 1137              	.L68:
 102:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1138              		.loc 1 102 21 is_stmt 1 discriminator 1 view .LVU302
 1139 000a 0F2B     		cmp	r3, #15
 1140 000c 03D8     		bhi	.L72
 103:./block/partition.c ****             return 0;
 1141              		.loc 1 103 9 view .LVU303
 103:./block/partition.c ****             return 0;
 1142              		.loc 1 103 35 is_stmt 0 view .LVU304
 1143 000e C25C     		ldrb	r2, [r0, r3]	@ zero_extendqisi2
 103:./block/partition.c ****             return 0;
 1144              		.loc 1 103 11 view .LVU305
 1145 0010 1AB9     		cbnz	r2, .L71
 102:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1146              		.loc 1 102 53 is_stmt 1 discriminator 2 view .LVU306
 1147 0012 0133     		adds	r3, r3, #1
 1148              	.LVL102:
 102:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1149              		.loc 1 102 53 is_stmt 0 discriminator 2 view .LVU307
 1150 0014 F9E7     		b	.L68
 1151              	.L72:
 102:./block/partition.c ****         if(((char *)mbr_partition)[i] != 0)
 1152              		.loc 1 102 53 discriminator 2 view .LVU308
 1153              	.LBE108:
 106:./block/partition.c **** }
 1154              		.loc 1 106 12 view .LVU309
 1155 0016 0120     		movs	r0, #1
 1156              	.LVL103:
ARM GAS  /tmp/ccgt6wcN.s 			page 56


 1157              	.LBB109:
 106:./block/partition.c **** }
 1158              		.loc 1 106 12 view .LVU310
 1159 0018 7047     		bx	lr
 1160              	.LVL104:
 1161              	.L71:
 104:./block/partition.c ****     }
 1162              		.loc 1 104 20 view .LVU311
 1163 001a 0020     		movs	r0, #0
 1164              	.LVL105:
 104:./block/partition.c ****     }
 1165              		.loc 1 104 20 view .LVU312
 1166              	.LBE109:
 107:./block/partition.c **** static void clear_MBR_Table(struct partition *partition,int number)
 1167              		.loc 1 107 1 view .LVU313
 1168 001c 7047     		bx	lr
 1169              		.cfi_endproc
 1170              	.LFE1037:
 1172              		.section	.text.tidy_up_MBR_Table,"ax",%progbits
 1173              		.align	1
 1174              		.syntax unified
 1175              		.thumb
 1176              		.thumb_func
 1178              	tidy_up_MBR_Table:
 1179              	.LVL106:
 1180              	.LFB1048:
 214:./block/partition.c ****     uint8_t state[4];
 1181              		.loc 1 214 1 is_stmt 1 view -0
 1182              		.cfi_startproc
 1183              		@ args = 0, pretend = 0, frame = 8
 1184              		@ frame_needed = 0, uses_anonymous_args = 0
 214:./block/partition.c ****     uint8_t state[4];
 1185              		.loc 1 214 1 is_stmt 0 view .LVU315
 1186 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1187              	.LCFI26:
 1188              		.cfi_def_cfa_offset 20
 1189              		.cfi_offset 4, -20
 1190              		.cfi_offset 5, -16
 1191              		.cfi_offset 6, -12
 1192              		.cfi_offset 7, -8
 1193              		.cfi_offset 14, -4
 1194 0002 83B0     		sub	sp, sp, #12
 1195              	.LCFI27:
 1196              		.cfi_def_cfa_offset 32
 1197 0004 0646     		mov	r6, r0
 215:./block/partition.c ****     for(int i = 0; i < 4; i++)
 1198              		.loc 1 215 5 is_stmt 1 view .LVU316
 216:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1199              		.loc 1 216 5 view .LVU317
 1200              	.LBB110:
 216:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1201              		.loc 1 216 9 view .LVU318
 1202              	.LVL107:
 216:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1203              		.loc 1 216 13 is_stmt 0 view .LVU319
 1204 0006 0024     		movs	r4, #0
 216:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
ARM GAS  /tmp/ccgt6wcN.s 			page 57


 1205              		.loc 1 216 5 view .LVU320
 1206 0008 0BE0     		b	.L74
 1207              	.LVL108:
 1208              	.L75:
 217:./block/partition.c **** 
 1209              		.loc 1 217 9 is_stmt 1 view .LVU321
 217:./block/partition.c **** 
 1210              		.loc 1 217 24 is_stmt 0 view .LVU322
 1211 000a 2146     		mov	r1, r4
 1212 000c 3046     		mov	r0, r6
 1213 000e FFF7FEFF 		bl	check_empty_MBR_Table
 1214              	.LVL109:
 217:./block/partition.c **** 
 1215              		.loc 1 217 22 discriminator 1 view .LVU323
 1216 0012 C0F10103 		rsb	r3, r0, #1
 217:./block/partition.c **** 
 1217              		.loc 1 217 18 discriminator 1 view .LVU324
 1218 0016 04F10802 		add	r2, r4, #8
 1219 001a 6A44     		add	r2, sp, r2
 1220 001c 02F8043C 		strb	r3, [r2, #-4]
 216:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1221              		.loc 1 216 28 is_stmt 1 discriminator 3 view .LVU325
 1222 0020 0134     		adds	r4, r4, #1
 1223              	.LVL110:
 1224              	.L74:
 216:./block/partition.c ****         state[i] = 1 - check_empty_MBR_Table(partition,i);
 1225              		.loc 1 216 22 discriminator 1 view .LVU326
 1226 0022 032C     		cmp	r4, #3
 1227 0024 F1DD     		ble	.L75
 1228              	.LBE110:
 1229              	.LBB111:
 219:./block/partition.c ****         for(int k = 0; k < 3; k++){
 1230              		.loc 1 219 13 is_stmt 0 view .LVU327
 1231 0026 0027     		movs	r7, #0
 1232 0028 2BE0     		b	.L76
 1233              	.LVL111:
 1234              	.L77:
 1235              	.LBB112:
 220:./block/partition.c ****             if(state[k] == 0 && state[k+1] == 1){
 1236              		.loc 1 220 32 is_stmt 1 discriminator 2 view .LVU328
 1237 002a 0134     		adds	r4, r4, #1
 1238              	.LVL112:
 1239              	.L79:
 220:./block/partition.c ****             if(state[k] == 0 && state[k+1] == 1){
 1240              		.loc 1 220 26 discriminator 1 view .LVU329
 1241 002c 022C     		cmp	r4, #2
 1242 002e 27DC     		bgt	.L82
 221:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1243              		.loc 1 221 13 view .LVU330
 221:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1244              		.loc 1 221 21 is_stmt 0 view .LVU331
 1245 0030 04F10803 		add	r3, r4, #8
 1246 0034 6B44     		add	r3, sp, r3
 1247 0036 13F8043C 		ldrb	r3, [r3, #-4]	@ zero_extendqisi2
 221:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1248              		.loc 1 221 15 view .LVU332
 1249 003a 002B     		cmp	r3, #0
ARM GAS  /tmp/ccgt6wcN.s 			page 58


 1250 003c F5D1     		bne	.L77
 221:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1251              		.loc 1 221 38 discriminator 1 view .LVU333
 1252 003e 04F10903 		add	r3, r4, #9
 1253 0042 6B44     		add	r3, sp, r3
 1254 0044 13F8043C 		ldrb	r3, [r3, #-4]	@ zero_extendqisi2
 221:./block/partition.c ****                 move_MBR_Table(&partition->mbr_partition[k+1],&partition->mbr_partition[k]);
 1255              		.loc 1 221 30 discriminator 1 view .LVU334
 1256 0048 012B     		cmp	r3, #1
 1257 004a EED1     		bne	.L77
 222:./block/partition.c ****                 state[k]   = 1;
 1258              		.loc 1 222 17 is_stmt 1 view .LVU335
 1259 004c 04F13E01 		add	r1, r4, #62
 1260 0050 06EB0111 		add	r1, r6, r1, lsl #4
 1261 0054 04F13F00 		add	r0, r4, #63
 1262 0058 06EB0010 		add	r0, r6, r0, lsl #4
 1263 005c 0431     		adds	r1, r1, #4
 1264 005e 0430     		adds	r0, r0, #4
 1265 0060 FFF7FEFF 		bl	move_MBR_Table
 1266              	.LVL113:
 223:./block/partition.c ****                 state[k+1] = 0;
 1267              		.loc 1 223 17 view .LVU336
 223:./block/partition.c ****                 state[k+1] = 0;
 1268              		.loc 1 223 28 is_stmt 0 view .LVU337
 1269 0064 0122     		movs	r2, #1
 1270 0066 04F10803 		add	r3, r4, #8
 1271 006a 6B44     		add	r3, sp, r3
 1272 006c 03F8042C 		strb	r2, [r3, #-4]
 224:./block/partition.c ****             }
 1273              		.loc 1 224 17 is_stmt 1 view .LVU338
 224:./block/partition.c ****             }
 1274              		.loc 1 224 28 is_stmt 0 view .LVU339
 1275 0070 04F10903 		add	r3, r4, #9
 1276 0074 0DEB0305 		add	r5, sp, r3
 1277 0078 0023     		movs	r3, #0
 1278 007a 05F8043C 		strb	r3, [r5, #-4]
 1279 007e D4E7     		b	.L77
 1280              	.L82:
 224:./block/partition.c ****             }
 1281              		.loc 1 224 28 view .LVU340
 1282              	.LBE112:
 219:./block/partition.c ****         for(int k = 0; k < 3; k++){
 1283              		.loc 1 219 28 is_stmt 1 discriminator 2 view .LVU341
 1284 0080 0137     		adds	r7, r7, #1
 1285              	.LVL114:
 1286              	.L76:
 219:./block/partition.c ****         for(int k = 0; k < 3; k++){
 1287              		.loc 1 219 22 discriminator 1 view .LVU342
 1288 0082 022F     		cmp	r7, #2
 1289 0084 01DC     		bgt	.L83
 1290              	.LBB113:
 220:./block/partition.c ****             if(state[k] == 0 && state[k+1] == 1){
 1291              		.loc 1 220 17 is_stmt 0 view .LVU343
 1292 0086 0024     		movs	r4, #0
 1293 0088 D0E7     		b	.L79
 1294              	.L83:
 1295              	.LBE113:
ARM GAS  /tmp/ccgt6wcN.s 			page 59


 1296              	.LBE111:
 228:./block/partition.c **** 
 1297              		.loc 1 228 1 view .LVU344
 1298 008a 03B0     		add	sp, sp, #12
 1299              	.LCFI28:
 1300              		.cfi_def_cfa_offset 20
 1301              		@ sp needed
 1302 008c F0BD     		pop	{r4, r5, r6, r7, pc}
 228:./block/partition.c **** 
 1303              		.loc 1 228 1 view .LVU345
 1304              		.cfi_endproc
 1305              	.LFE1048:
 1307              		.section	.rodata.mbr_table_delete.str1.4,"aMS",%progbits,1
 1308              		.align	2
 1309              	.LC3:
 1310 0000 54686973 		.ascii	"This device has not init\012\015\000"
 1310      20646576 
 1310      69636520 
 1310      68617320 
 1310      6E6F7420 
 1311 001b 00       		.align	2
 1312              	.LC4:
 1313 001c 49742773 		.ascii	"It's not a mbr device\012\015\000"
 1313      206E6F74 
 1313      2061206D 
 1313      62722064 
 1313      65766963 
 1314              		.align	2
 1315              	.LC5:
 1316 0034 70617274 		.ascii	"partition number is out of range\012\015\000"
 1316      6974696F 
 1316      6E206E75 
 1316      6D626572 
 1316      20697320 
 1317 0057 00       		.align	2
 1318              	.LC6:
 1319 0058 54686973 		.ascii	"This is a empty partition table slot\012\015\000"
 1319      20697320 
 1319      6120656D 
 1319      70747920 
 1319      70617274 
 1320              		.section	.text.mbr_table_delete,"ax",%progbits
 1321              		.align	1
 1322              		.syntax unified
 1323              		.thumb
 1324              		.thumb_func
 1326              	mbr_table_delete:
 1327              	.LVL115:
 1328              	.LFB1051:
 299:./block/partition.c ****     if(device == NULL || partition == NULL) {
 1329              		.loc 1 299 1 is_stmt 1 view -0
 1330              		.cfi_startproc
 1331              		@ args = 0, pretend = 0, frame = 0
 1332              		@ frame_needed = 0, uses_anonymous_args = 0
 299:./block/partition.c ****     if(device == NULL || partition == NULL) {
 1333              		.loc 1 299 1 is_stmt 0 view .LVU347
 1334 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
ARM GAS  /tmp/ccgt6wcN.s 			page 60


 1335              	.LCFI29:
 1336              		.cfi_def_cfa_offset 24
 1337              		.cfi_offset 4, -24
 1338              		.cfi_offset 5, -20
 1339              		.cfi_offset 6, -16
 1340              		.cfi_offset 7, -12
 1341              		.cfi_offset 8, -8
 1342              		.cfi_offset 14, -4
 300:./block/partition.c ****         printk("This device has not init\n\r");
 1343              		.loc 1 300 5 is_stmt 1 view .LVU348
 300:./block/partition.c ****         printk("This device has not init\n\r");
 1344              		.loc 1 300 7 is_stmt 0 view .LVU349
 1345 0004 48B3     		cbz	r0, .L85
 1346 0006 0C46     		mov	r4, r1
 1347 0008 1546     		mov	r5, r2
 1348 000a 8046     		mov	r8, r0
 300:./block/partition.c ****         printk("This device has not init\n\r");
 1349              		.loc 1 300 23 discriminator 1 view .LVU350
 1350 000c 29B3     		cbz	r1, .L85
 304:./block/partition.c ****         printk("It's not a mbr device\n\r");
 1351              		.loc 1 304 5 is_stmt 1 view .LVU351
 304:./block/partition.c ****         printk("It's not a mbr device\n\r");
 1352              		.loc 1 304 7 is_stmt 0 view .LVU352
 1353 000e 012B     		cmp	r3, #1
 1354 0010 01D0     		beq	.L88
 304:./block/partition.c ****         printk("It's not a mbr device\n\r");
 1355              		.loc 1 304 39 discriminator 1 view .LVU353
 1356 0012 032B     		cmp	r3, #3
 1357 0014 27D1     		bne	.L93
 1358              	.L88:
 308:./block/partition.c ****         printk("partition number is out of range\n\r");
 1359              		.loc 1 308 5 is_stmt 1 view .LVU354
 308:./block/partition.c ****         printk("partition number is out of range\n\r");
 1360              		.loc 1 308 7 is_stmt 0 view .LVU355
 1361 0016 032D     		cmp	r5, #3
 1362 0018 2BD8     		bhi	.L94
 312:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1363              		.loc 1 312 5 is_stmt 1 view .LVU356
 312:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1364              		.loc 1 312 8 is_stmt 0 view .LVU357
 1365 001a 2146     		mov	r1, r4
 1366              	.LVL116:
 312:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1367              		.loc 1 312 8 view .LVU358
 1368 001c 4046     		mov	r0, r8
 1369              	.LVL117:
 312:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1370              		.loc 1 312 8 view .LVU359
 1371 001e FFF7FEFF 		bl	mbr_partition_table_load
 1372              	.LVL118:
 312:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1373              		.loc 1 312 7 discriminator 1 view .LVU360
 1374 0022 0028     		cmp	r0, #0
 1375 0024 31DB     		blt	.L91
 313:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1){
 1376              		.loc 1 313 5 is_stmt 1 view .LVU361
 313:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1){
ARM GAS  /tmp/ccgt6wcN.s 			page 61


 1377              		.loc 1 313 27 is_stmt 0 view .LVU362
 1378 0026 05F13E06 		add	r6, r5, #62
 1379 002a 04EB0616 		add	r6, r4, r6, lsl #4
 1380 002e 371D     		adds	r7, r6, #4
 1381              	.LVL119:
 314:./block/partition.c ****         printk("This is a empty partition table slot\n\r");
 1382              		.loc 1 314 5 is_stmt 1 view .LVU363
 314:./block/partition.c ****         printk("This is a empty partition table slot\n\r");
 1383              		.loc 1 314 8 is_stmt 0 view .LVU364
 1384 0030 2946     		mov	r1, r5
 1385 0032 2046     		mov	r0, r4
 1386 0034 FFF7FEFF 		bl	check_empty_MBR_Table
 1387              	.LVL120:
 314:./block/partition.c ****         printk("This is a empty partition table slot\n\r");
 1388              		.loc 1 314 7 discriminator 1 view .LVU365
 1389 0038 0128     		cmp	r0, #1
 1390 003a 20D0     		beq	.L95
 319:./block/partition.c ****     tidy_up_MBR_Table(partition);
 1391              		.loc 1 319 9 is_stmt 1 view .LVU366
 1392 003c 0025     		movs	r5, #0
 1393              	.LVL121:
 319:./block/partition.c ****     tidy_up_MBR_Table(partition);
 1394              		.loc 1 319 9 is_stmt 0 view .LVU367
 1395 003e 7560     		str	r5, [r6, #4]	@ unaligned
 1396 0040 7D60     		str	r5, [r7, #4]	@ unaligned
 1397 0042 BD60     		str	r5, [r7, #8]	@ unaligned
 1398 0044 FD60     		str	r5, [r7, #12]	@ unaligned
 320:./block/partition.c ****     mbr_partition_table_update(device,partition);
 1399              		.loc 1 320 5 is_stmt 1 view .LVU368
 1400 0046 2046     		mov	r0, r4
 1401 0048 FFF7FEFF 		bl	tidy_up_MBR_Table
 1402              	.LVL122:
 321:./block/partition.c ****     return 0;
 1403              		.loc 1 321 5 view .LVU369
 1404 004c 2146     		mov	r1, r4
 1405 004e 4046     		mov	r0, r8
 1406 0050 FFF7FEFF 		bl	mbr_partition_table_update
 1407              	.LVL123:
 322:./block/partition.c **** }
 1408              		.loc 1 322 5 view .LVU370
 322:./block/partition.c **** }
 1409              		.loc 1 322 12 is_stmt 0 view .LVU371
 1410 0054 2846     		mov	r0, r5
 1411              	.LVL124:
 1412              	.L84:
 323:./block/partition.c **** EXPORT_SYMBOL(mbr_table_delete);
 1413              		.loc 1 323 1 view .LVU372
 1414 0056 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1415              	.LVL125:
 1416              	.L85:
 301:./block/partition.c ****         return -1;
 1417              		.loc 1 301 9 is_stmt 1 view .LVU373
 1418 005a 0D48     		ldr	r0, .L96
 1419              	.LVL126:
 301:./block/partition.c ****         return -1;
 1420              		.loc 1 301 9 is_stmt 0 view .LVU374
 1421 005c FFF7FEFF 		bl	printk
ARM GAS  /tmp/ccgt6wcN.s 			page 62


 1422              	.LVL127:
 302:./block/partition.c ****     }
 1423              		.loc 1 302 9 is_stmt 1 view .LVU375
 302:./block/partition.c ****     }
 1424              		.loc 1 302 16 is_stmt 0 view .LVU376
 1425 0060 4FF0FF30 		mov	r0, #-1
 1426 0064 F7E7     		b	.L84
 1427              	.LVL128:
 1428              	.L93:
 305:./block/partition.c ****         return -1;
 1429              		.loc 1 305 9 is_stmt 1 view .LVU377
 1430 0066 0B48     		ldr	r0, .L96+4
 1431              	.LVL129:
 305:./block/partition.c ****         return -1;
 1432              		.loc 1 305 9 is_stmt 0 view .LVU378
 1433 0068 FFF7FEFF 		bl	printk
 1434              	.LVL130:
 306:./block/partition.c ****     }
 1435              		.loc 1 306 9 is_stmt 1 view .LVU379
 306:./block/partition.c ****     }
 1436              		.loc 1 306 16 is_stmt 0 view .LVU380
 1437 006c 4FF0FF30 		mov	r0, #-1
 1438 0070 F1E7     		b	.L84
 1439              	.LVL131:
 1440              	.L94:
 309:./block/partition.c ****         return -1;
 1441              		.loc 1 309 9 is_stmt 1 view .LVU381
 1442 0072 0948     		ldr	r0, .L96+8
 1443              	.LVL132:
 309:./block/partition.c ****         return -1;
 1444              		.loc 1 309 9 is_stmt 0 view .LVU382
 1445 0074 FFF7FEFF 		bl	printk
 1446              	.LVL133:
 310:./block/partition.c ****     }
 1447              		.loc 1 310 9 is_stmt 1 view .LVU383
 310:./block/partition.c ****     }
 1448              		.loc 1 310 16 is_stmt 0 view .LVU384
 1449 0078 4FF0FF30 		mov	r0, #-1
 1450 007c EBE7     		b	.L84
 1451              	.LVL134:
 1452              	.L95:
 315:./block/partition.c ****         return -1;
 1453              		.loc 1 315 9 is_stmt 1 view .LVU385
 1454 007e 0748     		ldr	r0, .L96+12
 1455 0080 FFF7FEFF 		bl	printk
 1456              	.LVL135:
 316:./block/partition.c ****     }
 1457              		.loc 1 316 9 view .LVU386
 316:./block/partition.c ****     }
 1458              		.loc 1 316 16 is_stmt 0 view .LVU387
 1459 0084 4FF0FF30 		mov	r0, #-1
 1460 0088 E5E7     		b	.L84
 1461              	.LVL136:
 1462              	.L91:
 312:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1463              		.loc 1 312 63 discriminator 1 view .LVU388
 1464 008a 4FF0FF30 		mov	r0, #-1
ARM GAS  /tmp/ccgt6wcN.s 			page 63


 1465 008e E2E7     		b	.L84
 1466              	.L97:
 1467              		.align	2
 1468              	.L96:
 1469 0090 00000000 		.word	.LC3
 1470 0094 1C000000 		.word	.LC4
 1471 0098 34000000 		.word	.LC5
 1472 009c 58000000 		.word	.LC6
 1473              		.cfi_endproc
 1474              	.LFE1051:
 1476              		.section	.text.get_empty_MBR_Table,"ax",%progbits
 1477              		.align	1
 1478              		.syntax unified
 1479              		.thumb
 1480              		.thumb_func
 1482              	get_empty_MBR_Table:
 1483              	.LVL137:
 1484              	.LFB1039:
 116:./block/partition.c ****     for(int i = 0 ; i <4 ; i++){
 1485              		.loc 1 116 1 is_stmt 1 view -0
 1486              		.cfi_startproc
 1487              		@ args = 0, pretend = 0, frame = 0
 1488              		@ frame_needed = 0, uses_anonymous_args = 0
 116:./block/partition.c ****     for(int i = 0 ; i <4 ; i++){
 1489              		.loc 1 116 1 is_stmt 0 view .LVU390
 1490 0000 70B5     		push	{r4, r5, r6, lr}
 1491              	.LCFI30:
 1492              		.cfi_def_cfa_offset 16
 1493              		.cfi_offset 4, -16
 1494              		.cfi_offset 5, -12
 1495              		.cfi_offset 6, -8
 1496              		.cfi_offset 14, -4
 1497 0002 0546     		mov	r5, r0
 1498 0004 0E46     		mov	r6, r1
 117:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1499              		.loc 1 117 5 is_stmt 1 view .LVU391
 1500              	.LBB114:
 117:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1501              		.loc 1 117 9 view .LVU392
 1502              	.LVL138:
 117:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1503              		.loc 1 117 13 is_stmt 0 view .LVU393
 1504 0006 0024     		movs	r4, #0
 1505              	.LVL139:
 1506              	.L99:
 117:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1507              		.loc 1 117 23 is_stmt 1 discriminator 1 view .LVU394
 1508 0008 032C     		cmp	r4, #3
 1509 000a 0CDC     		bgt	.L104
 118:./block/partition.c ****             number[0] = i;
 1510              		.loc 1 118 9 view .LVU395
 118:./block/partition.c ****             number[0] = i;
 1511              		.loc 1 118 12 is_stmt 0 view .LVU396
 1512 000c 2146     		mov	r1, r4
 1513 000e 2846     		mov	r0, r5
 1514 0010 FFF7FEFF 		bl	check_empty_MBR_Table
 1515              	.LVL140:
ARM GAS  /tmp/ccgt6wcN.s 			page 64


 118:./block/partition.c ****             number[0] = i;
 1516              		.loc 1 118 11 discriminator 1 view .LVU397
 1517 0014 08B9     		cbnz	r0, .L105
 117:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1518              		.loc 1 117 29 is_stmt 1 discriminator 2 view .LVU398
 1519 0016 0134     		adds	r4, r4, #1
 1520              	.LVL141:
 117:./block/partition.c ****         if(check_empty_MBR_Table(partition,i)){
 1521              		.loc 1 117 29 is_stmt 0 discriminator 2 view .LVU399
 1522 0018 F6E7     		b	.L99
 1523              	.L105:
 119:./block/partition.c ****             return &partition->mbr_partition[i];
 1524              		.loc 1 119 13 is_stmt 1 view .LVU400
 119:./block/partition.c ****             return &partition->mbr_partition[i];
 1525              		.loc 1 119 23 is_stmt 0 view .LVU401
 1526 001a 3460     		str	r4, [r6]
 120:./block/partition.c ****         }
 1527              		.loc 1 120 13 is_stmt 1 view .LVU402
 120:./block/partition.c ****         }
 1528              		.loc 1 120 20 is_stmt 0 view .LVU403
 1529 001c 3E34     		adds	r4, r4, #62
 1530              	.LVL142:
 120:./block/partition.c ****         }
 1531              		.loc 1 120 20 view .LVU404
 1532 001e 05EB0410 		add	r0, r5, r4, lsl #4
 1533 0022 0430     		adds	r0, r0, #4
 1534 0024 00E0     		b	.L98
 1535              	.LVL143:
 1536              	.L104:
 120:./block/partition.c ****         }
 1537              		.loc 1 120 20 view .LVU405
 1538              	.LBE114:
 123:./block/partition.c **** }
 1539              		.loc 1 123 12 view .LVU406
 1540 0026 0020     		movs	r0, #0
 1541              	.LVL144:
 1542              	.L98:
 124:./block/partition.c **** 
 1543              		.loc 1 124 1 view .LVU407
 1544 0028 70BD     		pop	{r4, r5, r6, pc}
 124:./block/partition.c **** 
 1545              		.loc 1 124 1 view .LVU408
 1546              		.cfi_endproc
 1547              	.LFE1039:
 1549              		.section	.text.get_mbr_partition_size,"ax",%progbits
 1550              		.align	1
 1551              		.syntax unified
 1552              		.thumb
 1553              		.thumb_func
 1555              	get_mbr_partition_size:
 1556              	.LVL145:
 1557              	.LFB1041:
 144:./block/partition.c ****     if(number < 0 || number > 3)
 1558              		.loc 1 144 79 is_stmt 1 view -0
 1559              		.cfi_startproc
 1560              		@ args = 0, pretend = 0, frame = 0
 1561              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccgt6wcN.s 			page 65


 145:./block/partition.c ****         return INVALID_PARTITION;
 1562              		.loc 1 145 5 view .LVU410
 145:./block/partition.c ****         return INVALID_PARTITION;
 1563              		.loc 1 145 7 is_stmt 0 view .LVU411
 1564 0000 0329     		cmp	r1, #3
 1565 0002 0BD8     		bhi	.L108
 144:./block/partition.c ****     if(number < 0 || number > 3)
 1566              		.loc 1 144 79 view .LVU412
 1567 0004 38B5     		push	{r3, r4, r5, lr}
 1568              	.LCFI31:
 1569              		.cfi_def_cfa_offset 16
 1570              		.cfi_offset 3, -16
 1571              		.cfi_offset 4, -12
 1572              		.cfi_offset 5, -8
 1573              		.cfi_offset 14, -4
 1574 0006 0446     		mov	r4, r0
 1575 0008 0D46     		mov	r5, r1
 147:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 1576              		.loc 1 147 5 is_stmt 1 view .LVU413
 1577              	.LVL146:
 148:./block/partition.c ****         return INVALID_PARTITION;
 1578              		.loc 1 148 5 view .LVU414
 148:./block/partition.c ****         return INVALID_PARTITION;
 1579              		.loc 1 148 8 is_stmt 0 view .LVU415
 1580 000a FFF7FEFF 		bl	check_empty_MBR_Table
 1581              	.LVL147:
 148:./block/partition.c ****         return INVALID_PARTITION;
 1582              		.loc 1 148 7 discriminator 1 view .LVU416
 1583 000e 0128     		cmp	r0, #1
 1584 0010 07D0     		beq	.L109
 150:./block/partition.c **** }
 1585              		.loc 1 150 5 is_stmt 1 view .LVU417
 150:./block/partition.c **** }
 1586              		.loc 1 150 25 is_stmt 0 view .LVU418
 1587 0012 04EB0514 		add	r4, r4, r5, lsl #4
 1588              	.LVL148:
 150:./block/partition.c **** }
 1589              		.loc 1 150 25 view .LVU419
 1590 0016 D4F8F003 		ldr	r0, [r4, #1008]	@ unaligned
 1591              	.L106:
 151:./block/partition.c **** 
 1592              		.loc 1 151 1 view .LVU420
 1593 001a 38BD     		pop	{r3, r4, r5, pc}
 1594              	.LVL149:
 1595              	.L108:
 1596              	.LCFI32:
 1597              		.cfi_def_cfa_offset 0
 1598              		.cfi_restore 3
 1599              		.cfi_restore 4
 1600              		.cfi_restore 5
 1601              		.cfi_restore 14
 146:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 1602              		.loc 1 146 16 view .LVU421
 1603 001c 4FF0FF30 		mov	r0, #-1
 1604              	.LVL150:
 151:./block/partition.c **** 
 1605              		.loc 1 151 1 view .LVU422
ARM GAS  /tmp/ccgt6wcN.s 			page 66


 1606 0020 7047     		bx	lr
 1607              	.LVL151:
 1608              	.L109:
 1609              	.LCFI33:
 1610              		.cfi_def_cfa_offset 16
 1611              		.cfi_offset 3, -16
 1612              		.cfi_offset 4, -12
 1613              		.cfi_offset 5, -8
 1614              		.cfi_offset 14, -4
 149:./block/partition.c ****     return mbr_partition->nr_sectors;
 1615              		.loc 1 149 16 view .LVU423
 1616 0022 4FF0FF30 		mov	r0, #-1
 1617 0026 F8E7     		b	.L106
 1618              		.cfi_endproc
 1619              	.LFE1041:
 1621              		.section	.text.get_mbr_partition_start_address,"ax",%progbits
 1622              		.align	1
 1623              		.syntax unified
 1624              		.thumb
 1625              		.thumb_func
 1627              	get_mbr_partition_start_address:
 1628              	.LVL152:
 1629              	.LFB1042:
 153:./block/partition.c ****     if(number < 0 || number > 3)
 1630              		.loc 1 153 88 is_stmt 1 view -0
 1631              		.cfi_startproc
 1632              		@ args = 0, pretend = 0, frame = 0
 1633              		@ frame_needed = 0, uses_anonymous_args = 0
 154:./block/partition.c ****         return INVALID_PARTITION;
 1634              		.loc 1 154 5 view .LVU425
 154:./block/partition.c ****         return INVALID_PARTITION;
 1635              		.loc 1 154 7 is_stmt 0 view .LVU426
 1636 0000 0329     		cmp	r1, #3
 1637 0002 11D8     		bhi	.L117
 153:./block/partition.c ****     if(number < 0 || number > 3)
 1638              		.loc 1 153 88 view .LVU427
 1639 0004 38B5     		push	{r3, r4, r5, lr}
 1640              	.LCFI34:
 1641              		.cfi_def_cfa_offset 16
 1642              		.cfi_offset 3, -16
 1643              		.cfi_offset 4, -12
 1644              		.cfi_offset 5, -8
 1645              		.cfi_offset 14, -4
 1646 0006 0446     		mov	r4, r0
 1647 0008 0D46     		mov	r5, r1
 157:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1){
 1648              		.loc 1 157 5 is_stmt 1 view .LVU428
 1649              	.LVL153:
 158:./block/partition.c ****          printk("This is a empty partition table slot\n\r");
 1650              		.loc 1 158 5 view .LVU429
 158:./block/partition.c ****          printk("This is a empty partition table slot\n\r");
 1651              		.loc 1 158 8 is_stmt 0 view .LVU430
 1652 000a FFF7FEFF 		bl	check_empty_MBR_Table
 1653              	.LVL154:
 158:./block/partition.c ****          printk("This is a empty partition table slot\n\r");
 1654              		.loc 1 158 7 discriminator 1 view .LVU431
 1655 000e 0128     		cmp	r0, #1
ARM GAS  /tmp/ccgt6wcN.s 			page 67


 1656 0010 04D0     		beq	.L122
 162:./block/partition.c **** }
 1657              		.loc 1 162 5 is_stmt 1 view .LVU432
 162:./block/partition.c **** }
 1658              		.loc 1 162 25 is_stmt 0 view .LVU433
 1659 0012 04EB0514 		add	r4, r4, r5, lsl #4
 1660              	.LVL155:
 162:./block/partition.c **** }
 1661              		.loc 1 162 25 view .LVU434
 1662 0016 D4F8EC03 		ldr	r0, [r4, #1004]	@ unaligned
 1663              	.L114:
 163:./block/partition.c **** 
 1664              		.loc 1 163 1 view .LVU435
 1665 001a 38BD     		pop	{r3, r4, r5, pc}
 1666              	.LVL156:
 1667              	.L122:
 159:./block/partition.c ****          return INVALID_PARTITION;
 1668              		.loc 1 159 10 is_stmt 1 view .LVU436
 1669 001c 0448     		ldr	r0, .L123
 1670 001e FFF7FEFF 		bl	printk
 1671              	.LVL157:
 160:./block/partition.c ****     }
 1672              		.loc 1 160 10 view .LVU437
 160:./block/partition.c ****     }
 1673              		.loc 1 160 17 is_stmt 0 view .LVU438
 1674 0022 4FF0FF30 		mov	r0, #-1
 1675 0026 F8E7     		b	.L114
 1676              	.LVL158:
 1677              	.L117:
 1678              	.LCFI35:
 1679              		.cfi_def_cfa_offset 0
 1680              		.cfi_restore 3
 1681              		.cfi_restore 4
 1682              		.cfi_restore 5
 1683              		.cfi_restore 14
 155:./block/partition.c ****     
 1684              		.loc 1 155 16 view .LVU439
 1685 0028 4FF0FF30 		mov	r0, #-1
 1686              	.LVL159:
 163:./block/partition.c **** 
 1687              		.loc 1 163 1 view .LVU440
 1688 002c 7047     		bx	lr
 1689              	.L124:
 1690 002e 00BF     		.align	2
 1691              	.L123:
 1692 0030 58000000 		.word	.LC6
 1693              		.cfi_endproc
 1694              	.LFE1042:
 1696              		.section	.rodata.mbr_partition_table_format.str1.4,"aMS",%progbits,1
 1697              		.align	2
 1698              	.LC7:
 1699 0000 54686973 		.ascii	"This device has not init\012\000"
 1699      20646576 
 1699      69636520 
 1699      68617320 
 1699      6E6F7420 
 1700 001a 0000     		.align	2
ARM GAS  /tmp/ccgt6wcN.s 			page 68


 1701              	.LC8:
 1702 001c 63616E20 		.ascii	"can not load mbr partition\012\000"
 1702      6E6F7420 
 1702      6C6F6164 
 1702      206D6272 
 1702      20706172 
 1703              		.align	2
 1704              	.LC9:
 1705 0038 74686973 		.ascii	"this storage device can not builded more partition "
 1705      2073746F 
 1705      72616765 
 1705      20646576 
 1705      69636520 
 1706 006b 7461626C 		.ascii	"table any more\012\000"
 1706      6520616E 
 1706      79206D6F 
 1706      72650A00 
 1707 007b 00       		.align	2
 1708              	.LC10:
 1709 007c 47455420 		.ascii	"GET last table start address = %d last_size\012\000"
 1709      6C617374 
 1709      20746162 
 1709      6C652073 
 1709      74617274 
 1710 00a9 000000   		.align	2
 1711              	.LC11:
 1712 00ac 6E6F206C 		.ascii	"no last table\012\000"
 1712      61737420 
 1712      7461626C 
 1712      650A00
 1713 00bb 00       		.align	2
 1714              	.LC12:
 1715 00bc 69742773 		.ascii	"it's the first partition\012\000"
 1715      20746865 
 1715      20666972 
 1715      73742070 
 1715      61727469 
 1716 00d6 0000     		.align	2
 1717              	.LC13:
 1718 00d8 74686973 		.ascii	"this disk size is too small\000"
 1718      20646973 
 1718      6B207369 
 1718      7A652069 
 1718      7320746F 
 1719              		.align	2
 1720              	.LC14:
 1721 00f4 64656374 		.ascii	"dected stand storage device,use 2048 as start addre"
 1721      65642073 
 1721      74616E64 
 1721      2073746F 
 1721      72616765 
 1722 0127 73730A00 		.ascii	"ss\012\000"
 1723 012b 00       		.align	2
 1724              	.LC15:
 1725 012c 47455420 		.ascii	"GET last table size = %d block\012\000"
 1725      6C617374 
 1725      20746162 
ARM GAS  /tmp/ccgt6wcN.s 			page 69


 1725      6C652073 
 1725      697A6520 
 1726              		.align	2
 1727              	.LC16:
 1728 014c 6E6F7420 		.ascii	"not support this storage device,storage siz is too "
 1728      73757070 
 1728      6F727420 
 1728      74686973 
 1728      2073746F 
 1729 017f 736D616C 		.ascii	"small\012\000"
 1729      6C0A00
 1730 0186 0000     		.align	2
 1731              	.LC17:
 1732 0188 50617274 		.ascii	"Partition size %d is too large, adjusting to fit av"
 1732      6974696F 
 1732      6E207369 
 1732      7A652025 
 1732      64206973 
 1733 01bb 61696C61 		.ascii	"ailable space.\012\000"
 1733      626C6520 
 1733      73706163 
 1733      652E0A00 
 1734 01cb 00       		.align	2
 1735              	.LC18:
 1736 01cc 4E657720 		.ascii	"New partition size: %d\012\000"
 1736      70617274 
 1736      6974696F 
 1736      6E207369 
 1736      7A653A20 
 1737              		.align	2
 1738              	.LC19:
 1739 01e4 74686973 		.ascii	"this size: %d of block  is not work\012\000"
 1739      2073697A 
 1739      653A2025 
 1739      64206F66 
 1739      20626C6F 
 1740              		.section	.text.mbr_partition_table_format,"ax",%progbits
 1741              		.align	1
 1742              		.syntax unified
 1743              		.thumb
 1744              		.thumb_func
 1746              	mbr_partition_table_format:
 1747              	.LVL160:
 1748              	.LFB1052:
 356:./block/partition.c ****     if(device == NULL || partition == NULL) {
 1749              		.loc 1 356 1 is_stmt 1 view -0
 1750              		.cfi_startproc
 1751              		@ args = 0, pretend = 0, frame = 8
 1752              		@ frame_needed = 0, uses_anonymous_args = 0
 356:./block/partition.c ****     if(device == NULL || partition == NULL) {
 1753              		.loc 1 356 1 is_stmt 0 view .LVU442
 1754 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1755              	.LCFI36:
 1756              		.cfi_def_cfa_offset 32
 1757              		.cfi_offset 4, -32
 1758              		.cfi_offset 5, -28
 1759              		.cfi_offset 6, -24
ARM GAS  /tmp/ccgt6wcN.s 			page 70


 1760              		.cfi_offset 7, -20
 1761              		.cfi_offset 8, -16
 1762              		.cfi_offset 9, -12
 1763              		.cfi_offset 10, -8
 1764              		.cfi_offset 14, -4
 1765 0004 84B0     		sub	sp, sp, #16
 1766              	.LCFI37:
 1767              		.cfi_def_cfa_offset 48
 357:./block/partition.c ****         printk(KERN_INFO "This device has not init\n");
 1768              		.loc 1 357 5 is_stmt 1 view .LVU443
 357:./block/partition.c ****         printk(KERN_INFO "This device has not init\n");
 1769              		.loc 1 357 7 is_stmt 0 view .LVU444
 1770 0006 60B3     		cbz	r0, .L126
 1771 0008 0E46     		mov	r6, r1
 1772 000a 1546     		mov	r5, r2
 1773 000c 9946     		mov	r9, r3
 1774 000e 8046     		mov	r8, r0
 357:./block/partition.c ****         printk(KERN_INFO "This device has not init\n");
 1775              		.loc 1 357 23 discriminator 1 view .LVU445
 1776 0010 39B3     		cbz	r1, .L126
 361:./block/partition.c ****     {
 1777              		.loc 1 361 5 is_stmt 1 view .LVU446
 361:./block/partition.c ****     {
 1778              		.loc 1 361 8 is_stmt 0 view .LVU447
 1779 0012 FFF7FEFF 		bl	mbr_partition_table_load
 1780              	.LVL161:
 361:./block/partition.c ****     {
 1781              		.loc 1 361 7 discriminator 1 view .LVU448
 1782 0016 0028     		cmp	r0, #0
 1783 0018 29DB     		blt	.L144
 366:./block/partition.c ****     if(size < 0) return -1;
 1784              		.loc 1 366 5 is_stmt 1 view .LVU449
 366:./block/partition.c ****     if(size < 0) return -1;
 1785              		.loc 1 366 10 is_stmt 0 view .LVU450
 1786 001a 25F00705 		bic	r5, r5, #7
 1787              	.LVL162:
 367:./block/partition.c ****     
 1788              		.loc 1 367 5 is_stmt 1 view .LVU451
 369:./block/partition.c ****     struct mbr_partition *mbr_partition = get_empty_MBR_Table(partition,&partition_number);   //
 1789              		.loc 1 369 5 view .LVU452
 369:./block/partition.c ****     struct mbr_partition *mbr_partition = get_empty_MBR_Table(partition,&partition_number);   //
 1790              		.loc 1 369 9 is_stmt 0 view .LVU453
 1791 001e 0023     		movs	r3, #0
 1792 0020 0393     		str	r3, [sp, #12]
 370:./block/partition.c ****     if(mbr_partition == NULL){
 1793              		.loc 1 370 5 is_stmt 1 view .LVU454
 370:./block/partition.c ****     if(mbr_partition == NULL){
 1794              		.loc 1 370 43 is_stmt 0 view .LVU455
 1795 0022 03A9     		add	r1, sp, #12
 1796 0024 3046     		mov	r0, r6
 1797 0026 FFF7FEFF 		bl	get_empty_MBR_Table
 1798              	.LVL163:
 371:./block/partition.c ****         printk(KERN_INFO "this storage device can not builded more partition table any more\n");
 1799              		.loc 1 371 5 is_stmt 1 view .LVU456
 371:./block/partition.c ****         printk(KERN_INFO "this storage device can not builded more partition table any more\n");
 1800              		.loc 1 371 7 is_stmt 0 view .LVU457
 1801 002a 8246     		mov	r10, r0
ARM GAS  /tmp/ccgt6wcN.s 			page 71


 1802 002c 28B3     		cbz	r0, .L145
 376:./block/partition.c ****     if(partition_number - 1 >= 0){     
 1803              		.loc 1 376 5 is_stmt 1 view .LVU458
 377:./block/partition.c ****         start_address = get_mbr_partition_start_address(partition,partition_number - 1);
 1804              		.loc 1 377 5 view .LVU459
 377:./block/partition.c ****         start_address = get_mbr_partition_start_address(partition,partition_number - 1);
 1805              		.loc 1 377 29 is_stmt 0 view .LVU460
 1806 002e 0399     		ldr	r1, [sp, #12]
 377:./block/partition.c ****         start_address = get_mbr_partition_start_address(partition,partition_number - 1);
 1807              		.loc 1 377 7 view .LVU461
 1808 0030 0029     		cmp	r1, #0
 1809 0032 28DD     		ble	.L131
 378:./block/partition.c ****         printk(KERN_INFO "GET last table start address = %d last_size\n",start_address);
 1810              		.loc 1 378 9 is_stmt 1 view .LVU462
 378:./block/partition.c ****         printk(KERN_INFO "GET last table start address = %d last_size\n",start_address);
 1811              		.loc 1 378 25 is_stmt 0 view .LVU463
 1812 0034 0139     		subs	r1, r1, #1
 1813 0036 3046     		mov	r0, r6
 1814              	.LVL164:
 378:./block/partition.c ****         printk(KERN_INFO "GET last table start address = %d last_size\n",start_address);
 1815              		.loc 1 378 25 view .LVU464
 1816 0038 FFF7FEFF 		bl	get_mbr_partition_start_address
 1817              	.LVL165:
 1818 003c 0446     		mov	r4, r0
 1819              	.LVL166:
 379:./block/partition.c ****     }
 1820              		.loc 1 379 9 is_stmt 1 view .LVU465
 1821 003e 0146     		mov	r1, r0
 1822 0040 3E48     		ldr	r0, .L151
 1823              	.LVL167:
 379:./block/partition.c ****     }
 1824              		.loc 1 379 9 is_stmt 0 view .LVU466
 1825 0042 FFF7FEFF 		bl	printk
 1826              	.LVL168:
 385:./block/partition.c ****         printk(KERN_INFO "it's the first partition\n");
 1827              		.loc 1 385 5 is_stmt 1 view .LVU467
 385:./block/partition.c ****         printk(KERN_INFO "it's the first partition\n");
 1828              		.loc 1 385 8 is_stmt 0 view .LVU468
 1829 0046 B4F1FF3F 		cmp	r4, #-1
 1830 004a 1FD0     		beq	.L132
 1831              	.LBB115:
 397:./block/partition.c ****         start_address += last_size;               
 1832              		.loc 1 397 9 is_stmt 1 view .LVU469
 397:./block/partition.c ****         start_address += last_size;               
 1833              		.loc 1 397 30 is_stmt 0 view .LVU470
 1834 004c 0399     		ldr	r1, [sp, #12]
 1835 004e 0139     		subs	r1, r1, #1
 1836 0050 3046     		mov	r0, r6
 1837 0052 FFF7FEFF 		bl	get_mbr_partition_size
 1838              	.LVL169:
 1839 0056 0146     		mov	r1, r0
 1840              	.LVL170:
 398:./block/partition.c ****         printk(KERN_INFO "GET last table size = %d block\n",last_size);
 1841              		.loc 1 398 9 is_stmt 1 view .LVU471
 398:./block/partition.c ****         printk(KERN_INFO "GET last table size = %d block\n",last_size);
 1842              		.loc 1 398 23 is_stmt 0 view .LVU472
 1843 0058 0444     		add	r4, r4, r0
ARM GAS  /tmp/ccgt6wcN.s 			page 72


 1844              	.LVL171:
 399:./block/partition.c ****     }
 1845              		.loc 1 399 9 is_stmt 1 view .LVU473
 1846 005a 3948     		ldr	r0, .L151+4
 1847              	.LVL172:
 399:./block/partition.c ****     }
 1848              		.loc 1 399 9 is_stmt 0 view .LVU474
 1849 005c FFF7FEFF 		bl	printk
 1850              	.LVL173:
 399:./block/partition.c ****     }
 1851              		.loc 1 399 9 view .LVU475
 1852 0060 21E0     		b	.L135
 1853              	.LVL174:
 1854              	.L126:
 399:./block/partition.c ****     }
 1855              		.loc 1 399 9 view .LVU476
 1856              	.LBE115:
 358:./block/partition.c ****         return -1;
 1857              		.loc 1 358 9 is_stmt 1 view .LVU477
 1858 0062 3848     		ldr	r0, .L151+8
 1859              	.LVL175:
 358:./block/partition.c ****         return -1;
 1860              		.loc 1 358 9 is_stmt 0 view .LVU478
 1861 0064 FFF7FEFF 		bl	printk
 1862              	.LVL176:
 359:./block/partition.c ****     }
 1863              		.loc 1 359 9 is_stmt 1 view .LVU479
 359:./block/partition.c ****     }
 1864              		.loc 1 359 16 is_stmt 0 view .LVU480
 1865 0068 4FF0FF30 		mov	r0, #-1
 1866 006c 3DE0     		b	.L125
 1867              	.LVL177:
 1868              	.L144:
 363:./block/partition.c ****         return -1;           //mbr
 1869              		.loc 1 363 9 is_stmt 1 view .LVU481
 1870 006e 3648     		ldr	r0, .L151+12
 1871 0070 FFF7FEFF 		bl	printk
 1872              	.LVL178:
 364:./block/partition.c ****     }
 1873              		.loc 1 364 9 view .LVU482
 364:./block/partition.c ****     }
 1874              		.loc 1 364 16 is_stmt 0 view .LVU483
 1875 0074 4FF0FF30 		mov	r0, #-1
 1876 0078 37E0     		b	.L125
 1877              	.LVL179:
 1878              	.L145:
 372:./block/partition.c ****         return -1;
 1879              		.loc 1 372 9 is_stmt 1 view .LVU484
 1880 007a 3448     		ldr	r0, .L151+16
 1881              	.LVL180:
 372:./block/partition.c ****         return -1;
 1882              		.loc 1 372 9 is_stmt 0 view .LVU485
 1883 007c FFF7FEFF 		bl	printk
 1884              	.LVL181:
 373:./block/partition.c ****     }
 1885              		.loc 1 373 9 is_stmt 1 view .LVU486
 373:./block/partition.c ****     }
ARM GAS  /tmp/ccgt6wcN.s 			page 73


 1886              		.loc 1 373 16 is_stmt 0 view .LVU487
 1887 0080 4FF0FF30 		mov	r0, #-1
 1888 0084 31E0     		b	.L125
 1889              	.LVL182:
 1890              	.L131:
 382:./block/partition.c ****         start_address = INVALID_PARTITION;
 1891              		.loc 1 382 9 is_stmt 1 view .LVU488
 1892 0086 3248     		ldr	r0, .L151+20
 1893              	.LVL183:
 382:./block/partition.c ****         start_address = INVALID_PARTITION;
 1894              		.loc 1 382 9 is_stmt 0 view .LVU489
 1895 0088 FFF7FEFF 		bl	printk
 1896              	.LVL184:
 383:./block/partition.c ****     }
 1897              		.loc 1 383 9 is_stmt 1 view .LVU490
 385:./block/partition.c ****         printk(KERN_INFO "it's the first partition\n");
 1898              		.loc 1 385 5 view .LVU491
 1899              	.L132:
 386:./block/partition.c ****         if(device->bd_nr_sectors  < 2048){
 1900              		.loc 1 386 9 view .LVU492
 1901 008c 3148     		ldr	r0, .L151+24
 1902 008e FFF7FEFF 		bl	printk
 1903              	.LVL185:
 387:./block/partition.c ****            printk(KERN_INFO "this disk size is too small");
 1904              		.loc 1 387 9 view .LVU493
 387:./block/partition.c ****            printk(KERN_INFO "this disk size is too small");
 1905              		.loc 1 387 18 is_stmt 0 view .LVU494
 1906 0092 D8F80430 		ldr	r3, [r8, #4]
 387:./block/partition.c ****            printk(KERN_INFO "this disk size is too small");
 1907              		.loc 1 387 11 view .LVU495
 1908 0096 B3F5006F 		cmp	r3, #2048
 1909 009a 29D3     		bcc	.L146
 392:./block/partition.c ****             printk(KERN_INFO "dected stand storage device,use 2048 as start address\n");
 1910              		.loc 1 392 13 is_stmt 1 view .LVU496
 1911              	.LVL186:
 393:./block/partition.c ****         }
 1912              		.loc 1 393 13 view .LVU497
 1913 009c 2E48     		ldr	r0, .L151+28
 1914 009e FFF7FEFF 		bl	printk
 1915              	.LVL187:
 392:./block/partition.c ****             printk(KERN_INFO "dected stand storage device,use 2048 as start address\n");
 1916              		.loc 1 392 27 is_stmt 0 view .LVU498
 1917 00a2 4FF40064 		mov	r4, #2048
 1918              	.LVL188:
 1919              	.L135:
 402:./block/partition.c ****     start_address = start_address - (start_address%8) + 8;
 1920              		.loc 1 402 5 is_stmt 1 view .LVU499
 402:./block/partition.c ****     start_address = start_address - (start_address%8) + 8;
 1921              		.loc 1 402 7 is_stmt 0 view .LVU500
 1922 00a6 14F0070F 		tst	r4, #7
 1923 00aa 02D0     		beq	.L136
 403:./block/partition.c ****     //
 1924              		.loc 1 403 5 is_stmt 1 view .LVU501
 403:./block/partition.c ****     //
 1925              		.loc 1 403 35 is_stmt 0 view .LVU502
 1926 00ac 24F00704 		bic	r4, r4, #7
 1927              	.LVL189:
ARM GAS  /tmp/ccgt6wcN.s 			page 74


 403:./block/partition.c ****     //
 1928              		.loc 1 403 19 view .LVU503
 1929 00b0 0834     		adds	r4, r4, #8
 1930              	.LVL190:
 1931              	.L136:
 405:./block/partition.c ****     if(partition_number + 1 < 4)
 1932              		.loc 1 405 5 is_stmt 1 view .LVU504
 406:./block/partition.c ****         end_address = get_mbr_partition_start_address(device,partition_number + 1);        //
 1933              		.loc 1 406 5 view .LVU505
 406:./block/partition.c ****         end_address = get_mbr_partition_start_address(device,partition_number + 1);        //
 1934              		.loc 1 406 29 is_stmt 0 view .LVU506
 1935 00b2 0399     		ldr	r1, [sp, #12]
 406:./block/partition.c ****         end_address = get_mbr_partition_start_address(device,partition_number + 1);        //
 1936              		.loc 1 406 7 view .LVU507
 1937 00b4 0229     		cmp	r1, #2
 1938 00b6 21DD     		ble	.L147
 1939              	.L137:
 411:./block/partition.c ****     }
 1940              		.loc 1 411 9 is_stmt 1 view .LVU508
 411:./block/partition.c ****     }
 1941              		.loc 1 411 28 is_stmt 0 view .LVU509
 1942 00b8 D8F80470 		ldr	r7, [r8, #4]
 411:./block/partition.c ****     }
 1943              		.loc 1 411 21 view .LVU510
 1944 00bc 223F     		subs	r7, r7, #34
 1945              	.LVL191:
 1946              	.L138:
 413:./block/partition.c ****         printk(KERN_INFO "not support this storage device,storage siz is too small\n");
 1947              		.loc 1 413 5 is_stmt 1 view .LVU511
 413:./block/partition.c ****         printk(KERN_INFO "not support this storage device,storage siz is too small\n");
 1948              		.loc 1 413 7 is_stmt 0 view .LVU512
 1949 00be BC42     		cmp	r4, r7
 1950 00c0 25D8     		bhi	.L148
 417:./block/partition.c ****         printk(KERN_INFO "Partition size %d is too large, adjusting to fit available space.\n", siz
 1951              		.loc 1 417 5 is_stmt 1 view .LVU513
 417:./block/partition.c ****         printk(KERN_INFO "Partition size %d is too large, adjusting to fit available space.\n", siz
 1952              		.loc 1 417 38 is_stmt 0 view .LVU514
 1953 00c2 6319     		adds	r3, r4, r5
 417:./block/partition.c ****         printk(KERN_INFO "Partition size %d is too large, adjusting to fit available space.\n", siz
 1954              		.loc 1 417 8 view .LVU515
 1955 00c4 BB42     		cmp	r3, r7
 1956 00c6 28D2     		bcs	.L149
 1957              	.L140:
 422:./block/partition.c ****         printk(KERN_INFO "this size: %d of block  is not work\n",size);
 1958              		.loc 1 422 5 is_stmt 1 view .LVU516
 422:./block/partition.c ****         printk(KERN_INFO "this size: %d of block  is not work\n",size);
 1959              		.loc 1 422 7 is_stmt 0 view .LVU517
 1960 00c8 8DB3     		cbz	r5, .L150
 426:./block/partition.c ****     tidy_up_MBR_Table(partition);                                                               //
 1961              		.loc 1 426 5 is_stmt 1 view .LVU518
 1962 00ca CDF80090 		str	r9, [sp]
 1963 00ce 2B46     		mov	r3, r5
 1964 00d0 2246     		mov	r2, r4
 1965 00d2 0021     		movs	r1, #0
 1966 00d4 5046     		mov	r0, r10
 1967 00d6 FFF7FEFF 		bl	MBR_partition_table_create
 1968              	.LVL192:
ARM GAS  /tmp/ccgt6wcN.s 			page 75


 427:./block/partition.c ****     mbr_partition_table_update(device,partition);                                                  
 1969              		.loc 1 427 5 view .LVU519
 1970 00da 3046     		mov	r0, r6
 1971 00dc FFF7FEFF 		bl	tidy_up_MBR_Table
 1972              	.LVL193:
 428:./block/partition.c ****     return 0;
 1973              		.loc 1 428 5 view .LVU520
 1974 00e0 3146     		mov	r1, r6
 1975 00e2 4046     		mov	r0, r8
 1976 00e4 FFF7FEFF 		bl	mbr_partition_table_update
 1977              	.LVL194:
 429:./block/partition.c **** }
 1978              		.loc 1 429 5 view .LVU521
 429:./block/partition.c **** }
 1979              		.loc 1 429 12 is_stmt 0 view .LVU522
 1980 00e8 0020     		movs	r0, #0
 1981              	.LVL195:
 1982              	.L125:
 430:./block/partition.c **** EXPORT_SYMBOL(mbr_partition_table_format);
 1983              		.loc 1 430 1 view .LVU523
 1984 00ea 04B0     		add	sp, sp, #16
 1985              	.LCFI38:
 1986              		.cfi_remember_state
 1987              		.cfi_def_cfa_offset 32
 1988              		@ sp needed
 1989 00ec BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1990              	.LVL196:
 1991              	.L146:
 1992              	.LCFI39:
 1993              		.cfi_restore_state
 388:./block/partition.c ****             return -1;
 1994              		.loc 1 388 12 is_stmt 1 view .LVU524
 1995 00f0 1A48     		ldr	r0, .L151+32
 1996 00f2 FFF7FEFF 		bl	printk
 1997              	.LVL197:
 389:./block/partition.c ****         }
 1998              		.loc 1 389 13 view .LVU525
 389:./block/partition.c ****         }
 1999              		.loc 1 389 20 is_stmt 0 view .LVU526
 2000 00f6 4FF0FF30 		mov	r0, #-1
 2001 00fa F6E7     		b	.L125
 2002              	.LVL198:
 2003              	.L147:
 407:./block/partition.c ****     else 
 2004              		.loc 1 407 9 is_stmt 1 view .LVU527
 407:./block/partition.c ****     else 
 2005              		.loc 1 407 23 is_stmt 0 view .LVU528
 2006 00fc 0131     		adds	r1, r1, #1
 2007 00fe 4046     		mov	r0, r8
 2008 0100 FFF7FEFF 		bl	get_mbr_partition_start_address
 2009              	.LVL199:
 2010 0104 0746     		mov	r7, r0
 2011              	.LVL200:
 410:./block/partition.c ****         end_address =device->bd_nr_sectors - 33 -1;                                          //
 2012              		.loc 1 410 5 is_stmt 1 view .LVU529
 410:./block/partition.c ****         end_address =device->bd_nr_sectors - 33 -1;                                          //
 2013              		.loc 1 410 7 is_stmt 0 view .LVU530
ARM GAS  /tmp/ccgt6wcN.s 			page 76


 2014 0106 B0F1FF3F 		cmp	r0, #-1
 2015 010a D8D1     		bne	.L138
 2016 010c D4E7     		b	.L137
 2017              	.LVL201:
 2018              	.L148:
 414:./block/partition.c ****         return -1;
 2019              		.loc 1 414 9 is_stmt 1 view .LVU531
 2020 010e 1448     		ldr	r0, .L151+36
 2021 0110 FFF7FEFF 		bl	printk
 2022              	.LVL202:
 415:./block/partition.c ****     }
 2023              		.loc 1 415 9 view .LVU532
 415:./block/partition.c ****     }
 2024              		.loc 1 415 16 is_stmt 0 view .LVU533
 2025 0114 4FF0FF30 		mov	r0, #-1
 2026 0118 E7E7     		b	.L125
 2027              	.L149:
 418:./block/partition.c ****         size = end_address - start_address;
 2028              		.loc 1 418 9 is_stmt 1 view .LVU534
 2029 011a 2946     		mov	r1, r5
 2030 011c 1148     		ldr	r0, .L151+40
 2031 011e FFF7FEFF 		bl	printk
 2032              	.LVL203:
 419:./block/partition.c ****         printk(KERN_INFO "New partition size: %d\n", size);
 2033              		.loc 1 419 9 view .LVU535
 419:./block/partition.c ****         printk(KERN_INFO "New partition size: %d\n", size);
 2034              		.loc 1 419 14 is_stmt 0 view .LVU536
 2035 0122 3D1B     		subs	r5, r7, r4
 2036              	.LVL204:
 420:./block/partition.c ****     }
 2037              		.loc 1 420 9 is_stmt 1 view .LVU537
 2038 0124 2946     		mov	r1, r5
 2039 0126 1048     		ldr	r0, .L151+44
 2040 0128 FFF7FEFF 		bl	printk
 2041              	.LVL205:
 2042 012c CCE7     		b	.L140
 2043              	.L150:
 423:./block/partition.c ****         return -1;
 2044              		.loc 1 423 9 view .LVU538
 2045 012e 2946     		mov	r1, r5
 2046 0130 0E48     		ldr	r0, .L151+48
 2047 0132 FFF7FEFF 		bl	printk
 2048              	.LVL206:
 424:./block/partition.c ****     }
 2049              		.loc 1 424 9 view .LVU539
 424:./block/partition.c ****     }
 2050              		.loc 1 424 16 is_stmt 0 view .LVU540
 2051 0136 4FF0FF30 		mov	r0, #-1
 2052 013a D6E7     		b	.L125
 2053              	.L152:
 2054              		.align	2
 2055              	.L151:
 2056 013c 7C000000 		.word	.LC10
 2057 0140 2C010000 		.word	.LC15
 2058 0144 00000000 		.word	.LC7
 2059 0148 1C000000 		.word	.LC8
 2060 014c 38000000 		.word	.LC9
ARM GAS  /tmp/ccgt6wcN.s 			page 77


 2061 0150 AC000000 		.word	.LC11
 2062 0154 BC000000 		.word	.LC12
 2063 0158 F4000000 		.word	.LC14
 2064 015c D8000000 		.word	.LC13
 2065 0160 4C010000 		.word	.LC16
 2066 0164 88010000 		.word	.LC17
 2067 0168 CC010000 		.word	.LC18
 2068 016c E4010000 		.word	.LC19
 2069              		.cfi_endproc
 2070              	.LFE1052:
 2072              		.section	.text.create_mbr_artiton,"ax",%progbits
 2073              		.align	1
 2074              		.global	create_mbr_artiton
 2075              		.syntax unified
 2076              		.thumb
 2077              		.thumb_func
 2079              	create_mbr_artiton:
 2080              	.LVL207:
 2081              	.LFB1056:
 521:./block/partition.c **** EXPORT_SYMBOL(get_partition_from_device);
 522:./block/partition.c **** 
 523:./block/partition.c **** #define mbr_partiton_startaddress 0x01
 524:./block/partition.c **** #define mbr_partiton_size         0x02
 525:./block/partition.c **** #define mbr_partiton_magic        0x03
 526:./block/partition.c **** 
 527:./block/partition.c **** 
 528:./block/partition.c **** /**
 529:./block/partition.c ****  * get_partiton_data - Retrieve specific partition data based on the flag
 530:./block/partition.c ****  * @partition: pointer to the partition structure
 531:./block/partition.c ****  * @number: partition number to get data for
 532:./block/partition.c ****  * @flag: flag to specify what partition data to retrieve
 533:./block/partition.c ****  *
 534:./block/partition.c ****  * This function retrieves specific partition data based on the given flag.
 535:./block/partition.c ****  * Depending on the flag value, it returns different pieces of information 
 536:./block/partition.c ****  * related to the specified partition. 
 537:./block/partition.c ****  * The flags used in this function correspond to partition start address, 
 538:./block/partition.c ****  * size, and type as per the MBR (Master Boot Record) partition table.
 539:./block/partition.c ****  *
 540:./block/partition.c ****  * Steps:
 541:./block/partition.c ****  * 1. Checks if the partition pointer is valid.
 542:./block/partition.c ****  * 2. Based on the flag, retrieves the corresponding partition data.
 543:./block/partition.c ****  *    - `mbr_partiton_startaddress`: Retrieves the partition's start address.
 544:./block/partition.c ****  *    - `mbr_partiton_size`: Retrieves the partition's size.
 545:./block/partition.c ****  *    - `mbr_partiton_magic`: Retrieves the partition's type.
 546:./block/partition.c ****  * 3. Returns the corresponding partition data or 0 if the partition is NULL or flag is unrecognize
 547:./block/partition.c ****  *
 548:./block/partition.c ****  * 
 549:./block/partition.c ****  * get_partiton_data - 
 550:./block/partition.c ****  * @partition: 
 551:./block/partition.c ****  * @number: 
 552:./block/partition.c ****  * @flag: 
 553:./block/partition.c ****  *
 554:./block/partition.c ****  * 
 555:./block/partition.c ****  * 
 556:./block/partition.c ****  *  MBR
 557:./block/partition.c ****  *
 558:./block/partition.c ****  * 
ARM GAS  /tmp/ccgt6wcN.s 			page 78


 559:./block/partition.c ****  * 1. 
 560:./block/partition.c ****  * 2. 
 561:./block/partition.c ****  *    - `mbr_partiton_startaddress`
 562:./block/partition.c ****  *    - `mbr_partiton_size`
 563:./block/partition.c ****  *    - `mbr_partiton_magic`
 564:./block/partition.c ****  * 3.  NULL 
 565:./block/partition.c ****  */
 566:./block/partition.c **** uint32_t get_partiton_data(struct partition* partition,int number,uint32_t flag)
 567:./block/partition.c **** {
 568:./block/partition.c ****     if(partition == NULL) return 0;
 569:./block/partition.c ****     if(flag == mbr_partiton_startaddress)
 570:./block/partition.c ****         return get_mbr_partition_start_address(partition, number);
 571:./block/partition.c ****     if(flag == mbr_partiton_size)
 572:./block/partition.c ****         return get_mbr_partition_size(partition,number);
 573:./block/partition.c ****     if(flag == mbr_partiton_magic)
 574:./block/partition.c ****         return get_mbr_partition_type(partition,number);
 575:./block/partition.c **** }
 576:./block/partition.c **** EXPORT_SYMBOL(get_partiton_data);
 577:./block/partition.c **** 
 578:./block/partition.c **** 
 579:./block/partition.c **** #define  FAT32 0x0B
 580:./block/partition.c **** #define  EXT   0x83
 581:./block/partition.c **** #define  NTFS  0x07
 582:./block/partition.c **** 
 583:./block/partition.c **** /**
 584:./block/partition.c ****  * create_mbr_artiton -  MBR 
 585:./block/partition.c ****  * @bdev: 
 586:./block/partition.c ****  * @size: 
 587:./block/partition.c ****  * @type: 
 588:./block/partition.c ****  *
 589:./block/partition.c ****  *  mbr_partition_table_format  MBR 
 590:./block/partition.c ****  *  mbr_partition_table_format 
 591:./block/partition.c ****  * 
 592:./block/partition.c ****  * 
 593:./block/partition.c ****  * create_mbr_artiton -  MBR 
 594:./block/partition.c ****  * @bdev: 
 595:./block/partition.c ****  * @size: 
 596:./block/partition.c ****  * @type: 
 597:./block/partition.c ****  *
 598:./block/partition.c ****  *  mbr_partition_table_format  MBR 
 599:./block/partition.c ****  *  mbr_partition_table_format 
 600:./block/partition.c ****  */
 601:./block/partition.c **** int create_mbr_artiton(struct block_device *bdev,size_t size,uint8_t type)
 602:./block/partition.c **** {
 2082              		.loc 1 602 1 is_stmt 1 view -0
 2083              		.cfi_startproc
 2084              		@ args = 0, pretend = 0, frame = 1064
 2085              		@ frame_needed = 0, uses_anonymous_args = 0
 2086              		.loc 1 602 1 is_stmt 0 view .LVU542
 2087 0000 00B5     		push	{lr}
 2088              	.LCFI40:
 2089              		.cfi_def_cfa_offset 4
 2090              		.cfi_offset 14, -4
 2091 0002 ADF22C4D 		subw	sp, sp, #1068
 2092              	.LCFI41:
 2093              		.cfi_def_cfa_offset 1072
 2094 0006 1346     		mov	r3, r2
ARM GAS  /tmp/ccgt6wcN.s 			page 79


 603:./block/partition.c ****     struct partition device_partition;
 2095              		.loc 1 603 5 is_stmt 1 view .LVU543
 604:./block/partition.c ****     return mbr_partition_table_format(bdev,&device_partition,size,type); 
 2096              		.loc 1 604 5 view .LVU544
 2097              		.loc 1 604 12 is_stmt 0 view .LVU545
 2098 0008 0A46     		mov	r2, r1
 2099              	.LVL208:
 2100              		.loc 1 604 12 view .LVU546
 2101 000a 01A9     		add	r1, sp, #4
 2102              	.LVL209:
 2103              		.loc 1 604 12 view .LVU547
 2104 000c FFF7FEFF 		bl	mbr_partition_table_format
 2105              	.LVL210:
 605:./block/partition.c **** }
 2106              		.loc 1 605 1 view .LVU548
 2107 0010 0DF22C4D 		addw	sp, sp, #1068
 2108              	.LCFI42:
 2109              		.cfi_def_cfa_offset 4
 2110              		@ sp needed
 2111 0014 5DF804FB 		ldr	pc, [sp], #4
 2112              		.cfi_endproc
 2113              	.LFE1056:
 2115              		.section	.text.get_mbr_partition_type,"ax",%progbits
 2116              		.align	1
 2117              		.syntax unified
 2118              		.thumb
 2119              		.thumb_func
 2121              	get_mbr_partition_type:
 2122              	.LVL211:
 2123              	.LFB1043:
 165:./block/partition.c ****     if(number < 0 || number > 3)
 2124              		.loc 1 165 78 is_stmt 1 view -0
 2125              		.cfi_startproc
 2126              		@ args = 0, pretend = 0, frame = 0
 2127              		@ frame_needed = 0, uses_anonymous_args = 0
 166:./block/partition.c ****         return 0xff;
 2128              		.loc 1 166 5 view .LVU550
 166:./block/partition.c ****         return 0xff;
 2129              		.loc 1 166 7 is_stmt 0 view .LVU551
 2130 0000 0329     		cmp	r1, #3
 2131 0002 0BD8     		bhi	.L157
 165:./block/partition.c ****     if(number < 0 || number > 3)
 2132              		.loc 1 165 78 view .LVU552
 2133 0004 38B5     		push	{r3, r4, r5, lr}
 2134              	.LCFI43:
 2135              		.cfi_def_cfa_offset 16
 2136              		.cfi_offset 3, -16
 2137              		.cfi_offset 4, -12
 2138              		.cfi_offset 5, -8
 2139              		.cfi_offset 14, -4
 2140 0006 0546     		mov	r5, r0
 2141 0008 0C46     		mov	r4, r1
 168:./block/partition.c ****     if(check_empty_MBR_Table(partition,number) == 1)
 2142              		.loc 1 168 5 is_stmt 1 view .LVU553
 2143              	.LVL212:
 169:./block/partition.c ****         return 0xff;
 2144              		.loc 1 169 5 view .LVU554
ARM GAS  /tmp/ccgt6wcN.s 			page 80


 169:./block/partition.c ****         return 0xff;
 2145              		.loc 1 169 8 is_stmt 0 view .LVU555
 2146 000a FFF7FEFF 		bl	check_empty_MBR_Table
 2147              	.LVL213:
 169:./block/partition.c ****         return 0xff;
 2148              		.loc 1 169 7 discriminator 1 view .LVU556
 2149 000e 0128     		cmp	r0, #1
 2150 0010 06D0     		beq	.L158
 171:./block/partition.c **** }
 2151              		.loc 1 171 5 is_stmt 1 view .LVU557
 171:./block/partition.c **** }
 2152              		.loc 1 171 25 is_stmt 0 view .LVU558
 2153 0012 3E34     		adds	r4, r4, #62
 2154              	.LVL214:
 171:./block/partition.c **** }
 2155              		.loc 1 171 25 view .LVU559
 2156 0014 05EB0415 		add	r5, r5, r4, lsl #4
 2157              	.LVL215:
 171:./block/partition.c **** }
 2158              		.loc 1 171 25 view .LVU560
 2159 0018 287A     		ldrb	r0, [r5, #8]	@ zero_extendqisi2
 2160              	.LVL216:
 2161              	.L156:
 172:./block/partition.c **** 
 2162              		.loc 1 172 1 view .LVU561
 2163 001a 38BD     		pop	{r3, r4, r5, pc}
 2164              	.LVL217:
 2165              	.L157:
 2166              	.LCFI44:
 2167              		.cfi_def_cfa_offset 0
 2168              		.cfi_restore 3
 2169              		.cfi_restore 4
 2170              		.cfi_restore 5
 2171              		.cfi_restore 14
 167:./block/partition.c ****     struct mbr_partition *mbr_partition = &partition->mbr_partition[number];
 2172              		.loc 1 167 16 view .LVU562
 2173 001c FF20     		movs	r0, #255
 2174              	.LVL218:
 172:./block/partition.c **** 
 2175              		.loc 1 172 1 view .LVU563
 2176 001e 7047     		bx	lr
 2177              	.LVL219:
 2178              	.L158:
 2179              	.LCFI45:
 2180              		.cfi_def_cfa_offset 16
 2181              		.cfi_offset 3, -16
 2182              		.cfi_offset 4, -12
 2183              		.cfi_offset 5, -8
 2184              		.cfi_offset 14, -4
 170:./block/partition.c ****     return mbr_partition->sys_ind;
 2185              		.loc 1 170 16 view .LVU564
 2186 0020 FF20     		movs	r0, #255
 2187 0022 FAE7     		b	.L156
 2188              		.cfi_endproc
 2189              	.LFE1043:
 2191              		.section	.text.get_partiton_data,"ax",%progbits
 2192              		.align	1
ARM GAS  /tmp/ccgt6wcN.s 			page 81


 2193              		.global	get_partiton_data
 2194              		.syntax unified
 2195              		.thumb
 2196              		.thumb_func
 2198              	get_partiton_data:
 2199              	.LVL220:
 2200              	.LFB1055:
 567:./block/partition.c ****     if(partition == NULL) return 0;
 2201              		.loc 1 567 1 is_stmt 1 view -0
 2202              		.cfi_startproc
 2203              		@ args = 0, pretend = 0, frame = 0
 2204              		@ frame_needed = 0, uses_anonymous_args = 0
 568:./block/partition.c ****     if(flag == mbr_partiton_startaddress)
 2205              		.loc 1 568 5 view .LVU566
 568:./block/partition.c ****     if(flag == mbr_partiton_startaddress)
 2206              		.loc 1 568 7 is_stmt 0 view .LVU567
 2207 0000 80B1     		cbz	r0, .L168
 567:./block/partition.c ****     if(partition == NULL) return 0;
 2208              		.loc 1 567 1 view .LVU568
 2209 0002 08B5     		push	{r3, lr}
 2210              	.LCFI46:
 2211              		.cfi_def_cfa_offset 8
 2212              		.cfi_offset 3, -8
 2213              		.cfi_offset 14, -4
 569:./block/partition.c ****         return get_mbr_partition_start_address(partition, number);
 2214              		.loc 1 569 5 is_stmt 1 view .LVU569
 569:./block/partition.c ****         return get_mbr_partition_start_address(partition, number);
 2215              		.loc 1 569 7 is_stmt 0 view .LVU570
 2216 0004 012A     		cmp	r2, #1
 2217 0006 04D0     		beq	.L173
 571:./block/partition.c ****         return get_mbr_partition_size(partition,number);
 2218              		.loc 1 571 5 is_stmt 1 view .LVU571
 571:./block/partition.c ****         return get_mbr_partition_size(partition,number);
 2219              		.loc 1 571 7 is_stmt 0 view .LVU572
 2220 0008 022A     		cmp	r2, #2
 2221 000a 05D0     		beq	.L174
 573:./block/partition.c ****         return get_mbr_partition_type(partition,number);
 2222              		.loc 1 573 5 is_stmt 1 view .LVU573
 573:./block/partition.c ****         return get_mbr_partition_type(partition,number);
 2223              		.loc 1 573 7 is_stmt 0 view .LVU574
 2224 000c 032A     		cmp	r2, #3
 2225 000e 06D0     		beq	.L175
 2226              	.LVL221:
 2227              	.L163:
 575:./block/partition.c **** EXPORT_SYMBOL(get_partiton_data);
 2228              		.loc 1 575 1 view .LVU575
 2229 0010 08BD     		pop	{r3, pc}
 2230              	.LVL222:
 2231              	.L173:
 570:./block/partition.c ****     if(flag == mbr_partiton_size)
 2232              		.loc 1 570 9 is_stmt 1 view .LVU576
 570:./block/partition.c ****     if(flag == mbr_partiton_size)
 2233              		.loc 1 570 16 is_stmt 0 view .LVU577
 2234 0012 FFF7FEFF 		bl	get_mbr_partition_start_address
 2235              	.LVL223:
 570:./block/partition.c ****     if(flag == mbr_partiton_size)
 2236              		.loc 1 570 16 view .LVU578
ARM GAS  /tmp/ccgt6wcN.s 			page 82


 2237 0016 FBE7     		b	.L163
 2238              	.LVL224:
 2239              	.L174:
 572:./block/partition.c ****     if(flag == mbr_partiton_magic)
 2240              		.loc 1 572 9 is_stmt 1 view .LVU579
 572:./block/partition.c ****     if(flag == mbr_partiton_magic)
 2241              		.loc 1 572 16 is_stmt 0 view .LVU580
 2242 0018 FFF7FEFF 		bl	get_mbr_partition_size
 2243              	.LVL225:
 572:./block/partition.c ****     if(flag == mbr_partiton_magic)
 2244              		.loc 1 572 16 view .LVU581
 2245 001c F8E7     		b	.L163
 2246              	.LVL226:
 2247              	.L175:
 574:./block/partition.c **** }
 2248              		.loc 1 574 9 is_stmt 1 view .LVU582
 574:./block/partition.c **** }
 2249              		.loc 1 574 16 is_stmt 0 view .LVU583
 2250 001e FFF7FEFF 		bl	get_mbr_partition_type
 2251              	.LVL227:
 574:./block/partition.c **** }
 2252              		.loc 1 574 16 view .LVU584
 2253 0022 F5E7     		b	.L163
 2254              	.LVL228:
 2255              	.L168:
 2256              	.LCFI47:
 2257              		.cfi_def_cfa_offset 0
 2258              		.cfi_restore 3
 2259              		.cfi_restore 14
 568:./block/partition.c ****     if(flag == mbr_partiton_startaddress)
 2260              		.loc 1 568 34 discriminator 1 view .LVU585
 2261 0024 0020     		movs	r0, #0
 2262              	.LVL229:
 575:./block/partition.c **** EXPORT_SYMBOL(get_partiton_data);
 2263              		.loc 1 575 1 view .LVU586
 2264 0026 7047     		bx	lr
 2265              		.cfi_endproc
 2266              	.LFE1055:
 2268              		.section	.text.get_partition_type,"ax",%progbits
 2269              		.align	1
 2270              		.global	get_partition_type
 2271              		.syntax unified
 2272              		.thumb
 2273              		.thumb_func
 2275              	get_partition_type:
 2276              	.LVL230:
 2277              	.LFB1057:
 606:./block/partition.c **** EXPORT_SYMBOL(create_mbr_artiton);
 607:./block/partition.c **** 
 608:./block/partition.c **** 
 609:./block/partition.c **** /**
 610:./block/partition.c ****  * get_partition_type - 
 611:./block/partition.c ****  * @bdev: 
 612:./block/partition.c ****  *
 613:./block/partition.c ****  *  MBR  GPT 
 614:./block/partition.c ****  *  detect_partition_table 
 615:./block/partition.c ****  *
ARM GAS  /tmp/ccgt6wcN.s 			page 83


 616:./block/partition.c ****  * 
 617:./block/partition.c ****  * -  BLOCK_DEVICE_FLAG_MBR, BLOCK_DEVICE_FLAG_GPT 
 618:./block/partition.c ****  *
 619:./block/partition.c ****  * 
 620:./block/partition.c ****  * get_partition_type - 
 621:./block/partition.c ****  * @bdev: 
 622:./block/partition.c ****  *
 623:./block/partition.c ****  *  MBR  GPT 
 624:./block/partition.c ****  *  detect_partition_table 
 625:./block/partition.c ****  *
 626:./block/partition.c ****  * 
 627:./block/partition.c ****  * -  BLOCK_DEVICE_FLAG_MBR  BLOCK_DEVICE_FLAG_GPT
 628:./block/partition.c ****  */
 629:./block/partition.c **** int get_partition_type(struct block_device *bdev)
 630:./block/partition.c **** {
 2278              		.loc 1 630 1 is_stmt 1 view -0
 2279              		.cfi_startproc
 2280              		@ args = 0, pretend = 0, frame = 8
 2281              		@ frame_needed = 0, uses_anonymous_args = 0
 2282              		.loc 1 630 1 is_stmt 0 view .LVU588
 2283 0000 30B5     		push	{r4, r5, lr}
 2284              	.LCFI48:
 2285              		.cfi_def_cfa_offset 12
 2286              		.cfi_offset 4, -12
 2287              		.cfi_offset 5, -8
 2288              		.cfi_offset 14, -4
 2289 0002 83B0     		sub	sp, sp, #12
 2290              	.LCFI49:
 2291              		.cfi_def_cfa_offset 24
 2292 0004 0446     		mov	r4, r0
 631:./block/partition.c ****     enum block_device_flags_t flags;
 2293              		.loc 1 631 5 is_stmt 1 view .LVU589
 632:./block/partition.c ****     char *buffer = kmalloc(512,GFP_KERNEL);
 2294              		.loc 1 632 5 view .LVU590
 2295              	.LVL231:
 2296              	.LBB116:
 2297              	.LBI116:
 379:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 2298              		.loc 3 379 21 view .LVU591
 2299              	.LBB117:
 380:./include/linux/slab.h **** }
 2300              		.loc 3 380 2 view .LVU592
 380:./include/linux/slab.h **** }
 2301              		.loc 3 380 9 is_stmt 0 view .LVU593
 2302 0006 4FF44C61 		mov	r1, #3264
 2303 000a 4FF40070 		mov	r0, #512
 2304              	.LVL232:
 380:./include/linux/slab.h **** }
 2305              		.loc 3 380 9 view .LVU594
 2306 000e FFF7FEFF 		bl	__smalloc__
 2307              	.LVL233:
 380:./include/linux/slab.h **** }
 2308              		.loc 3 380 9 view .LVU595
 2309              	.LBE117:
 2310              	.LBE116:
 633:./block/partition.c ****     if(buffer == NULL) return -ENOMEM;
 2311              		.loc 1 633 5 is_stmt 1 view .LVU596
ARM GAS  /tmp/ccgt6wcN.s 			page 84


 2312              		.loc 1 633 7 is_stmt 0 view .LVU597
 2313 0012 68B1     		cbz	r0, .L178
 2314 0014 0546     		mov	r5, r0
 634:./block/partition.c ****     detect_partition_table(bdev,buffer,&flags);
 2315              		.loc 1 634 5 is_stmt 1 view .LVU598
 2316 0016 0DF10702 		add	r2, sp, #7
 2317 001a 0146     		mov	r1, r0
 2318 001c 2046     		mov	r0, r4
 2319              	.LVL234:
 2320              		.loc 1 634 5 is_stmt 0 view .LVU599
 2321 001e FFF7FEFF 		bl	detect_partition_table
 2322              	.LVL235:
 635:./block/partition.c ****     kfree(buffer);
 2323              		.loc 1 635 5 is_stmt 1 view .LVU600
 2324              	.LBB118:
 2325              	.LBI118:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 2326              		.loc 3 383 20 view .LVU601
 2327              	.LBB119:
 2328              		.loc 3 384 2 view .LVU602
 2329 0022 2846     		mov	r0, r5
 2330 0024 FFF7FEFF 		bl	__sfree__
 2331              	.LVL236:
 2332              		.loc 3 384 2 is_stmt 0 view .LVU603
 2333              	.LBE119:
 2334              	.LBE118:
 636:./block/partition.c ****     return flags;
 2335              		.loc 1 636 5 is_stmt 1 view .LVU604
 2336              		.loc 1 636 12 is_stmt 0 view .LVU605
 2337 0028 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 2338              	.LVL237:
 2339              	.L176:
 637:./block/partition.c **** }
 2340              		.loc 1 637 1 view .LVU606
 2341 002c 03B0     		add	sp, sp, #12
 2342              	.LCFI50:
 2343              		.cfi_remember_state
 2344              		.cfi_def_cfa_offset 12
 2345              		@ sp needed
 2346 002e 30BD     		pop	{r4, r5, pc}
 2347              	.LVL238:
 2348              	.L178:
 2349              	.LCFI51:
 2350              		.cfi_restore_state
 633:./block/partition.c ****     detect_partition_table(bdev,buffer,&flags);
 2351              		.loc 1 633 31 discriminator 1 view .LVU607
 2352 0030 6FF00B00 		mvn	r0, #11
 2353              	.LVL239:
 633:./block/partition.c ****     detect_partition_table(bdev,buffer,&flags);
 2354              		.loc 1 633 31 discriminator 1 view .LVU608
 2355 0034 FAE7     		b	.L176
 2356              		.cfi_endproc
 2357              	.LFE1057:
 2359              		.section	.rodata.str1.4,"aMS",%progbits,1
 2360              		.align	2
 2361              	.LC20:
 2362 0000 63726561 		.ascii	"create_mbr_artiton\000"
ARM GAS  /tmp/ccgt6wcN.s 			page 85


 2362      74655F6D 
 2362      62725F61 
 2362      72746974 
 2362      6F6E00
 2363 0013 00       		.align	2
 2364              	.LC21:
 2365 0014 00       		.ascii	"\000"
 2366              		.section	.export_table,"aw"
 2367              		.align	2
 2370              	create_mbr_artiton_export_struct:
 2371 0000 00000000 		.word	.LC20
 2372 0004 14000000 		.word	.LC21
 2373 0008 00000000 		.word	create_mbr_artiton
 2374              		.section	.rodata.str1.4
 2375 0015 000000   		.align	2
 2376              	.LC22:
 2377 0018 6765745F 		.ascii	"get_partiton_data\000"
 2377      70617274 
 2377      69746F6E 
 2377      5F646174 
 2377      6100
 2378              		.section	.export_table
 2379              		.align	2
 2382              	get_partiton_data_export_struct:
 2383 000c 18000000 		.word	.LC22
 2384 0010 14000000 		.word	.LC21
 2385 0014 00000000 		.word	get_partiton_data
 2386              		.section	.rodata.str1.4
 2387 002a 0000     		.align	2
 2388              	.LC23:
 2389 002c 6765745F 		.ascii	"get_partition_from_device\000"
 2389      70617274 
 2389      6974696F 
 2389      6E5F6672 
 2389      6F6D5F64 
 2390              		.section	.export_table
 2391              		.align	2
 2394              	get_partition_from_device_export_struct:
 2395 0018 2C000000 		.word	.LC23
 2396 001c 14000000 		.word	.LC21
 2397 0020 00000000 		.word	get_partition_from_device
 2398              		.section	.rodata.str1.4
 2399 0046 0000     		.align	2
 2400              	.LC24:
 2401 0048 6D62725F 		.ascii	"mbr_partition_table_format\000"
 2401      70617274 
 2401      6974696F 
 2401      6E5F7461 
 2401      626C655F 
 2402              		.section	.export_table
 2403              		.align	2
 2406              	mbr_partition_table_format_export_struct:
 2407 0024 48000000 		.word	.LC24
 2408 0028 14000000 		.word	.LC21
 2409 002c 00000000 		.word	mbr_partition_table_format
 2410              		.section	.rodata.str1.4
 2411 0063 00       		.align	2
ARM GAS  /tmp/ccgt6wcN.s 			page 86


 2412              	.LC25:
 2413 0064 6D62725F 		.ascii	"mbr_table_delete\000"
 2413      7461626C 
 2413      655F6465 
 2413      6C657465 
 2413      00
 2414              		.section	.export_table
 2415              		.align	2
 2418              	mbr_table_delete_export_struct:
 2419 0030 64000000 		.word	.LC25
 2420 0034 14000000 		.word	.LC21
 2421 0038 00000000 		.word	mbr_table_delete
 2422              		.section	.rodata.str1.4
 2423 0075 000000   		.align	2
 2424              	.LC26:
 2425 0078 64657465 		.ascii	"detect_partition_table\000"
 2425      63745F70 
 2425      61727469 
 2425      74696F6E 
 2425      5F746162 
 2426              		.section	.export_table
 2427              		.align	2
 2430              	detect_partition_table_export_struct:
 2431 003c 78000000 		.word	.LC26
 2432 0040 14000000 		.word	.LC21
 2433 0044 00000000 		.word	detect_partition_table
 2434              		.section	.data.gpt_head,"aw"
 2435              		.align	2
 2438              	gpt_head:
 2439 0000 45464920 		.ascii	"EFI PART"
 2439      50415254 
 2440              		.text
 2441              	.Letext0:
 2442              		.file 7 "./include/asm-generic/int-l64.h"
 2443              		.file 8 "./include/asm-generic/posix_types.h"
 2444              		.file 9 "./include/uapi/linux/types.h"
 2445              		.file 10 "./include/linux/types.h"
 2446              		.file 11 "./include/linux/export.h"
 2447              		.file 12 "./include/linux/stddef.h"
 2448              		.file 13 "./include/linux/gfp_types.h"
 2449              		.file 14 "./include/linux/reciprocal_div.h"
 2450              		.file 15 "./include/linux/time64.h"
 2451              		.file 16 "./arch/arm_m/include/asm/spinlock.h"
 2452              		.file 17 "./include/linux/spinlock_types_raw.h"
 2453              		.file 18 "./include/linux/spinlock_types.h"
 2454              		.file 19 "./include/linux/errseq.h"
 2455              		.file 20 "./include/linux/rbtree_types.h"
 2456              		.file 21 "./include/linux/uidgid_types.h"
 2457              		.file 22 "./include/linux/projid.h"
 2458              		.file 23 "./include/linux/fs.h"
 2459              		.file 24 "./include/linux/mnt_idmapping.h"
 2460              		.file 25 "./include/linux/mutex.h"
 2461              		.file 26 "./include/linux/uio.h"
 2462              		.file 27 "./include/linux/wait.h"
 2463              		.file 28 "./include/linux/xarray.h"
 2464              		.file 29 "./include/linux/migrate_mode.h"
 2465              		.file 30 "./include/linux/rw_hint.h"
ARM GAS  /tmp/ccgt6wcN.s 			page 87


 2466              		.file 31 "./include/linux/bvec.h"
 2467              		.file 32 "./include/linux/blk_types.h"
 2468              		.file 33 "./include/linux/blkdev.h"
 2469              		.file 34 "./include/linux/mempool_super_haper.h"
 2470              		.file 35 "./include/linux/mempool.h"
 2471              		.file 36 "./include/linux/lockdep_types.h"
 2472              		.file 37 "./include/linux/workqueue_types.h"
 2473              		.file 38 "./include/linux/blk-mq.h"
 2474              		.file 39 "./include/linux/dcache.h"
 2475              		.file 40 "./include/uapi/linux/pr.h"
 2476              		.file 41 "./include/linux/pr.h"
 2477              		.file 42 "./include/linux/hdreg.h"
 2478              		.file 43 "./include/linux/lockref.h"
 2479              		.file 44 "./include/linux/path.h"
 2480              		.file 45 "./include/linux/statfs.h"
 2481              		.file 46 "./include/linux/stat.h"
 2482              		.file 47 "./arch/arm_m/include/asm/string.h"
 2483              		.file 48 "./include/linux/printk.h"
 2484              		.file 49 "./include/linux/instrumented.h"
 2485              		.file 50 "./include/linux/kcsan-checks.h"
 2486              		.file 51 "./include/linux/kasan-checks.h"
ARM GAS  /tmp/ccgt6wcN.s 			page 88


DEFINED SYMBOLS
                            *ABS*:00000000 partition.c
     /tmp/ccgt6wcN.s:21     .text.my_end_io:00000000 $t
     /tmp/ccgt6wcN.s:26     .text.my_end_io:00000000 my_end_io
     /tmp/ccgt6wcN.s:48     .text.__page_create:00000000 $t
     /tmp/ccgt6wcN.s:53     .text.__page_create:00000000 __page_create
     /tmp/ccgt6wcN.s:165    .text.trans_data_to_blk_dev:00000000 $t
     /tmp/ccgt6wcN.s:170    .text.trans_data_to_blk_dev:00000000 trans_data_to_blk_dev
     /tmp/ccgt6wcN.s:351    .text.trans_data_to_blk_dev:0000007c $d
     /tmp/ccgt6wcN.s:357    .text.detect_partition_table:00000000 $t
     /tmp/ccgt6wcN.s:362    .text.detect_partition_table:00000000 detect_partition_table
     /tmp/ccgt6wcN.s:469    .text.detect_partition_table:00000064 $d
     /tmp/ccgt6wcN.s:2438   .data.gpt_head:00000000 gpt_head
     /tmp/ccgt6wcN.s:474    .rodata.MBR_partition_table_create.str1.4:00000000 $d
     /tmp/ccgt6wcN.s:479    .text.MBR_partition_table_create:00000000 $t
     /tmp/ccgt6wcN.s:484    .text.MBR_partition_table_create:00000000 MBR_partition_table_create
     /tmp/ccgt6wcN.s:563    .text.MBR_partition_table_create:00000044 $d
     /tmp/ccgt6wcN.s:568    .text.move_MBR_Table:00000000 $t
     /tmp/ccgt6wcN.s:573    .text.move_MBR_Table:00000000 move_MBR_Table
     /tmp/ccgt6wcN.s:606    .rodata.mbr_partition_table_load.str1.4:00000000 $d
     /tmp/ccgt6wcN.s:613    .text.mbr_partition_table_load:00000000 $t
     /tmp/ccgt6wcN.s:618    .text.mbr_partition_table_load:00000000 mbr_partition_table_load
     /tmp/ccgt6wcN.s:811    .text.mbr_partition_table_load:000000a0 $d
     /tmp/ccgt6wcN.s:817    .text.mbr_partition_table_update:00000000 $t
     /tmp/ccgt6wcN.s:822    .text.mbr_partition_table_update:00000000 mbr_partition_table_update
     /tmp/ccgt6wcN.s:1011   .text.get_partition_from_device:00000000 $t
     /tmp/ccgt6wcN.s:1017   .text.get_partition_from_device:00000000 get_partition_from_device
     /tmp/ccgt6wcN.s:1107   .text.check_empty_MBR_Table:00000000 $t
     /tmp/ccgt6wcN.s:1113   .text.check_empty_MBR_Table:00000000 check_empty_MBR_Table
     /tmp/ccgt6wcN.s:1173   .text.tidy_up_MBR_Table:00000000 $t
     /tmp/ccgt6wcN.s:1178   .text.tidy_up_MBR_Table:00000000 tidy_up_MBR_Table
     /tmp/ccgt6wcN.s:1308   .rodata.mbr_table_delete.str1.4:00000000 $d
     /tmp/ccgt6wcN.s:1321   .text.mbr_table_delete:00000000 $t
     /tmp/ccgt6wcN.s:1326   .text.mbr_table_delete:00000000 mbr_table_delete
     /tmp/ccgt6wcN.s:1469   .text.mbr_table_delete:00000090 $d
     /tmp/ccgt6wcN.s:1477   .text.get_empty_MBR_Table:00000000 $t
     /tmp/ccgt6wcN.s:1482   .text.get_empty_MBR_Table:00000000 get_empty_MBR_Table
     /tmp/ccgt6wcN.s:1550   .text.get_mbr_partition_size:00000000 $t
     /tmp/ccgt6wcN.s:1555   .text.get_mbr_partition_size:00000000 get_mbr_partition_size
     /tmp/ccgt6wcN.s:1622   .text.get_mbr_partition_start_address:00000000 $t
     /tmp/ccgt6wcN.s:1627   .text.get_mbr_partition_start_address:00000000 get_mbr_partition_start_address
     /tmp/ccgt6wcN.s:1692   .text.get_mbr_partition_start_address:00000030 $d
     /tmp/ccgt6wcN.s:1697   .rodata.mbr_partition_table_format.str1.4:00000000 $d
     /tmp/ccgt6wcN.s:1741   .text.mbr_partition_table_format:00000000 $t
     /tmp/ccgt6wcN.s:1746   .text.mbr_partition_table_format:00000000 mbr_partition_table_format
     /tmp/ccgt6wcN.s:2056   .text.mbr_partition_table_format:0000013c $d
     /tmp/ccgt6wcN.s:2073   .text.create_mbr_artiton:00000000 $t
     /tmp/ccgt6wcN.s:2079   .text.create_mbr_artiton:00000000 create_mbr_artiton
     /tmp/ccgt6wcN.s:2116   .text.get_mbr_partition_type:00000000 $t
     /tmp/ccgt6wcN.s:2121   .text.get_mbr_partition_type:00000000 get_mbr_partition_type
     /tmp/ccgt6wcN.s:2192   .text.get_partiton_data:00000000 $t
     /tmp/ccgt6wcN.s:2198   .text.get_partiton_data:00000000 get_partiton_data
     /tmp/ccgt6wcN.s:2269   .text.get_partition_type:00000000 $t
     /tmp/ccgt6wcN.s:2275   .text.get_partition_type:00000000 get_partition_type
     /tmp/ccgt6wcN.s:2360   .rodata.str1.4:00000000 $d
     /tmp/ccgt6wcN.s:2367   .export_table:00000000 $d
     /tmp/ccgt6wcN.s:2370   .export_table:00000000 create_mbr_artiton_export_struct
ARM GAS  /tmp/ccgt6wcN.s 			page 89


     /tmp/ccgt6wcN.s:2382   .export_table:0000000c get_partiton_data_export_struct
     /tmp/ccgt6wcN.s:2394   .export_table:00000018 get_partition_from_device_export_struct
     /tmp/ccgt6wcN.s:2406   .export_table:00000024 mbr_partition_table_format_export_struct
     /tmp/ccgt6wcN.s:2418   .export_table:00000030 mbr_table_delete_export_struct
     /tmp/ccgt6wcN.s:2430   .export_table:0000003c detect_partition_table_export_struct
     /tmp/ccgt6wcN.s:2435   .data.gpt_head:00000000 $d

UNDEFINED SYMBOLS
bio_put
__smalloc__
bio_alloc_bioset
bio_add_page
submit_bio_wait
fs_bio_set
memcmp
printk
__sfree__
