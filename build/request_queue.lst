ARM GAS  /tmp/cczZAjmm.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"request_queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./block/request_queue.c"
  20              		.section	.text.__spin_init,"ax",%progbits
  21              		.align	1
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	__spin_init:
  27              	.LVL0:
  28              	.LFB228:
  29              		.file 2 "./arch/arm_m/include/asm/spinlock.h"
   1:./arch/arm_m/include/asm/spinlock.h **** #ifndef __SPIN_LOCK_H_
   2:./arch/arm_m/include/asm/spinlock.h **** #define __SPIN_LOCK_H_
   3:./arch/arm_m/include/asm/spinlock.h **** 
   4:./arch/arm_m/include/asm/spinlock.h **** #include <linux/sched.h>
   5:./arch/arm_m/include/asm/spinlock.h **** 
   6:./arch/arm_m/include/asm/spinlock.h **** typedef struct { 
   7:./arch/arm_m/include/asm/spinlock.h ****      int flag; 
   8:./arch/arm_m/include/asm/spinlock.h **** } arch_spinlock_t;
   9:./arch/arm_m/include/asm/spinlock.h **** 
  10:./arch/arm_m/include/asm/spinlock.h **** static int __spin_init(arch_spinlock_t *lock) 
  11:./arch/arm_m/include/asm/spinlock.h **** {
  30              		.loc 2 11 1 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		@ link register save eliminated.
  12:./arch/arm_m/include/asm/spinlock.h ****     lock->flag = 0;
  35              		.loc 2 12 5 view .LVU1
  36              		.loc 2 12 16 is_stmt 0 view .LVU2
  37 0000 0023     		movs	r3, #0
  38 0002 0360     		str	r3, [r0]
  39              	.LVL1:
  13:./arch/arm_m/include/asm/spinlock.h **** }
  40              		.loc 2 13 1 view .LVU3
  41 0004 7047     		bx	lr
  42              		.cfi_endproc
  43              	.LFE228:
  45              		.section	.text.__spin_unlock,"ax",%progbits
  46              		.align	1
ARM GAS  /tmp/cczZAjmm.s 			page 2


  47              		.syntax unified
  48              		.thumb
  49              		.thumb_func
  51              	__spin_unlock:
  52              	.LVL2:
  53              	.LFB230:
  14:./arch/arm_m/include/asm/spinlock.h **** 
  15:./arch/arm_m/include/asm/spinlock.h **** static int __spin_lock(arch_spinlock_t *lock) {
  16:./arch/arm_m/include/asm/spinlock.h **** 
  17:./arch/arm_m/include/asm/spinlock.h ****     stop_all_scheduler();
  18:./arch/arm_m/include/asm/spinlock.h ****     if(lock->flag == 0){
  19:./arch/arm_m/include/asm/spinlock.h ****           lock->flag = 1;  
  20:./arch/arm_m/include/asm/spinlock.h ****           start_all_scheduler();
  21:./arch/arm_m/include/asm/spinlock.h ****         return 1;
  22:./arch/arm_m/include/asm/spinlock.h ****     }
  23:./arch/arm_m/include/asm/spinlock.h ****     else
  24:./arch/arm_m/include/asm/spinlock.h ****     {
  25:./arch/arm_m/include/asm/spinlock.h ****         start_all_scheduler();
  26:./arch/arm_m/include/asm/spinlock.h ****         return 0;
  27:./arch/arm_m/include/asm/spinlock.h ****     }
  28:./arch/arm_m/include/asm/spinlock.h **** }
  29:./arch/arm_m/include/asm/spinlock.h **** 
  30:./arch/arm_m/include/asm/spinlock.h **** static void  __spin_unlock( arch_spinlock_t *lock ){
  54              		.loc 2 30 52 is_stmt 1 view -0
  55              		.cfi_startproc
  56              		@ args = 0, pretend = 0, frame = 0
  57              		@ frame_needed = 0, uses_anonymous_args = 0
  58              		@ link register save eliminated.
  31:./arch/arm_m/include/asm/spinlock.h ****     lock->flag = 0;
  59              		.loc 2 31 5 view .LVU5
  60              		.loc 2 31 16 is_stmt 0 view .LVU6
  61 0000 0023     		movs	r3, #0
  62 0002 0360     		str	r3, [r0]
  32:./arch/arm_m/include/asm/spinlock.h **** }
  63              		.loc 2 32 1 view .LVU7
  64 0004 7047     		bx	lr
  65              		.cfi_endproc
  66              	.LFE230:
  68              		.section	.text.spin_lock_init,"ax",%progbits
  69              		.align	1
  70              		.syntax unified
  71              		.thumb
  72              		.thumb_func
  74              	spin_lock_init:
  75              	.LVL3:
  76              	.LFB231:
  77              		.file 3 "./include/linux/spinlock.h"
   1:./include/linux/spinlock.h **** #ifndef __SPINLOCK_H__
   2:./include/linux/spinlock.h **** #define __SPINLOCK_H__
   3:./include/linux/spinlock.h **** 
   4:./include/linux/spinlock.h **** #include <linux/types.h>
   5:./include/linux/spinlock.h **** #include <linux/spinlock_types.h>
   6:./include/linux/spinlock.h **** #include <linux/sched.h>
   7:./include/linux/spinlock.h **** 
   8:./include/linux/spinlock.h **** 
   9:./include/linux/spinlock.h **** 
  10:./include/linux/spinlock.h **** static void spin_lock_init(spinlock_t* lock){
ARM GAS  /tmp/cczZAjmm.s 			page 3


  78              		.loc 3 10 45 is_stmt 1 view -0
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 0
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82              		.loc 3 10 45 is_stmt 0 view .LVU9
  83 0000 08B5     		push	{r3, lr}
  84              	.LCFI0:
  85              		.cfi_def_cfa_offset 8
  86              		.cfi_offset 3, -8
  87              		.cfi_offset 14, -4
  11:./include/linux/spinlock.h ****     __spin_init(&lock->rlock.raw_lock);
  88              		.loc 3 11 5 is_stmt 1 view .LVU10
  89 0002 FFF7FEFF 		bl	__spin_init
  90              	.LVL4:
  12:./include/linux/spinlock.h **** }
  91              		.loc 3 12 1 is_stmt 0 view .LVU11
  92 0006 08BD     		pop	{r3, pc}
  93              		.cfi_endproc
  94              	.LFE231:
  96              		.section	.text.spin_unlock,"ax",%progbits
  97              		.align	1
  98              		.syntax unified
  99              		.thumb
 100              		.thumb_func
 102              	spin_unlock:
 103              	.LVL5:
 104              	.LFB233:
  13:./include/linux/spinlock.h **** 
  14:./include/linux/spinlock.h **** static void spin_lock(spinlock_t* lock)
  15:./include/linux/spinlock.h **** {  
  16:./include/linux/spinlock.h ****     while (1)
  17:./include/linux/spinlock.h ****     {
  18:./include/linux/spinlock.h ****         if(__spin_lock(&lock->rlock.raw_lock) == 1){
  19:./include/linux/spinlock.h ****             lock->owner = get_current_task();
  20:./include/linux/spinlock.h ****             break;
  21:./include/linux/spinlock.h ****         }
  22:./include/linux/spinlock.h ****         else  if(lock->owner == get_current_task()){  //Â¶ÇÊûúÂ∑≤ÁªèË¢´ÈîÅ‰Ωè‰ΩÜÊòØÈîÅÊòØËá™Â∑±ÁöÑÔ
  23:./include/linux/spinlock.h ****             return;   
  24:./include/linux/spinlock.h ****         }
  25:./include/linux/spinlock.h ****         else{
  26:./include/linux/spinlock.h ****             __delay(5); //‰∏ªÂä®ËÆ©Âá∫Êó∂Èó¥Áâá
  27:./include/linux/spinlock.h ****         }
  28:./include/linux/spinlock.h ****     }
  29:./include/linux/spinlock.h **** }
  30:./include/linux/spinlock.h **** 
  31:./include/linux/spinlock.h **** static void spin_unlock(spinlock_t* lock)
  32:./include/linux/spinlock.h **** {
 105              		.loc 3 32 1 is_stmt 1 view -0
 106              		.cfi_startproc
 107              		@ args = 0, pretend = 0, frame = 0
 108              		@ frame_needed = 0, uses_anonymous_args = 0
 109              		.loc 3 32 1 is_stmt 0 view .LVU13
 110 0000 08B5     		push	{r3, lr}
 111              	.LCFI1:
 112              		.cfi_def_cfa_offset 8
 113              		.cfi_offset 3, -8
 114              		.cfi_offset 14, -4
ARM GAS  /tmp/cczZAjmm.s 			page 4


  33:./include/linux/spinlock.h ****     __spin_unlock(&lock->rlock.raw_lock);
 115              		.loc 3 33 5 is_stmt 1 view .LVU14
 116 0002 FFF7FEFF 		bl	__spin_unlock
 117              	.LVL6:
  34:./include/linux/spinlock.h **** }
 118              		.loc 3 34 1 is_stmt 0 view .LVU15
 119 0006 08BD     		pop	{r3, pc}
 120              		.cfi_endproc
 121              	.LFE233:
 123              		.section	.text.__spin_lock,"ax",%progbits
 124              		.align	1
 125              		.syntax unified
 126              		.thumb
 127              		.thumb_func
 129              	__spin_lock:
 130              	.LVL7:
 131              	.LFB229:
  15:./arch/arm_m/include/asm/spinlock.h **** 
 132              		.loc 2 15 47 is_stmt 1 view -0
 133              		.cfi_startproc
 134              		@ args = 0, pretend = 0, frame = 0
 135              		@ frame_needed = 0, uses_anonymous_args = 0
  15:./arch/arm_m/include/asm/spinlock.h **** 
 136              		.loc 2 15 47 is_stmt 0 view .LVU17
 137 0000 38B5     		push	{r3, r4, r5, lr}
 138              	.LCFI2:
 139              		.cfi_def_cfa_offset 16
 140              		.cfi_offset 3, -16
 141              		.cfi_offset 4, -12
 142              		.cfi_offset 5, -8
 143              		.cfi_offset 14, -4
 144 0002 0446     		mov	r4, r0
  17:./arch/arm_m/include/asm/spinlock.h ****     if(lock->flag == 0){
 145              		.loc 2 17 5 is_stmt 1 view .LVU18
 146 0004 FFF7FEFF 		bl	stop_all_scheduler
 147              	.LVL8:
  18:./arch/arm_m/include/asm/spinlock.h ****           lock->flag = 1;  
 148              		.loc 2 18 5 view .LVU19
  18:./arch/arm_m/include/asm/spinlock.h ****           lock->flag = 1;  
 149              		.loc 2 18 12 is_stmt 0 view .LVU20
 150 0008 2368     		ldr	r3, [r4]
  18:./arch/arm_m/include/asm/spinlock.h ****           lock->flag = 1;  
 151              		.loc 2 18 7 view .LVU21
 152 000a 2BB9     		cbnz	r3, .L8
  19:./arch/arm_m/include/asm/spinlock.h ****           start_all_scheduler();
 153              		.loc 2 19 11 is_stmt 1 view .LVU22
  19:./arch/arm_m/include/asm/spinlock.h ****           start_all_scheduler();
 154              		.loc 2 19 22 is_stmt 0 view .LVU23
 155 000c 0125     		movs	r5, #1
 156 000e 2560     		str	r5, [r4]
  20:./arch/arm_m/include/asm/spinlock.h ****         return 1;
 157              		.loc 2 20 11 is_stmt 1 view .LVU24
 158 0010 FFF7FEFF 		bl	start_all_scheduler
 159              	.LVL9:
  21:./arch/arm_m/include/asm/spinlock.h ****     }
 160              		.loc 2 21 9 view .LVU25
  21:./arch/arm_m/include/asm/spinlock.h ****     }
ARM GAS  /tmp/cczZAjmm.s 			page 5


 161              		.loc 2 21 16 is_stmt 0 view .LVU26
 162 0014 2846     		mov	r0, r5
 163              	.L7:
  28:./arch/arm_m/include/asm/spinlock.h **** 
 164              		.loc 2 28 1 view .LVU27
 165 0016 38BD     		pop	{r3, r4, r5, pc}
 166              	.LVL10:
 167              	.L8:
  25:./arch/arm_m/include/asm/spinlock.h ****         return 0;
 168              		.loc 2 25 9 is_stmt 1 view .LVU28
 169 0018 FFF7FEFF 		bl	start_all_scheduler
 170              	.LVL11:
  26:./arch/arm_m/include/asm/spinlock.h ****     }
 171              		.loc 2 26 9 view .LVU29
  26:./arch/arm_m/include/asm/spinlock.h ****     }
 172              		.loc 2 26 16 is_stmt 0 view .LVU30
 173 001c 0020     		movs	r0, #0
 174 001e FAE7     		b	.L7
 175              		.cfi_endproc
 176              	.LFE229:
 178              		.section	.text.spin_lock,"ax",%progbits
 179              		.align	1
 180              		.syntax unified
 181              		.thumb
 182              		.thumb_func
 184              	spin_lock:
 185              	.LVL12:
 186              	.LFB232:
  15:./include/linux/spinlock.h ****     while (1)
 187              		.loc 3 15 1 is_stmt 1 view -0
 188              		.cfi_startproc
 189              		@ args = 0, pretend = 0, frame = 0
 190              		@ frame_needed = 0, uses_anonymous_args = 0
  15:./include/linux/spinlock.h ****     while (1)
 191              		.loc 3 15 1 is_stmt 0 view .LVU32
 192 0000 38B5     		push	{r3, r4, r5, lr}
 193              	.LCFI3:
 194              		.cfi_def_cfa_offset 16
 195              		.cfi_offset 3, -16
 196              		.cfi_offset 4, -12
 197              		.cfi_offset 5, -8
 198              		.cfi_offset 14, -4
 199 0002 0446     		mov	r4, r0
 200 0004 06E0     		b	.L14
 201              	.LVL13:
 202              	.L16:
  19:./include/linux/spinlock.h ****             break;
 203              		.loc 3 19 13 is_stmt 1 view .LVU33
  19:./include/linux/spinlock.h ****             break;
 204              		.loc 3 19 27 is_stmt 0 view .LVU34
 205 0006 FFF7FEFF 		bl	get_current_task
 206              	.LVL14:
  19:./include/linux/spinlock.h ****             break;
 207              		.loc 3 19 25 discriminator 1 view .LVU35
 208 000a 2060     		str	r0, [r4]
  20:./include/linux/spinlock.h ****         }
 209              		.loc 3 20 13 is_stmt 1 view .LVU36
ARM GAS  /tmp/cczZAjmm.s 			page 6


 210              	.L11:
  29:./include/linux/spinlock.h **** 
 211              		.loc 3 29 1 is_stmt 0 view .LVU37
 212 000c 38BD     		pop	{r3, r4, r5, pc}
 213              	.LVL15:
 214              	.L17:
  26:./include/linux/spinlock.h ****         }
 215              		.loc 3 26 13 is_stmt 1 view .LVU38
 216 000e 0520     		movs	r0, #5
 217 0010 FFF7FEFF 		bl	__delay
 218              	.LVL16:
  16:./include/linux/spinlock.h ****     {
 219              		.loc 3 16 11 view .LVU39
 220              	.L14:
  16:./include/linux/spinlock.h ****     {
 221              		.loc 3 16 5 view .LVU40
  18:./include/linux/spinlock.h ****             lock->owner = get_current_task();
 222              		.loc 3 18 9 view .LVU41
  18:./include/linux/spinlock.h ****             lock->owner = get_current_task();
 223              		.loc 3 18 12 is_stmt 0 view .LVU42
 224 0014 2046     		mov	r0, r4
 225 0016 FFF7FEFF 		bl	__spin_lock
 226              	.LVL17:
  18:./include/linux/spinlock.h ****             lock->owner = get_current_task();
 227              		.loc 3 18 11 discriminator 1 view .LVU43
 228 001a 0128     		cmp	r0, #1
 229 001c F3D0     		beq	.L16
  22:./include/linux/spinlock.h ****             return;   
 230              		.loc 3 22 15 is_stmt 1 view .LVU44
  22:./include/linux/spinlock.h ****             return;   
 231              		.loc 3 22 22 is_stmt 0 view .LVU45
 232 001e 2568     		ldr	r5, [r4]
  22:./include/linux/spinlock.h ****             return;   
 233              		.loc 3 22 33 view .LVU46
 234 0020 FFF7FEFF 		bl	get_current_task
 235              	.LVL18:
  22:./include/linux/spinlock.h ****             return;   
 236              		.loc 3 22 17 discriminator 1 view .LVU47
 237 0024 8542     		cmp	r5, r0
 238 0026 F2D1     		bne	.L17
 239 0028 F0E7     		b	.L11
 240              		.cfi_endproc
 241              	.LFE232:
 243              		.section	.text.request_queue_init,"ax",%progbits
 244              		.align	1
 245              		.global	request_queue_init
 246              		.syntax unified
 247              		.thumb
 248              		.thumb_func
 250              	request_queue_init:
 251              	.LVL19:
 252              	.LFB1035:
   1:./block/request_queue.c **** #include <linux/kernel.h>
   2:./block/request_queue.c **** #include <linux/types.h>
   3:./block/request_queue.c **** #include <linux/blkdev.h>
   4:./block/request_queue.c **** #include <linux/list.h>
   5:./block/request_queue.c **** 
ARM GAS  /tmp/cczZAjmm.s 			page 7


   6:./block/request_queue.c **** 
   7:./block/request_queue.c **** 
   8:./block/request_queue.c **** struct request_queue *request_queue_init(int id, struct gendisk *gd,gfp_t flags)
   9:./block/request_queue.c **** {
 253              		.loc 1 9 1 is_stmt 1 view -0
 254              		.cfi_startproc
 255              		@ args = 0, pretend = 0, frame = 0
 256              		@ frame_needed = 0, uses_anonymous_args = 0
 257              		.loc 1 9 1 is_stmt 0 view .LVU49
 258 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 259              	.LCFI4:
 260              		.cfi_def_cfa_offset 24
 261              		.cfi_offset 3, -24
 262              		.cfi_offset 4, -20
 263              		.cfi_offset 5, -16
 264              		.cfi_offset 6, -12
 265              		.cfi_offset 7, -8
 266              		.cfi_offset 14, -4
 267 0002 0546     		mov	r5, r0
 268 0004 0E46     		mov	r6, r1
  10:./block/request_queue.c ****     struct request_queue *q;
 269              		.loc 1 10 5 is_stmt 1 view .LVU50
  11:./block/request_queue.c **** 
  12:./block/request_queue.c ****     q = kmalloc(sizeof(*q), GFP_KERNEL);  // ÂàÜÈÖçÂÜÖÂ≠ò
 270              		.loc 1 12 5 view .LVU51
 271              	.LVL20:
 272              	.LBB96:
 273              	.LBI96:
 274              		.file 4 "./include/linux/slab.h"
   1:./include/linux/slab.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/slab.h **** /*
   3:./include/linux/slab.h ****  * Written by Mark Hemment, 1996 (markhe@nextd.demon.co.uk).
   4:./include/linux/slab.h ****  *
   5:./include/linux/slab.h ****  * (C) SGI 2006, Christoph Lameter
   6:./include/linux/slab.h ****  * 	Cleaned up and restructured to ease the addition of alternative
   7:./include/linux/slab.h ****  * 	implementations of SLAB allocators.
   8:./include/linux/slab.h ****  * (C) Linux Foundation 2008-2013
   9:./include/linux/slab.h ****  *      Unified interface for all slab allocators
  10:./include/linux/slab.h ****  */
  11:./include/linux/slab.h **** 
  12:./include/linux/slab.h **** #ifndef _LINUX_SLAB_H
  13:./include/linux/slab.h **** #define	_LINUX_SLAB_H
  14:./include/linux/slab.h **** 
  15:./include/linux/slab.h **** #include <linux/cache.h>
  16:./include/linux/slab.h **** #include <linux/overflow.h>
  17:./include/linux/slab.h **** #include <linux/types.h>
  18:./include/linux/slab.h **** #include <linux/raid/pq.h>
  19:./include/linux/slab.h **** #include <linux/gfp_types.h>
  20:./include/linux/slab.h **** #include <linux/numa.h>
  21:./include/linux/slab.h **** #include <linux/reciprocal_div.h>
  22:./include/linux/slab.h **** #include <linux/spinlock.h>
  23:./include/linux/slab.h **** 
  24:./include/linux/slab.h **** enum _slab_flag_bits {
  25:./include/linux/slab.h **** 	_SLAB_CONSISTENCY_CHECKS,
  26:./include/linux/slab.h **** 	_SLAB_RED_ZONE,
  27:./include/linux/slab.h **** 	_SLAB_POISON,
  28:./include/linux/slab.h **** 	_SLAB_KMALLOC,
ARM GAS  /tmp/cczZAjmm.s 			page 8


  29:./include/linux/slab.h **** 	_SLAB_HWCACHE_ALIGN,
  30:./include/linux/slab.h **** 	_SLAB_CACHE_DMA,
  31:./include/linux/slab.h **** 	_SLAB_CACHE_DMA32,
  32:./include/linux/slab.h **** 	_SLAB_STORE_USER,
  33:./include/linux/slab.h **** 	_SLAB_PANIC,
  34:./include/linux/slab.h **** 	_SLAB_TYPESAFE_BY_RCU,
  35:./include/linux/slab.h **** 	_SLAB_TRACE,
  36:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
  37:./include/linux/slab.h **** 	_SLAB_DEBUG_OBJECTS,
  38:./include/linux/slab.h **** #endif
  39:./include/linux/slab.h **** 	_SLAB_NOLEAKTRACE,
  40:./include/linux/slab.h **** 	_SLAB_NO_MERGE,
  41:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
  42:./include/linux/slab.h **** 	_SLAB_FAILSLAB,
  43:./include/linux/slab.h **** #endif
  44:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
  45:./include/linux/slab.h **** 	_SLAB_ACCOUNT,
  46:./include/linux/slab.h **** #endif
  47:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
  48:./include/linux/slab.h **** 	_SLAB_KASAN,
  49:./include/linux/slab.h **** #endif
  50:./include/linux/slab.h **** 	_SLAB_NO_USER_FLAGS,
  51:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
  52:./include/linux/slab.h **** 	_SLAB_SKIP_KFENCE,
  53:./include/linux/slab.h **** #endif
  54:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
  55:./include/linux/slab.h **** 	_SLAB_RECLAIM_ACCOUNT,
  56:./include/linux/slab.h **** #endif
  57:./include/linux/slab.h **** 	_SLAB_OBJECT_POISON,
  58:./include/linux/slab.h **** 	_SLAB_CMPXCHG_DOUBLE,
  59:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
  60:./include/linux/slab.h **** 	_SLAB_NO_OBJ_EXT,
  61:./include/linux/slab.h **** #endif
  62:./include/linux/slab.h **** 	_SLAB_FLAGS_LAST_BIT
  63:./include/linux/slab.h **** };
  64:./include/linux/slab.h **** 
  65:./include/linux/slab.h **** 
  66:./include/linux/slab.h **** 
  67:./include/linux/slab.h **** #define __SLAB_FLAG_BIT(nr)	((slab_flags_t __force)(1U << (nr)))
  68:./include/linux/slab.h **** #define __SLAB_FLAG_UNUSED	((slab_flags_t __force)(0U))
  69:./include/linux/slab.h **** 
  70:./include/linux/slab.h **** /*
  71:./include/linux/slab.h ****  * Flags to pass to kmem_cache_create().
  72:./include/linux/slab.h ****  * The ones marked DEBUG need CONFIG_SLUB_DEBUG enabled, otherwise are no-op
  73:./include/linux/slab.h ****  */
  74:./include/linux/slab.h **** /* DEBUG: Perform (expensive) checks on alloc/free */
  75:./include/linux/slab.h **** #define SLAB_CONSISTENCY_CHECKS	__SLAB_FLAG_BIT(_SLAB_CONSISTENCY_CHECKS)
  76:./include/linux/slab.h **** /* DEBUG: Red zone objs in a cache */
  77:./include/linux/slab.h **** #define SLAB_RED_ZONE		__SLAB_FLAG_BIT(_SLAB_RED_ZONE)
  78:./include/linux/slab.h **** /* DEBUG: Poison objects */
  79:./include/linux/slab.h **** #define SLAB_POISON		__SLAB_FLAG_BIT(_SLAB_POISON)
  80:./include/linux/slab.h **** /* Indicate a kmalloc slab */
  81:./include/linux/slab.h **** #define SLAB_KMALLOC		__SLAB_FLAG_BIT(_SLAB_KMALLOC)
  82:./include/linux/slab.h **** /**
  83:./include/linux/slab.h ****  * define SLAB_HWCACHE_ALIGN - Align objects on cache line boundaries.
  84:./include/linux/slab.h ****  *
  85:./include/linux/slab.h ****  * Sufficiently large objects are aligned on cache line boundary. For object
ARM GAS  /tmp/cczZAjmm.s 			page 9


  86:./include/linux/slab.h ****  * size smaller than a half of cache line size, the alignment is on the half of
  87:./include/linux/slab.h ****  * cache line size. In general, if object size is smaller than 1/2^n of cache
  88:./include/linux/slab.h ****  * line size, the alignment is adjusted to 1/2^n.
  89:./include/linux/slab.h ****  *
  90:./include/linux/slab.h ****  * If explicit alignment is also requested by the respective
  91:./include/linux/slab.h ****  * &struct kmem_cache_args field, the greater of both is alignments is applied.
  92:./include/linux/slab.h ****  */
  93:./include/linux/slab.h **** #define SLAB_HWCACHE_ALIGN	__SLAB_FLAG_BIT(_SLAB_HWCACHE_ALIGN)
  94:./include/linux/slab.h **** /* Use GFP_DMA memory */
  95:./include/linux/slab.h **** #define SLAB_CACHE_DMA		__SLAB_FLAG_BIT(_SLAB_CACHE_DMA)
  96:./include/linux/slab.h **** /* Use GFP_DMA32 memory */
  97:./include/linux/slab.h **** #define SLAB_CACHE_DMA32	__SLAB_FLAG_BIT(_SLAB_CACHE_DMA32)
  98:./include/linux/slab.h **** /* DEBUG: Store the last owner for bug hunting */
  99:./include/linux/slab.h **** #define SLAB_STORE_USER		__SLAB_FLAG_BIT(_SLAB_STORE_USER)
 100:./include/linux/slab.h **** /* Panic if kmem_cache_create() fails */
 101:./include/linux/slab.h **** #define SLAB_PANIC		__SLAB_FLAG_BIT(_SLAB_PANIC)
 102:./include/linux/slab.h **** /**
 103:./include/linux/slab.h ****  * define SLAB_TYPESAFE_BY_RCU - **WARNING** READ THIS!
 104:./include/linux/slab.h ****  *
 105:./include/linux/slab.h ****  * This delays freeing the SLAB page by a grace period, it does _NOT_
 106:./include/linux/slab.h ****  * delay object freeing. This means that if you do kmem_cache_free()
 107:./include/linux/slab.h ****  * that memory location is free to be reused at any time. Thus it may
 108:./include/linux/slab.h ****  * be possible to see another object there in the same RCU grace period.
 109:./include/linux/slab.h ****  *
 110:./include/linux/slab.h ****  * This feature only ensures the memory location backing the object
 111:./include/linux/slab.h ****  * stays valid, the trick to using this is relying on an independent
 112:./include/linux/slab.h ****  * object validation pass. Something like:
 113:./include/linux/slab.h ****  *
 114:./include/linux/slab.h ****  * ::
 115:./include/linux/slab.h ****  *
 116:./include/linux/slab.h ****  *  begin:
 117:./include/linux/slab.h ****  *   rcu_read_lock();
 118:./include/linux/slab.h ****  *   obj = lockless_lookup(key);
 119:./include/linux/slab.h ****  *   if (obj) {
 120:./include/linux/slab.h ****  *     if (!try_get_ref(obj)) // might fail for free objects
 121:./include/linux/slab.h ****  *       rcu_read_unlock();
 122:./include/linux/slab.h ****  *       goto begin;
 123:./include/linux/slab.h ****  *
 124:./include/linux/slab.h ****  *     if (obj->key != key) { // not the object we expected
 125:./include/linux/slab.h ****  *       put_ref(obj);
 126:./include/linux/slab.h ****  *       rcu_read_unlock();
 127:./include/linux/slab.h ****  *       goto begin;
 128:./include/linux/slab.h ****  *     }
 129:./include/linux/slab.h ****  *   }
 130:./include/linux/slab.h ****  *  rcu_read_unlock();
 131:./include/linux/slab.h ****  *
 132:./include/linux/slab.h ****  * This is useful if we need to approach a kernel structure obliquely,
 133:./include/linux/slab.h ****  * from its address obtained without the usual locking. We can lock
 134:./include/linux/slab.h ****  * the structure to stabilize it and check it's still at the given address,
 135:./include/linux/slab.h ****  * only if we can be sure that the memory has not been meanwhile reused
 136:./include/linux/slab.h ****  * for some other kind of object (which our subsystem's lock might corrupt).
 137:./include/linux/slab.h ****  *
 138:./include/linux/slab.h ****  * rcu_read_lock before reading the address, then rcu_read_unlock after
 139:./include/linux/slab.h ****  * taking the spinlock within the structure expected at that address.
 140:./include/linux/slab.h ****  *
 141:./include/linux/slab.h ****  * Note that it is not possible to acquire a lock within a structure
 142:./include/linux/slab.h ****  * allocated with SLAB_TYPESAFE_BY_RCU without first acquiring a reference
ARM GAS  /tmp/cczZAjmm.s 			page 10


 143:./include/linux/slab.h ****  * as described above.  The reason is that SLAB_TYPESAFE_BY_RCU pages
 144:./include/linux/slab.h ****  * are not zeroed before being given to the slab, which means that any
 145:./include/linux/slab.h ****  * locks must be initialized after each and every kmem_struct_alloc().
 146:./include/linux/slab.h ****  * Alternatively, make the ctor passed to kmem_cache_create() initialize
 147:./include/linux/slab.h ****  * the locks at page-allocation time, as is done in __i915_request_ctor(),
 148:./include/linux/slab.h ****  * sighand_ctor(), and anon_vma_ctor().  Such a ctor permits readers
 149:./include/linux/slab.h ****  * to safely acquire those ctor-initialized locks under rcu_read_lock()
 150:./include/linux/slab.h ****  * protection.
 151:./include/linux/slab.h ****  *
 152:./include/linux/slab.h ****  * Note that SLAB_TYPESAFE_BY_RCU was originally named SLAB_DESTROY_BY_RCU.
 153:./include/linux/slab.h ****  */
 154:./include/linux/slab.h **** #define SLAB_TYPESAFE_BY_RCU	__SLAB_FLAG_BIT(_SLAB_TYPESAFE_BY_RCU)
 155:./include/linux/slab.h **** /* Trace allocations and frees */
 156:./include/linux/slab.h **** #define SLAB_TRACE		__SLAB_FLAG_BIT(_SLAB_TRACE)
 157:./include/linux/slab.h **** 
 158:./include/linux/slab.h **** /* Flag to prevent checks on free */
 159:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
 160:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_BIT(_SLAB_DEBUG_OBJECTS)
 161:./include/linux/slab.h **** #else
 162:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_UNUSED
 163:./include/linux/slab.h **** #endif
 164:./include/linux/slab.h **** 
 165:./include/linux/slab.h **** /* Avoid kmemleak tracing */
 166:./include/linux/slab.h **** #define SLAB_NOLEAKTRACE	__SLAB_FLAG_BIT(_SLAB_NOLEAKTRACE)
 167:./include/linux/slab.h **** 
 168:./include/linux/slab.h **** /*
 169:./include/linux/slab.h ****  * Prevent merging with compatible kmem caches. This flag should be used
 170:./include/linux/slab.h ****  * cautiously. Valid use cases:
 171:./include/linux/slab.h ****  *
 172:./include/linux/slab.h ****  * - caches created for self-tests (e.g. kunit)
 173:./include/linux/slab.h ****  * - general caches created and used by a subsystem, only when a
 174:./include/linux/slab.h ****  *   (subsystem-specific) debug option is enabled
 175:./include/linux/slab.h ****  * - performance critical caches, should be very rare and consulted with slab
 176:./include/linux/slab.h ****  *   maintainers, and not used together with CONFIG_SLUB_TINY
 177:./include/linux/slab.h ****  */
 178:./include/linux/slab.h **** #define SLAB_NO_MERGE		__SLAB_FLAG_BIT(_SLAB_NO_MERGE)
 179:./include/linux/slab.h **** 
 180:./include/linux/slab.h **** /* Fault injection mark */
 181:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
 182:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_BIT(_SLAB_FAILSLAB)
 183:./include/linux/slab.h **** #else
 184:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_UNUSED
 185:./include/linux/slab.h **** #endif
 186:./include/linux/slab.h **** /**
 187:./include/linux/slab.h ****  * define SLAB_ACCOUNT - Account allocations to memcg.
 188:./include/linux/slab.h ****  *
 189:./include/linux/slab.h ****  * All object allocations from this cache will be memcg accounted, regardless of
 190:./include/linux/slab.h ****  * __GFP_ACCOUNT being or not being passed to individual allocations.
 191:./include/linux/slab.h ****  */
 192:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
 193:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_BIT(_SLAB_ACCOUNT)
 194:./include/linux/slab.h **** #else
 195:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_UNUSED
 196:./include/linux/slab.h **** #endif
 197:./include/linux/slab.h **** 
 198:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
 199:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_BIT(_SLAB_KASAN)
ARM GAS  /tmp/cczZAjmm.s 			page 11


 200:./include/linux/slab.h **** #else
 201:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_UNUSED
 202:./include/linux/slab.h **** #endif
 203:./include/linux/slab.h **** 
 204:./include/linux/slab.h **** /*
 205:./include/linux/slab.h ****  * Ignore user specified debugging flags.
 206:./include/linux/slab.h ****  * Intended for caches created for self-tests so they have only flags
 207:./include/linux/slab.h ****  * specified in the code and other flags are ignored.
 208:./include/linux/slab.h ****  */
 209:./include/linux/slab.h **** #define SLAB_NO_USER_FLAGS	__SLAB_FLAG_BIT(_SLAB_NO_USER_FLAGS)
 210:./include/linux/slab.h **** 
 211:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
 212:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_BIT(_SLAB_SKIP_KFENCE)
 213:./include/linux/slab.h **** #else
 214:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_UNUSED
 215:./include/linux/slab.h **** #endif
 216:./include/linux/slab.h **** 
 217:./include/linux/slab.h **** /* The following flags affect the page allocator grouping pages by mobility */
 218:./include/linux/slab.h **** /**
 219:./include/linux/slab.h ****  * define SLAB_RECLAIM_ACCOUNT - Objects are reclaimable.
 220:./include/linux/slab.h ****  *
 221:./include/linux/slab.h ****  * Use this flag for caches that have an associated shrinker. As a result, slab
 222:./include/linux/slab.h ****  * pages are allocated with __GFP_RECLAIMABLE, which affects grouping pages by
 223:./include/linux/slab.h ****  * mobility, and are accounted in SReclaimable counter in /proc/meminfo
 224:./include/linux/slab.h ****  */
 225:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
 226:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_BIT(_SLAB_RECLAIM_ACCOUNT)
 227:./include/linux/slab.h **** #else
 228:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_UNUSED
 229:./include/linux/slab.h **** #endif
 230:./include/linux/slab.h **** #define SLAB_TEMPORARY		SLAB_RECLAIM_ACCOUNT	/* Objects are short-lived */
 231:./include/linux/slab.h **** 
 232:./include/linux/slab.h **** /* Slab created using create_boot_cache */
 233:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
 234:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_BIT(_SLAB_NO_OBJ_EXT)
 235:./include/linux/slab.h **** #else
 236:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_UNUSED
 237:./include/linux/slab.h **** #endif
 238:./include/linux/slab.h **** 
 239:./include/linux/slab.h **** /*
 240:./include/linux/slab.h ****  * freeptr_t represents a SLUB freelist pointer, which might be encoded
 241:./include/linux/slab.h ****  * and not dereferenceable if CONFIG_SLAB_FREELIST_HARDENED is enabled.
 242:./include/linux/slab.h ****  */
 243:./include/linux/slab.h **** typedef struct { unsigned long v; } freeptr_t;
 244:./include/linux/slab.h **** 
 245:./include/linux/slab.h **** /*
 246:./include/linux/slab.h ****  * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.
 247:./include/linux/slab.h ****  *
 248:./include/linux/slab.h ****  * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault.
 249:./include/linux/slab.h ****  *
 250:./include/linux/slab.h ****  * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.
 251:./include/linux/slab.h ****  * Both make kfree a no-op.
 252:./include/linux/slab.h ****  */
 253:./include/linux/slab.h **** #define ZERO_SIZE_PTR ((void *)16)
 254:./include/linux/slab.h **** 
 255:./include/linux/slab.h **** #define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) <= \
 256:./include/linux/slab.h **** 				(unsigned long)ZERO_SIZE_PTR)
ARM GAS  /tmp/cczZAjmm.s 			page 12


 257:./include/linux/slab.h **** 
 258:./include/linux/slab.h **** 
 259:./include/linux/slab.h **** 
 260:./include/linux/slab.h **** 
 261:./include/linux/slab.h **** 
 262:./include/linux/slab.h **** #ifdef CONFIG_SLUB_CPU_PARTIAL
 263:./include/linux/slab.h **** #define slub_percpu_partial(c)			((c)->partial)
 264:./include/linux/slab.h **** 
 265:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)		\
 266:./include/linux/slab.h **** ({						\
 267:./include/linux/slab.h **** 	slub_percpu_partial(c) = (p)->next;	\
 268:./include/linux/slab.h **** })
 269:./include/linux/slab.h **** 
 270:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	READ_ONCE(slub_percpu_partial(c))
 271:./include/linux/slab.h **** #else
 272:./include/linux/slab.h **** #define slub_percpu_partial(c)			NULL
 273:./include/linux/slab.h **** 
 274:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)
 275:./include/linux/slab.h **** 
 276:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	NULL
 277:./include/linux/slab.h **** 
 278:./include/linux/slab.h **** 
 279:./include/linux/slab.h **** #endif // CONFIG_SLUB_CPU_PARTIAL
 280:./include/linux/slab.h **** 
 281:./include/linux/slab.h **** /*
 282:./include/linux/slab.h **** 	* Word size structure that can be atomically updated or read and that
 283:./include/linux/slab.h **** 	* contains both the order and the number of objects that a slab of the
 284:./include/linux/slab.h **** 	* given order would contain.
 285:./include/linux/slab.h **** 	*/				
 286:./include/linux/slab.h **** struct kmem_cache_order_objects {
 287:./include/linux/slab.h **** 	unsigned int x;
 288:./include/linux/slab.h **** };
 289:./include/linux/slab.h **** 
 290:./include/linux/slab.h **** struct kmem_cache_node {
 291:./include/linux/slab.h **** 	spinlock_t list_lock;
 292:./include/linux/slab.h **** 	unsigned long nr_partial;
 293:./include/linux/slab.h **** 	struct list_head partial;
 294:./include/linux/slab.h **** #ifdef CONFIG_SLUB_DEBUG
 295:./include/linux/slab.h **** 	atomic_long_t nr_slabs;
 296:./include/linux/slab.h **** 	atomic_long_t total_objects;
 297:./include/linux/slab.h **** 	struct list_head full;
 298:./include/linux/slab.h **** #endif
 299:./include/linux/slab.h **** };
 300:./include/linux/slab.h **** 
 301:./include/linux/slab.h **** struct kmem_cache {
 302:./include/linux/slab.h **** 	#ifndef CONFIG_SLUB_TINY
 303:./include/linux/slab.h **** 	//	struct kmem_cache_cpu __percpu *cpu_slab;
 304:./include/linux/slab.h **** 	#endif
 305:./include/linux/slab.h **** 		/* Used for retrieving partial slabs, etc. */
 306:./include/linux/slab.h **** 		slab_flags_t flags;
 307:./include/linux/slab.h **** 		unsigned long min_partial;
 308:./include/linux/slab.h **** 		unsigned int size;		/* Object size including metadata */
 309:./include/linux/slab.h **** 		unsigned int object_size;	/* Object size without metadata */
 310:./include/linux/slab.h **** 		struct reciprocal_value reciprocal_size;
 311:./include/linux/slab.h **** 		unsigned int offset;		/* Free pointer offset */
 312:./include/linux/slab.h **** 	#ifdef CONFIG_SLUB_CPU_PARTIAL
 313:./include/linux/slab.h **** 		/* Number of per cpu partial objects to keep around */
ARM GAS  /tmp/cczZAjmm.s 			page 13


 314:./include/linux/slab.h **** 		unsigned int cpu_partial;
 315:./include/linux/slab.h **** 		/* Number of per cpu partial slabs to keep around */
 316:./include/linux/slab.h **** 		unsigned int cpu_partial_slabs;
 317:./include/linux/slab.h **** 	#endif
 318:./include/linux/slab.h **** 		struct kmem_cache_order_objects oo;
 319:./include/linux/slab.h **** 	
 320:./include/linux/slab.h **** 		/* Allocation and freeing of slabs */
 321:./include/linux/slab.h **** 		struct kmem_cache_order_objects min;
 322:./include/linux/slab.h **** 		gfp_t allocflags;		/* gfp flags to use on each alloc */
 323:./include/linux/slab.h **** 		int refcount;			/* Refcount for slab cache destroy */
 324:./include/linux/slab.h **** 		void (*ctor)(void *object);	/* Object constructor */
 325:./include/linux/slab.h **** 		unsigned int inuse;		/* Offset to metadata */
 326:./include/linux/slab.h **** 		unsigned int align;		/* Alignment */
 327:./include/linux/slab.h **** 		unsigned int red_left_pad;	/* Left redzone padding size */
 328:./include/linux/slab.h **** 		const char *name;		/* Name (only for display!) */
 329:./include/linux/slab.h **** 		struct list_head list;		/* List of slab caches */
 330:./include/linux/slab.h **** 	#ifdef CONFIG_SYSFS
 331:./include/linux/slab.h **** 		struct kobject kobj;		/* For sysfs */
 332:./include/linux/slab.h **** 	#endif
 333:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_HARDENED
 334:./include/linux/slab.h **** 		unsigned long random;
 335:./include/linux/slab.h **** 	#endif
 336:./include/linux/slab.h **** 	
 337:./include/linux/slab.h **** 	#ifdef CONFIG_NUMA
 338:./include/linux/slab.h **** 		/*
 339:./include/linux/slab.h **** 			* Defragmentation by allocating from a remote node.
 340:./include/linux/slab.h **** 			*/
 341:./include/linux/slab.h **** 		unsigned int remote_node_defrag_ratio;
 342:./include/linux/slab.h **** 	#endif
 343:./include/linux/slab.h **** 	
 344:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_RANDOM
 345:./include/linux/slab.h **** 		unsigned int *random_seq;
 346:./include/linux/slab.h **** 	#endif
 347:./include/linux/slab.h **** 	
 348:./include/linux/slab.h **** 	#ifdef CONFIG_KASAN_GENERIC
 349:./include/linux/slab.h **** 		struct kasan_cache kasan_info;
 350:./include/linux/slab.h **** 	#endif
 351:./include/linux/slab.h **** 	
 352:./include/linux/slab.h **** 	#ifdef CONFIG_HARDENED_USERCOPY
 353:./include/linux/slab.h **** 		unsigned int useroffset;	/* Usercopy region offset */
 354:./include/linux/slab.h **** 		unsigned int usersize;		/* Usercopy region size */
 355:./include/linux/slab.h **** 	#endif
 356:./include/linux/slab.h **** 	
 357:./include/linux/slab.h **** 		struct kmem_cache_node *node[MAX_NUMNODES];
 358:./include/linux/slab.h **** 	};
 359:./include/linux/slab.h **** 					
 360:./include/linux/slab.h **** 
 361:./include/linux/slab.h **** 
 362:./include/linux/slab.h **** 
 363:./include/linux/slab.h **** 
 364:./include/linux/slab.h **** #define KMALLOC_WAIT 1
 365:./include/linux/slab.h **** 
 366:./include/linux/slab.h **** 
 367:./include/linux/slab.h **** extern void* __smalloc__(u32 size, gfp_t flags);
 368:./include/linux/slab.h **** extern void  __sfree__(void* addr);
 369:./include/linux/slab.h **** 
 370:./include/linux/slab.h **** 
ARM GAS  /tmp/cczZAjmm.s 			page 14


 371:./include/linux/slab.h **** static void inline *vmalloc(unsigned long size){
 372:./include/linux/slab.h **** 	return __smalloc__(size,GFP_TRANSHUGE_LIGHT);
 373:./include/linux/slab.h **** }
 374:./include/linux/slab.h **** 
 375:./include/linux/slab.h **** static void inline vfree(void *addr){
 376:./include/linux/slab.h **** 	__sfree__(addr);
 377:./include/linux/slab.h **** }
 378:./include/linux/slab.h **** 
 379:./include/linux/slab.h **** static void inline *kmalloc(size_t size, gfp_t flags){
 275              		.loc 4 379 21 view .LVU52
 276              	.LBB97:
 380:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 277              		.loc 4 380 2 view .LVU53
 278              		.loc 4 380 9 is_stmt 0 view .LVU54
 279 0006 4FF44C61 		mov	r1, #3264
 280              	.LVL21:
 281              		.loc 4 380 9 view .LVU55
 282 000a E020     		movs	r0, #224
 283              	.LVL22:
 284              		.loc 4 380 9 view .LVU56
 285 000c FFF7FEFF 		bl	__smalloc__
 286              	.LVL23:
 287              		.loc 4 380 9 view .LVU57
 288              	.LBE97:
 289              	.LBE96:
  13:./block/request_queue.c ****     if (!q)
 290              		.loc 1 13 5 is_stmt 1 view .LVU58
 291              		.loc 1 13 8 is_stmt 0 view .LVU59
 292 0010 0446     		mov	r4, r0
 293 0012 C8B1     		cbz	r0, .L18
  14:./block/request_queue.c ****         return NULL;
  15:./block/request_queue.c ****     
  16:./block/request_queue.c ****     q->queuedata = NULL;               // ÂàùÂßãÂåñ‰∏∫ NULLÔºåÂêéÊúüÂèØÂàÜÈÖçÊï∞ÊçÆ
 294              		.loc 1 16 5 is_stmt 1 view .LVU60
 295              		.loc 1 16 18 is_stmt 0 view .LVU61
 296 0014 0027     		movs	r7, #0
 297 0016 0760     		str	r7, [r0]
  17:./block/request_queue.c ****     q->last_merge = NULL;              // Êó†ÂêàÂπ∂ËØ∑Ê±Ç
 298              		.loc 1 17 5 is_stmt 1 view .LVU62
 299              		.loc 1 17 19 is_stmt 0 view .LVU63
 300 0018 4760     		str	r7, [r0, #4]
  18:./block/request_queue.c ****     spin_lock_init(&q->queue_lock);    // ÂàùÂßãÂåñËá™ÊóãÈîÅ
 301              		.loc 1 18 5 is_stmt 1 view .LVU64
 302 001a 0830     		adds	r0, r0, #8
 303              	.LVL24:
 304              		.loc 1 18 5 is_stmt 0 view .LVU65
 305 001c FFF7FEFF 		bl	spin_lock_init
 306              	.LVL25:
  19:./block/request_queue.c ****     q->quiesce_depth = 0;              // ÂàùÂßãÈùôÊ≠¢Ê∑±Â∫¶‰∏∫ 0
 307              		.loc 1 19 5 is_stmt 1 view .LVU66
 308              		.loc 1 19 22 is_stmt 0 view .LVU67
 309 0020 A761     		str	r7, [r4, #24]
  20:./block/request_queue.c ****     q->disk = gd;                      // ÂÖ≥ËÅîÁöÑÁ£ÅÁõòËÆæÂ§á
 310              		.loc 1 20 5 is_stmt 1 view .LVU68
 311              		.loc 1 20 13 is_stmt 0 view .LVU69
 312 0022 E661     		str	r6, [r4, #28]
  21:./block/request_queue.c ****     q->limits.max_sectors = 128;       // ÂÅáËÆæÈòüÂàóÁöÑÊúÄÂ§ßÊâáÂå∫Êï∞‰∏∫ 128
ARM GAS  /tmp/cczZAjmm.s 			page 15


 313              		.loc 1 21 5 is_stmt 1 view .LVU70
 314              		.loc 1 21 27 is_stmt 0 view .LVU71
 315 0024 8023     		movs	r3, #128
 316 0026 E363     		str	r3, [r4, #60]
  22:./block/request_queue.c ****     q->limits.max_segment_size = 32;   // ÂÅáËÆæÊúÄÂ§ßÊÆµÊï∞‰∏∫ 32
 317              		.loc 1 22 5 is_stmt 1 view .LVU72
 318              		.loc 1 22 32 is_stmt 0 view .LVU73
 319 0028 2023     		movs	r3, #32
 320 002a 6364     		str	r3, [r4, #68]
  23:./block/request_queue.c ****     q->id = id;                        // ÈòüÂàóÁöÑÂîØ‰∏ÄÊ†áËØÜÁ¨¶
 321              		.loc 1 23 5 is_stmt 1 view .LVU74
 322              		.loc 1 23 11 is_stmt 0 view .LVU75
 323 002c C4F8C450 		str	r5, [r4, #196]
  24:./block/request_queue.c ****     q->nr_requests = 1000;             // ÈòüÂàóÊîØÊåÅÁöÑÊúÄÂ§ßËØ∑Ê±ÇÊï∞
 324              		.loc 1 24 5 is_stmt 1 view .LVU76
 325              		.loc 1 24 20 is_stmt 0 view .LVU77
 326 0030 4FF47A73 		mov	r3, #1000
 327 0034 C4F8C830 		str	r3, [r4, #200]
  25:./block/request_queue.c ****     INIT_LIST_HEAD(&q->icq_list);      // ÂàùÂßãÂåñÈìæË°®Â§¥
 328              		.loc 1 25 5 is_stmt 1 view .LVU78
 329 0038 04F1CC03 		add	r3, r4, #204
 330              	.LVL26:
 331              	.LBB98:
 332              	.LBI98:
 333              		.file 5 "./include/linux/list.h"
   1:./include/linux/list.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/list.h **** #ifndef _LINUX_LIST_H
   3:./include/linux/list.h **** #define _LINUX_LIST_H
   4:./include/linux/list.h **** 
   5:./include/linux/list.h **** #include <linux/container_of.h>
   6:./include/linux/list.h **** #include <linux/types.h>
   7:./include/linux/list.h **** #include <linux/stddef.h>
   8:./include/linux/list.h **** #include <linux/poison.h>
   9:./include/linux/list.h **** #include <linux/const.h>
  10:./include/linux/list.h **** 
  11:./include/linux/list.h **** #include <asm/barrier.h>
  12:./include/linux/list.h **** #include <linux/rwonce.h>
  13:./include/linux/list.h **** /*
  14:./include/linux/list.h ****  * Circular doubly linked list implementation.
  15:./include/linux/list.h ****  *
  16:./include/linux/list.h ****  * Some of the internal functions ("__xxx") are useful when
  17:./include/linux/list.h ****  * manipulating whole lists rather than single entries, as
  18:./include/linux/list.h ****  * sometimes we already know the next/prev entries and we can
  19:./include/linux/list.h ****  * generate better code by using them directly rather than
  20:./include/linux/list.h ****  * using the generic single-entry routines.
  21:./include/linux/list.h ****  */
  22:./include/linux/list.h **** 
  23:./include/linux/list.h **** #define LIST_HEAD_INIT(name) { &(name), &(name) }
  24:./include/linux/list.h **** 
  25:./include/linux/list.h **** #define LIST_HEAD(name) \
  26:./include/linux/list.h **** 	struct list_head name = LIST_HEAD_INIT(name)
  27:./include/linux/list.h **** 
  28:./include/linux/list.h **** /**
  29:./include/linux/list.h ****  * INIT_LIST_HEAD - Initialize a list_head structure
  30:./include/linux/list.h ****  * @list: list_head structure to be initialized.
  31:./include/linux/list.h ****  *
  32:./include/linux/list.h ****  * Initializes the list_head to point to itself.  If it is a list header,
ARM GAS  /tmp/cczZAjmm.s 			page 16


  33:./include/linux/list.h ****  * the result is an empty list.
  34:./include/linux/list.h ****  */
  35:./include/linux/list.h **** static inline void INIT_LIST_HEAD(struct list_head *list)
 334              		.loc 5 35 20 view .LVU79
 335              	.LBB99:
  36:./include/linux/list.h **** {
  37:./include/linux/list.h **** 	WRITE_ONCE(list->next, list);
 336              		.loc 5 37 2 view .LVU80
 337              		.loc 5 37 2 view .LVU81
 338              	.LBB100:
 339              		.loc 5 37 2 view .LVU82
 340              		.loc 5 37 2 view .LVU83
 341              	.LBE100:
 342              		.loc 5 37 2 discriminator 2 view .LVU84
 343              		.loc 5 37 2 discriminator 2 view .LVU85
 344              		.loc 5 37 2 discriminator 2 view .LVU86
 345 003c C4F8CC30 		str	r3, [r4, #204]
 346              		.loc 5 37 2 discriminator 2 view .LVU87
 347              		.loc 5 37 2 discriminator 2 view .LVU88
  38:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 348              		.loc 5 38 2 view .LVU89
 349              		.loc 5 38 2 view .LVU90
 350              	.LBB101:
 351              		.loc 5 38 2 view .LVU91
 352              		.loc 5 38 2 view .LVU92
 353              	.LBE101:
 354              		.loc 5 38 2 discriminator 2 view .LVU93
 355              		.loc 5 38 2 discriminator 2 view .LVU94
 356              		.loc 5 38 2 discriminator 2 view .LVU95
 357 0040 C4F8D030 		str	r3, [r4, #208]
 358              		.loc 5 38 2 discriminator 2 view .LVU96
 359              		.loc 5 38 2 discriminator 2 view .LVU97
 360              	.LVL27:
 361              		.loc 5 38 2 is_stmt 0 discriminator 2 view .LVU98
 362              	.LBE99:
 363              	.LBE98:
  26:./block/request_queue.c ****     q->node = 0;                       // ÈªòËÆ§ NUMA ËäÇÁÇπ‰∏∫ 0
 364              		.loc 1 26 5 is_stmt 1 view .LVU99
 365              		.loc 1 26 13 is_stmt 0 view .LVU100
 366 0044 C4F8D470 		str	r7, [r4, #212]
  27:./block/request_queue.c **** 
  28:./block/request_queue.c ****     return q;
 367              		.loc 1 28 5 is_stmt 1 view .LVU101
 368              	.L18:
  29:./block/request_queue.c **** }
 369              		.loc 1 29 1 is_stmt 0 view .LVU102
 370 0048 2046     		mov	r0, r4
 371 004a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 372              		.loc 1 29 1 view .LVU103
 373              		.cfi_endproc
 374              	.LFE1035:
 376              		.section	.text.__blk_cleanup_queue,"ax",%progbits
 377              		.align	1
 378              		.global	__blk_cleanup_queue
 379              		.syntax unified
 380              		.thumb
 381              		.thumb_func
ARM GAS  /tmp/cczZAjmm.s 			page 17


 383              	__blk_cleanup_queue:
 384              	.LVL28:
 385              	.LFB1036:
  30:./block/request_queue.c **** 
  31:./block/request_queue.c **** void __blk_cleanup_queue(struct request_queue *q){
 386              		.loc 1 31 50 is_stmt 1 view -0
 387              		.cfi_startproc
 388              		@ args = 0, pretend = 0, frame = 0
 389              		@ frame_needed = 0, uses_anonymous_args = 0
  32:./block/request_queue.c ****     if(q) kfree(q);
 390              		.loc 1 32 5 view .LVU105
 391              		.loc 1 32 7 is_stmt 0 view .LVU106
 392 0000 18B1     		cbz	r0, .L24
  31:./block/request_queue.c ****     if(q) kfree(q);
 393              		.loc 1 31 50 view .LVU107
 394 0002 08B5     		push	{r3, lr}
 395              	.LCFI5:
 396              		.cfi_def_cfa_offset 8
 397              		.cfi_offset 3, -8
 398              		.cfi_offset 14, -4
 399              		.loc 1 32 11 is_stmt 1 discriminator 1 view .LVU108
 400              	.LVL29:
 401              	.LBB102:
 402              	.LBI102:
 381:./include/linux/slab.h **** }
 382:./include/linux/slab.h **** 
 383:./include/linux/slab.h **** static void inline kfree(const void *ptr){
 403              		.loc 4 383 20 view .LVU109
 404              	.LBB103:
 384:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 405              		.loc 4 384 2 view .LVU110
 406 0004 FFF7FEFF 		bl	__sfree__
 407              	.LVL30:
 408              		.loc 4 384 2 is_stmt 0 view .LVU111
 409              	.LBE103:
 410              	.LBE102:
  33:./block/request_queue.c **** }
 411              		.loc 1 33 1 view .LVU112
 412 0008 08BD     		pop	{r3, pc}
 413              	.LVL31:
 414              	.L24:
 415              	.LCFI6:
 416              		.cfi_def_cfa_offset 0
 417              		.cfi_restore 3
 418              		.cfi_restore 14
 419              		.loc 1 33 1 view .LVU113
 420 000a 7047     		bx	lr
 421              		.cfi_endproc
 422              	.LFE1036:
 424              		.section	.text.request_queue_add,"ax",%progbits
 425              		.align	1
 426              		.global	request_queue_add
 427              		.syntax unified
 428              		.thumb
 429              		.thumb_func
 431              	request_queue_add:
 432              	.LVL32:
ARM GAS  /tmp/cczZAjmm.s 			page 18


 433              	.LFB1037:
  34:./block/request_queue.c ****  
  35:./block/request_queue.c **** void request_queue_add(struct request_queue *q, struct request *req)
  36:./block/request_queue.c **** {
 434              		.loc 1 36 1 is_stmt 1 view -0
 435              		.cfi_startproc
 436              		@ args = 0, pretend = 0, frame = 0
 437              		@ frame_needed = 0, uses_anonymous_args = 0
 438              		@ link register save eliminated.
 439              		.loc 1 36 1 is_stmt 0 view .LVU115
 440 0000 10B4     		push	{r4}
 441              	.LCFI7:
 442              		.cfi_def_cfa_offset 4
 443              		.cfi_offset 4, -4
  37:./block/request_queue.c ****     list_add_tail(&req->queuelist, &q->icq_list);  // Â∞ÜËØ∑Ê±ÇÊ∑ªÂä†Âà∞ÈòüÂàóÊú´Â∞æ
 444              		.loc 1 37 5 is_stmt 1 view .LVU116
 445 0002 01F12802 		add	r2, r1, #40
 446 0006 00F1CC04 		add	r4, r0, #204
 447              	.LVL33:
 448              	.LBB104:
 449              	.LBI104:
  39:./include/linux/list.h **** }
  40:./include/linux/list.h **** 
  41:./include/linux/list.h **** #ifdef CONFIG_LIST_HARDENED
  42:./include/linux/list.h **** 
  43:./include/linux/list.h **** #ifdef CONFIG_DEBUG_LIST
  44:./include/linux/list.h **** # define __list_valid_slowpath
  45:./include/linux/list.h **** #else
  46:./include/linux/list.h **** # define __list_valid_slowpath __cold __preserve_most
  47:./include/linux/list.h **** #endif
  48:./include/linux/list.h **** 
  49:./include/linux/list.h **** /*
  50:./include/linux/list.h ****  * Performs the full set of list corruption checks before __list_add().
  51:./include/linux/list.h ****  * On list corruption reports a warning, and returns false.
  52:./include/linux/list.h ****  */
  53:./include/linux/list.h **** extern bool __list_valid_slowpath __list_add_valid_or_report(struct list_head *new,
  54:./include/linux/list.h **** 							     struct list_head *prev,
  55:./include/linux/list.h **** 							     struct list_head *next);
  56:./include/linux/list.h **** 
  57:./include/linux/list.h **** /*
  58:./include/linux/list.h ****  * Performs list corruption checks before __list_add(). Returns false if a
  59:./include/linux/list.h ****  * corruption is detected, true otherwise.
  60:./include/linux/list.h ****  *
  61:./include/linux/list.h ****  * With CONFIG_LIST_HARDENED only, performs minimal list integrity checking
  62:./include/linux/list.h ****  * inline to catch non-faulting corruptions, and only if a corruption is
  63:./include/linux/list.h ****  * detected calls the reporting function __list_add_valid_or_report().
  64:./include/linux/list.h ****  */
  65:./include/linux/list.h **** static __always_inline bool __list_add_valid(struct list_head *new,
  66:./include/linux/list.h **** 					     struct list_head *prev,
  67:./include/linux/list.h **** 					     struct list_head *next)
  68:./include/linux/list.h **** {
  69:./include/linux/list.h **** 	bool ret = true;
  70:./include/linux/list.h **** 
  71:./include/linux/list.h **** 	if (!IS_ENABLED(CONFIG_DEBUG_LIST)) {
  72:./include/linux/list.h **** 		/*
  73:./include/linux/list.h **** 		 * With the hardening version, elide checking if next and prev
  74:./include/linux/list.h **** 		 * are NULL, since the immediate dereference of them below would
ARM GAS  /tmp/cczZAjmm.s 			page 19


  75:./include/linux/list.h **** 		 * result in a fault if NULL.
  76:./include/linux/list.h **** 		 *
  77:./include/linux/list.h **** 		 * With the reduced set of checks, we can afford to inline the
  78:./include/linux/list.h **** 		 * checks, which also gives the compiler a chance to elide some
  79:./include/linux/list.h **** 		 * of them completely if they can be proven at compile-time. If
  80:./include/linux/list.h **** 		 * one of the pre-conditions does not hold, the slow-path will
  81:./include/linux/list.h **** 		 * show a report which pre-condition failed.
  82:./include/linux/list.h **** 		 */
  83:./include/linux/list.h **** 		if (likely(next->prev == prev && prev->next == next && new != prev && new != next))
  84:./include/linux/list.h **** 			return true;
  85:./include/linux/list.h **** 		ret = false;
  86:./include/linux/list.h **** 	}
  87:./include/linux/list.h **** 
  88:./include/linux/list.h **** 	ret &= __list_add_valid_or_report(new, prev, next);
  89:./include/linux/list.h **** 	return ret;
  90:./include/linux/list.h **** }
  91:./include/linux/list.h **** 
  92:./include/linux/list.h **** /*
  93:./include/linux/list.h ****  * Performs the full set of list corruption checks before __list_del_entry().
  94:./include/linux/list.h ****  * On list corruption reports a warning, and returns false.
  95:./include/linux/list.h ****  */
  96:./include/linux/list.h **** extern bool __list_valid_slowpath __list_del_entry_valid_or_report(struct list_head *entry);
  97:./include/linux/list.h **** 
  98:./include/linux/list.h **** /*
  99:./include/linux/list.h ****  * Performs list corruption checks before __list_del_entry(). Returns false if a
 100:./include/linux/list.h ****  * corruption is detected, true otherwise.
 101:./include/linux/list.h ****  *
 102:./include/linux/list.h ****  * With CONFIG_LIST_HARDENED only, performs minimal list integrity checking
 103:./include/linux/list.h ****  * inline to catch non-faulting corruptions, and only if a corruption is
 104:./include/linux/list.h ****  * detected calls the reporting function __list_del_entry_valid_or_report().
 105:./include/linux/list.h ****  */
 106:./include/linux/list.h **** static __always_inline bool __list_del_entry_valid(struct list_head *entry)
 107:./include/linux/list.h **** {
 108:./include/linux/list.h **** 	bool ret = true;
 109:./include/linux/list.h **** 
 110:./include/linux/list.h **** 	if (!IS_ENABLED(CONFIG_DEBUG_LIST)) {
 111:./include/linux/list.h **** 		struct list_head *prev = entry->prev;
 112:./include/linux/list.h **** 		struct list_head *next = entry->next;
 113:./include/linux/list.h **** 
 114:./include/linux/list.h **** 		/*
 115:./include/linux/list.h **** 		 * With the hardening version, elide checking if next and prev
 116:./include/linux/list.h **** 		 * are NULL, LIST_POISON1 or LIST_POISON2, since the immediate
 117:./include/linux/list.h **** 		 * dereference of them below would result in a fault.
 118:./include/linux/list.h **** 		 */
 119:./include/linux/list.h **** 		if (likely(prev->next == entry && next->prev == entry))
 120:./include/linux/list.h **** 			return true;
 121:./include/linux/list.h **** 		ret = false;
 122:./include/linux/list.h **** 	}
 123:./include/linux/list.h **** 
 124:./include/linux/list.h **** 	ret &= __list_del_entry_valid_or_report(entry);
 125:./include/linux/list.h **** 	return ret;
 126:./include/linux/list.h **** }
 127:./include/linux/list.h **** #else
 128:./include/linux/list.h **** static inline bool __list_add_valid(struct list_head *new,
 129:./include/linux/list.h **** 				struct list_head *prev,
 130:./include/linux/list.h **** 				struct list_head *next)
 131:./include/linux/list.h **** {
ARM GAS  /tmp/cczZAjmm.s 			page 20


 132:./include/linux/list.h **** 	return true;
 133:./include/linux/list.h **** }
 134:./include/linux/list.h **** static inline bool __list_del_entry_valid(struct list_head *entry)
 135:./include/linux/list.h **** {
 136:./include/linux/list.h **** 	return true;
 137:./include/linux/list.h **** }
 138:./include/linux/list.h **** #endif
 139:./include/linux/list.h **** 
 140:./include/linux/list.h **** /*
 141:./include/linux/list.h ****  * Insert a new entry between two known consecutive entries.
 142:./include/linux/list.h ****  *
 143:./include/linux/list.h ****  * This is only for internal list manipulation where we know
 144:./include/linux/list.h ****  * the prev/next entries already!
 145:./include/linux/list.h ****  */
 146:./include/linux/list.h **** static inline void __list_add(struct list_head *new,
 147:./include/linux/list.h **** 			      struct list_head *prev,
 148:./include/linux/list.h **** 			      struct list_head *next)
 149:./include/linux/list.h **** {
 150:./include/linux/list.h **** 	if (!__list_add_valid(new, prev, next))
 151:./include/linux/list.h **** 		return;
 152:./include/linux/list.h **** 
 153:./include/linux/list.h **** 	next->prev = new;
 154:./include/linux/list.h **** 	new->next = next;
 155:./include/linux/list.h **** 	new->prev = prev;
 156:./include/linux/list.h **** 	WRITE_ONCE(prev->next, new);
 157:./include/linux/list.h **** }
 158:./include/linux/list.h **** 
 159:./include/linux/list.h **** /**
 160:./include/linux/list.h ****  * list_add - add a new entry
 161:./include/linux/list.h ****  * @new: new entry to be added
 162:./include/linux/list.h ****  * @head: list head to add it after
 163:./include/linux/list.h ****  *
 164:./include/linux/list.h ****  * Insert a new entry after the specified head.
 165:./include/linux/list.h ****  * This is good for implementing stacks.
 166:./include/linux/list.h ****  */
 167:./include/linux/list.h **** static inline void list_add(struct list_head *new, struct list_head *head)
 168:./include/linux/list.h **** {
 169:./include/linux/list.h **** 	__list_add(new, head, head->next);
 170:./include/linux/list.h **** }
 171:./include/linux/list.h **** 
 172:./include/linux/list.h **** 
 173:./include/linux/list.h **** /**
 174:./include/linux/list.h ****  * list_add_tail - add a new entry
 175:./include/linux/list.h ****  * @new: new entry to be added
 176:./include/linux/list.h ****  * @head: list head to add it before
 177:./include/linux/list.h ****  *
 178:./include/linux/list.h ****  * Insert a new entry before the specified head.
 179:./include/linux/list.h ****  * This is useful for implementing queues.
 180:./include/linux/list.h ****  */
 181:./include/linux/list.h **** static inline void list_add_tail(struct list_head *new, struct list_head *head)
 450              		.loc 5 181 20 view .LVU117
 451              	.LBB105:
 182:./include/linux/list.h **** {
 183:./include/linux/list.h **** 	__list_add(new, head->prev, head);
 452              		.loc 5 183 2 view .LVU118
 453 000a D0F8D030 		ldr	r3, [r0, #208]
 454              	.LVL34:
ARM GAS  /tmp/cczZAjmm.s 			page 21


 455              	.LBB106:
 456              	.LBI106:
 146:./include/linux/list.h **** 			      struct list_head *prev,
 457              		.loc 5 146 20 view .LVU119
 458              	.LBB107:
 150:./include/linux/list.h **** 		return;
 459              		.loc 5 150 2 view .LVU120
 153:./include/linux/list.h **** 	new->next = next;
 460              		.loc 5 153 2 view .LVU121
 153:./include/linux/list.h **** 	new->next = next;
 461              		.loc 5 153 13 is_stmt 0 view .LVU122
 462 000e C0F8D020 		str	r2, [r0, #208]
 154:./include/linux/list.h **** 	new->prev = prev;
 463              		.loc 5 154 2 is_stmt 1 view .LVU123
 154:./include/linux/list.h **** 	new->prev = prev;
 464              		.loc 5 154 12 is_stmt 0 view .LVU124
 465 0012 8C62     		str	r4, [r1, #40]
 155:./include/linux/list.h **** 	WRITE_ONCE(prev->next, new);
 466              		.loc 5 155 2 is_stmt 1 view .LVU125
 155:./include/linux/list.h **** 	WRITE_ONCE(prev->next, new);
 467              		.loc 5 155 12 is_stmt 0 view .LVU126
 468 0014 CB62     		str	r3, [r1, #44]
 156:./include/linux/list.h **** }
 469              		.loc 5 156 2 is_stmt 1 view .LVU127
 156:./include/linux/list.h **** }
 470              		.loc 5 156 2 view .LVU128
 471              	.LBB108:
 156:./include/linux/list.h **** }
 472              		.loc 5 156 2 view .LVU129
 156:./include/linux/list.h **** }
 473              		.loc 5 156 2 view .LVU130
 474              	.LBE108:
 156:./include/linux/list.h **** }
 475              		.loc 5 156 2 discriminator 2 view .LVU131
 156:./include/linux/list.h **** }
 476              		.loc 5 156 2 discriminator 2 view .LVU132
 156:./include/linux/list.h **** }
 477              		.loc 5 156 2 discriminator 2 view .LVU133
 478 0016 1A60     		str	r2, [r3]
 156:./include/linux/list.h **** }
 479              		.loc 5 156 2 discriminator 3 view .LVU134
 156:./include/linux/list.h **** }
 480              		.loc 5 156 2 discriminator 3 view .LVU135
 481              	.LVL35:
 156:./include/linux/list.h **** }
 482              		.loc 5 156 2 is_stmt 0 discriminator 3 view .LVU136
 483              	.LBE107:
 484              	.LBE106:
 485              	.LBE105:
 486              	.LBE104:
  38:./block/request_queue.c **** }
 487              		.loc 1 38 1 view .LVU137
 488 0018 5DF8044B 		ldr	r4, [sp], #4
 489              	.LCFI8:
 490              		.cfi_restore 4
 491              		.cfi_def_cfa_offset 0
 492 001c 7047     		bx	lr
ARM GAS  /tmp/cczZAjmm.s 			page 22


 493              		.cfi_endproc
 494              	.LFE1037:
 496              		.section	.text.request_queue_remove,"ax",%progbits
 497              		.align	1
 498              		.global	request_queue_remove
 499              		.syntax unified
 500              		.thumb
 501              		.thumb_func
 503              	request_queue_remove:
 504              	.LVL36:
 505              	.LFB1038:
  39:./block/request_queue.c **** 
  40:./block/request_queue.c **** 
  41:./block/request_queue.c **** void request_queue_remove(struct request_queue *q, struct request *req)
  42:./block/request_queue.c **** {
 506              		.loc 1 42 1 is_stmt 1 view -0
 507              		.cfi_startproc
 508              		@ args = 0, pretend = 0, frame = 0
 509              		@ frame_needed = 0, uses_anonymous_args = 0
 510              		.loc 1 42 1 is_stmt 0 view .LVU139
 511 0000 38B5     		push	{r3, r4, r5, lr}
 512              	.LCFI9:
 513              		.cfi_def_cfa_offset 16
 514              		.cfi_offset 3, -16
 515              		.cfi_offset 4, -12
 516              		.cfi_offset 5, -8
 517              		.cfi_offset 14, -4
 518 0002 0C46     		mov	r4, r1
  43:./block/request_queue.c ****     spin_lock(&q->queue_lock);
 519              		.loc 1 43 5 is_stmt 1 view .LVU140
 520 0004 00F10805 		add	r5, r0, #8
 521 0008 2846     		mov	r0, r5
 522              	.LVL37:
 523              		.loc 1 43 5 is_stmt 0 view .LVU141
 524 000a FFF7FEFF 		bl	spin_lock
 525              	.LVL38:
  44:./block/request_queue.c ****     if (!list_empty(&req->queuelist)) {
 526              		.loc 1 44 5 is_stmt 1 view .LVU142
 527              		.loc 1 44 21 is_stmt 0 view .LVU143
 528 000e 04F12803 		add	r3, r4, #40
 529              	.LVL39:
 530              	.LBB109:
 531              	.LBI109:
 184:./include/linux/list.h **** }
 185:./include/linux/list.h **** 
 186:./include/linux/list.h **** /*
 187:./include/linux/list.h ****  * Delete a list entry by making the prev/next entries
 188:./include/linux/list.h ****  * point to each other.
 189:./include/linux/list.h ****  *
 190:./include/linux/list.h ****  * This is only for internal list manipulation where we know
 191:./include/linux/list.h ****  * the prev/next entries already!
 192:./include/linux/list.h ****  */
 193:./include/linux/list.h **** static inline void __list_del(struct list_head * prev, struct list_head * next)
 194:./include/linux/list.h **** {
 195:./include/linux/list.h **** 	next->prev = prev;
 196:./include/linux/list.h **** 	WRITE_ONCE(prev->next, next);
 197:./include/linux/list.h **** }
ARM GAS  /tmp/cczZAjmm.s 			page 23


 198:./include/linux/list.h **** 
 199:./include/linux/list.h **** /*
 200:./include/linux/list.h ****  * Delete a list entry and clear the 'prev' pointer.
 201:./include/linux/list.h ****  *
 202:./include/linux/list.h ****  * This is a special-purpose list clearing method used in the networking code
 203:./include/linux/list.h ****  * for lists allocated as per-cpu, where we don't want to incur the extra
 204:./include/linux/list.h ****  * WRITE_ONCE() overhead of a regular list_del_init(). The code that uses this
 205:./include/linux/list.h ****  * needs to check the node 'prev' pointer instead of calling list_empty().
 206:./include/linux/list.h ****  */
 207:./include/linux/list.h **** static inline void __list_del_clearprev(struct list_head *entry)
 208:./include/linux/list.h **** {
 209:./include/linux/list.h **** 	__list_del(entry->prev, entry->next);
 210:./include/linux/list.h **** 	entry->prev = NULL;
 211:./include/linux/list.h **** }
 212:./include/linux/list.h **** 
 213:./include/linux/list.h **** static inline void __list_del_entry(struct list_head *entry)
 214:./include/linux/list.h **** {
 215:./include/linux/list.h **** 	if (!__list_del_entry_valid(entry))
 216:./include/linux/list.h **** 		return;
 217:./include/linux/list.h **** 
 218:./include/linux/list.h **** 	__list_del(entry->prev, entry->next);
 219:./include/linux/list.h **** }
 220:./include/linux/list.h **** 
 221:./include/linux/list.h **** /**
 222:./include/linux/list.h ****  * list_del - deletes entry from list.
 223:./include/linux/list.h ****  * @entry: the element to delete from the list.
 224:./include/linux/list.h ****  * Note: list_empty() on entry does not return true after this, the entry is
 225:./include/linux/list.h ****  * in an undefined state.
 226:./include/linux/list.h ****  */
 227:./include/linux/list.h **** static inline void list_del(struct list_head *entry)
 228:./include/linux/list.h **** {
 229:./include/linux/list.h **** 	__list_del_entry(entry);
 230:./include/linux/list.h **** 	entry->next = LIST_POISON1;
 231:./include/linux/list.h **** 	entry->prev = LIST_POISON2;
 232:./include/linux/list.h **** }
 233:./include/linux/list.h **** 
 234:./include/linux/list.h **** /**
 235:./include/linux/list.h ****  * list_replace - replace old entry by new one
 236:./include/linux/list.h ****  * @old : the element to be replaced
 237:./include/linux/list.h ****  * @new : the new element to insert
 238:./include/linux/list.h ****  *
 239:./include/linux/list.h ****  * If @old was empty, it will be overwritten.
 240:./include/linux/list.h ****  */
 241:./include/linux/list.h **** static inline void list_replace(struct list_head *old,
 242:./include/linux/list.h **** 				struct list_head *new)
 243:./include/linux/list.h **** {
 244:./include/linux/list.h **** 	new->next = old->next;
 245:./include/linux/list.h **** 	new->next->prev = new;
 246:./include/linux/list.h **** 	new->prev = old->prev;
 247:./include/linux/list.h **** 	new->prev->next = new;
 248:./include/linux/list.h **** }
 249:./include/linux/list.h **** 
 250:./include/linux/list.h **** /**
 251:./include/linux/list.h ****  * list_replace_init - replace old entry by new one and initialize the old one
 252:./include/linux/list.h ****  * @old : the element to be replaced
 253:./include/linux/list.h ****  * @new : the new element to insert
 254:./include/linux/list.h ****  *
ARM GAS  /tmp/cczZAjmm.s 			page 24


 255:./include/linux/list.h ****  * If @old was empty, it will be overwritten.
 256:./include/linux/list.h ****  */
 257:./include/linux/list.h **** static inline void list_replace_init(struct list_head *old,
 258:./include/linux/list.h **** 				     struct list_head *new)
 259:./include/linux/list.h **** {
 260:./include/linux/list.h **** 	list_replace(old, new);
 261:./include/linux/list.h **** 	INIT_LIST_HEAD(old);
 262:./include/linux/list.h **** }
 263:./include/linux/list.h **** 
 264:./include/linux/list.h **** /**
 265:./include/linux/list.h ****  * list_swap - replace entry1 with entry2 and re-add entry1 at entry2's position
 266:./include/linux/list.h ****  * @entry1: the location to place entry2
 267:./include/linux/list.h ****  * @entry2: the location to place entry1
 268:./include/linux/list.h ****  */
 269:./include/linux/list.h **** static inline void list_swap(struct list_head *entry1,
 270:./include/linux/list.h **** 			     struct list_head *entry2)
 271:./include/linux/list.h **** {
 272:./include/linux/list.h **** 	struct list_head *pos = entry2->prev;
 273:./include/linux/list.h **** 
 274:./include/linux/list.h **** 	list_del(entry2);
 275:./include/linux/list.h **** 	list_replace(entry1, entry2);
 276:./include/linux/list.h **** 	if (pos == entry1)
 277:./include/linux/list.h **** 		pos = entry2;
 278:./include/linux/list.h **** 	list_add(entry1, pos);
 279:./include/linux/list.h **** }
 280:./include/linux/list.h **** 
 281:./include/linux/list.h **** /**
 282:./include/linux/list.h ****  * list_del_init - deletes entry from list and reinitialize it.
 283:./include/linux/list.h ****  * @entry: the element to delete from the list.
 284:./include/linux/list.h ****  */
 285:./include/linux/list.h **** static inline void list_del_init(struct list_head *entry)
 286:./include/linux/list.h **** {
 287:./include/linux/list.h **** 	__list_del_entry(entry);
 288:./include/linux/list.h **** 	INIT_LIST_HEAD(entry);
 289:./include/linux/list.h **** }
 290:./include/linux/list.h **** 
 291:./include/linux/list.h **** /**
 292:./include/linux/list.h ****  * list_move - delete from one list and add as another's head
 293:./include/linux/list.h ****  * @list: the entry to move
 294:./include/linux/list.h ****  * @head: the head that will precede our entry
 295:./include/linux/list.h ****  */
 296:./include/linux/list.h **** static inline void list_move(struct list_head *list, struct list_head *head)
 297:./include/linux/list.h **** {
 298:./include/linux/list.h **** 	__list_del_entry(list);
 299:./include/linux/list.h **** 	list_add(list, head);
 300:./include/linux/list.h **** }
 301:./include/linux/list.h **** 
 302:./include/linux/list.h **** /**
 303:./include/linux/list.h ****  * list_move_tail - delete from one list and add as another's tail
 304:./include/linux/list.h ****  * @list: the entry to move
 305:./include/linux/list.h ****  * @head: the head that will follow our entry
 306:./include/linux/list.h ****  */
 307:./include/linux/list.h **** static inline void list_move_tail(struct list_head *list,
 308:./include/linux/list.h **** 				  struct list_head *head)
 309:./include/linux/list.h **** {
 310:./include/linux/list.h **** 	__list_del_entry(list);
 311:./include/linux/list.h **** 	list_add_tail(list, head);
ARM GAS  /tmp/cczZAjmm.s 			page 25


 312:./include/linux/list.h **** }
 313:./include/linux/list.h **** 
 314:./include/linux/list.h **** /**
 315:./include/linux/list.h ****  * list_bulk_move_tail - move a subsection of a list to its tail
 316:./include/linux/list.h ****  * @head: the head that will follow our entry
 317:./include/linux/list.h ****  * @first: first entry to move
 318:./include/linux/list.h ****  * @last: last entry to move, can be the same as first
 319:./include/linux/list.h ****  *
 320:./include/linux/list.h ****  * Move all entries between @first and including @last before @head.
 321:./include/linux/list.h ****  * All three entries must belong to the same linked list.
 322:./include/linux/list.h ****  */
 323:./include/linux/list.h **** static inline void list_bulk_move_tail(struct list_head *head,
 324:./include/linux/list.h **** 				       struct list_head *first,
 325:./include/linux/list.h **** 				       struct list_head *last)
 326:./include/linux/list.h **** {
 327:./include/linux/list.h **** 	first->prev->next = last->next;
 328:./include/linux/list.h **** 	last->next->prev = first->prev;
 329:./include/linux/list.h **** 
 330:./include/linux/list.h **** 	head->prev->next = first;
 331:./include/linux/list.h **** 	first->prev = head->prev;
 332:./include/linux/list.h **** 
 333:./include/linux/list.h **** 	last->next = head;
 334:./include/linux/list.h **** 	head->prev = last;
 335:./include/linux/list.h **** }
 336:./include/linux/list.h **** 
 337:./include/linux/list.h **** /**
 338:./include/linux/list.h ****  * list_is_first -- tests whether @list is the first entry in list @head
 339:./include/linux/list.h ****  * @list: the entry to test
 340:./include/linux/list.h ****  * @head: the head of the list
 341:./include/linux/list.h ****  */
 342:./include/linux/list.h **** static inline int list_is_first(const struct list_head *list, const struct list_head *head)
 343:./include/linux/list.h **** {
 344:./include/linux/list.h **** 	return list->prev == head;
 345:./include/linux/list.h **** }
 346:./include/linux/list.h **** 
 347:./include/linux/list.h **** /**
 348:./include/linux/list.h ****  * list_is_last - tests whether @list is the last entry in list @head
 349:./include/linux/list.h ****  * @list: the entry to test
 350:./include/linux/list.h ****  * @head: the head of the list
 351:./include/linux/list.h ****  */
 352:./include/linux/list.h **** static inline int list_is_last(const struct list_head *list, const struct list_head *head)
 353:./include/linux/list.h **** {
 354:./include/linux/list.h **** 	return list->next == head;
 355:./include/linux/list.h **** }
 356:./include/linux/list.h **** 
 357:./include/linux/list.h **** /**
 358:./include/linux/list.h ****  * list_is_head - tests whether @list is the list @head
 359:./include/linux/list.h ****  * @list: the entry to test
 360:./include/linux/list.h ****  * @head: the head of the list
 361:./include/linux/list.h ****  */
 362:./include/linux/list.h **** static inline int list_is_head(const struct list_head *list, const struct list_head *head)
 363:./include/linux/list.h **** {
 364:./include/linux/list.h **** 	return list == head;
 365:./include/linux/list.h **** }
 366:./include/linux/list.h **** 
 367:./include/linux/list.h **** /**
 368:./include/linux/list.h ****  * list_empty - tests whether a list is empty
ARM GAS  /tmp/cczZAjmm.s 			page 26


 369:./include/linux/list.h ****  * @head: the list to test.
 370:./include/linux/list.h ****  */
 371:./include/linux/list.h **** static inline int list_empty(const struct list_head *head)
 532              		.loc 5 371 19 is_stmt 1 view .LVU144
 372:./include/linux/list.h **** {
 373:./include/linux/list.h **** 	return READ_ONCE(head->next) == head;
 533              		.loc 5 373 2 view .LVU145
 534              	.LBB110:
 535              		.loc 5 373 9 view .LVU146
 536              	.LBB111:
 537              		.loc 5 373 9 view .LVU147
 538              		.loc 5 373 9 view .LVU148
 539              	.LBE111:
 540              		.loc 5 373 9 discriminator 2 view .LVU149
 541              		.loc 5 373 9 discriminator 2 view .LVU150
 542 0012 A26A     		ldr	r2, [r4, #40]
 543              	.LVL40:
 544              		.loc 5 373 9 is_stmt 0 discriminator 2 view .LVU151
 545              	.LBE110:
 546              	.LBE109:
 547              		.loc 1 44 8 discriminator 1 view .LVU152
 548 0014 9342     		cmp	r3, r2
 549 0016 08D0     		beq	.L30
  45:./block/request_queue.c ****         list_del_init(&req->queuelist);  // Á°Æ‰øù `req->queuelist` Âèò‰∏∫Êú™‰ΩøÁî®Áä∂ÊÄÅ
 550              		.loc 1 45 9 is_stmt 1 view .LVU153
 551              	.LVL41:
 552              	.LBB112:
 553              	.LBI112:
 285:./include/linux/list.h **** {
 554              		.loc 5 285 20 view .LVU154
 287:./include/linux/list.h **** 	INIT_LIST_HEAD(entry);
 555              		.loc 5 287 2 view .LVU155
 556              	.LBB113:
 557              	.LBI113:
 213:./include/linux/list.h **** {
 558              		.loc 5 213 20 view .LVU156
 559              	.LBB114:
 215:./include/linux/list.h **** 		return;
 560              		.loc 5 215 2 view .LVU157
 218:./include/linux/list.h **** }
 561              		.loc 5 218 2 view .LVU158
 562 0018 E26A     		ldr	r2, [r4, #44]
 563 001a A16A     		ldr	r1, [r4, #40]
 564              	.LVL42:
 565              	.LBB115:
 566              	.LBI115:
 193:./include/linux/list.h **** {
 567              		.loc 5 193 20 view .LVU159
 568              	.LBB116:
 195:./include/linux/list.h **** 	WRITE_ONCE(prev->next, next);
 569              		.loc 5 195 2 view .LVU160
 195:./include/linux/list.h **** 	WRITE_ONCE(prev->next, next);
 570              		.loc 5 195 13 is_stmt 0 view .LVU161
 571 001c 4A60     		str	r2, [r1, #4]
 196:./include/linux/list.h **** }
 572              		.loc 5 196 2 is_stmt 1 view .LVU162
 196:./include/linux/list.h **** }
ARM GAS  /tmp/cczZAjmm.s 			page 27


 573              		.loc 5 196 2 view .LVU163
 574              	.LBB117:
 196:./include/linux/list.h **** }
 575              		.loc 5 196 2 view .LVU164
 196:./include/linux/list.h **** }
 576              		.loc 5 196 2 view .LVU165
 577              	.LBE117:
 196:./include/linux/list.h **** }
 578              		.loc 5 196 2 discriminator 2 view .LVU166
 196:./include/linux/list.h **** }
 579              		.loc 5 196 2 discriminator 2 view .LVU167
 196:./include/linux/list.h **** }
 580              		.loc 5 196 2 discriminator 2 view .LVU168
 581 001e 1160     		str	r1, [r2]
 196:./include/linux/list.h **** }
 582              		.loc 5 196 2 discriminator 2 view .LVU169
 196:./include/linux/list.h **** }
 583              		.loc 5 196 2 discriminator 2 view .LVU170
 584              	.LVL43:
 196:./include/linux/list.h **** }
 585              		.loc 5 196 2 is_stmt 0 discriminator 2 view .LVU171
 586              	.LBE116:
 587              	.LBE115:
 588              	.LBE114:
 589              	.LBE113:
 288:./include/linux/list.h **** }
 590              		.loc 5 288 2 is_stmt 1 view .LVU172
 591              	.LBB118:
 592              	.LBI118:
  35:./include/linux/list.h **** {
 593              		.loc 5 35 20 view .LVU173
 594              	.LBB119:
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 595              		.loc 5 37 2 view .LVU174
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 596              		.loc 5 37 2 view .LVU175
 597              	.LBB120:
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 598              		.loc 5 37 2 view .LVU176
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 599              		.loc 5 37 2 view .LVU177
 600              	.LBE120:
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 601              		.loc 5 37 2 discriminator 2 view .LVU178
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 602              		.loc 5 37 2 discriminator 2 view .LVU179
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 603              		.loc 5 37 2 discriminator 2 view .LVU180
 604 0020 A362     		str	r3, [r4, #40]
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 605              		.loc 5 37 2 discriminator 2 view .LVU181
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 606              		.loc 5 37 2 discriminator 2 view .LVU182
  38:./include/linux/list.h **** }
 607              		.loc 5 38 2 view .LVU183
  38:./include/linux/list.h **** }
 608              		.loc 5 38 2 view .LVU184
ARM GAS  /tmp/cczZAjmm.s 			page 28


 609              	.LBB121:
  38:./include/linux/list.h **** }
 610              		.loc 5 38 2 view .LVU185
  38:./include/linux/list.h **** }
 611              		.loc 5 38 2 view .LVU186
 612              	.LBE121:
  38:./include/linux/list.h **** }
 613              		.loc 5 38 2 discriminator 2 view .LVU187
  38:./include/linux/list.h **** }
 614              		.loc 5 38 2 discriminator 2 view .LVU188
  38:./include/linux/list.h **** }
 615              		.loc 5 38 2 discriminator 2 view .LVU189
 616 0022 E362     		str	r3, [r4, #44]
  38:./include/linux/list.h **** }
 617              		.loc 5 38 2 discriminator 2 view .LVU190
  38:./include/linux/list.h **** }
 618              		.loc 5 38 2 discriminator 2 view .LVU191
 619              	.LVL44:
  38:./include/linux/list.h **** }
 620              		.loc 5 38 2 is_stmt 0 discriminator 2 view .LVU192
 621              	.LBE119:
 622              	.LBE118:
 623              	.LBE112:
  46:./block/request_queue.c ****         vfree(req);
 624              		.loc 1 46 9 is_stmt 1 view .LVU193
 625              	.LBB122:
 626              	.LBI122:
 375:./include/linux/slab.h **** 	__sfree__(addr);
 627              		.loc 4 375 20 view .LVU194
 628              	.LBB123:
 376:./include/linux/slab.h **** }
 629              		.loc 4 376 2 view .LVU195
 630 0024 2046     		mov	r0, r4
 631 0026 FFF7FEFF 		bl	__sfree__
 632              	.LVL45:
 633              	.L30:
 376:./include/linux/slab.h **** }
 634              		.loc 4 376 2 is_stmt 0 view .LVU196
 635              	.LBE123:
 636              	.LBE122:
  47:./block/request_queue.c ****     } 
  48:./block/request_queue.c ****     spin_unlock(&q->queue_lock);
 637              		.loc 1 48 5 is_stmt 1 view .LVU197
 638 002a 2846     		mov	r0, r5
 639 002c FFF7FEFF 		bl	spin_unlock
 640              	.LVL46:
  49:./block/request_queue.c **** }
 641              		.loc 1 49 1 is_stmt 0 view .LVU198
 642 0030 38BD     		pop	{r3, r4, r5, pc}
 643              		.loc 1 49 1 view .LVU199
 644              		.cfi_endproc
 645              	.LFE1038:
 647              		.section	.rodata.process_requests_in_queue.str1.4,"aMS",%progbits,1
 648              		.align	2
 649              	.LC0:
 650 0000 50726F63 		.ascii	"Processing request: %p\012\000"
 650      65737369 
ARM GAS  /tmp/cczZAjmm.s 			page 29


 650      6E672072 
 650      65717565 
 650      73743A20 
 651              		.section	.text.process_requests_in_queue,"ax",%progbits
 652              		.align	1
 653              		.global	process_requests_in_queue
 654              		.syntax unified
 655              		.thumb
 656              		.thumb_func
 658              	process_requests_in_queue:
 659              	.LVL47:
 660              	.LFB1039:
  50:./block/request_queue.c **** 
  51:./block/request_queue.c **** 
  52:./block/request_queue.c **** void process_requests_in_queue(struct request_queue *q)
  53:./block/request_queue.c **** {
 661              		.loc 1 53 1 is_stmt 1 view -0
 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 0
 664              		@ frame_needed = 0, uses_anonymous_args = 0
 665              		.loc 1 53 1 is_stmt 0 view .LVU201
 666 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 667              	.LCFI10:
 668              		.cfi_def_cfa_offset 24
 669              		.cfi_offset 3, -24
 670              		.cfi_offset 4, -20
 671              		.cfi_offset 5, -16
 672              		.cfi_offset 6, -12
 673              		.cfi_offset 7, -8
 674              		.cfi_offset 14, -4
 675 0002 0746     		mov	r7, r0
  54:./block/request_queue.c ****     struct request *req, *tmp;
 676              		.loc 1 54 5 is_stmt 1 view .LVU202
  55:./block/request_queue.c **** 
  56:./block/request_queue.c ****     spin_lock(&q->queue_lock);
 677              		.loc 1 56 5 view .LVU203
 678 0004 00F10806 		add	r6, r0, #8
 679 0008 3046     		mov	r0, r6
 680              	.LVL48:
 681              		.loc 1 56 5 is_stmt 0 view .LVU204
 682 000a FFF7FEFF 		bl	spin_lock
 683              	.LVL49:
  57:./block/request_queue.c **** 
  58:./block/request_queue.c ****     list_for_each_entry_safe(req, tmp, &q->icq_list, queuelist) {
 684              		.loc 1 58 5 is_stmt 1 view .LVU205
 685              	.LBB124:
 686              		.loc 1 58 5 view .LVU206
 687              		.loc 1 58 5 view .LVU207
 688              		.loc 1 58 5 view .LVU208
 689 000e D7F8CC40 		ldr	r4, [r7, #204]
 690              	.LVL50:
 691              		.loc 1 58 5 is_stmt 0 view .LVU209
 692              	.LBE124:
 693              	.LBB125:
 694              		.loc 1 58 5 is_stmt 1 view .LVU210
 695 0012 54F82859 		ldr	r5, [r4], #-40
 696              	.LVL51:
ARM GAS  /tmp/cczZAjmm.s 			page 30


 697              		.loc 1 58 5 view .LVU211
 698              		.loc 1 58 5 view .LVU212
 699 0016 283D     		subs	r5, r5, #40
 700              	.LVL52:
 701              		.loc 1 58 5 is_stmt 0 view .LVU213
 702              	.LBE125:
 703 0018 1AE0     		b	.L33
 704              	.LVL53:
 705              	.L34:
  59:./block/request_queue.c ****         list_del(&req->queuelist);
 706              		.loc 1 59 9 is_stmt 1 view .LVU214
 707              	.LBB126:
 708              	.LBI126:
 227:./include/linux/list.h **** {
 709              		.loc 5 227 20 view .LVU215
 710              	.LBB127:
 229:./include/linux/list.h **** 	entry->next = LIST_POISON1;
 711              		.loc 5 229 2 view .LVU216
 712              	.LBB128:
 713              	.LBI128:
 213:./include/linux/list.h **** {
 714              		.loc 5 213 20 view .LVU217
 715              	.LBB129:
 215:./include/linux/list.h **** 		return;
 716              		.loc 5 215 2 view .LVU218
 218:./include/linux/list.h **** }
 717              		.loc 5 218 2 view .LVU219
 718 001a E36A     		ldr	r3, [r4, #44]
 719              	.LVL54:
 218:./include/linux/list.h **** }
 720              		.loc 5 218 2 is_stmt 0 view .LVU220
 721 001c A26A     		ldr	r2, [r4, #40]
 722              	.LVL55:
 723              	.LBB130:
 724              	.LBI130:
 193:./include/linux/list.h **** {
 725              		.loc 5 193 20 is_stmt 1 view .LVU221
 726              	.LBB131:
 195:./include/linux/list.h **** 	WRITE_ONCE(prev->next, next);
 727              		.loc 5 195 2 view .LVU222
 195:./include/linux/list.h **** 	WRITE_ONCE(prev->next, next);
 728              		.loc 5 195 13 is_stmt 0 view .LVU223
 729 001e 5360     		str	r3, [r2, #4]
 196:./include/linux/list.h **** }
 730              		.loc 5 196 2 is_stmt 1 view .LVU224
 196:./include/linux/list.h **** }
 731              		.loc 5 196 2 view .LVU225
 732              	.LBB132:
 196:./include/linux/list.h **** }
 733              		.loc 5 196 2 view .LVU226
 196:./include/linux/list.h **** }
 734              		.loc 5 196 2 view .LVU227
 735              	.LBE132:
 196:./include/linux/list.h **** }
 736              		.loc 5 196 2 discriminator 2 view .LVU228
 196:./include/linux/list.h **** }
 737              		.loc 5 196 2 discriminator 2 view .LVU229
ARM GAS  /tmp/cczZAjmm.s 			page 31


 196:./include/linux/list.h **** }
 738              		.loc 5 196 2 discriminator 2 view .LVU230
 739 0020 1A60     		str	r2, [r3]
 196:./include/linux/list.h **** }
 740              		.loc 5 196 2 discriminator 2 view .LVU231
 196:./include/linux/list.h **** }
 741              		.loc 5 196 2 discriminator 2 view .LVU232
 742              	.LVL56:
 196:./include/linux/list.h **** }
 743              		.loc 5 196 2 is_stmt 0 discriminator 2 view .LVU233
 744              	.LBE131:
 745              	.LBE130:
 746              	.LBE129:
 747              	.LBE128:
 230:./include/linux/list.h **** 	entry->prev = LIST_POISON2;
 748              		.loc 5 230 2 is_stmt 1 view .LVU234
 230:./include/linux/list.h **** 	entry->prev = LIST_POISON2;
 749              		.loc 5 230 14 is_stmt 0 view .LVU235
 750 0022 4FF48073 		mov	r3, #256
 751 0026 A362     		str	r3, [r4, #40]
 231:./include/linux/list.h **** }
 752              		.loc 5 231 2 is_stmt 1 view .LVU236
 231:./include/linux/list.h **** }
 753              		.loc 5 231 14 is_stmt 0 view .LVU237
 754 0028 4FF49173 		mov	r3, #290
 755 002c E362     		str	r3, [r4, #44]
 756              	.LVL57:
 231:./include/linux/list.h **** }
 757              		.loc 5 231 14 view .LVU238
 758              	.LBE127:
 759              	.LBE126:
  60:./block/request_queue.c ****         spin_unlock(&q->queue_lock);
 760              		.loc 1 60 9 is_stmt 1 view .LVU239
 761 002e 3046     		mov	r0, r6
 762 0030 FFF7FEFF 		bl	spin_unlock
 763              	.LVL58:
  61:./block/request_queue.c **** 
  62:./block/request_queue.c ****         // Â§ÑÁêÜËØ∑Ê±Ç
  63:./block/request_queue.c ****         printk(KERN_INFO "Processing request: %p\n", req);
 764              		.loc 1 63 9 view .LVU240
 765 0034 2146     		mov	r1, r4
 766 0036 0B48     		ldr	r0, .L36
 767 0038 FFF7FEFF 		bl	printk
 768              	.LVL59:
  64:./block/request_queue.c ****         kfree(req);  // ÈáäÊîæËØ∑Ê±Ç
 769              		.loc 1 64 9 view .LVU241
 770              	.LBB133:
 771              	.LBI133:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 772              		.loc 4 383 20 view .LVU242
 773              	.LBB134:
 774              		.loc 4 384 2 view .LVU243
 775 003c 2046     		mov	r0, r4
 776 003e FFF7FEFF 		bl	__sfree__
 777              	.LVL60:
 778              		.loc 4 384 2 is_stmt 0 view .LVU244
 779              	.LBE134:
ARM GAS  /tmp/cczZAjmm.s 			page 32


 780              	.LBE133:
  65:./block/request_queue.c **** 
  66:./block/request_queue.c ****         spin_lock(&q->queue_lock);
 781              		.loc 1 66 9 is_stmt 1 view .LVU245
 782 0042 3046     		mov	r0, r6
 783 0044 FFF7FEFF 		bl	spin_lock
 784              	.LVL61:
  58:./block/request_queue.c ****         list_del(&req->queuelist);
 785              		.loc 1 58 5 discriminator 3 view .LVU246
 786              	.LBB135:
  58:./block/request_queue.c ****         list_del(&req->queuelist);
 787              		.loc 1 58 5 discriminator 3 view .LVU247
 788 0048 AB6A     		ldr	r3, [r5, #40]
 789              	.LVL62:
  58:./block/request_queue.c ****         list_del(&req->queuelist);
 790              		.loc 1 58 5 discriminator 3 view .LVU248
  58:./block/request_queue.c ****         list_del(&req->queuelist);
 791              		.loc 1 58 5 discriminator 3 view .LVU249
  58:./block/request_queue.c ****         list_del(&req->queuelist);
 792              		.loc 1 58 5 is_stmt 0 discriminator 3 view .LVU250
 793              	.LBE135:
 794 004a 2C46     		mov	r4, r5
 795 004c A3F12805 		sub	r5, r3, #40
 796              	.LVL63:
 797              	.L33:
  58:./block/request_queue.c ****         list_del(&req->queuelist);
 798              		.loc 1 58 5 is_stmt 1 discriminator 1 view .LVU251
 799 0050 04F12803 		add	r3, r4, #40
 800 0054 07F1CC02 		add	r2, r7, #204
 801 0058 9342     		cmp	r3, r2
 802 005a DED1     		bne	.L34
  67:./block/request_queue.c ****     }
  68:./block/request_queue.c **** 
  69:./block/request_queue.c ****     spin_unlock(&q->queue_lock);
 803              		.loc 1 69 5 view .LVU252
 804 005c 3046     		mov	r0, r6
 805 005e FFF7FEFF 		bl	spin_unlock
 806              	.LVL64:
  70:./block/request_queue.c **** }
 807              		.loc 1 70 1 is_stmt 0 view .LVU253
 808 0062 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 809              	.LVL65:
 810              	.L37:
 811              		.loc 1 70 1 view .LVU254
 812              		.align	2
 813              	.L36:
 814 0064 00000000 		.word	.LC0
 815              		.cfi_endproc
 816              	.LFE1039:
 818              		.section	.text.blk_fetch_request,"ax",%progbits
 819              		.align	1
 820              		.global	blk_fetch_request
 821              		.syntax unified
 822              		.thumb
 823              		.thumb_func
 825              	blk_fetch_request:
 826              	.LVL66:
ARM GAS  /tmp/cczZAjmm.s 			page 33


 827              	.LFB1040:
  71:./block/request_queue.c **** 
  72:./block/request_queue.c **** 
  73:./block/request_queue.c **** 
  74:./block/request_queue.c **** struct request *blk_fetch_request(struct request_queue *q)
  75:./block/request_queue.c **** {
 828              		.loc 1 75 1 is_stmt 1 view -0
 829              		.cfi_startproc
 830              		@ args = 0, pretend = 0, frame = 0
 831              		@ frame_needed = 0, uses_anonymous_args = 0
 832              		.loc 1 75 1 is_stmt 0 view .LVU256
 833 0000 38B5     		push	{r3, r4, r5, lr}
 834              	.LCFI11:
 835              		.cfi_def_cfa_offset 16
 836              		.cfi_offset 3, -16
 837              		.cfi_offset 4, -12
 838              		.cfi_offset 5, -8
 839              		.cfi_offset 14, -4
 840 0002 0446     		mov	r4, r0
  76:./block/request_queue.c ****     struct request *req = NULL;
 841              		.loc 1 76 5 is_stmt 1 view .LVU257
 842              	.LVL67:
  77:./block/request_queue.c **** 
  78:./block/request_queue.c ****     // Ëé∑ÂèñÈòüÂàóÁöÑËá™ÊóãÈîÅÔºåÈò≤Ê≠¢Âπ∂Âèë‰øÆÊîπ
  79:./block/request_queue.c ****     spin_lock(&q->queue_lock);
 843              		.loc 1 79 5 view .LVU258
 844 0004 00F10805 		add	r5, r0, #8
 845 0008 2846     		mov	r0, r5
 846              	.LVL68:
 847              		.loc 1 79 5 is_stmt 0 view .LVU259
 848 000a FFF7FEFF 		bl	spin_lock
 849              	.LVL69:
  80:./block/request_queue.c **** 
  81:./block/request_queue.c ****     if (!list_empty(&q->icq_list)) {
 850              		.loc 1 81 5 is_stmt 1 view .LVU260
 851              		.loc 1 81 21 is_stmt 0 view .LVU261
 852 000e 04F1CC02 		add	r2, r4, #204
 853              	.LVL70:
 854              	.LBB136:
 855              	.LBI136:
 371:./include/linux/list.h **** {
 856              		.loc 5 371 19 is_stmt 1 view .LVU262
 857              		.loc 5 373 2 view .LVU263
 858              	.LBB137:
 859              		.loc 5 373 9 view .LVU264
 860              	.LBB138:
 861              		.loc 5 373 9 view .LVU265
 862              		.loc 5 373 9 view .LVU266
 863              	.LBE138:
 864              		.loc 5 373 9 discriminator 2 view .LVU267
 865              		.loc 5 373 9 discriminator 2 view .LVU268
 866 0012 D4F8CC30 		ldr	r3, [r4, #204]
 867              	.LVL71:
 868              		.loc 5 373 9 is_stmt 0 discriminator 2 view .LVU269
 869              	.LBE137:
 870              	.LBE136:
 871              		.loc 1 81 8 discriminator 1 view .LVU270
ARM GAS  /tmp/cczZAjmm.s 			page 34


 872 0016 9A42     		cmp	r2, r3
 873 0018 12D0     		beq	.L40
  82:./block/request_queue.c ****         // Ëé∑ÂèñÈòüÂàóÂ§¥ÈÉ®ÁöÑËØ∑Ê±Ç
  83:./block/request_queue.c ****         req = list_first_entry(&q->icq_list, struct request, queuelist);
 874              		.loc 1 83 9 is_stmt 1 view .LVU271
 875              	.LBB139:
 876              		.loc 1 83 15 view .LVU272
 877 001a D4F8CC30 		ldr	r3, [r4, #204]
 878              	.LVL72:
 879              		.loc 1 83 15 view .LVU273
 880              		.loc 1 83 15 view .LVU274
 881 001e A3F12804 		sub	r4, r3, #40
 882              	.LVL73:
 883              		.loc 1 83 15 is_stmt 0 view .LVU275
 884              	.LBE139:
  84:./block/request_queue.c ****         // ‰ªéÈòüÂàó‰∏≠Âà†Èô§Ëøô‰∏™ËØ∑Ê±Ç
  85:./block/request_queue.c ****         list_del(&req->queuelist);
 885              		.loc 1 85 9 is_stmt 1 view .LVU276
 886              	.LBB140:
 887              	.LBI140:
 227:./include/linux/list.h **** {
 888              		.loc 5 227 20 view .LVU277
 889              	.LBB141:
 229:./include/linux/list.h **** 	entry->next = LIST_POISON1;
 890              		.loc 5 229 2 view .LVU278
 891              	.LBB142:
 892              	.LBI142:
 213:./include/linux/list.h **** {
 893              		.loc 5 213 20 view .LVU279
 894              	.LBB143:
 215:./include/linux/list.h **** 		return;
 895              		.loc 5 215 2 view .LVU280
 218:./include/linux/list.h **** }
 896              		.loc 5 218 2 view .LVU281
 897 0022 5A68     		ldr	r2, [r3, #4]
 898              	.LVL74:
 218:./include/linux/list.h **** }
 899              		.loc 5 218 2 is_stmt 0 view .LVU282
 900 0024 1968     		ldr	r1, [r3]
 901              	.LVL75:
 902              	.LBB144:
 903              	.LBI144:
 193:./include/linux/list.h **** {
 904              		.loc 5 193 20 is_stmt 1 view .LVU283
 905              	.LBB145:
 195:./include/linux/list.h **** 	WRITE_ONCE(prev->next, next);
 906              		.loc 5 195 2 view .LVU284
 195:./include/linux/list.h **** 	WRITE_ONCE(prev->next, next);
 907              		.loc 5 195 13 is_stmt 0 view .LVU285
 908 0026 4A60     		str	r2, [r1, #4]
 196:./include/linux/list.h **** }
 909              		.loc 5 196 2 is_stmt 1 view .LVU286
 196:./include/linux/list.h **** }
 910              		.loc 5 196 2 view .LVU287
 911              	.LBB146:
 196:./include/linux/list.h **** }
 912              		.loc 5 196 2 view .LVU288
ARM GAS  /tmp/cczZAjmm.s 			page 35


 196:./include/linux/list.h **** }
 913              		.loc 5 196 2 view .LVU289
 914              	.LBE146:
 196:./include/linux/list.h **** }
 915              		.loc 5 196 2 discriminator 2 view .LVU290
 196:./include/linux/list.h **** }
 916              		.loc 5 196 2 discriminator 2 view .LVU291
 196:./include/linux/list.h **** }
 917              		.loc 5 196 2 discriminator 2 view .LVU292
 918 0028 1160     		str	r1, [r2]
 196:./include/linux/list.h **** }
 919              		.loc 5 196 2 discriminator 2 view .LVU293
 196:./include/linux/list.h **** }
 920              		.loc 5 196 2 discriminator 2 view .LVU294
 921              	.LVL76:
 196:./include/linux/list.h **** }
 922              		.loc 5 196 2 is_stmt 0 discriminator 2 view .LVU295
 923              	.LBE145:
 924              	.LBE144:
 925              	.LBE143:
 926              	.LBE142:
 230:./include/linux/list.h **** 	entry->prev = LIST_POISON2;
 927              		.loc 5 230 2 is_stmt 1 view .LVU296
 230:./include/linux/list.h **** 	entry->prev = LIST_POISON2;
 928              		.loc 5 230 14 is_stmt 0 view .LVU297
 929 002a 4FF48072 		mov	r2, #256
 930 002e 1A60     		str	r2, [r3]
 231:./include/linux/list.h **** }
 931              		.loc 5 231 2 is_stmt 1 view .LVU298
 231:./include/linux/list.h **** }
 932              		.loc 5 231 14 is_stmt 0 view .LVU299
 933 0030 4FF49172 		mov	r2, #290
 934 0034 5A60     		str	r2, [r3, #4]
 935              	.LVL77:
 936              	.L39:
 231:./include/linux/list.h **** }
 937              		.loc 5 231 14 view .LVU300
 938              	.LBE141:
 939              	.LBE140:
  86:./block/request_queue.c ****     }
  87:./block/request_queue.c **** 
  88:./block/request_queue.c ****     // ÈáäÊîæËá™ÊóãÈîÅ
  89:./block/request_queue.c ****     spin_unlock(&q->queue_lock);
 940              		.loc 1 89 5 is_stmt 1 view .LVU301
 941 0036 2846     		mov	r0, r5
 942 0038 FFF7FEFF 		bl	spin_unlock
 943              	.LVL78:
  90:./block/request_queue.c **** 
  91:./block/request_queue.c ****     return req;  // ËøîÂõûÊâæÂà∞ÁöÑËØ∑Ê±Ç
 944              		.loc 1 91 5 view .LVU302
  92:./block/request_queue.c **** }
 945              		.loc 1 92 1 is_stmt 0 view .LVU303
 946 003c 2046     		mov	r0, r4
 947 003e 38BD     		pop	{r3, r4, r5, pc}
 948              	.LVL79:
 949              	.L40:
  76:./block/request_queue.c **** 
ARM GAS  /tmp/cczZAjmm.s 			page 36


 950              		.loc 1 76 21 view .LVU304
 951 0040 0024     		movs	r4, #0
 952              	.LVL80:
  76:./block/request_queue.c **** 
 953              		.loc 1 76 21 view .LVU305
 954 0042 F8E7     		b	.L39
 955              		.cfi_endproc
 956              	.LFE1040:
 958              		.section	.text.__blk_end_request_cur,"ax",%progbits
 959              		.align	1
 960              		.global	__blk_end_request_cur
 961              		.syntax unified
 962              		.thumb
 963              		.thumb_func
 965              	__blk_end_request_cur:
 966              	.LVL81:
 967              	.LFB1041:
  93:./block/request_queue.c **** 
  94:./block/request_queue.c **** int __blk_end_request_cur(struct request *req, int error)
  95:./block/request_queue.c **** {
 968              		.loc 1 95 1 is_stmt 1 view -0
 969              		.cfi_startproc
 970              		@ args = 0, pretend = 0, frame = 0
 971              		@ frame_needed = 0, uses_anonymous_args = 0
 972              		.loc 1 95 1 is_stmt 0 view .LVU307
 973 0000 38B5     		push	{r3, r4, r5, lr}
 974              	.LCFI12:
 975              		.cfi_def_cfa_offset 16
 976              		.cfi_offset 3, -16
 977              		.cfi_offset 4, -12
 978              		.cfi_offset 5, -8
 979              		.cfi_offset 14, -4
  96:./block/request_queue.c ****     struct request_queue *q = req->q;
 980              		.loc 1 96 5 is_stmt 1 view .LVU308
 981              		.loc 1 96 27 is_stmt 0 view .LVU309
 982 0002 0468     		ldr	r4, [r0]
 983              	.LVL82:
  97:./block/request_queue.c ****     spin_lock(&q->queue_lock);
 984              		.loc 1 97 5 is_stmt 1 view .LVU310
 985 0004 04F10805 		add	r5, r4, #8
 986 0008 2846     		mov	r0, r5
 987              	.LVL83:
 988              		.loc 1 97 5 is_stmt 0 view .LVU311
 989 000a FFF7FEFF 		bl	spin_lock
 990              	.LVL84:
  98:./block/request_queue.c ****     int is_last = list_is_singular(&q->icq_list) || list_empty(&q->icq_list);
 991              		.loc 1 98 5 is_stmt 1 view .LVU312
 992              		.loc 1 98 36 is_stmt 0 view .LVU313
 993 000e 04F1CC03 		add	r3, r4, #204
 994              	.LVL85:
 995              	.LBB147:
 996              	.LBI147:
 374:./include/linux/list.h **** }
 375:./include/linux/list.h **** 
 376:./include/linux/list.h **** /**
 377:./include/linux/list.h ****  * list_del_init_careful - deletes entry from list and reinitialize it.
 378:./include/linux/list.h ****  * @entry: the element to delete from the list.
ARM GAS  /tmp/cczZAjmm.s 			page 37


 379:./include/linux/list.h ****  *
 380:./include/linux/list.h ****  * This is the same as list_del_init(), except designed to be used
 381:./include/linux/list.h ****  * together with list_empty_careful() in a way to guarantee ordering
 382:./include/linux/list.h ****  * of other memory operations.
 383:./include/linux/list.h ****  *
 384:./include/linux/list.h ****  * Any memory operations done before a list_del_init_careful() are
 385:./include/linux/list.h ****  * guaranteed to be visible after a list_empty_careful() test.
 386:./include/linux/list.h ****  */
 387:./include/linux/list.h **** static inline void list_del_init_careful(struct list_head *entry)
 388:./include/linux/list.h **** {
 389:./include/linux/list.h **** 	__list_del_entry(entry);
 390:./include/linux/list.h **** 	WRITE_ONCE(entry->prev, entry);
 391:./include/linux/list.h **** 	smp_store_release(&entry->next, entry);
 392:./include/linux/list.h **** }
 393:./include/linux/list.h **** 
 394:./include/linux/list.h **** /**
 395:./include/linux/list.h ****  * list_empty_careful - tests whether a list is empty and not being modified
 396:./include/linux/list.h ****  * @head: the list to test
 397:./include/linux/list.h ****  *
 398:./include/linux/list.h ****  * Description:
 399:./include/linux/list.h ****  * tests whether a list is empty _and_ checks that no other CPU might be
 400:./include/linux/list.h ****  * in the process of modifying either member (next or prev)
 401:./include/linux/list.h ****  *
 402:./include/linux/list.h ****  * NOTE: using list_empty_careful() without synchronization
 403:./include/linux/list.h ****  * can only be safe if the only activity that can happen
 404:./include/linux/list.h ****  * to the list entry is list_del_init(). Eg. it cannot be used
 405:./include/linux/list.h ****  * if another CPU could re-list_add() it.
 406:./include/linux/list.h ****  */
 407:./include/linux/list.h **** static inline int list_empty_careful(const struct list_head *head)
 408:./include/linux/list.h **** {
 409:./include/linux/list.h **** 	struct list_head *next = smp_load_acquire(&head->next);
 410:./include/linux/list.h **** 	return list_is_head(next, head) && (next == READ_ONCE(head->prev));
 411:./include/linux/list.h **** }
 412:./include/linux/list.h **** 
 413:./include/linux/list.h **** /**
 414:./include/linux/list.h ****  * list_rotate_left - rotate the list to the left
 415:./include/linux/list.h ****  * @head: the head of the list
 416:./include/linux/list.h ****  */
 417:./include/linux/list.h **** static inline void list_rotate_left(struct list_head *head)
 418:./include/linux/list.h **** {
 419:./include/linux/list.h **** 	struct list_head *first;
 420:./include/linux/list.h **** 
 421:./include/linux/list.h **** 	if (!list_empty(head)) {
 422:./include/linux/list.h **** 		first = head->next;
 423:./include/linux/list.h **** 		list_move_tail(first, head);
 424:./include/linux/list.h **** 	}
 425:./include/linux/list.h **** }
 426:./include/linux/list.h **** 
 427:./include/linux/list.h **** /**
 428:./include/linux/list.h ****  * list_rotate_to_front() - Rotate list to specific item.
 429:./include/linux/list.h ****  * @list: The desired new front of the list.
 430:./include/linux/list.h ****  * @head: The head of the list.
 431:./include/linux/list.h ****  *
 432:./include/linux/list.h ****  * Rotates list so that @list becomes the new front of the list.
 433:./include/linux/list.h ****  */
 434:./include/linux/list.h **** static inline void list_rotate_to_front(struct list_head *list,
 435:./include/linux/list.h **** 					struct list_head *head)
ARM GAS  /tmp/cczZAjmm.s 			page 38


 436:./include/linux/list.h **** {
 437:./include/linux/list.h **** 	/*
 438:./include/linux/list.h **** 	 * Deletes the list head from the list denoted by @head and
 439:./include/linux/list.h **** 	 * places it as the tail of @list, this effectively rotates the
 440:./include/linux/list.h **** 	 * list so that @list is at the front.
 441:./include/linux/list.h **** 	 */
 442:./include/linux/list.h **** 	list_move_tail(head, list);
 443:./include/linux/list.h **** }
 444:./include/linux/list.h **** 
 445:./include/linux/list.h **** /**
 446:./include/linux/list.h ****  * list_is_singular - tests whether a list has just one entry.
 447:./include/linux/list.h ****  * @head: the list to test.
 448:./include/linux/list.h ****  */
 449:./include/linux/list.h **** static inline int list_is_singular(const struct list_head *head)
 997              		.loc 5 449 19 is_stmt 1 view .LVU314
 998              	.LBB148:
 450:./include/linux/list.h **** {
 451:./include/linux/list.h **** 	return !list_empty(head) && (head->next == head->prev);
 999              		.loc 5 451 2 view .LVU315
 1000              	.LBB149:
 1001              	.LBI149:
 371:./include/linux/list.h **** {
 1002              		.loc 5 371 19 view .LVU316
 373:./include/linux/list.h **** }
 1003              		.loc 5 373 2 view .LVU317
 1004              	.LBB150:
 373:./include/linux/list.h **** }
 1005              		.loc 5 373 9 view .LVU318
 1006              	.LBB151:
 373:./include/linux/list.h **** }
 1007              		.loc 5 373 9 view .LVU319
 373:./include/linux/list.h **** }
 1008              		.loc 5 373 9 view .LVU320
 1009              	.LBE151:
 373:./include/linux/list.h **** }
 1010              		.loc 5 373 9 discriminator 2 view .LVU321
 373:./include/linux/list.h **** }
 1011              		.loc 5 373 9 discriminator 2 view .LVU322
 1012 0012 D4F8CC20 		ldr	r2, [r4, #204]
 1013              	.LVL86:
 373:./include/linux/list.h **** }
 1014              		.loc 5 373 9 is_stmt 0 discriminator 2 view .LVU323
 1015              	.LBE150:
 1016              	.LBE149:
 1017              		.loc 5 451 27 discriminator 1 view .LVU324
 1018 0016 9342     		cmp	r3, r2
 1019 0018 05D0     		beq	.L43
 1020              		.loc 5 451 35 discriminator 1 view .LVU325
 1021 001a D4F8CC10 		ldr	r1, [r4, #204]
 1022              		.loc 5 451 49 discriminator 1 view .LVU326
 1023 001e D4F8D020 		ldr	r2, [r4, #208]
 1024              		.loc 5 451 27 discriminator 1 view .LVU327
 1025 0022 9142     		cmp	r1, r2
 1026 0024 09D0     		beq	.L45
 1027              	.L43:
 1028              	.LVL87:
 1029              		.loc 5 451 27 discriminator 1 view .LVU328
ARM GAS  /tmp/cczZAjmm.s 			page 39


 1030              	.LBE148:
 1031              	.LBE147:
 1032              	.LBB152:
 1033              	.LBI152:
 371:./include/linux/list.h **** {
 1034              		.loc 5 371 19 is_stmt 1 view .LVU329
 373:./include/linux/list.h **** }
 1035              		.loc 5 373 2 view .LVU330
 1036              	.LBB153:
 373:./include/linux/list.h **** }
 1037              		.loc 5 373 9 view .LVU331
 1038              	.LBB154:
 373:./include/linux/list.h **** }
 1039              		.loc 5 373 9 view .LVU332
 373:./include/linux/list.h **** }
 1040              		.loc 5 373 9 view .LVU333
 1041              	.LBE154:
 373:./include/linux/list.h **** }
 1042              		.loc 5 373 9 discriminator 2 view .LVU334
 373:./include/linux/list.h **** }
 1043              		.loc 5 373 9 discriminator 2 view .LVU335
 1044 0026 D4F8CC20 		ldr	r2, [r4, #204]
 1045              	.LVL88:
 373:./include/linux/list.h **** }
 1046              		.loc 5 373 9 is_stmt 0 discriminator 2 view .LVU336
 1047              	.LBE153:
 1048              	.LBE152:
 1049              		.loc 1 98 50 discriminator 1 view .LVU337
 1050 002a 9342     		cmp	r3, r2
 1051 002c 07D0     		beq	.L46
 1052              		.loc 1 98 50 discriminator 4 view .LVU338
 1053 002e 0024     		movs	r4, #0
 1054              	.LVL89:
 1055              	.L44:
  99:./block/request_queue.c ****     spin_unlock(&q->queue_lock);
 1056              		.loc 1 99 5 is_stmt 1 view .LVU339
 1057 0030 2846     		mov	r0, r5
 1058 0032 FFF7FEFF 		bl	spin_unlock
 1059              	.LVL90:
 100:./block/request_queue.c ****     return is_last;
 1060              		.loc 1 100 5 view .LVU340
 101:./block/request_queue.c **** }...
 1061              		.loc 1 101 1 is_stmt 0 view .LVU341
 1062 0036 2046     		mov	r0, r4
 1063 0038 38BD     		pop	{r3, r4, r5, pc}
 1064              	.LVL91:
 1065              	.L45:
  98:./block/request_queue.c ****     int is_last = list_is_singular(&q->icq_list) || list_empty(&q->icq_list);
 1066              		.loc 1 98 50 discriminator 3 view .LVU342
 1067 003a 0124     		movs	r4, #1
 1068              	.LVL92:
  98:./block/request_queue.c ****     int is_last = list_is_singular(&q->icq_list) || list_empty(&q->icq_list);
 1069              		.loc 1 98 50 discriminator 3 view .LVU343
 1070 003c F8E7     		b	.L44
 1071              	.LVL93:
 1072              	.L46:
  98:./block/request_queue.c ****     int is_last = list_is_singular(&q->icq_list) || list_empty(&q->icq_list);
ARM GAS  /tmp/cczZAjmm.s 			page 40


 1073              		.loc 1 98 50 discriminator 3 view .LVU344
 1074 003e 0124     		movs	r4, #1
 1075              	.LVL94:
  98:./block/request_queue.c ****     int is_last = list_is_singular(&q->icq_list) || list_empty(&q->icq_list);
 1076              		.loc 1 98 50 discriminator 3 view .LVU345
 1077 0040 F6E7     		b	.L44
 1078              		.cfi_endproc
 1079              	.LFE1041:
 1081              		.text
 1082              	.Letext0:
 1083              		.file 6 "./include/asm-generic/int-l64.h"
 1084              		.file 7 "./include/asm-generic/posix_types.h"
 1085              		.file 8 "./include/uapi/linux/types.h"
 1086              		.file 9 "./include/linux/types.h"
 1087              		.file 10 "./include/linux/time64.h"
 1088              		.file 11 "./arch/arm_m/include/asm/sched.h"
 1089              		.file 12 "./include/linux/sched.h"
 1090              		.file 13 "./include/linux/spinlock_types_raw.h"
 1091              		.file 14 "./include/linux/spinlock_types.h"
 1092              		.file 15 "./include/linux/mutex.h"
 1093              		.file 16 "./include/linux/errseq.h"
 1094              		.file 17 "./include/linux/rbtree_types.h"
 1095              		.file 18 "./include/linux/uidgid_types.h"
 1096              		.file 19 "./include/linux/projid.h"
 1097              		.file 20 "./include/linux/fs.h"
 1098              		.file 21 "./include/linux/mnt_idmapping.h"
 1099              		.file 22 "./include/linux/uio.h"
 1100              		.file 23 "./include/linux/migrate_mode.h"
 1101              		.file 24 "./include/linux/wait.h"
 1102              		.file 25 "./include/linux/xarray.h"
 1103              		.file 26 "./include/linux/lockref.h"
 1104              		.file 27 "./include/linux/dcache.h"
 1105              		.file 28 "./include/linux/path.h"
 1106              		.file 29 "./include/linux/stddef.h"
 1107              		.file 30 "./include/linux/gfp_types.h"
 1108              		.file 31 "./include/linux/reciprocal_div.h"
 1109              		.file 32 "./include/linux/mm_type.h"
 1110              		.file 33 "./include/linux/statfs.h"
 1111              		.file 34 "./include/linux/stat.h"
 1112              		.file 35 "./include/linux/bvec.h"
 1113              		.file 36 "./include/linux/blk_types.h"
 1114              		.file 37 "./include/linux/rw_hint.h"
 1115              		.file 38 "./include/linux/blkdev.h"
 1116              		.file 39 "./include/linux/bio.h"
 1117              		.file 40 "./include/linux/mempool_super_haper.h"
 1118              		.file 41 "./include/linux/mempool.h"
 1119              		.file 42 "./include/linux/lockdep_types.h"
 1120              		.file 43 "./include/linux/workqueue_types.h"
 1121              		.file 44 "./include/linux/blk-mq.h"
 1122              		.file 45 "./include/uapi/linux/pr.h"
 1123              		.file 46 "./include/linux/pr.h"
 1124              		.file 47 "./include/linux/hdreg.h"
 1125              		.file 48 "./include/linux/printk.h"
ARM GAS  /tmp/cczZAjmm.s 			page 41


DEFINED SYMBOLS
                            *ABS*:00000000 request_queue.c
     /tmp/cczZAjmm.s:21     .text.__spin_init:00000000 $t
     /tmp/cczZAjmm.s:26     .text.__spin_init:00000000 __spin_init
     /tmp/cczZAjmm.s:46     .text.__spin_unlock:00000000 $t
     /tmp/cczZAjmm.s:51     .text.__spin_unlock:00000000 __spin_unlock
     /tmp/cczZAjmm.s:69     .text.spin_lock_init:00000000 $t
     /tmp/cczZAjmm.s:74     .text.spin_lock_init:00000000 spin_lock_init
     /tmp/cczZAjmm.s:97     .text.spin_unlock:00000000 $t
     /tmp/cczZAjmm.s:102    .text.spin_unlock:00000000 spin_unlock
     /tmp/cczZAjmm.s:124    .text.__spin_lock:00000000 $t
     /tmp/cczZAjmm.s:129    .text.__spin_lock:00000000 __spin_lock
     /tmp/cczZAjmm.s:179    .text.spin_lock:00000000 $t
     /tmp/cczZAjmm.s:184    .text.spin_lock:00000000 spin_lock
     /tmp/cczZAjmm.s:244    .text.request_queue_init:00000000 $t
     /tmp/cczZAjmm.s:250    .text.request_queue_init:00000000 request_queue_init
     /tmp/cczZAjmm.s:377    .text.__blk_cleanup_queue:00000000 $t
     /tmp/cczZAjmm.s:383    .text.__blk_cleanup_queue:00000000 __blk_cleanup_queue
     /tmp/cczZAjmm.s:425    .text.request_queue_add:00000000 $t
     /tmp/cczZAjmm.s:431    .text.request_queue_add:00000000 request_queue_add
     /tmp/cczZAjmm.s:497    .text.request_queue_remove:00000000 $t
     /tmp/cczZAjmm.s:503    .text.request_queue_remove:00000000 request_queue_remove
     /tmp/cczZAjmm.s:648    .rodata.process_requests_in_queue.str1.4:00000000 $d
     /tmp/cczZAjmm.s:652    .text.process_requests_in_queue:00000000 $t
     /tmp/cczZAjmm.s:658    .text.process_requests_in_queue:00000000 process_requests_in_queue
     /tmp/cczZAjmm.s:814    .text.process_requests_in_queue:00000064 $d
     /tmp/cczZAjmm.s:819    .text.blk_fetch_request:00000000 $t
     /tmp/cczZAjmm.s:825    .text.blk_fetch_request:00000000 blk_fetch_request
     /tmp/cczZAjmm.s:959    .text.__blk_end_request_cur:00000000 $t
     /tmp/cczZAjmm.s:965    .text.__blk_end_request_cur:00000000 __blk_end_request_cur

UNDEFINED SYMBOLS
stop_all_scheduler
start_all_scheduler
get_current_task
__delay
__smalloc__
__sfree__
printk
