ARM GAS  /tmp/cc80GKN8.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"stm32f4_spi.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./drivers/spi/stm32f4_spi.c"
  20              		.section	.text.SPI1_Init,"ax",%progbits
  21              		.align	1
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	SPI1_Init:
  27              	.LFB1033:
   1:./drivers/spi/stm32f4_spi.c **** #include <linux/kernel.h>
   2:./drivers/spi/stm32f4_spi.c **** #include <linux/fs.h>
   3:./drivers/spi/stm32f4_spi.c **** #include <linux/init.h>
   4:./drivers/spi/stm32f4_spi.c **** #include <linux/spi/spi.h>
   5:./drivers/spi/stm32f4_spi.c **** #include <linux/slab.h>
   6:./drivers/spi/stm32f4_spi.c **** #include <linux/device.h>
   7:./drivers/spi/stm32f4_spi.c **** #include <linux/gpio_subsystem.h>
   8:./drivers/spi/stm32f4_spi.c **** 
   9:./drivers/spi/stm32f4_spi.c **** // 基础地址
  10:./drivers/spi/stm32f4_spi.c **** #define PERIPH_BASE           ((unsigned int)0x40000000)
  11:./drivers/spi/stm32f4_spi.c **** #define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000)
  12:./drivers/spi/stm32f4_spi.c **** #define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000)
  13:./drivers/spi/stm32f4_spi.c **** 
  14:./drivers/spi/stm32f4_spi.c **** // GPIOA
  15:./drivers/spi/stm32f4_spi.c **** #define GPIOA_BASE            (AHB1PERIPH_BASE + 0x0000)
  16:./drivers/spi/stm32f4_spi.c **** #define GPIOA_MODER           (*(volatile unsigned int *)(GPIOA_BASE + 0x00))
  17:./drivers/spi/stm32f4_spi.c **** #define GPIOA_OTYPER          (*(volatile unsigned int *)(GPIOA_BASE + 0x04))
  18:./drivers/spi/stm32f4_spi.c **** #define GPIOA_OSPEEDR         (*(volatile unsigned int *)(GPIOA_BASE + 0x08))
  19:./drivers/spi/stm32f4_spi.c **** #define GPIOA_PUPDR           (*(volatile unsigned int *)(GPIOA_BASE + 0x0C))
  20:./drivers/spi/stm32f4_spi.c **** #define GPIOA_AFRL            (*(volatile unsigned int *)(GPIOA_BASE + 0x20))  // 低8位引脚AFR
  21:./drivers/spi/stm32f4_spi.c **** 
  22:./drivers/spi/stm32f4_spi.c **** // RCC
  23:./drivers/spi/stm32f4_spi.c **** #define RCC_BASE              (AHB1PERIPH_BASE + 0x3800)
  24:./drivers/spi/stm32f4_spi.c **** #define RCC_AHB1ENR           (*(volatile unsigned int *)(RCC_BASE + 0x30))
  25:./drivers/spi/stm32f4_spi.c **** #define RCC_APB2ENR           (*(volatile unsigned int *)(RCC_BASE + 0x44))
  26:./drivers/spi/stm32f4_spi.c **** #define RCC_APB2RSTR          (*(volatile unsigned int *)(RCC_BASE + 0x24))
  27:./drivers/spi/stm32f4_spi.c **** 
  28:./drivers/spi/stm32f4_spi.c **** // SPI1
  29:./drivers/spi/stm32f4_spi.c **** #define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
  30:./drivers/spi/stm32f4_spi.c **** #define SPI1_CR1              (*(volatile unsigned int *)(SPI1_BASE + 0x00))
  31:./drivers/spi/stm32f4_spi.c **** #define SPI1_CR2              (*(volatile unsigned int *)(SPI1_BASE + 0x04))
ARM GAS  /tmp/cc80GKN8.s 			page 2


  32:./drivers/spi/stm32f4_spi.c **** #define SPI1_SR               (*(volatile unsigned int *)(SPI1_BASE + 0x08))
  33:./drivers/spi/stm32f4_spi.c **** #define SPI1_DR               (*(volatile unsigned int *)(SPI1_BASE + 0x0C))
  34:./drivers/spi/stm32f4_spi.c **** 
  35:./drivers/spi/stm32f4_spi.c **** // 位定义
  36:./drivers/spi/stm32f4_spi.c **** #define RCC_AHB1ENR_GPIOAEN   (1 << 0)
  37:./drivers/spi/stm32f4_spi.c **** #define RCC_APB2ENR_SPI1EN    (1 << 12)
  38:./drivers/spi/stm32f4_spi.c **** #define RCC_APB2RSTR_SPI1RST  (1 << 12)
  39:./drivers/spi/stm32f4_spi.c **** 
  40:./drivers/spi/stm32f4_spi.c **** #define SPI_CR1_SPE           (1 << 6)
  41:./drivers/spi/stm32f4_spi.c **** #define SPI_CR1_MSTR          (1 << 2)
  42:./drivers/spi/stm32f4_spi.c **** #define SPI_CR1_CPOL          (1 << 1)
  43:./drivers/spi/stm32f4_spi.c **** #define SPI_CR1_CPHA          (1 << 0)
  44:./drivers/spi/stm32f4_spi.c **** #define SPI_CR1_DFF           (1 << 11)
  45:./drivers/spi/stm32f4_spi.c **** #define SPI_CR1_LSBFIRST      (1 << 7)
  46:./drivers/spi/stm32f4_spi.c **** #define SPI_CR1_SSM           (1 << 9)
  47:./drivers/spi/stm32f4_spi.c **** #define SPI_CR1_SSI           (1 << 8)
  48:./drivers/spi/stm32f4_spi.c **** 
  49:./drivers/spi/stm32f4_spi.c **** #define SPI_SR_TXE            (1 << 1)
  50:./drivers/spi/stm32f4_spi.c **** #define SPI_SR_RXNE           (1 << 0)
  51:./drivers/spi/stm32f4_spi.c **** 
  52:./drivers/spi/stm32f4_spi.c **** 
  53:./drivers/spi/stm32f4_spi.c **** 
  54:./drivers/spi/stm32f4_spi.c **** static void SPI1_Init(void)
  55:./drivers/spi/stm32f4_spi.c **** {
  28              		.loc 1 55 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  56:./drivers/spi/stm32f4_spi.c ****     // 1. 使能GPIOA时钟
  57:./drivers/spi/stm32f4_spi.c ****     RCC_AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
  33              		.loc 1 57 5 view .LVU1
  34 0000 284A     		ldr	r2, .L2
  35 0002 D2F83038 		ldr	r3, [r2, #2096]
  36              		.loc 1 57 17 is_stmt 0 view .LVU2
  37 0006 43F00103 		orr	r3, r3, #1
  38 000a C2F83038 		str	r3, [r2, #2096]
  58:./drivers/spi/stm32f4_spi.c **** 
  59:./drivers/spi/stm32f4_spi.c ****     // 2. 配置PA5, PA6, PA7为复用模式
  60:./drivers/spi/stm32f4_spi.c ****     GPIOA_MODER &= ~((3 << (5 * 2)) | (3 << (6 * 2)) | (3 << (7 * 2)));
  39              		.loc 1 60 5 is_stmt 1 view .LVU3
  40 000e 264B     		ldr	r3, .L2+4
  41 0010 1968     		ldr	r1, [r3]
  42              		.loc 1 60 17 is_stmt 0 view .LVU4
  43 0012 21F47C41 		bic	r1, r1, #64512
  44 0016 1960     		str	r1, [r3]
  61:./drivers/spi/stm32f4_spi.c ****     GPIOA_MODER |=  ((2 << (5 * 2)) | (2 << (6 * 2)) | (2 << (7 * 2)));
  45              		.loc 1 61 5 is_stmt 1 view .LVU5
  46 0018 1968     		ldr	r1, [r3]
  47              		.loc 1 61 17 is_stmt 0 view .LVU6
  48 001a 41F42841 		orr	r1, r1, #43008
  49 001e 1960     		str	r1, [r3]
  62:./drivers/spi/stm32f4_spi.c **** 
  63:./drivers/spi/stm32f4_spi.c ****     // 3. 推挽输出
  64:./drivers/spi/stm32f4_spi.c ****     GPIOA_OTYPER &= ~((1 << 5) | (1 << 6) | (1 << 7));
  50              		.loc 1 64 5 is_stmt 1 view .LVU7
  51 0020 5968     		ldr	r1, [r3, #4]
ARM GAS  /tmp/cc80GKN8.s 			page 3


  52              		.loc 1 64 18 is_stmt 0 view .LVU8
  53 0022 21F0E001 		bic	r1, r1, #224
  54 0026 5960     		str	r1, [r3, #4]
  65:./drivers/spi/stm32f4_spi.c **** 
  66:./drivers/spi/stm32f4_spi.c ****     // 4. 高速
  67:./drivers/spi/stm32f4_spi.c ****     GPIOA_OSPEEDR |= ((3 << (5 * 2)) | (3 << (6 * 2)) | (3 << (7 * 2)));
  55              		.loc 1 67 5 is_stmt 1 view .LVU9
  56 0028 9968     		ldr	r1, [r3, #8]
  57              		.loc 1 67 19 is_stmt 0 view .LVU10
  58 002a 41F47C41 		orr	r1, r1, #64512
  59 002e 9960     		str	r1, [r3, #8]
  68:./drivers/spi/stm32f4_spi.c **** 
  69:./drivers/spi/stm32f4_spi.c ****     // 5. 无上下拉
  70:./drivers/spi/stm32f4_spi.c ****     GPIOA_PUPDR &= ~((3 << (5 * 2)) | (3 << (6 * 2)) | (3 << (7 * 2)));
  60              		.loc 1 70 5 is_stmt 1 view .LVU11
  61 0030 D968     		ldr	r1, [r3, #12]
  62              		.loc 1 70 17 is_stmt 0 view .LVU12
  63 0032 21F47C41 		bic	r1, r1, #64512
  64 0036 D960     		str	r1, [r3, #12]
  71:./drivers/spi/stm32f4_spi.c **** 
  72:./drivers/spi/stm32f4_spi.c ****     // 6. 配置PA5, PA6, PA7 复用为AF5 (SPI1)
  73:./drivers/spi/stm32f4_spi.c ****     GPIOA_AFRL &= ~((0xF << (5 * 4)) | (0xF << (6 * 4)) | (0xF << (7 * 4)));
  65              		.loc 1 73 5 is_stmt 1 view .LVU13
  66 0038 196A     		ldr	r1, [r3, #32]
  67              		.loc 1 73 16 is_stmt 0 view .LVU14
  68 003a C1F31301 		ubfx	r1, r1, #0, #20
  69 003e 1962     		str	r1, [r3, #32]
  74:./drivers/spi/stm32f4_spi.c ****     GPIOA_AFRL |=  ((5 << (5 * 4)) | (5 << (6 * 4)) | (5 << (7 * 4)));
  70              		.loc 1 74 5 is_stmt 1 view .LVU15
  71 0040 196A     		ldr	r1, [r3, #32]
  72              		.loc 1 74 16 is_stmt 0 view .LVU16
  73 0042 41F0AA41 		orr	r1, r1, #1426063360
  74 0046 41F4A001 		orr	r1, r1, #5242880
  75 004a 1962     		str	r1, [r3, #32]
  75:./drivers/spi/stm32f4_spi.c **** 
  76:./drivers/spi/stm32f4_spi.c ****     // 7. 使能SPI1时钟
  77:./drivers/spi/stm32f4_spi.c ****     RCC_APB2ENR |= RCC_APB2ENR_SPI1EN;
  76              		.loc 1 77 5 is_stmt 1 view .LVU17
  77 004c D2F84438 		ldr	r3, [r2, #2116]
  78              		.loc 1 77 17 is_stmt 0 view .LVU18
  79 0050 43F48053 		orr	r3, r3, #4096
  80 0054 C2F84438 		str	r3, [r2, #2116]
  78:./drivers/spi/stm32f4_spi.c **** 
  79:./drivers/spi/stm32f4_spi.c ****     // 8. SPI1复位
  80:./drivers/spi/stm32f4_spi.c ****     RCC_APB2RSTR |= RCC_APB2RSTR_SPI1RST;
  81              		.loc 1 80 5 is_stmt 1 view .LVU19
  82 0058 D2F82438 		ldr	r3, [r2, #2084]
  83              		.loc 1 80 18 is_stmt 0 view .LVU20
  84 005c 43F48053 		orr	r3, r3, #4096
  85 0060 C2F82438 		str	r3, [r2, #2084]
  81:./drivers/spi/stm32f4_spi.c ****     RCC_APB2RSTR &= ~RCC_APB2RSTR_SPI1RST;
  86              		.loc 1 81 5 is_stmt 1 view .LVU21
  87 0064 D2F82438 		ldr	r3, [r2, #2084]
  88              		.loc 1 81 18 is_stmt 0 view .LVU22
  89 0068 23F48053 		bic	r3, r3, #4096
  90 006c C2F82438 		str	r3, [r2, #2084]
  82:./drivers/spi/stm32f4_spi.c **** 
ARM GAS  /tmp/cc80GKN8.s 			page 4


  83:./drivers/spi/stm32f4_spi.c ****     // 9. SPI1参数配置
  84:./drivers/spi/stm32f4_spi.c ****     SPI1_CR1 = 0;
  91              		.loc 1 84 5 is_stmt 1 view .LVU23
  92              		.loc 1 84 14 is_stmt 0 view .LVU24
  93 0070 0E4B     		ldr	r3, .L2+8
  94 0072 0022     		movs	r2, #0
  95 0074 1A60     		str	r2, [r3]
  85:./drivers/spi/stm32f4_spi.c ****     SPI1_CR1 |= SPI_CR1_MSTR;      // 主模式
  96              		.loc 1 85 5 is_stmt 1 view .LVU25
  97 0076 1A68     		ldr	r2, [r3]
  98              		.loc 1 85 14 is_stmt 0 view .LVU26
  99 0078 42F00402 		orr	r2, r2, #4
 100 007c 1A60     		str	r2, [r3]
  86:./drivers/spi/stm32f4_spi.c ****     SPI1_CR1 |= SPI_CR1_CPOL;      // 空闲高电平
 101              		.loc 1 86 5 is_stmt 1 view .LVU27
 102 007e 1A68     		ldr	r2, [r3]
 103              		.loc 1 86 14 is_stmt 0 view .LVU28
 104 0080 42F00202 		orr	r2, r2, #2
 105 0084 1A60     		str	r2, [r3]
  87:./drivers/spi/stm32f4_spi.c ****     SPI1_CR1 |= SPI_CR1_CPHA;      // 第二个边沿采样
 106              		.loc 1 87 5 is_stmt 1 view .LVU29
 107 0086 1A68     		ldr	r2, [r3]
 108              		.loc 1 87 14 is_stmt 0 view .LVU30
 109 0088 42F00102 		orr	r2, r2, #1
 110 008c 1A60     		str	r2, [r3]
  88:./drivers/spi/stm32f4_spi.c ****     SPI1_CR1 |= SPI_CR1_SSM | SPI_CR1_SSI;  // 软件管理NSS
 111              		.loc 1 88 5 is_stmt 1 view .LVU31
 112 008e 1A68     		ldr	r2, [r3]
 113              		.loc 1 88 14 is_stmt 0 view .LVU32
 114 0090 42F44072 		orr	r2, r2, #768
 115 0094 1A60     		str	r2, [r3]
  89:./drivers/spi/stm32f4_spi.c ****     SPI1_CR1 |= (0 << 3);          // 默认分频：fPCLK/2
 116              		.loc 1 89 5 is_stmt 1 view .LVU33
 117              		.loc 1 89 14 is_stmt 0 view .LVU34
 118 0096 1A68     		ldr	r2, [r3]
 119 0098 1A60     		str	r2, [r3]
  90:./drivers/spi/stm32f4_spi.c **** 
  91:./drivers/spi/stm32f4_spi.c ****     // 10. 使能SPI1
  92:./drivers/spi/stm32f4_spi.c ****     SPI1_CR1 |= SPI_CR1_SPE;
 120              		.loc 1 92 5 is_stmt 1 view .LVU35
 121 009a 1A68     		ldr	r2, [r3]
 122              		.loc 1 92 14 is_stmt 0 view .LVU36
 123 009c 42F04002 		orr	r2, r2, #64
 124 00a0 1A60     		str	r2, [r3]
  93:./drivers/spi/stm32f4_spi.c **** }
 125              		.loc 1 93 1 view .LVU37
 126 00a2 7047     		bx	lr
 127              	.L3:
 128              		.align	2
 129              	.L2:
 130 00a4 00300240 		.word	1073885184
 131 00a8 00000240 		.word	1073872896
 132 00ac 00300140 		.word	1073819648
 133              		.cfi_endproc
 134              	.LFE1033:
 136              		.section	.text.SPI1_SetSpeed,"ax",%progbits
 137              		.align	1
ARM GAS  /tmp/cc80GKN8.s 			page 5


 138              		.syntax unified
 139              		.thumb
 140              		.thumb_func
 142              	SPI1_SetSpeed:
 143              	.LVL0:
 144              	.LFB1034:
  94:./drivers/spi/stm32f4_spi.c **** 
  95:./drivers/spi/stm32f4_spi.c **** static void SPI1_SetSpeed(uint8_t prescaler)
  96:./drivers/spi/stm32f4_spi.c **** {
 145              		.loc 1 96 1 is_stmt 1 view -0
 146              		.cfi_startproc
 147              		@ args = 0, pretend = 0, frame = 0
 148              		@ frame_needed = 0, uses_anonymous_args = 0
 149              		@ link register save eliminated.
  97:./drivers/spi/stm32f4_spi.c ****     SPI1_CR1 &= ~(7 << 3);  // 清除BR[2:0]位
 150              		.loc 1 97 5 view .LVU39
 151 0000 044B     		ldr	r3, .L5
 152 0002 1A68     		ldr	r2, [r3]
 153              		.loc 1 97 14 is_stmt 0 view .LVU40
 154 0004 22F03802 		bic	r2, r2, #56
 155 0008 1A60     		str	r2, [r3]
  98:./drivers/spi/stm32f4_spi.c ****     SPI1_CR1 |= (prescaler << 3); // 设置新的分频值
 156              		.loc 1 98 5 is_stmt 1 view .LVU41
 157 000a 1A68     		ldr	r2, [r3]
 158              		.loc 1 98 14 is_stmt 0 view .LVU42
 159 000c 42EAC002 		orr	r2, r2, r0, lsl #3
 160 0010 1A60     		str	r2, [r3]
  99:./drivers/spi/stm32f4_spi.c **** }
 161              		.loc 1 99 1 view .LVU43
 162 0012 7047     		bx	lr
 163              	.L6:
 164              		.align	2
 165              	.L5:
 166 0014 00300140 		.word	1073819648
 167              		.cfi_endproc
 168              	.LFE1034:
 170              		.section	.text.SPI1_ReadWriteByte,"ax",%progbits
 171              		.align	1
 172              		.syntax unified
 173              		.thumb
 174              		.thumb_func
 176              	SPI1_ReadWriteByte:
 177              	.LFB1036:
 100:./drivers/spi/stm32f4_spi.c **** 
 101:./drivers/spi/stm32f4_spi.c **** 
 102:./drivers/spi/stm32f4_spi.c **** 
 103:./drivers/spi/stm32f4_spi.c **** unsigned short get_spi_speed(unsigned int speed)
 104:./drivers/spi/stm32f4_spi.c **** {
 105:./drivers/spi/stm32f4_spi.c ****     unsigned int pclk2 = 168000000 / 2; // 默认核心频率是168MHz
 106:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/2 )   return 0;
 107:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/4 )   return 1;
 108:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/8 )   return 2;
 109:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/16 )  return 3;
 110:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/32 )  return 4;
 111:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/64 )  return 5;
 112:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/128 ) return 6;
 113:./drivers/spi/stm32f4_spi.c ****     return 7;
ARM GAS  /tmp/cc80GKN8.s 			page 6


 114:./drivers/spi/stm32f4_spi.c **** }
 115:./drivers/spi/stm32f4_spi.c **** 
 116:./drivers/spi/stm32f4_spi.c **** static inline uint8_t SPI1_ReadWriteByte(uint8_t TxData)
 117:./drivers/spi/stm32f4_spi.c **** {
 178              		.loc 1 117 1 is_stmt 1 view -0
 179              		.cfi_startproc
 180              		@ args = 0, pretend = 0, frame = 0
 181              		@ frame_needed = 0, uses_anonymous_args = 0
 182              		@ link register save eliminated.
 183              	.LVL1:
 184              	.L8:
 118:./drivers/spi/stm32f4_spi.c ****     // 等待发送缓冲区空
 119:./drivers/spi/stm32f4_spi.c ****     while (!(SPI1_SR & SPI_SR_TXE));
 185              		.loc 1 119 12 discriminator 1 view .LVU45
 186              		.loc 1 119 14 is_stmt 0 discriminator 1 view .LVU46
 187 0000 074B     		ldr	r3, .L10
 188 0002 9B68     		ldr	r3, [r3, #8]
 189              		.loc 1 119 12 discriminator 1 view .LVU47
 190 0004 13F0020F 		tst	r3, #2
 191 0008 FAD0     		beq	.L8
 120:./drivers/spi/stm32f4_spi.c ****     SPI1_DR = TxData;
 192              		.loc 1 120 5 is_stmt 1 view .LVU48
 193              		.loc 1 120 13 is_stmt 0 view .LVU49
 194 000a 054B     		ldr	r3, .L10
 195 000c D860     		str	r0, [r3, #12]
 121:./drivers/spi/stm32f4_spi.c ****     // 等待接收缓冲区有数据
 122:./drivers/spi/stm32f4_spi.c ****     while (!(SPI1_SR & SPI_SR_RXNE));
 196              		.loc 1 122 5 is_stmt 1 view .LVU50
 197              	.L9:
 198              		.loc 1 122 12 discriminator 1 view .LVU51
 199              		.loc 1 122 14 is_stmt 0 discriminator 1 view .LVU52
 200 000e 044B     		ldr	r3, .L10
 201 0010 9B68     		ldr	r3, [r3, #8]
 202              		.loc 1 122 12 discriminator 1 view .LVU53
 203 0012 13F0010F 		tst	r3, #1
 204 0016 FAD0     		beq	.L9
 123:./drivers/spi/stm32f4_spi.c ****     return (uint8_t)(SPI1_DR);
 205              		.loc 1 123 5 is_stmt 1 view .LVU54
 206              		.loc 1 123 22 is_stmt 0 view .LVU55
 207 0018 014B     		ldr	r3, .L10
 208 001a D868     		ldr	r0, [r3, #12]
 209              	.LVL2:
 124:./drivers/spi/stm32f4_spi.c **** }
 210              		.loc 1 124 1 view .LVU56
 211 001c C0B2     		uxtb	r0, r0
 212 001e 7047     		bx	lr
 213              	.L11:
 214              		.align	2
 215              	.L10:
 216 0020 00300140 		.word	1073819648
 217              		.cfi_endproc
 218              	.LFE1036:
 220              		.section	.text.spi_device_swap,"ax",%progbits
 221              		.align	1
 222              		.syntax unified
 223              		.thumb
 224              		.thumb_func
ARM GAS  /tmp/cc80GKN8.s 			page 7


 226              	spi_device_swap:
 227              	.LVL3:
 228              	.LFB1037:
 125:./drivers/spi/stm32f4_spi.c **** 
 126:./drivers/spi/stm32f4_spi.c **** 
 127:./drivers/spi/stm32f4_spi.c **** 
 128:./drivers/spi/stm32f4_spi.c **** #define SPI1_BSP_DEBUG 0
 129:./drivers/spi/stm32f4_spi.c **** 
 130:./drivers/spi/stm32f4_spi.c **** static int spi_device_swap(void *tx_buf, void *rx_buf, int len)
 131:./drivers/spi/stm32f4_spi.c **** {
 229              		.loc 1 131 1 is_stmt 1 view -0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              		.loc 1 131 1 is_stmt 0 view .LVU58
 234 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 235              	.LCFI0:
 236              		.cfi_def_cfa_offset 24
 237              		.cfi_offset 3, -24
 238              		.cfi_offset 4, -20
 239              		.cfi_offset 5, -16
 240              		.cfi_offset 6, -12
 241              		.cfi_offset 7, -8
 242              		.cfi_offset 14, -4
 243 0002 0E46     		mov	r6, r1
 244 0004 1546     		mov	r5, r2
 132:./drivers/spi/stm32f4_spi.c ****     if(tx_buf == NULL && rx_buf == NULL) return -1;
 245              		.loc 1 132 5 is_stmt 1 view .LVU59
 246              		.loc 1 132 7 is_stmt 0 view .LVU60
 247 0006 18B1     		cbz	r0, .L29
 248 0008 0746     		mov	r7, r0
 133:./drivers/spi/stm32f4_spi.c ****     
 134:./drivers/spi/stm32f4_spi.c ****     uint8_t *p = (uint8_t *)tx_buf;
 135:./drivers/spi/stm32f4_spi.c ****     uint8_t *q = (uint8_t *)rx_buf;
 136:./drivers/spi/stm32f4_spi.c ****      
 137:./drivers/spi/stm32f4_spi.c ****     #if SPI1_BSP_DEBUG 
 138:./drivers/spi/stm32f4_spi.c ****     if(p){ 
 139:./drivers/spi/stm32f4_spi.c ****       printk("send data:\n\r");
 140:./drivers/spi/stm32f4_spi.c ****       printk("TX:\n\r");
 141:./drivers/spi/stm32f4_spi.c ****       for(int i = 0; i < len; i++){
 142:./drivers/spi/stm32f4_spi.c ****         printk("0x%02x \n\r", p[i]);
 143:./drivers/spi/stm32f4_spi.c ****       }
 144:./drivers/spi/stm32f4_spi.c ****     }
 145:./drivers/spi/stm32f4_spi.c ****     #endif
 146:./drivers/spi/stm32f4_spi.c **** 
 147:./drivers/spi/stm32f4_spi.c **** 
 148:./drivers/spi/stm32f4_spi.c ****     if(p && q) {
 249              		.loc 1 148 10 discriminator 1 view .LVU61
 250 000a 71B1     		cbz	r1, .L30
 251              	.LBB8:
 149:./drivers/spi/stm32f4_spi.c **** 
 150:./drivers/spi/stm32f4_spi.c ****         for(int i = 0; i < len; i++) {
 252              		.loc 1 150 17 view .LVU62
 253 000c 0024     		movs	r4, #0
 254 000e 08E0     		b	.L16
 255              	.L29:
 256              		.loc 1 150 17 view .LVU63
ARM GAS  /tmp/cc80GKN8.s 			page 8


 257              	.LBE8:
 132:./drivers/spi/stm32f4_spi.c ****     
 258              		.loc 1 132 23 discriminator 1 view .LVU64
 259 0010 F1B1     		cbz	r1, .L31
 260              	.L15:
 151:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(p[i]);
 152:./drivers/spi/stm32f4_spi.c ****         }
 153:./drivers/spi/stm32f4_spi.c ****     } 
 154:./drivers/spi/stm32f4_spi.c ****     else if(p) {
 155:./drivers/spi/stm32f4_spi.c ****         for(int i = 0; i < len; i++) {
 156:./drivers/spi/stm32f4_spi.c ****             SPI1_ReadWriteByte(p[i]);
 157:./drivers/spi/stm32f4_spi.c ****         }
 158:./drivers/spi/stm32f4_spi.c ****     }
 159:./drivers/spi/stm32f4_spi.c ****     else if(q) {
 261              		.loc 1 159 10 is_stmt 1 view .LVU65
 262              		.loc 1 159 12 is_stmt 0 view .LVU66
 263 0012 46B1     		cbz	r6, .L14
 264              	.LBB9:
 160:./drivers/spi/stm32f4_spi.c ****         for(int i = 0; i < len; i++) {
 265              		.loc 1 160 17 view .LVU67
 266 0014 0024     		movs	r4, #0
 267 0016 18E0     		b	.L21
 268              	.LVL4:
 269              	.L18:
 270              		.loc 1 160 17 view .LVU68
 271              	.LBE9:
 272              	.LBB10:
 151:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(p[i]);
 273              		.loc 1 151 13 is_stmt 1 view .LVU69
 151:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(p[i]);
 274              		.loc 1 151 20 is_stmt 0 view .LVU70
 275 0018 385D     		ldrb	r0, [r7, r4]	@ zero_extendqisi2
 276 001a FFF7FEFF 		bl	SPI1_ReadWriteByte
 277              	.LVL5:
 151:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(p[i]);
 278              		.loc 1 151 18 discriminator 1 view .LVU71
 279 001e 3055     		strb	r0, [r6, r4]
 150:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(p[i]);
 280              		.loc 1 150 34 is_stmt 1 discriminator 3 view .LVU72
 281 0020 0134     		adds	r4, r4, #1
 282              	.LVL6:
 283              	.L16:
 150:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(p[i]);
 284              		.loc 1 150 26 discriminator 1 view .LVU73
 285 0022 AC42     		cmp	r4, r5
 286 0024 F8DB     		blt	.L18
 287              	.LVL7:
 288              	.L14:
 150:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(p[i]);
 289              		.loc 1 150 26 is_stmt 0 discriminator 1 view .LVU74
 290              	.LBE10:
 161:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(0xFF);
 162:./drivers/spi/stm32f4_spi.c ****         }
 163:./drivers/spi/stm32f4_spi.c ****     }
 164:./drivers/spi/stm32f4_spi.c ****     
 165:./drivers/spi/stm32f4_spi.c ****     #if SPI1_BSP_DEBUG
 166:./drivers/spi/stm32f4_spi.c ****     if(q){ 
ARM GAS  /tmp/cc80GKN8.s 			page 9


 167:./drivers/spi/stm32f4_spi.c ****       printk("receive data:\n\r");
 168:./drivers/spi/stm32f4_spi.c ****       printk("RX:\n\r");
 169:./drivers/spi/stm32f4_spi.c ****       for(int i = 0; i < len; i++){
 170:./drivers/spi/stm32f4_spi.c ****         printk("0x%02x \n\r", q[i]);
 171:./drivers/spi/stm32f4_spi.c ****       }
 172:./drivers/spi/stm32f4_spi.c ****     }
 173:./drivers/spi/stm32f4_spi.c ****     #endif
 174:./drivers/spi/stm32f4_spi.c **** 
 175:./drivers/spi/stm32f4_spi.c ****     return len;
 176:./drivers/spi/stm32f4_spi.c **** }
 291              		.loc 1 176 1 view .LVU75
 292 0026 2846     		mov	r0, r5
 293 0028 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 294              	.LVL8:
 295              	.L30:
 154:./drivers/spi/stm32f4_spi.c ****         for(int i = 0; i < len; i++) {
 296              		.loc 1 154 10 is_stmt 1 view .LVU76
 154:./drivers/spi/stm32f4_spi.c ****         for(int i = 0; i < len; i++) {
 297              		.loc 1 154 12 is_stmt 0 view .LVU77
 298 002a 0028     		cmp	r0, #0
 299 002c F1D0     		beq	.L15
 300              	.LBB11:
 155:./drivers/spi/stm32f4_spi.c ****             SPI1_ReadWriteByte(p[i]);
 301              		.loc 1 155 17 view .LVU78
 302 002e 0024     		movs	r4, #0
 303 0030 03E0     		b	.L19
 304              	.LVL9:
 305              	.L20:
 156:./drivers/spi/stm32f4_spi.c ****         }
 306              		.loc 1 156 13 is_stmt 1 view .LVU79
 307 0032 385D     		ldrb	r0, [r7, r4]	@ zero_extendqisi2
 308 0034 FFF7FEFF 		bl	SPI1_ReadWriteByte
 309              	.LVL10:
 155:./drivers/spi/stm32f4_spi.c ****             SPI1_ReadWriteByte(p[i]);
 310              		.loc 1 155 34 discriminator 3 view .LVU80
 311 0038 0134     		adds	r4, r4, #1
 312              	.LVL11:
 313              	.L19:
 155:./drivers/spi/stm32f4_spi.c ****             SPI1_ReadWriteByte(p[i]);
 314              		.loc 1 155 26 discriminator 1 view .LVU81
 315 003a AC42     		cmp	r4, r5
 316 003c F9DB     		blt	.L20
 317 003e F2E7     		b	.L14
 318              	.LVL12:
 319              	.L22:
 155:./drivers/spi/stm32f4_spi.c ****             SPI1_ReadWriteByte(p[i]);
 320              		.loc 1 155 26 is_stmt 0 discriminator 1 view .LVU82
 321              	.LBE11:
 322              	.LBB12:
 161:./drivers/spi/stm32f4_spi.c ****         }
 323              		.loc 1 161 13 is_stmt 1 view .LVU83
 161:./drivers/spi/stm32f4_spi.c ****         }
 324              		.loc 1 161 20 is_stmt 0 view .LVU84
 325 0040 FF20     		movs	r0, #255
 326 0042 FFF7FEFF 		bl	SPI1_ReadWriteByte
 327              	.LVL13:
 161:./drivers/spi/stm32f4_spi.c ****         }
ARM GAS  /tmp/cc80GKN8.s 			page 10


 328              		.loc 1 161 18 discriminator 1 view .LVU85
 329 0046 3055     		strb	r0, [r6, r4]
 160:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(0xFF);
 330              		.loc 1 160 34 is_stmt 1 discriminator 3 view .LVU86
 331 0048 0134     		adds	r4, r4, #1
 332              	.LVL14:
 333              	.L21:
 160:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(0xFF);
 334              		.loc 1 160 26 discriminator 1 view .LVU87
 335 004a AC42     		cmp	r4, r5
 336 004c F8DB     		blt	.L22
 337 004e EAE7     		b	.L14
 338              	.LVL15:
 339              	.L31:
 160:./drivers/spi/stm32f4_spi.c ****             q[i] = SPI1_ReadWriteByte(0xFF);
 340              		.loc 1 160 26 is_stmt 0 discriminator 1 view .LVU88
 341              	.LBE12:
 132:./drivers/spi/stm32f4_spi.c ****     
 342              		.loc 1 132 49 discriminator 2 view .LVU89
 343 0050 4FF0FF35 		mov	r5, #-1
 344 0054 E7E7     		b	.L14
 345              		.cfi_endproc
 346              	.LFE1037:
 348              		.section	.rodata.spi_dev_open.str1.4,"aMS",%progbits,1
 349              		.align	2
 350              	.LC0:
 351 0000 7370695F 		.ascii	"spi_dev_opern\012\015\000"
 351      6465765F 
 351      6F706572 
 351      6E0A0D00 
 352              		.section	.text.spi_dev_open,"ax",%progbits
 353              		.align	1
 354              		.syntax unified
 355              		.thumb
 356              		.thumb_func
 358              	spi_dev_open:
 359              	.LVL16:
 360              	.LFB1038:
 177:./drivers/spi/stm32f4_spi.c **** 
 178:./drivers/spi/stm32f4_spi.c **** 
 179:./drivers/spi/stm32f4_spi.c **** 
 180:./drivers/spi/stm32f4_spi.c **** static int spi_dev_open(struct inode *inode, struct file *file)
 181:./drivers/spi/stm32f4_spi.c **** {
 361              		.loc 1 181 1 is_stmt 1 view -0
 362              		.cfi_startproc
 363              		@ args = 0, pretend = 0, frame = 0
 364              		@ frame_needed = 0, uses_anonymous_args = 0
 365              		.loc 1 181 1 is_stmt 0 view .LVU91
 366 0000 08B5     		push	{r3, lr}
 367              	.LCFI1:
 368              		.cfi_def_cfa_offset 8
 369              		.cfi_offset 3, -8
 370              		.cfi_offset 14, -4
 182:./drivers/spi/stm32f4_spi.c ****    printk("spi_dev_opern\n\r");
 371              		.loc 1 182 4 is_stmt 1 view .LVU92
 372 0002 0248     		ldr	r0, .L34
 373              	.LVL17:
ARM GAS  /tmp/cc80GKN8.s 			page 11


 374              		.loc 1 182 4 is_stmt 0 view .LVU93
 375 0004 FFF7FEFF 		bl	printk
 376              	.LVL18:
 183:./drivers/spi/stm32f4_spi.c ****    return 0;
 377              		.loc 1 183 4 is_stmt 1 view .LVU94
 184:./drivers/spi/stm32f4_spi.c **** }
 378              		.loc 1 184 1 is_stmt 0 view .LVU95
 379 0008 0020     		movs	r0, #0
 380 000a 08BD     		pop	{r3, pc}
 381              	.L35:
 382              		.align	2
 383              	.L34:
 384 000c 00000000 		.word	.LC0
 385              		.cfi_endproc
 386              	.LFE1038:
 388              		.section	.rodata.spi1_device_init.str1.4,"aMS",%progbits,1
 389              		.align	2
 390              	.LC1:
 391 0000 73706964 		.ascii	"spidev1\000"
 391      65763100 
 392              		.align	2
 393              	.LC2:
 394 0008 72656769 		.ascii	"register spi device %d\000"
 394      73746572 
 394      20737069 
 394      20646576 
 394      69636520 
 395 001f 00       		.align	2
 396              	.LC3:
 397 0020 63616E20 		.ascii	"can not create spi class\012\000"
 397      6E6F7420 
 397      63726561 
 397      74652073 
 397      70692063 
 398 003a 0000     		.align	2
 399              	.LC4:
 400 003c 63616E20 		.ascii	"can not create spi device\012\000"
 400      6E6F7420 
 400      63726561 
 400      74652073 
 400      70692064 
 401              		.section	.text.spi1_device_init,"ax",%progbits
 402              		.align	1
 403              		.syntax unified
 404              		.thumb
 405              		.thumb_func
 407              	spi1_device_init:
 408              	.LFB1040:
 185:./drivers/spi/stm32f4_spi.c **** 
 186:./drivers/spi/stm32f4_spi.c **** 
 187:./drivers/spi/stm32f4_spi.c **** long spi_unlocked_ioctl(struct file * file, unsigned int cmd, unsigned long arg)
 188:./drivers/spi/stm32f4_spi.c **** {
 189:./drivers/spi/stm32f4_spi.c ****     if (arg==NULL){
 190:./drivers/spi/stm32f4_spi.c ****         printk("arg is null");
 191:./drivers/spi/stm32f4_spi.c ****         return -EINVAL;
 192:./drivers/spi/stm32f4_spi.c ****     } 
 193:./drivers/spi/stm32f4_spi.c ****     struct spi_ioc_transfer *spi = (struct spi_ioc_transfer *) arg;
ARM GAS  /tmp/cc80GKN8.s 			page 12


 194:./drivers/spi/stm32f4_spi.c ****     switch(cmd)
 195:./drivers/spi/stm32f4_spi.c ****     {
 196:./drivers/spi/stm32f4_spi.c ****         case SPI_IOC_MESSAGE(1):
 197:./drivers/spi/stm32f4_spi.c ****             // pr_info("setspeed:%d\n",spi->speed_hz);
 198:./drivers/spi/stm32f4_spi.c ****             SPI1_SetSpeed(get_spi_speed(spi->speed_hz));
 199:./drivers/spi/stm32f4_spi.c ****             return spi_device_swap(spi->tx_buf, spi->rx_buf, spi->len);
 200:./drivers/spi/stm32f4_spi.c ****         default:
 201:./drivers/spi/stm32f4_spi.c ****             return -EINVAL;
 202:./drivers/spi/stm32f4_spi.c ****     }
 203:./drivers/spi/stm32f4_spi.c ****     return 0;
 204:./drivers/spi/stm32f4_spi.c **** }
 205:./drivers/spi/stm32f4_spi.c **** 
 206:./drivers/spi/stm32f4_spi.c **** static struct file_operations spi_fops = {
 207:./drivers/spi/stm32f4_spi.c ****     .owner = THIS_MODULE,
 208:./drivers/spi/stm32f4_spi.c ****     .open = spi_dev_open,
 209:./drivers/spi/stm32f4_spi.c ****     .unlocked_ioctl = spi_unlocked_ioctl,
 210:./drivers/spi/stm32f4_spi.c **** };
 211:./drivers/spi/stm32f4_spi.c **** 
 212:./drivers/spi/stm32f4_spi.c **** 
 213:./drivers/spi/stm32f4_spi.c **** 
 214:./drivers/spi/stm32f4_spi.c **** static int spi1_device_init(void){
 409              		.loc 1 214 34 is_stmt 1 view -0
 410              		.cfi_startproc
 411              		@ args = 0, pretend = 0, frame = 0
 412              		@ frame_needed = 0, uses_anonymous_args = 0
 413 0000 30B5     		push	{r4, r5, lr}
 414              	.LCFI2:
 415              		.cfi_def_cfa_offset 12
 416              		.cfi_offset 4, -12
 417              		.cfi_offset 5, -8
 418              		.cfi_offset 14, -4
 419 0002 83B0     		sub	sp, sp, #12
 420              	.LCFI3:
 421              		.cfi_def_cfa_offset 24
 215:./drivers/spi/stm32f4_spi.c ****     SPI1_Init();
 422              		.loc 1 215 5 view .LVU97
 423 0004 FFF7FEFF 		bl	SPI1_Init
 424              	.LVL19:
 216:./drivers/spi/stm32f4_spi.c ****     
 217:./drivers/spi/stm32f4_spi.c ****     int major = register_chrdev(0,"spidev1", &spi_fops);
 425              		.loc 1 217 5 view .LVU98
 426              	.LBB13:
 427              	.LBI13:
 428              		.file 2 "./include/linux/fs.h"
   1:./include/linux/fs.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/fs.h **** #ifndef _LINUX_FS_H
   3:./include/linux/fs.h **** #define _LINUX_FS_H
   4:./include/linux/fs.h **** 
   5:./include/linux/fs.h **** #include <linux/types.h>
   6:./include/linux/fs.h **** #include <linux/errseq.h> 
   7:./include/linux/fs.h **** #include <linux/spinlock.h> 
   8:./include/linux/fs.h **** #include <linux/list.h>
   9:./include/linux/fs.h **** #include <linux/rbtree_types.h>  
  10:./include/linux/fs.h **** #include <linux/uuid.h>  
  11:./include/linux/fs.h **** #include <linux/uidgid_types.h>   
  12:./include/linux/fs.h **** #include <linux/projid.h>       
  13:./include/linux/fs.h **** #include <linux/time64.h> 
ARM GAS  /tmp/cc80GKN8.s 			page 13


  14:./include/linux/fs.h **** #include <linux/mnt_idmapping.h>  
  15:./include/linux/fs.h **** #include <linux/mutex.h>         
  16:./include/linux/fs.h **** #include <linux/uio.h>              
  17:./include/linux/fs.h **** #include <linux/migrate_mode.h>  
  18:./include/linux/fs.h **** #include <linux/raid/pq.h> 
  19:./include/linux/fs.h **** #include <linux/lockdep_types.h>
  20:./include/linux/fs.h **** #include <linux/wait.h>				
  21:./include/linux/fs.h **** #include <linux/pipe_fs_i.h>
  22:./include/linux/fs.h **** #include <linux/fcntl.h>
  23:./include/linux/fs.h **** #include <linux/xarray.h>
  24:./include/linux/fs.h **** #include <linux/blkdev.h>
  25:./include/linux/fs.h **** #include <linux/dcache.h>
  26:./include/linux/fs.h **** #include <linux/mm_type.h>
  27:./include/linux/fs.h **** #include <linux/statfs.h>
  28:./include/linux/fs.h **** #include <linux/stat.h>
  29:./include/linux/fs.h **** #include <linux/path.h>
  30:./include/linux/fs.h **** 
  31:./include/linux/fs.h **** 
  32:./include/linux/fs.h **** struct dentry;
  33:./include/linux/fs.h **** struct file;
  34:./include/linux/fs.h **** struct inode;
  35:./include/linux/fs.h **** struct kiocb;
  36:./include/linux/fs.h **** struct file_operations;
  37:./include/linux/fs.h **** struct inode_operations  ;
  38:./include/linux/fs.h **** struct dentry_operations ;
  39:./include/linux/fs.h **** struct writeback_control ;
  40:./include/linux/fs.h **** struct address_space;
  41:./include/linux/fs.h **** struct seq_file ;
  42:./include/linux/fs.h **** struct shrink_control;
  43:./include/linux/fs.h **** struct file_system_type;
  44:./include/linux/fs.h **** struct buffer_head;
  45:./include/linux/fs.h **** 
  46:./include/linux/fs.h **** #define MAY_EXEC		0x00000001
  47:./include/linux/fs.h **** #define MAY_WRITE		0x00000002
  48:./include/linux/fs.h **** #define MAY_READ		0x00000004
  49:./include/linux/fs.h **** #define MAY_APPEND		0x00000008
  50:./include/linux/fs.h **** #define MAY_ACCESS		0x00000010
  51:./include/linux/fs.h **** #define MAY_OPEN		0x00000020
  52:./include/linux/fs.h **** #define MAY_CHDIR		0x00000040
  53:./include/linux/fs.h **** /* called from RCU mode, don't block */
  54:./include/linux/fs.h **** #define MAY_NOT_BLOCK		0x00000080
  55:./include/linux/fs.h **** 
  56:./include/linux/fs.h **** /*
  57:./include/linux/fs.h ****  * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond
  58:./include/linux/fs.h ****  * to O_WRONLY and O_RDWR via the strange trick in do_dentry_open()
  59:./include/linux/fs.h ****  */
  60:./include/linux/fs.h **** 
  61:./include/linux/fs.h **** /* file is open for reading */
  62:./include/linux/fs.h **** #define FMODE_READ		((__force fmode_t)(1 << 0))
  63:./include/linux/fs.h **** /* file is open for writing */
  64:./include/linux/fs.h **** #define FMODE_WRITE		((__force fmode_t)(1 << 1))
  65:./include/linux/fs.h **** /* file is seekable */
  66:./include/linux/fs.h **** #define FMODE_LSEEK		((__force fmode_t)(1 << 2))
  67:./include/linux/fs.h **** /* file can be accessed using pread */
  68:./include/linux/fs.h **** #define FMODE_PREAD		((__force fmode_t)(1 << 3))
  69:./include/linux/fs.h **** /* file can be accessed using pwrite */
  70:./include/linux/fs.h **** #define FMODE_PWRITE		((__force fmode_t)(1 << 4))
ARM GAS  /tmp/cc80GKN8.s 			page 14


  71:./include/linux/fs.h **** /* File is opened for execution with sys_execve / sys_uselib */
  72:./include/linux/fs.h **** #define FMODE_EXEC		((__force fmode_t)(1 << 5))
  73:./include/linux/fs.h **** /* File writes are restricted (block device specific) */
  74:./include/linux/fs.h **** #define FMODE_WRITE_RESTRICTED	((__force fmode_t)(1 << 6))
  75:./include/linux/fs.h **** /* File supports atomic writes */
  76:./include/linux/fs.h **** #define FMODE_CAN_ATOMIC_WRITE	((__force fmode_t)(1 << 7))
  77:./include/linux/fs.h **** 
  78:./include/linux/fs.h **** /* FMODE_* bit 8 */
  79:./include/linux/fs.h **** 
  80:./include/linux/fs.h **** /* 32bit hashes as llseek() offset (for directories) */
  81:./include/linux/fs.h **** #define FMODE_32BITHASH         ((__force fmode_t)(1 << 9))
  82:./include/linux/fs.h **** /* 64bit hashes as llseek() offset (for directories) */
  83:./include/linux/fs.h **** #define FMODE_64BITHASH         ((__force fmode_t)(1 << 10))
  84:./include/linux/fs.h **** 
  85:./include/linux/fs.h **** /*
  86:./include/linux/fs.h ****  * Don't update ctime and mtime.
  87:./include/linux/fs.h ****  *
  88:./include/linux/fs.h ****  * Currently a special hack for the XFS open_by_handle ioctl, but we'll
  89:./include/linux/fs.h ****  * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.
  90:./include/linux/fs.h ****  */
  91:./include/linux/fs.h **** #define FMODE_NOCMTIME		((__force fmode_t)(1 << 11))
  92:./include/linux/fs.h **** 
  93:./include/linux/fs.h **** /* Expect random access pattern */
  94:./include/linux/fs.h **** #define FMODE_RANDOM		((__force fmode_t)(1 << 12))
  95:./include/linux/fs.h **** 
  96:./include/linux/fs.h **** /* FMODE_* bit 13 */
  97:./include/linux/fs.h **** 
  98:./include/linux/fs.h **** /* File is opened with O_PATH; almost nothing can be done with it */
  99:./include/linux/fs.h **** #define FMODE_PATH		((__force fmode_t)(1 << 14))
 100:./include/linux/fs.h **** 
 101:./include/linux/fs.h **** /* File needs atomic accesses to f_pos */
 102:./include/linux/fs.h **** #define FMODE_ATOMIC_POS	((__force fmode_t)(1 << 15))
 103:./include/linux/fs.h **** /* Write access to underlying fs */
 104:./include/linux/fs.h **** #define FMODE_WRITER		((__force fmode_t)(1 << 16))
 105:./include/linux/fs.h **** /* Has read method(s) */
 106:./include/linux/fs.h **** #define FMODE_CAN_READ          ((__force fmode_t)(1 << 17))
 107:./include/linux/fs.h **** /* Has write method(s) */
 108:./include/linux/fs.h **** #define FMODE_CAN_WRITE         ((__force fmode_t)(1 << 18))
 109:./include/linux/fs.h **** 
 110:./include/linux/fs.h **** #define FMODE_OPENED		((__force fmode_t)(1 << 19))
 111:./include/linux/fs.h **** #define FMODE_CREATED		((__force fmode_t)(1 << 20))
 112:./include/linux/fs.h **** 
 113:./include/linux/fs.h **** /* File is stream-like */
 114:./include/linux/fs.h **** #define FMODE_STREAM		((__force fmode_t)(1 << 21))
 115:./include/linux/fs.h **** 
 116:./include/linux/fs.h **** /* File supports DIRECT IO */
 117:./include/linux/fs.h **** #define	FMODE_CAN_ODIRECT	((__force fmode_t)(1 << 22))
 118:./include/linux/fs.h **** 
 119:./include/linux/fs.h **** #define	FMODE_NOREUSE		((__force fmode_t)(1 << 23))
 120:./include/linux/fs.h **** 
 121:./include/linux/fs.h **** /* FMODE_* bit 24 */
 122:./include/linux/fs.h **** 
 123:./include/linux/fs.h **** /* File is embedded in backing_file object */
 124:./include/linux/fs.h **** #define FMODE_BACKING		((__force fmode_t)(1 << 25))
 125:./include/linux/fs.h **** 
 126:./include/linux/fs.h **** /* File was opened by fanotify and shouldn't generate fanotify events */
 127:./include/linux/fs.h **** #define FMODE_NONOTIFY		((__force fmode_t)(1 << 26))
ARM GAS  /tmp/cc80GKN8.s 			page 15


 128:./include/linux/fs.h **** 
 129:./include/linux/fs.h **** /* File is capable of returning -EAGAIN if I/O will block */
 130:./include/linux/fs.h **** #define FMODE_NOWAIT		((__force fmode_t)(1 << 27))
 131:./include/linux/fs.h **** 
 132:./include/linux/fs.h **** /* File represents mount that needs unmounting */
 133:./include/linux/fs.h **** #define FMODE_NEED_UNMOUNT	((__force fmode_t)(1 << 28))
 134:./include/linux/fs.h **** 
 135:./include/linux/fs.h **** /* File does not contribute to nr_files count */
 136:./include/linux/fs.h **** #define FMODE_NOACCOUNT		((__force fmode_t)(1 << 29))
 137:./include/linux/fs.h **** 
 138:./include/linux/fs.h **** /*
 139:./include/linux/fs.h ****  * Attribute flags.  These should be or-ed together to figure out what
 140:./include/linux/fs.h ****  * has been changed!
 141:./include/linux/fs.h ****  */
 142:./include/linux/fs.h **** #define ATTR_MODE	(1 << 0)
 143:./include/linux/fs.h **** #define ATTR_UID	(1 << 1)
 144:./include/linux/fs.h **** #define ATTR_GID	(1 << 2)
 145:./include/linux/fs.h **** #define ATTR_SIZE	(1 << 3)
 146:./include/linux/fs.h **** #define ATTR_ATIME	(1 << 4)
 147:./include/linux/fs.h **** #define ATTR_MTIME	(1 << 5)
 148:./include/linux/fs.h **** #define ATTR_CTIME	(1 << 6)
 149:./include/linux/fs.h **** #define ATTR_ATIME_SET	(1 << 7)
 150:./include/linux/fs.h **** #define ATTR_MTIME_SET	(1 << 8)
 151:./include/linux/fs.h **** #define ATTR_FORCE	(1 << 9) /* Not a change, but a change it */
 152:./include/linux/fs.h **** #define ATTR_KILL_SUID	(1 << 11)
 153:./include/linux/fs.h **** #define ATTR_KILL_SGID	(1 << 12)
 154:./include/linux/fs.h **** #define ATTR_FILE	(1 << 13)
 155:./include/linux/fs.h **** #define ATTR_KILL_PRIV	(1 << 14)
 156:./include/linux/fs.h **** #define ATTR_OPEN	(1 << 15) /* Truncating from open(O_TRUNC) */
 157:./include/linux/fs.h **** #define ATTR_TIMES_SET	(1 << 16)
 158:./include/linux/fs.h **** #define ATTR_TOUCH	(1 << 17)
 159:./include/linux/fs.h **** #define ATTR_DELEG	(1 << 18) /* Delegated attrs. Don't break write delegations */
 160:./include/linux/fs.h **** 
 161:./include/linux/fs.h **** /*
 162:./include/linux/fs.h ****  * Whiteout is represented by a char device.  The following constants define the
 163:./include/linux/fs.h ****  * mode and device number to use.
 164:./include/linux/fs.h ****  */
 165:./include/linux/fs.h **** #define WHITEOUT_MODE 0
 166:./include/linux/fs.h **** #define WHITEOUT_DEV 0
 167:./include/linux/fs.h **** 
 168:./include/linux/fs.h **** 
 169:./include/linux/fs.h **** 
 170:./include/linux/fs.h **** /********************************************************
 171:./include/linux/fs.h ****  * 														*
 172:./include/linux/fs.h ****  * 			   		     iattr  						*
 173:./include/linux/fs.h ****  *														* 
 174:./include/linux/fs.h **** *********************************************************/
 175:./include/linux/fs.h **** 
 176:./include/linux/fs.h **** 
 177:./include/linux/fs.h **** struct iattr {
 178:./include/linux/fs.h **** 	unsigned int	ia_valid;
 179:./include/linux/fs.h **** 	umode_t		ia_mode;
 180:./include/linux/fs.h **** 	union {
 181:./include/linux/fs.h **** 		kuid_t		ia_uid;
 182:./include/linux/fs.h **** 		vfsuid_t	ia_vfsuid;
 183:./include/linux/fs.h **** 	};
 184:./include/linux/fs.h **** 	union {
ARM GAS  /tmp/cc80GKN8.s 			page 16


 185:./include/linux/fs.h **** 		kgid_t		ia_gid;
 186:./include/linux/fs.h **** 		vfsgid_t	ia_vfsgid;
 187:./include/linux/fs.h **** 	};
 188:./include/linux/fs.h **** 	loff_t		ia_size;
 189:./include/linux/fs.h **** 	struct timespec64 ia_atime;
 190:./include/linux/fs.h **** 	struct timespec64 ia_mtime;
 191:./include/linux/fs.h **** 	struct timespec64 ia_ctime;
 192:./include/linux/fs.h **** 	struct file	*ia_file;
 193:./include/linux/fs.h **** };
 194:./include/linux/fs.h **** 
 195:./include/linux/fs.h **** /********************************************************
 196:./include/linux/fs.h ****  * 														*
 197:./include/linux/fs.h ****  * 			     address_space  						*
 198:./include/linux/fs.h ****  *														* 
 199:./include/linux/fs.h **** *********************************************************/
 200:./include/linux/fs.h **** struct file_ra_state {
 201:./include/linux/fs.h **** 	pgoff_t start;
 202:./include/linux/fs.h **** 	unsigned int size;
 203:./include/linux/fs.h **** 	unsigned int async_size;
 204:./include/linux/fs.h **** 	unsigned int ra_pages;
 205:./include/linux/fs.h **** 	unsigned int mmap_miss;
 206:./include/linux/fs.h **** 	loff_t prev_pos;
 207:./include/linux/fs.h **** };
 208:./include/linux/fs.h **** 
 209:./include/linux/fs.h **** struct iov_iter {
 210:./include/linux/fs.h **** 	u8 iter_type;
 211:./include/linux/fs.h **** 	bool nofault;
 212:./include/linux/fs.h **** 	bool data_source;
 213:./include/linux/fs.h **** 	size_t iov_offset;
 214:./include/linux/fs.h **** 	/*
 215:./include/linux/fs.h **** 	 * Hack alert: overlay ubuf_iovec with iovec + count, so
 216:./include/linux/fs.h **** 	 * that the members resolve correctly regardless of the type
 217:./include/linux/fs.h **** 	 * of iterator used. This means that you can use:
 218:./include/linux/fs.h **** 	 *
 219:./include/linux/fs.h **** 	 * &iter->__ubuf_iovec or iter->__iov
 220:./include/linux/fs.h **** 	 *
 221:./include/linux/fs.h **** 	 * interchangably for the user_backed cases, hence simplifying
 222:./include/linux/fs.h **** 	 * some of the cases that need to deal with both.
 223:./include/linux/fs.h **** 	 */
 224:./include/linux/fs.h **** 	union {
 225:./include/linux/fs.h **** 		/*
 226:./include/linux/fs.h **** 		 * This really should be a const, but we cannot do that without
 227:./include/linux/fs.h **** 		 * also modifying any of the zero-filling iter init functions.
 228:./include/linux/fs.h **** 		 * Leave it non-const for now, but it should be treated as such.
 229:./include/linux/fs.h **** 		 */
 230:./include/linux/fs.h **** 		struct iovec __ubuf_iovec;
 231:./include/linux/fs.h **** 		struct {
 232:./include/linux/fs.h **** 			union {
 233:./include/linux/fs.h **** 				/* use iter_iov() to get the current vec */
 234:./include/linux/fs.h **** 				const struct iovec *__iov;
 235:./include/linux/fs.h **** 				const struct kvec *kvec;
 236:./include/linux/fs.h **** 				const struct bio_vec *bvec;
 237:./include/linux/fs.h **** 				const struct folio_queue *folioq;
 238:./include/linux/fs.h **** 				struct xarray *xarray;
 239:./include/linux/fs.h **** 				void __user *ubuf;
 240:./include/linux/fs.h **** 			};
 241:./include/linux/fs.h **** 			size_t count;
ARM GAS  /tmp/cc80GKN8.s 			page 17


 242:./include/linux/fs.h **** 		};
 243:./include/linux/fs.h **** 	};
 244:./include/linux/fs.h **** 	union {
 245:./include/linux/fs.h **** 		unsigned long nr_segs;
 246:./include/linux/fs.h **** 		u8 folioq_slot;
 247:./include/linux/fs.h **** 		loff_t xarray_start;
 248:./include/linux/fs.h **** 	};
 249:./include/linux/fs.h **** };
 250:./include/linux/fs.h **** 
 251:./include/linux/fs.h **** struct address_space_operations {
 252:./include/linux/fs.h **** 	int (*writepage)(struct page *page, struct writeback_control *wbc);
 253:./include/linux/fs.h **** 	int (*read_folio)(struct file *, struct folio *);
 254:./include/linux/fs.h **** 
 255:./include/linux/fs.h **** 	/* Write back some dirty pages from this mapping. */
 256:./include/linux/fs.h **** 	int (*writepages)(struct address_space *, struct writeback_control *);
 257:./include/linux/fs.h **** 
 258:./include/linux/fs.h **** 	/* Mark a folio dirty.  Return true if this dirtied it */
 259:./include/linux/fs.h **** 	bool (*dirty_folio)(struct address_space *, struct folio *);
 260:./include/linux/fs.h **** 
 261:./include/linux/fs.h **** 	void (*readahead)(struct readahead_control *);
 262:./include/linux/fs.h **** 
 263:./include/linux/fs.h **** 	int (*write_begin)(struct file *, struct address_space *mapping,
 264:./include/linux/fs.h **** 				loff_t pos, unsigned len,
 265:./include/linux/fs.h **** 				struct folio **foliop, void **fsdata);
 266:./include/linux/fs.h **** 	int (*write_end)(struct file *, struct address_space *mapping,
 267:./include/linux/fs.h **** 				loff_t pos, unsigned len, unsigned copied,
 268:./include/linux/fs.h **** 				struct folio *folio, void *fsdata);
 269:./include/linux/fs.h **** 
 270:./include/linux/fs.h **** 	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
 271:./include/linux/fs.h **** 	sector_t (*bmap)(struct address_space *, sector_t);
 272:./include/linux/fs.h **** 	void (*invalidate_folio) (struct folio *, size_t offset, size_t len);
 273:./include/linux/fs.h **** 	bool (*release_folio)(struct folio *, gfp_t);
 274:./include/linux/fs.h **** 	void (*free_folio)(struct folio *folio);
 275:./include/linux/fs.h **** 	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);
 276:./include/linux/fs.h **** 	/*
 277:./include/linux/fs.h **** 	 * migrate the contents of a folio to the specified target. If
 278:./include/linux/fs.h **** 	 * migrate_mode is MIGRATE_ASYNC, it must not block.
 279:./include/linux/fs.h **** 	 */
 280:./include/linux/fs.h **** 	int (*migrate_folio)(struct address_space *, struct folio *dst,
 281:./include/linux/fs.h **** 			struct folio *src, enum migrate_mode);
 282:./include/linux/fs.h **** 	int (*launder_folio)(struct folio *);
 283:./include/linux/fs.h **** 	bool (*is_partially_uptodate) (struct folio *, size_t from,
 284:./include/linux/fs.h **** 			size_t count);
 285:./include/linux/fs.h **** 	void (*is_dirty_writeback) (struct folio *, bool *dirty, bool *wb);
 286:./include/linux/fs.h **** 	int (*error_remove_folio)(struct address_space *, struct folio *);
 287:./include/linux/fs.h **** 
 288:./include/linux/fs.h **** 	/* swapfile support */
 289:./include/linux/fs.h **** 	// int (*swap_activate)(struct swap_info_struct *sis, struct file *file,
 290:./include/linux/fs.h **** 	// 			sector_t *span);
 291:./include/linux/fs.h **** 	// void (*swap_deactivate)(struct file *file);
 292:./include/linux/fs.h **** 	// int (*swap_rw)(struct kiocb *iocb, struct iov_iter *iter);
 293:./include/linux/fs.h **** };
 294:./include/linux/fs.h **** 
 295:./include/linux/fs.h ****  struct address_space {
 296:./include/linux/fs.h **** 	struct inode		*host;
 297:./include/linux/fs.h **** 	struct xarray		i_pages;
 298:./include/linux/fs.h **** 	gfp_t			gfp_mask;
ARM GAS  /tmp/cc80GKN8.s 			page 18


 299:./include/linux/fs.h **** 	atomic_t		i_mmap_writable;
 300:./include/linux/fs.h **** #ifdef CONFIG_READ_ONLY_THP_FOR_FS
 301:./include/linux/fs.h **** 	/* number of thp, only for non-shmem files */
 302:./include/linux/fs.h **** 	atomic_t		nr_thps;
 303:./include/linux/fs.h **** #endif
 304:./include/linux/fs.h **** 	struct rb_root_cached	i_mmap;
 305:./include/linux/fs.h **** 	unsigned long		nrpages;
 306:./include/linux/fs.h **** 	pgoff_t			writeback_index;
 307:./include/linux/fs.h **** 	const struct address_space_operations *a_ops;
 308:./include/linux/fs.h **** 	unsigned long		flags;
 309:./include/linux/fs.h **** 	errseq_t		wb_err;
 310:./include/linux/fs.h **** 	spinlock_t		i_private_lock;
 311:./include/linux/fs.h **** 	struct list_head	i_private_list;
 312:./include/linux/fs.h **** 	void *			i_private_data;
 313:./include/linux/fs.h **** } __attribute__((aligned(sizeof(long)))) __randomize_layout;
 314:./include/linux/fs.h **** 
 315:./include/linux/fs.h **** /********************************************************
 316:./include/linux/fs.h ****  * 														*
 317:./include/linux/fs.h ****  * 			   		  file struct						*
 318:./include/linux/fs.h ****  *														* 
 319:./include/linux/fs.h **** *********************************************************/
 320:./include/linux/fs.h **** 
 321:./include/linux/fs.h **** struct file {
 322:./include/linux/fs.h **** 	struct mutex					f_ref;
 323:./include/linux/fs.h **** 	struct mutex					f_lock;
 324:./include/linux/fs.h **** 	fmode_t							f_mode;
 325:./include/linux/fs.h **** 	const struct file_operations	*f_op;                            
 326:./include/linux/fs.h **** 	//	struct address_space			*f_mapping;
 327:./include/linux/fs.h **** 	void							*private_data;
 328:./include/linux/fs.h **** 	struct inode					*f_inode;
 329:./include/linux/fs.h **** 	unsigned int					f_flags;
 330:./include/linux/fs.h **** 	unsigned int					f_iocb_flags;
 331:./include/linux/fs.h **** 	char *						    f_path;
 332:./include/linux/fs.h **** 	union {
 333:./include/linux/fs.h **** 		struct mutex				f_pos_lock;
 334:./include/linux/fs.h **** 		u64							f_pipe;
 335:./include/linux/fs.h **** 	};
 336:./include/linux/fs.h **** 	loff_t							f_pos;
 337:./include/linux/fs.h **** 	void *							f_private;
 338:./include/linux/fs.h **** 	spinlock_t                      f_slock;
 339:./include/linux/fs.h **** }__attribute__((aligned(sizeof(long)))) __randomize_layout;	
 340:./include/linux/fs.h **** 
 341:./include/linux/fs.h **** 
 342:./include/linux/fs.h **** /********************************************************
 343:./include/linux/fs.h ****  * 														*
 344:./include/linux/fs.h ****  * 			   		  inode struct						*
 345:./include/linux/fs.h ****  *														* 
 346:./include/linux/fs.h **** *********************************************************/
 347:./include/linux/fs.h **** 
 348:./include/linux/fs.h **** #define IOP_FASTPERM	0x0001
 349:./include/linux/fs.h **** #define IOP_LOOKUP	0x0002
 350:./include/linux/fs.h **** #define IOP_NOFOLLOW	0x0004
 351:./include/linux/fs.h **** #define IOP_XATTR	0x0008
 352:./include/linux/fs.h **** #define IOP_DEFAULT_READLINK	0x0010
 353:./include/linux/fs.h **** #define IOP_MGTIME	0x0020
 354:./include/linux/fs.h **** 
 355:./include/linux/fs.h **** /*
ARM GAS  /tmp/cc80GKN8.s 			page 19


 356:./include/linux/fs.h ****  * Keep mostly read-only and often accessed (especially for
 357:./include/linux/fs.h ****  * the RCU path lookup and 'stat' data) fields at the beginning
 358:./include/linux/fs.h ****  * of the 'struct inode'
 359:./include/linux/fs.h ****  */
 360:./include/linux/fs.h **** 
 361:./include/linux/fs.h **** struct inode {
 362:./include/linux/fs.h **** 	umode_t            i_mode;   
 363:./include/linux/fs.h **** 
 364:./include/linux/fs.h **** 	unsigned short     		i_opflags;     /* inode 操作标志对应IOP宏 */
 365:./include/linux/fs.h **** 	kuid_t             i_uid;         /* 文件所有者用户ID */
 366:./include/linux/fs.h **** 	kgid_t             i_gid;         /* 文件所有者组ID */
 367:./include/linux/fs.h **** 
 368:./include/linux/fs.h **** 	unsigned int       i_flags;    
 369:./include/linux/fs.h **** 	const struct inode_operations *i_op;     
 370:./include/linux/fs.h **** 	struct super_block            *i_sb;       
 371:./include/linux/fs.h **** 	struct address_space	      *i_mapping;   
 372:./include/linux/fs.h **** 	dev_t             i_rdev;       
 373:./include/linux/fs.h **** 	loff_t            i_size;        
 374:./include/linux/fs.h **** 	time64_t          i_atime_sec;   
 375:./include/linux/fs.h **** 	time64_t          i_mtime_sec;   
 376:./include/linux/fs.h **** 	time64_t          i_ctime_sec;    
 377:./include/linux/fs.h **** 	u32               i_atime_nsec;   
 378:./include/linux/fs.h **** 	u32               i_mtime_nsec;   
 379:./include/linux/fs.h **** 	u32               i_ctime_nsec;  
 380:./include/linux/fs.h **** 	unsigned short    i_bytes;
 381:./include/linux/fs.h **** 	u32			i_state;
 382:./include/linux/fs.h **** 	struct hlist_node	i_hash;
 383:./include/linux/fs.h **** 	struct list_head	i_io_list;	/* backing dev IO list */
 384:./include/linux/fs.h **** 	spinlock_t	        i_lock;	/* i_blocks, i_bytes, maybe i_size */
 385:./include/linux/fs.h **** 	struct list_head	i_sb_list;
 386:./include/linux/fs.h **** 	struct list_head	i_dentry;
 387:./include/linux/fs.h **** 	atomic_t		i_count;
 388:./include/linux/fs.h **** 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 389:./include/linux/fs.h **** 	void (*free_inode)(struct inode *);
 390:./include/linux/fs.h **** 	void			*i_private; /* fs or device private pointer */
 391:./include/linux/fs.h **** }__attribute__((aligned(sizeof(long)))) __randomize_layout;
 392:./include/linux/fs.h **** 
 393:./include/linux/fs.h **** /********************************************************
 394:./include/linux/fs.h ****  * 														*
 395:./include/linux/fs.h ****  * 			   inode inode_operations					*
 396:./include/linux/fs.h ****  *														* 
 397:./include/linux/fs.h **** *********************************************************/
 398:./include/linux/fs.h **** 
 399:./include/linux/fs.h **** struct mnt_idmap {void * no_data;};
 400:./include/linux/fs.h **** 
 401:./include/linux/fs.h **** struct inode_operations {
 402:./include/linux/fs.h **** 	struct dentry  	 *(*lookup) 	   (struct inode *    ,struct dentry *, unsigned int);
 403:./include/linux/fs.h **** 	const char 	     *(*get_link) 	   (struct dentry *   , struct inode *, struct delayed_call *);
 404:./include/linux/fs.h **** 	int 			  (*permission)    (struct mnt_idmap *, struct inode *, int);
 405:./include/linux/fs.h **** 	struct posix_acl *(*get_inode_acl) (struct inode *	  , int, bool);
 406:./include/linux/fs.h **** 	int 			  (*readlink) 	   (struct dentry *   , char __user * ,int);
 407:./include/linux/fs.h **** 	int 			  (*create) 	   (struct mnt_idmap *, struct inode *,struct dentry *,umode_t, bool);
 408:./include/linux/fs.h **** 	int 			  (*link) 		   (struct dentry *   ,struct inode * ,struct dentry *);
 409:./include/linux/fs.h **** 	int 			  (*unlink) 	   (struct inode *	  ,struct dentry * );
 410:./include/linux/fs.h **** 	int 			  (*symlink) 	   (struct mnt_idmap *, struct inode *,struct dentry *,const char *);
 411:./include/linux/fs.h **** 	int 			  (*mkdir) 		   (struct mnt_idmap *, struct inode *,struct dentry *,umode_t);
 412:./include/linux/fs.h **** 	int 			  (*rmdir)		   (struct inode *	  ,struct dentry * );
ARM GAS  /tmp/cc80GKN8.s 			page 20


 413:./include/linux/fs.h **** 	int 			  (*mknod) 		   (struct mnt_idmap *, struct inode *,struct dentry *,umode_t,dev_t);
 414:./include/linux/fs.h **** 	int 			  (*rename) 	   (struct mnt_idmap *, struct inode *, struct dentry *,struct inode *, struct
 415:./include/linux/fs.h **** 	int 			  (*setattr)	   (struct mnt_idmap *, struct dentry*, struct iattr *);
 416:./include/linux/fs.h **** 	int 			  (*getattr) 	   (struct mnt_idmap *, const struct path *,struct kstat *, u32, unsigned int
 417:./include/linux/fs.h **** 	ssize_t 		  (*listxattr) 	   (struct dentry *	  , char *		  , size_t);
 418:./include/linux/fs.h **** 	int 			  (*fiemap)		   (struct inode *	  , struct fiemap_extent_info *, u64 start,u64 len);
 419:./include/linux/fs.h **** 	int 			  (*update_time)   (struct inode *    , int);
 420:./include/linux/fs.h **** 	int 			  (*atomic_open)   (struct inode *    , struct dentry*,struct file *, unsigned open_flag,um
 421:./include/linux/fs.h **** 	int 			  (*tmpfile)	   (struct mnt_idmap *, struct inode *,struct file *, umode_t);
 422:./include/linux/fs.h **** 	struct posix_acl *(*get_acl)	   (struct mnt_idmap *, struct dentry*,int);
 423:./include/linux/fs.h **** 	int 			  (*set_acl)	   (struct mnt_idmap *, struct dentry*,struct posix_acl *, int);
 424:./include/linux/fs.h **** 	int 			  (*fileattr_set)  (struct mnt_idmap *idmap,struct dentry *dentry, struct fileattr *fa);
 425:./include/linux/fs.h **** 	int 			  (*fileattr_get)  (struct dentry *dentry  , struct fileattr *fa);
 426:./include/linux/fs.h **** 	struct offset_ctx*(*get_offset_ctx)(struct inode *inode);
 427:./include/linux/fs.h **** };
 428:./include/linux/fs.h **** 
 429:./include/linux/fs.h **** /********************************************************
 430:./include/linux/fs.h ****  * 														*
 431:./include/linux/fs.h ****  * 			       file_operations						*
 432:./include/linux/fs.h ****  *														* 
 433:./include/linux/fs.h **** *********************************************************/
 434:./include/linux/fs.h **** 
 435:./include/linux/fs.h **** struct kiocb {
 436:./include/linux/fs.h **** 	struct file		*ki_filp;
 437:./include/linux/fs.h **** 	loff_t			ki_pos;
 438:./include/linux/fs.h **** 	void (*ki_complete)(struct kiocb *iocb, long ret);
 439:./include/linux/fs.h **** 	void			*private;
 440:./include/linux/fs.h **** 	int			ki_flags;
 441:./include/linux/fs.h **** 	u16			ki_ioprio; /* See linux/ioprio.h */
 442:./include/linux/fs.h **** 	union {
 443:./include/linux/fs.h **** 	//	struct wait_page_queue	*ki_waitq;
 444:./include/linux/fs.h **** 		ssize_t (*dio_complete)(void *data);
 445:./include/linux/fs.h **** 	};
 446:./include/linux/fs.h **** };
 447:./include/linux/fs.h **** 
 448:./include/linux/fs.h **** struct dir_context;
 449:./include/linux/fs.h **** typedef bool (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,
 450:./include/linux/fs.h **** 			 unsigned);
 451:./include/linux/fs.h **** 
 452:./include/linux/fs.h **** struct dir_context {
 453:./include/linux/fs.h **** 	filldir_t actor;
 454:./include/linux/fs.h **** 	loff_t pos;
 455:./include/linux/fs.h **** };
 456:./include/linux/fs.h **** 
 457:./include/linux/fs.h **** 
 458:./include/linux/fs.h **** 
 459:./include/linux/fs.h **** 
 460:./include/linux/fs.h **** typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);
 461:./include/linux/fs.h **** 
 462:./include/linux/fs.h **** typedef struct poll_table_struct {
 463:./include/linux/fs.h **** 	poll_queue_proc _qproc;
 464:./include/linux/fs.h **** 	__poll_t _key;
 465:./include/linux/fs.h **** } poll_table;
 466:./include/linux/fs.h **** 
 467:./include/linux/fs.h **** typedef unsigned int __bitwise fop_flags_t;
 468:./include/linux/fs.h **** typedef void *fl_owner_t;
 469:./include/linux/fs.h **** 
ARM GAS  /tmp/cc80GKN8.s 			page 21


 470:./include/linux/fs.h **** struct file_operations {
 471:./include/linux/fs.h **** 	void *owner;
 472:./include/linux/fs.h **** 	fop_flags_t fop_flags;
 473:./include/linux/fs.h **** 	loff_t (*llseek) (struct file *, loff_t, int);
 474:./include/linux/fs.h **** 	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
 475:./include/linux/fs.h **** 	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
 476:./include/linux/fs.h **** ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
 477:./include/linux/fs.h **** ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
 478:./include/linux/fs.h **** 	int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,unsigned int flags);
 479:./include/linux/fs.h **** 	int (*iterate_shared) (struct file *, struct dir_context *);
 480:./include/linux/fs.h **** 	__poll_t (*poll) (struct file *, struct poll_table_struct *);
 481:./include/linux/fs.h **** 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 482:./include/linux/fs.h **** 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 483:./include/linux/fs.h **** int (*mmap) (struct file *, struct vm_area_struct *);
 484:./include/linux/fs.h **** 	int (*open) (struct inode *, struct file *);
 485:./include/linux/fs.h **** 	int (*flush) (struct file *, fl_owner_t id);
 486:./include/linux/fs.h **** 	int (*release) (struct inode *, struct file *);
 487:./include/linux/fs.h **** 	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
 488:./include/linux/fs.h **** 	int (*fasync) (int, struct file *, int);
 489:./include/linux/fs.h **** 	int (*lock) (struct file *, int, struct file_lock *);
 490:./include/linux/fs.h **** 	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, uns
 491:./include/linux/fs.h **** 	int (*check_flags)(int);
 492:./include/linux/fs.h **** 	int (*flock) (struct file *, int, struct file_lock *);
 493:./include/linux/fs.h **** ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 494:./include/linux/fs.h **** ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
 495:./include/linux/fs.h **** 	void (*splice_eof)(struct file *file);
 496:./include/linux/fs.h **** 	int (*setlease)(struct file *, int, struct file_lease **, void **);
 497:./include/linux/fs.h **** 	long (*fallocate)(struct file *file, int mode, loff_t offset,loff_t len);
 498:./include/linux/fs.h **** 	void (*show_fdinfo)(struct seq_file *m, struct file *f);
 499:./include/linux/fs.h **** #ifndef CONFIG_MMU
 500:./include/linux/fs.h **** 	unsigned (*mmap_capabilities)(struct file *);
 501:./include/linux/fs.h **** #endif
 502:./include/linux/fs.h **** 	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,loff_t, size_t, unsigned int);
 503:./include/linux/fs.h **** 	loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,struct file *file_out, loff_t pos_o
 504:./include/linux/fs.h **** 	int (*fadvise)(struct file *, loff_t, loff_t, int);
 505:./include/linux/fs.h **** 	int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags);
 506:./include/linux/fs.h **** 	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *,unsigned int poll_flags);
 507:./include/linux/fs.h **** };
 508:./include/linux/fs.h **** 
 509:./include/linux/fs.h **** 
 510:./include/linux/fs.h **** /********************************************************
 511:./include/linux/fs.h ****  * 														*
 512:./include/linux/fs.h ****  * 			       super_block							*
 513:./include/linux/fs.h ****  *														* 
 514:./include/linux/fs.h **** *********************************************************/
 515:./include/linux/fs.h **** 
 516:./include/linux/fs.h **** struct rcu_sync {
 517:./include/linux/fs.h **** 	int			gp_state;
 518:./include/linux/fs.h **** 	int			gp_count;
 519:./include/linux/fs.h **** 	wait_queue_head_t	gp_wait;
 520:./include/linux/fs.h **** 
 521:./include/linux/fs.h **** 	struct rcu_head		cb_head;
 522:./include/linux/fs.h **** };
 523:./include/linux/fs.h **** 
 524:./include/linux/fs.h **** struct rcuwait {
 525:./include/linux/fs.h **** 	//struct task_struct __rcu *task;
 526:./include/linux/fs.h **** };
ARM GAS  /tmp/cc80GKN8.s 			page 22


 527:./include/linux/fs.h **** 
 528:./include/linux/fs.h **** struct percpu_rw_semaphore {
 529:./include/linux/fs.h **** 	struct rcu_sync		rss;
 530:./include/linux/fs.h **** 	unsigned int __percpu	*read_count;
 531:./include/linux/fs.h **** 	struct rcuwait		writer;
 532:./include/linux/fs.h **** 	wait_queue_head_t	waiters;
 533:./include/linux/fs.h **** 	atomic_t		block;
 534:./include/linux/fs.h **** #ifdef CONFIG_DEBUG_LOCK_ALLOC
 535:./include/linux/fs.h **** 	struct lockdep_map	dep_map;
 536:./include/linux/fs.h **** #endif
 537:./include/linux/fs.h **** };
 538:./include/linux/fs.h **** 
 539:./include/linux/fs.h **** /*
 540:./include/linux/fs.h ****  * sb->s_flags.  Note that these mirror the equivalent MS_* flags where
 541:./include/linux/fs.h ****  * represented in both.
 542:./include/linux/fs.h ****  */
 543:./include/linux/fs.h **** #define SB_RDONLY       BIT(0)	/* Mount read-only */
 544:./include/linux/fs.h **** #define SB_NOSUID       BIT(1)	/* Ignore suid and sgid bits */
 545:./include/linux/fs.h **** #define SB_NODEV        BIT(2)	/* Disallow access to device special files */
 546:./include/linux/fs.h **** #define SB_NOEXEC       BIT(3)	/* Disallow program execution */
 547:./include/linux/fs.h **** #define SB_SYNCHRONOUS  BIT(4)	/* Writes are synced at once */
 548:./include/linux/fs.h **** #define SB_MANDLOCK     BIT(6)	/* Allow mandatory locks on an FS */
 549:./include/linux/fs.h **** #define SB_DIRSYNC      BIT(7)	/* Directory modifications are synchronous */
 550:./include/linux/fs.h **** #define SB_NOATIME      BIT(10)	/* Do not update access times. */
 551:./include/linux/fs.h **** #define SB_NODIRATIME   BIT(11)	/* Do not update directory access times */
 552:./include/linux/fs.h **** #define SB_SILENT       BIT(15)
 553:./include/linux/fs.h **** #define SB_POSIXACL     BIT(16)	/* Supports POSIX ACLs */
 554:./include/linux/fs.h **** #define SB_INLINECRYPT  BIT(17)	/* Use blk-crypto for encrypted files */
 555:./include/linux/fs.h **** #define SB_KERNMOUNT    BIT(22)	/* this is a kern_mount call */
 556:./include/linux/fs.h **** #define SB_I_VERSION    BIT(23)	/* Update inode I_version field */
 557:./include/linux/fs.h **** #define SB_LAZYTIME     BIT(25)	/* Update the on-disk [acm]times lazily */
 558:./include/linux/fs.h **** 
 559:./include/linux/fs.h **** /* These sb flags are internal to the kernel */
 560:./include/linux/fs.h **** #define SB_DEAD         BIT(21)
 561:./include/linux/fs.h **** #define SB_DYING        BIT(24)
 562:./include/linux/fs.h **** #define SB_SUBMOUNT     BIT(26)
 563:./include/linux/fs.h **** #define SB_FORCE        BIT(27)
 564:./include/linux/fs.h **** #define SB_NOSEC        BIT(28)
 565:./include/linux/fs.h **** #define SB_BORN         BIT(29)
 566:./include/linux/fs.h **** #define SB_ACTIVE       BIT(30)
 567:./include/linux/fs.h **** #define SB_NOUSER       BIT(31)
 568:./include/linux/fs.h **** 
 569:./include/linux/fs.h **** /* These flags relate to encoding and casefolding */
 570:./include/linux/fs.h **** #define SB_ENC_STRICT_MODE_FL	(1 << 0)
 571:./include/linux/fs.h **** 
 572:./include/linux/fs.h **** #define sb_has_strict_encoding(sb) \
 573:./include/linux/fs.h **** 	(sb->s_encoding_flags & SB_ENC_STRICT_MODE_FL)
 574:./include/linux/fs.h **** 
 575:./include/linux/fs.h **** /*
 576:./include/linux/fs.h ****  *	Umount options
 577:./include/linux/fs.h ****  */
 578:./include/linux/fs.h **** 
 579:./include/linux/fs.h **** #define MNT_FORCE	0x00000001	/* Attempt to forcibily umount */
 580:./include/linux/fs.h **** #define MNT_DETACH	0x00000002	/* Just detach from the tree */
 581:./include/linux/fs.h **** #define MNT_EXPIRE	0x00000004	/* Mark for expiry */
 582:./include/linux/fs.h **** #define UMOUNT_NOFOLLOW	0x00000008	/* Don't follow symlink on umount */
 583:./include/linux/fs.h **** #define UMOUNT_UNUSED	0x80000000	/* Flag guaranteed to be unused */
ARM GAS  /tmp/cc80GKN8.s 			page 23


 584:./include/linux/fs.h **** 
 585:./include/linux/fs.h **** /* sb->s_iflags */
 586:./include/linux/fs.h **** #define SB_I_CGROUPWB	0x00000001	/* cgroup-aware writeback enabled */
 587:./include/linux/fs.h **** #define SB_I_NOEXEC	0x00000002	/* Ignore executables on this fs */
 588:./include/linux/fs.h **** #define SB_I_NODEV	0x00000004	/* Ignore devices on this fs */
 589:./include/linux/fs.h **** #define SB_I_STABLE_WRITES 0x00000008	/* don't modify blks until WB is done */
 590:./include/linux/fs.h **** 
 591:./include/linux/fs.h **** /* sb->s_iflags to limit user namespace mounts */
 592:./include/linux/fs.h **** #define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */
 593:./include/linux/fs.h **** #define SB_I_IMA_UNVERIFIABLE_SIGNATURE	0x00000020
 594:./include/linux/fs.h **** #define SB_I_UNTRUSTED_MOUNTER		0x00000040
 595:./include/linux/fs.h **** #define SB_I_EVM_HMAC_UNSUPPORTED	0x00000080
 596:./include/linux/fs.h **** 
 597:./include/linux/fs.h **** #define SB_I_SKIP_SYNC	0x00000100	/* Skip superblock at global sync */
 598:./include/linux/fs.h **** #define SB_I_PERSB_BDI	0x00000200	/* has a per-sb bdi */
 599:./include/linux/fs.h **** #define SB_I_TS_EXPIRY_WARNED 0x00000400 /* warned about timestamp range expiry */
 600:./include/linux/fs.h **** #define SB_I_RETIRED	0x00000800	/* superblock shouldn't be reused */
 601:./include/linux/fs.h **** #define SB_I_NOUMASK	0x00001000	/* VFS does not apply umask */
 602:./include/linux/fs.h **** #define SB_I_NOIDMAP	0x00002000	/* No idmapped mounts on this superblock */
 603:./include/linux/fs.h **** 
 604:./include/linux/fs.h **** 
 605:./include/linux/fs.h **** enum {
 606:./include/linux/fs.h **** 	SB_UNFROZEN = 0,		/* FS is unfrozen */
 607:./include/linux/fs.h **** 	SB_FREEZE_WRITE	= 1,		/* Writes, dir ops, ioctls frozen */
 608:./include/linux/fs.h **** 	SB_FREEZE_PAGEFAULT = 2,	/* Page faults stopped as well */
 609:./include/linux/fs.h **** 	SB_FREEZE_FS = 3,		/* For internal FS use (e.g. to stop
 610:./include/linux/fs.h **** 					 	* internal threads if needed) */
 611:./include/linux/fs.h **** 	SB_FREEZE_COMPLETE = 4,		/* ->freeze_fs finished successfully */
 612:./include/linux/fs.h **** };
 613:./include/linux/fs.h **** 
 614:./include/linux/fs.h **** #define SB_FREEZE_LEVELS (SB_FREEZE_COMPLETE - 1)
 615:./include/linux/fs.h **** 
 616:./include/linux/fs.h **** struct sb_writers {
 617:./include/linux/fs.h **** 	unsigned short			frozen;		/* Is sb frozen? */
 618:./include/linux/fs.h **** 	int				freeze_kcount;	/* How many kernel freeze requests? */
 619:./include/linux/fs.h **** 	int				freeze_ucount;	/* How many userspace freeze requests? */
 620:./include/linux/fs.h **** 	struct percpu_rw_semaphore	rw_sem[SB_FREEZE_LEVELS];
 621:./include/linux/fs.h **** };
 622:./include/linux/fs.h **** 
 623:./include/linux/fs.h **** #define	UUID_STRING_LEN		36
 624:./include/linux/fs.h **** 
 625:./include/linux/fs.h **** 
 626:./include/linux/fs.h **** 
 627:./include/linux/fs.h **** struct super_block 
 628:./include/linux/fs.h **** { 
 629:./include/linux/fs.h **** 	struct list_head				s_list;		/* Keep this first */
 630:./include/linux/fs.h ****     dev_t							s_dev;		/* search index; _not_ kdev_t */
 631:./include/linux/fs.h **** 	unsigned long					s_blocksize;
 632:./include/linux/fs.h ****     const struct super_operations	*s_op;
 633:./include/linux/fs.h **** 	const struct dquot_operations	*dq_op;
 634:./include/linux/fs.h **** 
 635:./include/linux/fs.h **** 	struct dentry		*s_root;      //superblock的根目录结点
 636:./include/linux/fs.h **** 	struct block_device	*s_bdev; 
 637:./include/linux/fs.h **** 	struct hlist_node	s_instances;
 638:./include/linux/fs.h **** 	struct list_head	s_mounts;
 639:./include/linux/fs.h **** 	void			   *s_fs_info;	/* Filesystem private info */
 640:./include/linux/fs.h **** 	char			    s_sysfs_name[UUID_STRING_LEN + 1];
ARM GAS  /tmp/cc80GKN8.s 			page 24


 641:./include/linux/fs.h **** 	unsigned int		s_max_links;
 642:./include/linux/fs.h **** 	struct mutex            		s_vfs_rename_mutex;	/* Kludge */
 643:./include/linux/fs.h **** 	const struct dentry_operations *s_d_op; /* default d_op for dentries */
 644:./include/linux/fs.h **** 	struct hlist_head s_pins;
 645:./include/linux/fs.h **** };
 646:./include/linux/fs.h **** 
 647:./include/linux/fs.h **** 
 648:./include/linux/fs.h **** /********************************************************
 649:./include/linux/fs.h ****  * 														*
 650:./include/linux/fs.h ****  * 			       super_operations						*
 651:./include/linux/fs.h ****  *														* 
 652:./include/linux/fs.h **** *********************************************************/
 653:./include/linux/fs.h **** 
 654:./include/linux/fs.h **** struct seq_operations ;
 655:./include/linux/fs.h **** struct seq_file {
 656:./include/linux/fs.h **** 	char *buf;
 657:./include/linux/fs.h **** 	size_t size;
 658:./include/linux/fs.h **** 	size_t from;
 659:./include/linux/fs.h **** 	size_t count;
 660:./include/linux/fs.h **** 	size_t pad_until;
 661:./include/linux/fs.h **** 	loff_t index;
 662:./include/linux/fs.h **** 	loff_t read_pos;
 663:./include/linux/fs.h **** 	struct mutex lock;
 664:./include/linux/fs.h **** 	const struct seq_operations *op;
 665:./include/linux/fs.h **** 	int poll_event;
 666:./include/linux/fs.h **** 	const struct file *file;
 667:./include/linux/fs.h **** 	void *private;
 668:./include/linux/fs.h **** };
 669:./include/linux/fs.h **** 
 670:./include/linux/fs.h **** struct seq_operations {
 671:./include/linux/fs.h **** 	void * (*start) (struct seq_file *m, loff_t *pos);
 672:./include/linux/fs.h **** 	void (*stop) (struct seq_file *m, void *v);
 673:./include/linux/fs.h **** 	void * (*next) (struct seq_file *m, void *v, loff_t *pos);
 674:./include/linux/fs.h **** 	int (*show) (struct seq_file *m, void *v);
 675:./include/linux/fs.h **** };
 676:./include/linux/fs.h **** 
 677:./include/linux/fs.h **** enum freeze_holder {
 678:./include/linux/fs.h **** 	FREEZE_HOLDER_KERNEL	= (1U << 0),
 679:./include/linux/fs.h **** 	FREEZE_HOLDER_USERSPACE	= (1U << 1),
 680:./include/linux/fs.h **** 	FREEZE_MAY_NEST		= (1U << 2),
 681:./include/linux/fs.h **** };
 682:./include/linux/fs.h **** 
 683:./include/linux/fs.h **** struct writeback_control {
 684:./include/linux/fs.h **** 	unsigned long nr_to_write;
 685:./include/linux/fs.h **** };
 686:./include/linux/fs.h **** 
 687:./include/linux/fs.h **** 
 688:./include/linux/fs.h **** struct shrink_control {
 689:./include/linux/fs.h **** 	gfp_t gfp_mask;
 690:./include/linux/fs.h **** 	int nid;
 691:./include/linux/fs.h **** 	unsigned long nr_to_scan;
 692:./include/linux/fs.h **** 	unsigned long nr_scanned;
 693:./include/linux/fs.h ****     //struct mem_cgroup *memcg;
 694:./include/linux/fs.h **** };
 695:./include/linux/fs.h **** 
 696:./include/linux/fs.h **** struct super_operations {
 697:./include/linux/fs.h ****    	struct inode *(*alloc_inode)(struct super_block *sb);
ARM GAS  /tmp/cc80GKN8.s 			page 25


 698:./include/linux/fs.h **** 	void (*destroy_inode)       (struct inode *);
 699:./include/linux/fs.h **** 	void (*free_inode)          (struct inode *);
 700:./include/linux/fs.h ****    	void (*dirty_inode)         (struct inode *, int flags);
 701:./include/linux/fs.h **** 	int  (*write_inode)         (struct inode *, struct writeback_control *wbc);
 702:./include/linux/fs.h **** 	int  (*drop_inode)          (struct inode *);
 703:./include/linux/fs.h **** 	void (*evict_inode)         (struct inode *);
 704:./include/linux/fs.h **** 	void (*put_super)           (struct super_block *);
 705:./include/linux/fs.h **** 	int  (*sync_fs)             (struct super_block *sb, int wait);
 706:./include/linux/fs.h **** 	int  (*freeze_super)        (struct super_block *, enum freeze_holder who);
 707:./include/linux/fs.h **** 	int  (*freeze_fs)           (struct super_block *);
 708:./include/linux/fs.h **** 	int  (*thaw_super)          (struct super_block *, enum freeze_holder who);
 709:./include/linux/fs.h **** 	int  (*unfreeze_fs)         (struct super_block *);
 710:./include/linux/fs.h **** 	int  (*statfs)              (struct dentry *, struct kstatfs *);
 711:./include/linux/fs.h **** 	int  (*remount_fs)          (struct super_block *, int *, char *);
 712:./include/linux/fs.h **** 	void (*umount_begin)        (struct super_block *);
 713:./include/linux/fs.h **** 	int  (*show_options)        (struct seq_file *, struct dentry *);
 714:./include/linux/fs.h **** 	int  (*show_devname)        (struct seq_file *, struct dentry *);
 715:./include/linux/fs.h **** 	int  (*show_path)           (struct seq_file *, struct dentry *);
 716:./include/linux/fs.h **** 	int  (*show_stats)          (struct seq_file *, struct dentry *);
 717:./include/linux/fs.h **** 
 718:./include/linux/fs.h **** #ifdef CONFIG_QUOTA
 719:./include/linux/fs.h **** 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
 720:./include/linux/fs.h **** 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 721:./include/linux/fs.h **** 	struct dquot __rcu **(*get_dquots)(struct inode *);
 722:./include/linux/fs.h **** #endif
 723:./include/linux/fs.h **** 
 724:./include/linux/fs.h **** 	long (*nr_cached_objects)(struct super_block *,struct shrink_control *);
 725:./include/linux/fs.h **** 	long (*free_cached_objects)(struct super_block *,struct shrink_control *);
 726:./include/linux/fs.h **** 	void (*shutdown)(struct super_block *sb);
 727:./include/linux/fs.h **** };
 728:./include/linux/fs.h **** 
 729:./include/linux/fs.h **** 
 730:./include/linux/fs.h **** 
 731:./include/linux/fs.h **** /********************************************************
 732:./include/linux/fs.h ****  * 														*
 733:./include/linux/fs.h ****  * 			       dquot_operations						*
 734:./include/linux/fs.h ****  *														* 
 735:./include/linux/fs.h **** *********************************************************/
 736:./include/linux/fs.h **** 
 737:./include/linux/fs.h **** typedef __kernel_uid32_t 	qid_t; /* Type in which we store ids in memory */
 738:./include/linux/fs.h **** typedef long long 			qsize_t;	/* Type in which we store sizes */
 739:./include/linux/fs.h **** 
 740:./include/linux/fs.h **** #undef USRQUOTA
 741:./include/linux/fs.h **** #undef GRPQUOTA
 742:./include/linux/fs.h **** #undef PRJQUOTA
 743:./include/linux/fs.h **** enum quota_type {
 744:./include/linux/fs.h **** 	USRQUOTA = 0,		/* element used for user quotas */
 745:./include/linux/fs.h **** 	GRPQUOTA = 1,		/* element used for group quotas */
 746:./include/linux/fs.h **** 	PRJQUOTA = 2,		/* element used for project quotas */
 747:./include/linux/fs.h **** };
 748:./include/linux/fs.h **** 
 749:./include/linux/fs.h **** struct kqid {			/* Type in which we store the quota identifier */
 750:./include/linux/fs.h **** 	union {
 751:./include/linux/fs.h **** 		kuid_t uid;
 752:./include/linux/fs.h **** 		kgid_t gid;
 753:./include/linux/fs.h **** 		kprojid_t projid;
 754:./include/linux/fs.h **** 	};
ARM GAS  /tmp/cc80GKN8.s 			page 26


 755:./include/linux/fs.h **** 	enum quota_type type;  /* USRQUOTA (uid) or GRPQUOTA (gid) or PRJQUOTA (projid) */
 756:./include/linux/fs.h **** };
 757:./include/linux/fs.h **** 
 758:./include/linux/fs.h **** struct mem_dqblk {
 759:./include/linux/fs.h **** 	qsize_t dqb_bhardlimit;	/* absolute limit on disk blks alloc */
 760:./include/linux/fs.h **** 	qsize_t dqb_bsoftlimit;	/* preferred limit on disk blks */
 761:./include/linux/fs.h **** 	qsize_t dqb_curspace;	/* current used space */
 762:./include/linux/fs.h **** 	qsize_t dqb_rsvspace;   /* current reserved space for delalloc*/
 763:./include/linux/fs.h **** 	qsize_t dqb_ihardlimit;	/* absolute limit on allocated inodes */
 764:./include/linux/fs.h **** 	qsize_t dqb_isoftlimit;	/* preferred inode limit */
 765:./include/linux/fs.h **** 	qsize_t dqb_curinodes;	/* current # allocated inodes */
 766:./include/linux/fs.h **** 	time64_t dqb_btime;	/* time limit for excessive disk use */
 767:./include/linux/fs.h **** 	time64_t dqb_itime;	/* time limit for excessive inode use */
 768:./include/linux/fs.h **** };
 769:./include/linux/fs.h **** 
 770:./include/linux/fs.h **** struct dquot {
 771:./include/linux/fs.h **** 	struct hlist_node dq_hash;	/* Hash list in memory [dq_list_lock] */
 772:./include/linux/fs.h **** 	struct list_head dq_inuse;	/* List of all quotas [dq_list_lock] */
 773:./include/linux/fs.h **** 	struct list_head dq_free;	/* Free list element [dq_list_lock] */
 774:./include/linux/fs.h **** 	struct list_head dq_dirty;	/* List of dirty dquots [dq_list_lock] */
 775:./include/linux/fs.h **** 	struct mutex dq_lock;		/* dquot IO lock */
 776:./include/linux/fs.h **** //	spinlock_t dq_dqb_lock;		/* Lock protecting dq_dqb changes */
 777:./include/linux/fs.h **** 	atomic_t dq_count;		/* Use count */
 778:./include/linux/fs.h **** 	struct super_block *dq_sb;	/* superblock this applies to */
 779:./include/linux/fs.h **** 	struct kqid dq_id;		/* ID this applies to (uid, gid, projid) */
 780:./include/linux/fs.h **** 	loff_t dq_off;			/* Offset of dquot on disk [dq_lock, stable once set] */
 781:./include/linux/fs.h **** 	unsigned long dq_flags;		/* See DQ_* */
 782:./include/linux/fs.h **** 	struct mem_dqblk dq_dqb;	/* Diskquota usage [dq_dqb_lock] */
 783:./include/linux/fs.h **** };
 784:./include/linux/fs.h **** 
 785:./include/linux/fs.h **** /* Operations which must be implemented by each quota format */
 786:./include/linux/fs.h **** 
 787:./include/linux/fs.h **** struct quota_format_ops {
 788:./include/linux/fs.h **** 	int (*check_quota_file)(struct super_block *sb, int type);	/* Detect whether file is in our format
 789:./include/linux/fs.h **** 	int (*read_file_info)(struct super_block *sb, int type);	/* Read main info about file - called on 
 790:./include/linux/fs.h **** 	int (*write_file_info)(struct super_block *sb, int type);	/* Write main info about file */
 791:./include/linux/fs.h **** 	int (*free_file_info)(struct super_block *sb, int type);	/* Called on quotaoff() */
 792:./include/linux/fs.h **** 	int (*read_dqblk)(struct dquot *dquot);		/* Read structure for one user */
 793:./include/linux/fs.h **** 	int (*commit_dqblk)(struct dquot *dquot);	/* Write structure for one user */
 794:./include/linux/fs.h **** 	int (*release_dqblk)(struct dquot *dquot);	/* Called when last reference to dquot is being dropped
 795:./include/linux/fs.h **** 	int (*get_next_id)(struct super_block *sb, struct kqid *qid);	/* Get next ID with existing structu
 796:./include/linux/fs.h **** };
 797:./include/linux/fs.h **** 
 798:./include/linux/fs.h **** struct dquot_operations {
 799:./include/linux/fs.h **** 	int (*write_dquot) (struct dquot *);		/* Ordinary dquot write */
 800:./include/linux/fs.h **** 	struct dquot *(*alloc_dquot)(struct super_block *, int);	/* Allocate memory for new dquot */
 801:./include/linux/fs.h **** 	void (*destroy_dquot)(struct dquot *);		/* Free memory for dquot */
 802:./include/linux/fs.h **** 	int (*acquire_dquot) (struct dquot *);		/* Quota is going to be created on disk */
 803:./include/linux/fs.h **** 	int (*release_dquot) (struct dquot *);		/* Quota is going to be deleted from disk */
 804:./include/linux/fs.h **** 	int (*mark_dirty) (struct dquot *);		/* Dquot is marked dirty */
 805:./include/linux/fs.h **** 	int (*write_info) (struct super_block *, int);	/* Write of quota "superblock" */
 806:./include/linux/fs.h **** 	/* get reserved quota for delayed alloc, value returned is managed by
 807:./include/linux/fs.h **** 	 * quota code only */
 808:./include/linux/fs.h **** 	qsize_t *(*get_reserved_space) (struct inode *);
 809:./include/linux/fs.h **** 	int (*get_projid) (struct inode *, kprojid_t *);/* Get project ID */
 810:./include/linux/fs.h **** 	/* Get number of inodes that were charged for a given inode */
 811:./include/linux/fs.h **** 	int (*get_inode_usage) (struct inode *, qsize_t *);
ARM GAS  /tmp/cc80GKN8.s 			page 27


 812:./include/linux/fs.h **** 	/* Get next ID with active quota structure */
 813:./include/linux/fs.h **** 	int (*get_next_id) (struct super_block *sb, struct kqid *qid);
 814:./include/linux/fs.h **** };
 815:./include/linux/fs.h **** 
 816:./include/linux/fs.h **** /********************************************************
 817:./include/linux/fs.h ****  * 														*
 818:./include/linux/fs.h ****  * 			       file_system_type						*
 819:./include/linux/fs.h ****  *														* 
 820:./include/linux/fs.h **** *********************************************************/
 821:./include/linux/fs.h **** 
 822:./include/linux/fs.h **** struct fs_parameter_spec {
 823:./include/linux/fs.h **** 	const char		*name;
 824:./include/linux/fs.h **** //	fs_param_type		*type;	/* The desired parameter type */
 825:./include/linux/fs.h **** 	u8			opt;	/* Option number (returned by fs_parse()) */
 826:./include/linux/fs.h **** 	unsigned short		flags;
 827:./include/linux/fs.h **** #define fs_param_neg_with_no	0x0002	/* "noxxx" is negative param */
 828:./include/linux/fs.h **** #define fs_param_can_be_empty	0x0004	/* "xxx=" is allowed */
 829:./include/linux/fs.h **** #define fs_param_deprecated	0x0008	/* The param is deprecated */
 830:./include/linux/fs.h **** 	const void		*data;
 831:./include/linux/fs.h **** };
 832:./include/linux/fs.h **** 
 833:./include/linux/fs.h **** 
 834:./include/linux/fs.h **** struct file_system_type {
 835:./include/linux/fs.h **** 	const char *name;
 836:./include/linux/fs.h **** 	int fs_flags;
 837:./include/linux/fs.h **** #define FS_REQUIRES_DEV		1 
 838:./include/linux/fs.h **** #define FS_BINARY_MOUNTDATA	2
 839:./include/linux/fs.h **** #define FS_HAS_SUBTYPE		4
 840:./include/linux/fs.h **** #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 841:./include/linux/fs.h **** #define FS_DISALLOW_NOTIFY_PERM	16	/* Disable fanotify permission events */
 842:./include/linux/fs.h **** #define FS_ALLOW_IDMAP         32      /* FS has been updated to handle vfs idmappings. */
 843:./include/linux/fs.h **** #define FS_MGTIME		64	/* FS uses multigrain timestamps */
 844:./include/linux/fs.h **** #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 845:./include/linux/fs.h **** 	int (*init_fs_context)(struct fs_context *);
 846:./include/linux/fs.h **** 	const struct fs_parameter_spec *parameters;
 847:./include/linux/fs.h **** 	struct dentry *(*mount) (struct file_system_type *, int,
 848:./include/linux/fs.h **** 		       const char *, void *);
 849:./include/linux/fs.h **** 	void (*kill_sb) (struct super_block *);
 850:./include/linux/fs.h **** 	void *owner;
 851:./include/linux/fs.h **** 	struct file_system_type * next;
 852:./include/linux/fs.h **** 	struct hlist_head fs_supers;
 853:./include/linux/fs.h **** 
 854:./include/linux/fs.h **** 	struct lock_class_key s_lock_key;
 855:./include/linux/fs.h **** 	struct lock_class_key s_umount_key;
 856:./include/linux/fs.h **** 	struct lock_class_key s_vfs_rename_key;
 857:./include/linux/fs.h **** 	struct lock_class_key s_writers_key[SB_FREEZE_LEVELS];
 858:./include/linux/fs.h **** 	struct lock_class_key i_lock_key;
 859:./include/linux/fs.h **** 	struct lock_class_key i_mutex_key;
 860:./include/linux/fs.h **** 	struct lock_class_key invalidate_lock_key;
 861:./include/linux/fs.h **** 	struct lock_class_key i_mutex_dir_key;
 862:./include/linux/fs.h **** };
 863:./include/linux/fs.h **** 
 864:./include/linux/fs.h **** 
 865:./include/linux/fs.h **** 
 866:./include/linux/fs.h **** extern int register_filesystem(struct file_system_type *);
 867:./include/linux/fs.h **** extern int unregister_filesystem(struct file_system_type *);
 868:./include/linux/fs.h **** extern struct file_system_type *lookup_fs_type(const char *name);
ARM GAS  /tmp/cc80GKN8.s 			page 28


 869:./include/linux/fs.h **** 
 870:./include/linux/fs.h **** /*--------------------------------------------------------------------------*/
 871:./include/linux/fs.h **** static inline bool is_sync_kiocb(struct kiocb *kiocb){
 872:./include/linux/fs.h **** 	return kiocb->ki_complete == NULL;
 873:./include/linux/fs.h **** }
 874:./include/linux/fs.h **** static inline struct inode *file_inode(const struct file *f){
 875:./include/linux/fs.h **** 	return f->f_inode;
 876:./include/linux/fs.h **** }
 877:./include/linux/fs.h **** /*--------------------------------------------------------------------------*/
 878:./include/linux/fs.h **** 
 879:./include/linux/fs.h **** extern int remove_dentry(char* path);
 880:./include/linux/fs.h **** extern struct file *filp_open(const char * path, int flags, umode_t mode);
 881:./include/linux/fs.h **** extern ssize_t kernel_read(struct file *file, void * buf, size_t count, loff_t *ppos);
 882:./include/linux/fs.h **** extern ssize_t kernel_write(struct file *file,const void * buf, size_t count, loff_t *ppos);
 883:./include/linux/fs.h **** extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
 884:./include/linux/fs.h **** extern int file_close(struct file *file, fl_owner_t id);
 885:./include/linux/fs.h **** 
 886:./include/linux/fs.h **** 
 887:./include/linux/fs.h **** 
 888:./include/linux/fs.h **** /* fs/char_dev.c */
 889:./include/linux/fs.h **** #define CHRDEV_MAJOR_MAX 512
 890:./include/linux/fs.h **** /* Marks the bottom of the first segment of free char majors */
 891:./include/linux/fs.h **** #define CHRDEV_MAJOR_DYN_END 234
 892:./include/linux/fs.h **** /* Marks the top and bottom of the second segment of free char majors */
 893:./include/linux/fs.h **** #define CHRDEV_MAJOR_DYN_EXT_START 511
 894:./include/linux/fs.h **** #define CHRDEV_MAJOR_DYN_EXT_END 384
 895:./include/linux/fs.h **** 
 896:./include/linux/fs.h **** 
 897:./include/linux/fs.h **** 
 898:./include/linux/fs.h **** extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
 899:./include/linux/fs.h **** extern int register_chrdev_region(dev_t, unsigned, const char *);
 900:./include/linux/fs.h **** extern int __register_chrdev(unsigned int major, unsigned int baseminor,
 901:./include/linux/fs.h ****     unsigned int count, const char *name,
 902:./include/linux/fs.h ****     const struct file_operations *fops);
 903:./include/linux/fs.h **** extern void __unregister_chrdev(unsigned int major, unsigned int baseminor,
 904:./include/linux/fs.h **** 		unsigned int count, const char *name);
 905:./include/linux/fs.h **** extern void unregister_chrdev_region(dev_t, unsigned);
 906:./include/linux/fs.h **** 
 907:./include/linux/fs.h **** static inline int register_chrdev(unsigned int major, const char *name,
 429              		.loc 2 907 19 view .LVU99
 430              	.LBB14:
 908:./include/linux/fs.h **** 	const struct file_operations *fops)
 909:./include/linux/fs.h **** {
 910:./include/linux/fs.h **** return __register_chrdev(major, 0, 256, name, fops);
 431              		.loc 2 910 1 view .LVU100
 432              		.loc 2 910 8 is_stmt 0 view .LVU101
 433 0008 164C     		ldr	r4, .L42
 434 000a 174B     		ldr	r3, .L42+4
 435 000c 0093     		str	r3, [sp]
 436 000e 2346     		mov	r3, r4
 437 0010 4FF48072 		mov	r2, #256
 438 0014 0021     		movs	r1, #0
 439 0016 0846     		mov	r0, r1
 440 0018 FFF7FEFF 		bl	__register_chrdev
 441              	.LVL20:
 442 001c 0546     		mov	r5, r0
 443              	.LVL21:
ARM GAS  /tmp/cc80GKN8.s 			page 29


 444              		.loc 2 910 8 view .LVU102
 445              	.LBE14:
 446              	.LBE13:
 218:./drivers/spi/stm32f4_spi.c ****     pr_info("register spi device %d",major);
 447              		.loc 1 218 5 is_stmt 1 view .LVU103
 448 001e 0146     		mov	r1, r0
 449 0020 1248     		ldr	r0, .L42+8
 450              	.LVL22:
 451              		.loc 1 218 5 is_stmt 0 view .LVU104
 452 0022 FFF7FEFF 		bl	printk
 453              	.LVL23:
 219:./drivers/spi/stm32f4_spi.c **** 
 220:./drivers/spi/stm32f4_spi.c ****     struct class * spi_class = class_create(THIS_MODULE,"spidev1");
 454              		.loc 1 220 5 is_stmt 1 view .LVU105
 455              		.loc 1 220 32 is_stmt 0 view .LVU106
 456 0026 2146     		mov	r1, r4
 457 0028 0020     		movs	r0, #0
 458 002a FFF7FEFF 		bl	class_create
 459              	.LVL24:
 460 002e 0446     		mov	r4, r0
 461              	.LVL25:
 221:./drivers/spi/stm32f4_spi.c ****     if(IS_ERR(spi_class)){
 462              		.loc 1 221 5 is_stmt 1 view .LVU107
 463              	.LBB15:
 464              	.LBI15:
 465              		.file 3 "./include/linux/err.h"
   1:./include/linux/err.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/err.h **** #ifndef _LINUX_ERR_H
   3:./include/linux/err.h **** #define _LINUX_ERR_H
   4:./include/linux/err.h **** 
   5:./include/linux/err.h **** #include <linux/compiler_attributes.h>
   6:./include/linux/err.h **** #include <linux/compiler.h>
   7:./include/linux/err.h **** #include <linux/types.h>
   8:./include/linux/err.h **** 
   9:./include/linux/err.h **** #include <asm/errno.h>
  10:./include/linux/err.h **** 
  11:./include/linux/err.h **** /*
  12:./include/linux/err.h ****  * Kernel pointers have redundant information, so we can use a
  13:./include/linux/err.h ****  * scheme where we can return either an error code or a normal
  14:./include/linux/err.h ****  * pointer with the same return value.
  15:./include/linux/err.h ****  *
  16:./include/linux/err.h ****  * This should be a per-architecture thing, to allow different
  17:./include/linux/err.h ****  * error and pointer decisions.
  18:./include/linux/err.h ****  */
  19:./include/linux/err.h **** #define MAX_ERRNO	4095
  20:./include/linux/err.h **** 
  21:./include/linux/err.h **** #ifndef __ASSEMBLY__
  22:./include/linux/err.h **** 
  23:./include/linux/err.h **** /**
  24:./include/linux/err.h ****  * IS_ERR_VALUE - Detect an error pointer.
  25:./include/linux/err.h ****  * @x: The pointer to check.
  26:./include/linux/err.h ****  *
  27:./include/linux/err.h ****  * Like IS_ERR(), but does not generate a compiler warning if result is unused.
  28:./include/linux/err.h ****  */
  29:./include/linux/err.h **** 
  30:./include/linux/err.h **** #ifndef unlikely
  31:./include/linux/err.h **** #  define unlikely(x) __builtin_expect(!!(x), 0)
ARM GAS  /tmp/cc80GKN8.s 			page 30


  32:./include/linux/err.h **** #endif
  33:./include/linux/err.h **** 
  34:./include/linux/err.h **** #ifndef likely
  35:./include/linux/err.h **** #  define likely(x) __builtin_expect(!!(x), 1)
  36:./include/linux/err.h **** #endif
  37:./include/linux/err.h **** 
  38:./include/linux/err.h **** #define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)
  39:./include/linux/err.h **** 
  40:./include/linux/err.h **** /**
  41:./include/linux/err.h ****  * ERR_PTR - Create an error pointer.
  42:./include/linux/err.h ****  * @error: A negative error code.
  43:./include/linux/err.h ****  *
  44:./include/linux/err.h ****  * Encodes @error into a pointer value. Users should consider the result
  45:./include/linux/err.h ****  * opaque and not assume anything about how the error is encoded.
  46:./include/linux/err.h ****  *
  47:./include/linux/err.h ****  * Return: A pointer with @error encoded within its value.
  48:./include/linux/err.h ****  */
  49:./include/linux/err.h **** static inline void * __must_check ERR_PTR(long error)
  50:./include/linux/err.h **** {
  51:./include/linux/err.h **** 	return (void *) error;
  52:./include/linux/err.h **** }
  53:./include/linux/err.h **** 
  54:./include/linux/err.h **** /* Return the pointer in the percpu address space. */
  55:./include/linux/err.h **** #define ERR_PTR_PCPU(error) ((void __percpu *)(unsigned long)ERR_PTR(error))
  56:./include/linux/err.h **** 
  57:./include/linux/err.h **** /**
  58:./include/linux/err.h ****  * PTR_ERR - Extract the error code from an error pointer.
  59:./include/linux/err.h ****  * @ptr: An error pointer.
  60:./include/linux/err.h ****  * Return: The error code within @ptr.
  61:./include/linux/err.h ****  */
  62:./include/linux/err.h **** static inline long __must_check PTR_ERR(__force const void *ptr)
  63:./include/linux/err.h **** {
  64:./include/linux/err.h **** 	return (long) ptr;
  65:./include/linux/err.h **** }
  66:./include/linux/err.h **** 
  67:./include/linux/err.h **** /* Read an error pointer from the percpu address space. */
  68:./include/linux/err.h **** #define PTR_ERR_PCPU(ptr) (PTR_ERR((const void *)(__force const unsigned long)(ptr)))
  69:./include/linux/err.h **** 
  70:./include/linux/err.h **** /**
  71:./include/linux/err.h ****  * IS_ERR - Detect an error pointer.
  72:./include/linux/err.h ****  * @ptr: The pointer to check.
  73:./include/linux/err.h ****  * Return: true if @ptr is an error pointer, false otherwise.
  74:./include/linux/err.h ****  */
  75:./include/linux/err.h **** static inline bool __must_check IS_ERR(__force const void *ptr)
 466              		.loc 3 75 33 view .LVU108
 467              	.LBB16:
  76:./include/linux/err.h **** {
  77:./include/linux/err.h **** 	return IS_ERR_VALUE((unsigned long)ptr);
 468              		.loc 3 77 2 view .LVU109
 469              		.loc 3 77 2 is_stmt 0 view .LVU110
 470              	.LBE16:
 471              	.LBE15:
 472              		.loc 1 221 7 discriminator 1 view .LVU111
 473 0030 10F5805F 		cmn	r0, #4096
 474 0034 0DD8     		bhi	.L40
 475              	.LVL26:
 476              	.L37:
ARM GAS  /tmp/cc80GKN8.s 			page 31


 222:./drivers/spi/stm32f4_spi.c ****     pr_info("can not create spi class\n");
 223:./drivers/spi/stm32f4_spi.c ****     }
 224:./drivers/spi/stm32f4_spi.c ****     struct device * spi_dev = device_create(spi_class,NULL,major,NULL,"spidev1");
 477              		.loc 1 224 5 is_stmt 1 view .LVU112
 478              		.loc 1 224 31 is_stmt 0 view .LVU113
 479 0036 0B4B     		ldr	r3, .L42
 480 0038 0093     		str	r3, [sp]
 481 003a 0023     		movs	r3, #0
 482 003c 2A46     		mov	r2, r5
 483 003e 1946     		mov	r1, r3
 484 0040 2046     		mov	r0, r4
 485 0042 FFF7FEFF 		bl	device_create
 486              	.LVL27:
 225:./drivers/spi/stm32f4_spi.c ****     if(IS_ERR(spi_dev)){
 487              		.loc 1 225 5 is_stmt 1 view .LVU114
 488              	.LBB17:
 489              	.LBI17:
  75:./include/linux/err.h **** {
 490              		.loc 3 75 33 view .LVU115
 491              	.LBB18:
 492              		.loc 3 77 2 view .LVU116
 493              		.loc 3 77 2 is_stmt 0 view .LVU117
 494              	.LBE18:
 495              	.LBE17:
 496              		.loc 1 225 7 discriminator 1 view .LVU118
 497 0046 10F5805F 		cmn	r0, #4096
 498 004a 06D8     		bhi	.L41
 499              	.LVL28:
 500              	.L38:
 226:./drivers/spi/stm32f4_spi.c ****         pr_info("can not create spi device\n");
 227:./drivers/spi/stm32f4_spi.c ****     }
 228:./drivers/spi/stm32f4_spi.c ****     return 0;
 501              		.loc 1 228 5 is_stmt 1 view .LVU119
 229:./drivers/spi/stm32f4_spi.c **** 
 230:./drivers/spi/stm32f4_spi.c ****  }
 502              		.loc 1 230 2 is_stmt 0 view .LVU120
 503 004c 0020     		movs	r0, #0
 504 004e 03B0     		add	sp, sp, #12
 505              	.LCFI4:
 506              		.cfi_remember_state
 507              		.cfi_def_cfa_offset 12
 508              		@ sp needed
 509 0050 30BD     		pop	{r4, r5, pc}
 510              	.LVL29:
 511              	.L40:
 512              	.LCFI5:
 513              		.cfi_restore_state
 222:./drivers/spi/stm32f4_spi.c ****     }
 514              		.loc 1 222 5 is_stmt 1 view .LVU121
 515 0052 0748     		ldr	r0, .L42+12
 516              	.LVL30:
 222:./drivers/spi/stm32f4_spi.c ****     }
 517              		.loc 1 222 5 is_stmt 0 view .LVU122
 518 0054 FFF7FEFF 		bl	printk
 519              	.LVL31:
 520 0058 EDE7     		b	.L37
 521              	.LVL32:
ARM GAS  /tmp/cc80GKN8.s 			page 32


 522              	.L41:
 226:./drivers/spi/stm32f4_spi.c ****         pr_info("can not create spi device\n");
 523              		.loc 1 226 9 is_stmt 1 view .LVU123
 524 005a 0648     		ldr	r0, .L42+16
 525              	.LVL33:
 226:./drivers/spi/stm32f4_spi.c ****         pr_info("can not create spi device\n");
 526              		.loc 1 226 9 is_stmt 0 view .LVU124
 527 005c FFF7FEFF 		bl	printk
 528              	.LVL34:
 529 0060 F4E7     		b	.L38
 530              	.L43:
 531 0062 00BF     		.align	2
 532              	.L42:
 533 0064 00000000 		.word	.LC1
 534 0068 00000000 		.word	spi_fops
 535 006c 08000000 		.word	.LC2
 536 0070 20000000 		.word	.LC3
 537 0074 3C000000 		.word	.LC4
 538              		.cfi_endproc
 539              	.LFE1040:
 541              		.section	.text.get_spi_speed,"ax",%progbits
 542              		.align	1
 543              		.global	get_spi_speed
 544              		.syntax unified
 545              		.thumb
 546              		.thumb_func
 548              	get_spi_speed:
 549              	.LVL35:
 550              	.LFB1035:
 104:./drivers/spi/stm32f4_spi.c ****     unsigned int pclk2 = 168000000 / 2; // 默认核心频率是168MHz
 551              		.loc 1 104 1 is_stmt 1 view -0
 552              		.cfi_startproc
 553              		@ args = 0, pretend = 0, frame = 0
 554              		@ frame_needed = 0, uses_anonymous_args = 0
 555              		@ link register save eliminated.
 105:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/2 )   return 0;
 556              		.loc 1 105 5 view .LVU126
 106:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/4 )   return 1;
 557              		.loc 1 106 5 view .LVU127
 106:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/4 )   return 1;
 558              		.loc 1 106 7 is_stmt 0 view .LVU128
 559 0000 124B     		ldr	r3, .L53
 560 0002 9842     		cmp	r0, r3
 561 0004 13D8     		bhi	.L46
 107:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/8 )   return 2;
 562              		.loc 1 107 5 is_stmt 1 view .LVU129
 107:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/8 )   return 2;
 563              		.loc 1 107 7 is_stmt 0 view .LVU130
 564 0006 124B     		ldr	r3, .L53+4
 565 0008 9842     		cmp	r0, r3
 566 000a 12D8     		bhi	.L47
 108:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/16 )  return 3;
 567              		.loc 1 108 5 is_stmt 1 view .LVU131
 108:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/16 )  return 3;
 568              		.loc 1 108 7 is_stmt 0 view .LVU132
 569 000c 114B     		ldr	r3, .L53+8
 570 000e 9842     		cmp	r0, r3
ARM GAS  /tmp/cc80GKN8.s 			page 33


 571 0010 11D2     		bcs	.L48
 109:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/32 )  return 4;
 572              		.loc 1 109 5 is_stmt 1 view .LVU133
 109:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/32 )  return 4;
 573              		.loc 1 109 7 is_stmt 0 view .LVU134
 574 0012 114B     		ldr	r3, .L53+12
 575 0014 9842     		cmp	r0, r3
 576 0016 10D8     		bhi	.L49
 110:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/64 )  return 5;
 577              		.loc 1 110 5 is_stmt 1 view .LVU135
 110:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/64 )  return 5;
 578              		.loc 1 110 7 is_stmt 0 view .LVU136
 579 0018 104B     		ldr	r3, .L53+16
 580 001a 9842     		cmp	r0, r3
 581 001c 0FD8     		bhi	.L50
 111:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/128 ) return 6;
 582              		.loc 1 111 5 is_stmt 1 view .LVU137
 111:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/128 ) return 6;
 583              		.loc 1 111 7 is_stmt 0 view .LVU138
 584 001e 104B     		ldr	r3, .L53+20
 585 0020 9842     		cmp	r0, r3
 586 0022 0ED8     		bhi	.L51
 112:./drivers/spi/stm32f4_spi.c ****     return 7;
 587              		.loc 1 112 5 is_stmt 1 view .LVU139
 112:./drivers/spi/stm32f4_spi.c ****     return 7;
 588              		.loc 1 112 7 is_stmt 0 view .LVU140
 589 0024 0F4B     		ldr	r3, .L53+24
 590 0026 9842     		cmp	r0, r3
 591 0028 0DD8     		bhi	.L52
 113:./drivers/spi/stm32f4_spi.c **** }
 592              		.loc 1 113 12 view .LVU141
 593 002a 0720     		movs	r0, #7
 594              	.LVL36:
 113:./drivers/spi/stm32f4_spi.c **** }
 595              		.loc 1 113 12 view .LVU142
 596 002c 7047     		bx	lr
 597              	.LVL37:
 598              	.L46:
 106:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/4 )   return 1;
 599              		.loc 1 106 36 discriminator 1 view .LVU143
 600 002e 0020     		movs	r0, #0
 601              	.LVL38:
 106:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/4 )   return 1;
 602              		.loc 1 106 36 discriminator 1 view .LVU144
 603 0030 7047     		bx	lr
 604              	.LVL39:
 605              	.L47:
 107:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/8 )   return 2;
 606              		.loc 1 107 36 discriminator 1 view .LVU145
 607 0032 0120     		movs	r0, #1
 608              	.LVL40:
 107:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/8 )   return 2;
 609              		.loc 1 107 36 discriminator 1 view .LVU146
 610 0034 7047     		bx	lr
 611              	.LVL41:
 612              	.L48:
 108:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/16 )  return 3;
ARM GAS  /tmp/cc80GKN8.s 			page 34


 613              		.loc 1 108 36 discriminator 1 view .LVU147
 614 0036 0220     		movs	r0, #2
 615              	.LVL42:
 108:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/16 )  return 3;
 616              		.loc 1 108 36 discriminator 1 view .LVU148
 617 0038 7047     		bx	lr
 618              	.LVL43:
 619              	.L49:
 109:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/32 )  return 4;
 620              		.loc 1 109 36 discriminator 1 view .LVU149
 621 003a 0320     		movs	r0, #3
 622              	.LVL44:
 109:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/32 )  return 4;
 623              		.loc 1 109 36 discriminator 1 view .LVU150
 624 003c 7047     		bx	lr
 625              	.LVL45:
 626              	.L50:
 110:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/64 )  return 5;
 627              		.loc 1 110 36 discriminator 1 view .LVU151
 628 003e 0420     		movs	r0, #4
 629              	.LVL46:
 110:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/64 )  return 5;
 630              		.loc 1 110 36 discriminator 1 view .LVU152
 631 0040 7047     		bx	lr
 632              	.LVL47:
 633              	.L51:
 111:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/128 ) return 6;
 634              		.loc 1 111 36 discriminator 1 view .LVU153
 635 0042 0520     		movs	r0, #5
 636              	.LVL48:
 111:./drivers/spi/stm32f4_spi.c ****     if(speed >= pclk2/128 ) return 6;
 637              		.loc 1 111 36 discriminator 1 view .LVU154
 638 0044 7047     		bx	lr
 639              	.LVL49:
 640              	.L52:
 112:./drivers/spi/stm32f4_spi.c ****     return 7;
 641              		.loc 1 112 36 discriminator 1 view .LVU155
 642 0046 0620     		movs	r0, #6
 643              	.LVL50:
 114:./drivers/spi/stm32f4_spi.c **** 
 644              		.loc 1 114 1 view .LVU156
 645 0048 7047     		bx	lr
 646              	.L54:
 647 004a 00BF     		.align	2
 648              	.L53:
 649 004c 7FDE8002 		.word	41999999
 650 0050 3F6F4001 		.word	20999999
 651 0054 A037A000 		.word	10500000
 652 0058 CF1B5000 		.word	5249999
 653 005c E70D2800 		.word	2624999
 654 0060 F3061400 		.word	1312499
 655 0064 79030A00 		.word	656249
 656              		.cfi_endproc
 657              	.LFE1035:
 659              		.section	.rodata.spi_unlocked_ioctl.str1.4,"aMS",%progbits,1
 660              		.align	2
 661              	.LC5:
ARM GAS  /tmp/cc80GKN8.s 			page 35


 662 0000 61726720 		.ascii	"arg is null\000"
 662      6973206E 
 662      756C6C00 
 663              		.section	.text.spi_unlocked_ioctl,"ax",%progbits
 664              		.align	1
 665              		.global	spi_unlocked_ioctl
 666              		.syntax unified
 667              		.thumb
 668              		.thumb_func
 670              	spi_unlocked_ioctl:
 671              	.LVL51:
 672              	.LFB1039:
 188:./drivers/spi/stm32f4_spi.c ****     if (arg==NULL){
 673              		.loc 1 188 1 is_stmt 1 view -0
 674              		.cfi_startproc
 675              		@ args = 0, pretend = 0, frame = 0
 676              		@ frame_needed = 0, uses_anonymous_args = 0
 188:./drivers/spi/stm32f4_spi.c ****     if (arg==NULL){
 677              		.loc 1 188 1 is_stmt 0 view .LVU158
 678 0000 10B5     		push	{r4, lr}
 679              	.LCFI6:
 680              		.cfi_def_cfa_offset 8
 681              		.cfi_offset 4, -8
 682              		.cfi_offset 14, -4
 189:./drivers/spi/stm32f4_spi.c ****         printk("arg is null");
 683              		.loc 1 189 5 is_stmt 1 view .LVU159
 189:./drivers/spi/stm32f4_spi.c ****         printk("arg is null");
 684              		.loc 1 189 8 is_stmt 0 view .LVU160
 685 0002 72B1     		cbz	r2, .L60
 686 0004 1446     		mov	r4, r2
 193:./drivers/spi/stm32f4_spi.c ****     switch(cmd)
 687              		.loc 1 193 5 is_stmt 1 view .LVU161
 688              	.LVL52:
 194:./drivers/spi/stm32f4_spi.c ****     {
 689              		.loc 1 194 5 view .LVU162
 690 0006 0129     		cmp	r1, #1
 691 0008 11D1     		bne	.L58
 198:./drivers/spi/stm32f4_spi.c ****             return spi_device_swap(spi->tx_buf, spi->rx_buf, spi->len);
 692              		.loc 1 198 13 view .LVU163
 198:./drivers/spi/stm32f4_spi.c ****             return spi_device_swap(spi->tx_buf, spi->rx_buf, spi->len);
 693              		.loc 1 198 27 is_stmt 0 view .LVU164
 694 000a D068     		ldr	r0, [r2, #12]	@ unaligned
 695              	.LVL53:
 198:./drivers/spi/stm32f4_spi.c ****             return spi_device_swap(spi->tx_buf, spi->rx_buf, spi->len);
 696              		.loc 1 198 27 view .LVU165
 697 000c FFF7FEFF 		bl	get_spi_speed
 698              	.LVL54:
 198:./drivers/spi/stm32f4_spi.c ****             return spi_device_swap(spi->tx_buf, spi->rx_buf, spi->len);
 699              		.loc 1 198 13 discriminator 1 view .LVU166
 700 0010 C0B2     		uxtb	r0, r0
 701 0012 FFF7FEFF 		bl	SPI1_SetSpeed
 702              	.LVL55:
 199:./drivers/spi/stm32f4_spi.c ****         default:
 703              		.loc 1 199 13 is_stmt 1 view .LVU167
 199:./drivers/spi/stm32f4_spi.c ****         default:
 704              		.loc 1 199 20 is_stmt 0 view .LVU168
 705 0016 A268     		ldr	r2, [r4, #8]	@ unaligned
ARM GAS  /tmp/cc80GKN8.s 			page 36


 706 0018 6168     		ldr	r1, [r4, #4]	@ unaligned
 707 001a 2068     		ldr	r0, [r4]	@ unaligned
 708 001c FFF7FEFF 		bl	spi_device_swap
 709              	.LVL56:
 710              	.L55:
 204:./drivers/spi/stm32f4_spi.c **** 
 711              		.loc 1 204 1 view .LVU169
 712 0020 10BD     		pop	{r4, pc}
 713              	.LVL57:
 714              	.L60:
 190:./drivers/spi/stm32f4_spi.c ****         return -EINVAL;
 715              		.loc 1 190 9 is_stmt 1 view .LVU170
 716 0022 0448     		ldr	r0, .L61
 717              	.LVL58:
 190:./drivers/spi/stm32f4_spi.c ****         return -EINVAL;
 718              		.loc 1 190 9 is_stmt 0 view .LVU171
 719 0024 FFF7FEFF 		bl	printk
 720              	.LVL59:
 191:./drivers/spi/stm32f4_spi.c ****     } 
 721              		.loc 1 191 9 is_stmt 1 view .LVU172
 191:./drivers/spi/stm32f4_spi.c ****     } 
 722              		.loc 1 191 16 is_stmt 0 view .LVU173
 723 0028 6FF01500 		mvn	r0, #21
 724 002c F8E7     		b	.L55
 725              	.LVL60:
 726              	.L58:
 201:./drivers/spi/stm32f4_spi.c ****     }
 727              		.loc 1 201 20 view .LVU174
 728 002e 6FF01500 		mvn	r0, #21
 729              	.LVL61:
 201:./drivers/spi/stm32f4_spi.c ****     }
 730              		.loc 1 201 20 view .LVU175
 731 0032 F5E7     		b	.L55
 732              	.L62:
 733              		.align	2
 734              	.L61:
 735 0034 00000000 		.word	.LC5
 736              		.cfi_endproc
 737              	.LFE1039:
 739              		.section	.deviceinitcall,"aw"
 740              		.align	2
 743              	_initcall_spi1_device_init:
 744 0000 00000000 		.word	spi1_device_init
 745              		.section	.data.spi_fops,"aw"
 746              		.align	2
 749              	spi_fops:
 750 0000 00000000 		.word	0
 751 0004 00000000 		.space	36
 751      00000000 
 751      00000000 
 751      00000000 
 751      00000000 
 752 0028 00000000 		.word	spi_unlocked_ioctl
 753 002c 00000000 		.space	8
 753      00000000 
 754 0034 00000000 		.word	spi_dev_open
 755 0038 00000000 		.space	80
ARM GAS  /tmp/cc80GKN8.s 			page 37


 755      00000000 
 755      00000000 
 755      00000000 
 755      00000000 
 756              		.text
 757              	.Letext0:
 758              		.file 4 "./include/asm-generic/int-l64.h"
 759              		.file 5 "./include/asm-generic/posix_types.h"
 760              		.file 6 "./include/uapi/linux/types.h"
 761              		.file 7 "./include/linux/types.h"
 762              		.file 8 "./include/linux/init.h"
 763              		.file 9 "./include/linux/errseq.h"
 764              		.file 10 "./include/linux/time64.h"
 765              		.file 11 "./arch/arm_m/include/asm/spinlock.h"
 766              		.file 12 "./include/linux/spinlock_types_raw.h"
 767              		.file 13 "./include/linux/spinlock_types.h"
 768              		.file 14 "./include/linux/rbtree_types.h"
 769              		.file 15 "./include/linux/uidgid_types.h"
 770              		.file 16 "./include/linux/projid.h"
 771              		.file 17 "./include/linux/mnt_idmapping.h"
 772              		.file 18 "./include/linux/mutex.h"
 773              		.file 19 "./include/linux/uio.h"
 774              		.file 20 "./include/linux/wait.h"
 775              		.file 21 "./include/linux/xarray.h"
 776              		.file 22 "./include/linux/migrate_mode.h"
 777              		.file 23 "./include/linux/rw_hint.h"
 778              		.file 24 "./include/linux/reciprocal_div.h"
 779              		.file 25 "./include/linux/slab.h"
 780              		.file 26 "./include/linux/mm_type.h"
 781              		.file 27 "./include/linux/bvec.h"
 782              		.file 28 "./include/linux/blk_types.h"
 783              		.file 29 "./include/linux/blkdev.h"
 784              		.file 30 "./include/linux/bio.h"
 785              		.file 31 "./include/linux/mempool_super_haper.h"
 786              		.file 32 "./include/linux/mempool.h"
 787              		.file 33 "./include/linux/lockdep_types.h"
 788              		.file 34 "./include/linux/workqueue_types.h"
 789              		.file 35 "./include/linux/blk-mq.h"
 790              		.file 36 "./include/linux/dcache.h"
 791              		.file 37 "./include/uapi/linux/pr.h"
 792              		.file 38 "./include/linux/pr.h"
 793              		.file 39 "./include/linux/hdreg.h"
 794              		.file 40 "./include/linux/lockref.h"
 795              		.file 41 "./include/linux/path.h"
 796              		.file 42 "./include/linux/statfs.h"
 797              		.file 43 "./include/linux/stat.h"
 798              		.file 44 "./include/linux/spi/spi.h"
 799              		.file 45 "./include/linux/device.h"
 800              		.file 46 "./include/linux/printk.h"
ARM GAS  /tmp/cc80GKN8.s 			page 38


DEFINED SYMBOLS
                            *ABS*:00000000 stm32f4_spi.c
     /tmp/cc80GKN8.s:21     .text.SPI1_Init:00000000 $t
     /tmp/cc80GKN8.s:26     .text.SPI1_Init:00000000 SPI1_Init
     /tmp/cc80GKN8.s:130    .text.SPI1_Init:000000a4 $d
     /tmp/cc80GKN8.s:137    .text.SPI1_SetSpeed:00000000 $t
     /tmp/cc80GKN8.s:142    .text.SPI1_SetSpeed:00000000 SPI1_SetSpeed
     /tmp/cc80GKN8.s:166    .text.SPI1_SetSpeed:00000014 $d
     /tmp/cc80GKN8.s:171    .text.SPI1_ReadWriteByte:00000000 $t
     /tmp/cc80GKN8.s:176    .text.SPI1_ReadWriteByte:00000000 SPI1_ReadWriteByte
     /tmp/cc80GKN8.s:216    .text.SPI1_ReadWriteByte:00000020 $d
     /tmp/cc80GKN8.s:221    .text.spi_device_swap:00000000 $t
     /tmp/cc80GKN8.s:226    .text.spi_device_swap:00000000 spi_device_swap
     /tmp/cc80GKN8.s:349    .rodata.spi_dev_open.str1.4:00000000 $d
     /tmp/cc80GKN8.s:353    .text.spi_dev_open:00000000 $t
     /tmp/cc80GKN8.s:358    .text.spi_dev_open:00000000 spi_dev_open
     /tmp/cc80GKN8.s:384    .text.spi_dev_open:0000000c $d
     /tmp/cc80GKN8.s:389    .rodata.spi1_device_init.str1.4:00000000 $d
     /tmp/cc80GKN8.s:402    .text.spi1_device_init:00000000 $t
     /tmp/cc80GKN8.s:407    .text.spi1_device_init:00000000 spi1_device_init
     /tmp/cc80GKN8.s:533    .text.spi1_device_init:00000064 $d
     /tmp/cc80GKN8.s:749    .data.spi_fops:00000000 spi_fops
     /tmp/cc80GKN8.s:542    .text.get_spi_speed:00000000 $t
     /tmp/cc80GKN8.s:548    .text.get_spi_speed:00000000 get_spi_speed
     /tmp/cc80GKN8.s:649    .text.get_spi_speed:0000004c $d
     /tmp/cc80GKN8.s:660    .rodata.spi_unlocked_ioctl.str1.4:00000000 $d
     /tmp/cc80GKN8.s:664    .text.spi_unlocked_ioctl:00000000 $t
     /tmp/cc80GKN8.s:670    .text.spi_unlocked_ioctl:00000000 spi_unlocked_ioctl
     /tmp/cc80GKN8.s:735    .text.spi_unlocked_ioctl:00000034 $d
     /tmp/cc80GKN8.s:740    .deviceinitcall:00000000 $d
     /tmp/cc80GKN8.s:743    .deviceinitcall:00000000 _initcall_spi1_device_init
     /tmp/cc80GKN8.s:746    .data.spi_fops:00000000 $d

UNDEFINED SYMBOLS
printk
__register_chrdev
class_create
device_create
