ARM GAS  /tmp/ccZE4dRO.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"char_device.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./fs/char_device.c"
  20              		.section	.text.sized_strscpy,"ax",%progbits
  21              		.align	1
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	sized_strscpy:
  27              	.LVL0:
  28              	.LFB244:
  29              		.file 2 "./include/linux/string.h"
   1:./include/linux/string.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/string.h **** #ifndef _LINUX_STRING_H_
   3:./include/linux/string.h **** #define _LINUX_STRING_H_ 
   4:./include/linux/string.h **** 
   5:./include/linux/string.h **** #include <linux/args.h>
   6:./include/linux/string.h **** #include <linux/array_size.h>
   7:./include/linux/string.h **** #include <linux/compiler.h>	/* for inline */
   8:./include/linux/string.h **** #include <linux/types.h>	/* for size_t */
   9:./include/linux/string.h **** #include <linux/stddef.h>	/* for NULL */
  10:./include/linux/string.h **** #include <linux/err.h>		/* for ERR_PTR() */
  11:./include/linux/string.h **** #include <linux/errno.h>	/* for E2BIG */
  12:./include/linux/string.h **** #include <linux/overflow.h>	/* for check_mul_overflow() */
  13:./include/linux/string.h **** #include <linux/stdarg.h>
  14:./include/linux/string.h **** #include <uapi/linux/string.h>
  15:./include/linux/string.h **** 
  16:./include/linux/string.h **** 
  17:./include/linux/string.h **** extern char *strndup_user(const char __user *, long);
  18:./include/linux/string.h **** extern void *memdup_user(const void __user *, size_t) __realloc_size(2);
  19:./include/linux/string.h **** extern void *vmemdup_user(const void __user *, size_t) __realloc_size(2);
  20:./include/linux/string.h **** extern void *memdup_user_nul(const void __user *, size_t);
  21:./include/linux/string.h **** 
  22:./include/linux/string.h **** 
  23:./include/linux/string.h **** 
  24:./include/linux/string.h **** static ssize_t sized_strscpy(char *dest, const char *src, size_t slen) {
  30              		.loc 2 24 72 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		@ link register save eliminated.
ARM GAS  /tmp/ccZE4dRO.s 			page 2


  35              		.loc 2 24 72 is_stmt 0 view .LVU1
  36 0000 10B4     		push	{r4}
  37              	.LCFI0:
  38              		.cfi_def_cfa_offset 4
  39              		.cfi_offset 4, -4
  25:./include/linux/string.h ****     size_t i;
  40              		.loc 2 25 5 is_stmt 1 view .LVU2
  26:./include/linux/string.h **** 
  27:./include/linux/string.h ****     for (i = 0;  i < slen && src[i] != '\0'; i++) {
  41              		.loc 2 27 5 view .LVU3
  42              	.LVL1:
  43              		.loc 2 27 12 is_stmt 0 view .LVU4
  44 0002 0023     		movs	r3, #0
  45              		.loc 2 27 5 view .LVU5
  46 0004 01E0     		b	.L2
  47              	.LVL2:
  48              	.L4:
  28:./include/linux/string.h ****         dest[i] = src[i];
  49              		.loc 2 28 9 is_stmt 1 view .LVU6
  50              		.loc 2 28 17 is_stmt 0 view .LVU7
  51 0006 C454     		strb	r4, [r0, r3]
  27:./include/linux/string.h ****         dest[i] = src[i];
  52              		.loc 2 27 47 is_stmt 1 discriminator 4 view .LVU8
  53 0008 0133     		adds	r3, r3, #1
  54              	.LVL3:
  55              	.L2:
  27:./include/linux/string.h ****         dest[i] = src[i];
  56              		.loc 2 27 27 discriminator 1 view .LVU9
  57 000a 9342     		cmp	r3, r2
  58 000c 02D2     		bcs	.L3
  27:./include/linux/string.h ****         dest[i] = src[i];
  59              		.loc 2 27 33 is_stmt 0 discriminator 3 view .LVU10
  60 000e CC5C     		ldrb	r4, [r1, r3]	@ zero_extendqisi2
  27:./include/linux/string.h ****         dest[i] = src[i];
  61              		.loc 2 27 27 discriminator 3 view .LVU11
  62 0010 002C     		cmp	r4, #0
  63 0012 F8D1     		bne	.L4
  64              	.L3:
  29:./include/linux/string.h ****     }
  30:./include/linux/string.h ****     dest[i] = '\0';  
  65              		.loc 2 30 5 is_stmt 1 view .LVU12
  66              		.loc 2 30 13 is_stmt 0 view .LVU13
  67 0014 0024     		movs	r4, #0
  68 0016 C454     		strb	r4, [r0, r3]
  31:./include/linux/string.h ****     if (i == slen || src[i] == '\0') {
  69              		.loc 2 31 5 is_stmt 1 view .LVU14
  70              		.loc 2 31 8 is_stmt 0 view .LVU15
  71 0018 9342     		cmp	r3, r2
  72 001a 01D0     		beq	.L5
  73              		.loc 2 31 25 discriminator 1 view .LVU16
  74 001c CA5C     		ldrb	r2, [r1, r3]	@ zero_extendqisi2
  75              	.LVL4:
  76              		.loc 2 31 19 discriminator 1 view .LVU17
  77 001e 1AB9     		cbnz	r2, .L7
  78              	.L5:
  32:./include/linux/string.h ****         return i; 
  79              		.loc 2 32 9 is_stmt 1 view .LVU18
ARM GAS  /tmp/ccZE4dRO.s 			page 3


  80              		.loc 2 32 16 is_stmt 0 view .LVU19
  81 0020 1846     		mov	r0, r3
  82              	.LVL5:
  83              	.L1:
  33:./include/linux/string.h ****     }
  34:./include/linux/string.h ****     return -1;
  35:./include/linux/string.h **** }
  84              		.loc 2 35 1 view .LVU20
  85 0022 5DF8044B 		ldr	r4, [sp], #4
  86              	.LCFI1:
  87              		.cfi_remember_state
  88              		.cfi_restore 4
  89              		.cfi_def_cfa_offset 0
  90 0026 7047     		bx	lr
  91              	.LVL6:
  92              	.L7:
  93              	.LCFI2:
  94              		.cfi_restore_state
  34:./include/linux/string.h **** }
  95              		.loc 2 34 12 view .LVU21
  96 0028 4FF0FF30 		mov	r0, #-1
  97              	.LVL7:
  34:./include/linux/string.h **** }
  98              		.loc 2 34 12 view .LVU22
  99 002c F9E7     		b	.L1
 100              		.cfi_endproc
 101              	.LFE244:
 103              		.section	.text.find_dynamic_major,"ax",%progbits
 104              		.align	1
 105              		.syntax unified
 106              		.thumb
 107              		.thumb_func
 109              	find_dynamic_major:
 110              	.LFB1036:
   1:./fs/char_device.c **** #include <linux/kernel.h>
   2:./fs/char_device.c **** #include <linux/list.h>
   3:./fs/char_device.c **** #include <linux/fs.h>
   4:./fs/char_device.c **** #include <linux/slab.h>
   5:./fs/char_device.c **** #include <linux/init.h>
   6:./fs/char_device.c **** #include <linux/fs.h>
   7:./fs/char_device.c **** #include <linux/kdev_t.h>
   8:./fs/char_device.c **** #include <linux/slab.h>
   9:./fs/char_device.c **** #include <linux/string.h>
  10:./fs/char_device.c **** #include <linux/cdev.h>
  11:./fs/char_device.c **** #include <linux/major.h>
  12:./fs/char_device.c **** #include <linux/errno.h>
  13:./fs/char_device.c **** #include <linux/module.h>
  14:./fs/char_device.c **** #include <linux/mutex.h>
  15:./fs/char_device.c **** 
  16:./fs/char_device.c **** 
  17:./fs/char_device.c **** #define CHRDEV_MAJOR_HASH_SIZE 127
  18:./fs/char_device.c **** 
  19:./fs/char_device.c **** static DEFINE_MUTEX(chrdevs_lock);
  20:./fs/char_device.c **** 
  21:./fs/char_device.c **** static struct char_device_struct 
  22:./fs/char_device.c **** {
  23:./fs/char_device.c ****     struct char_device_struct *next; 
ARM GAS  /tmp/ccZE4dRO.s 			page 4


  24:./fs/char_device.c ****     unsigned int major; 
  25:./fs/char_device.c ****     unsigned int baseminor; 
  26:./fs/char_device.c ****     int minorct;
  27:./fs/char_device.c ****     char name[64]; 
  28:./fs/char_device.c ****     struct cdev *cdev; /* will die */ 
  29:./fs/char_device.c **** } *chrdevs[CHRDEV_MAJOR_HASH_SIZE];
  30:./fs/char_device.c **** 
  31:./fs/char_device.c **** //static struct char_device_struct *chrdevs[CHRDEV_MAJOR_HASH_SIZE];
  32:./fs/char_device.c **** 
  33:./fs/char_device.c **** static inline int major_to_index(unsigned major)
  34:./fs/char_device.c **** {
  35:./fs/char_device.c **** 	return major % CHRDEV_MAJOR_HASH_SIZE;
  36:./fs/char_device.c **** }
  37:./fs/char_device.c **** 
  38:./fs/char_device.c **** 
  39:./fs/char_device.c **** static int find_dynamic_major(void)
  40:./fs/char_device.c **** {
 111              		.loc 1 40 1 is_stmt 1 view -0
 112              		.cfi_startproc
 113              		@ args = 0, pretend = 0, frame = 0
 114              		@ frame_needed = 0, uses_anonymous_args = 0
 115              		@ link register save eliminated.
  41:./fs/char_device.c **** 	int i;
 116              		.loc 1 41 2 view .LVU24
  42:./fs/char_device.c **** 	struct char_device_struct *cd;
 117              		.loc 1 42 2 view .LVU25
  43:./fs/char_device.c **** 
  44:./fs/char_device.c **** 	for (i = ARRAY_SIZE(chrdevs)-1; i >= CHRDEV_MAJOR_DYN_END; i--) {
 118              		.loc 1 44 2 view .LVU26
 119              	.LVL8:
 120              	.LBB67:
 121              		.loc 1 44 36 discriminator 1 view .LVU27
 122              	.LBE67:
  45:./fs/char_device.c **** 		if (chrdevs[i] == NULL)
  46:./fs/char_device.c **** 			return i;
  47:./fs/char_device.c **** 	}
  48:./fs/char_device.c **** 
  49:./fs/char_device.c **** 	for (i = CHRDEV_MAJOR_DYN_EXT_START;
 123              		.loc 1 49 2 view .LVU28
 124              		.loc 1 49 9 is_stmt 0 view .LVU29
 125 0000 40F2FF10 		movw	r0, #511
 126              	.LVL9:
 127              	.L10:
  50:./fs/char_device.c **** 	     i >= CHRDEV_MAJOR_DYN_EXT_END; i--) {
 128              		.loc 1 50 9 is_stmt 1 discriminator 1 view .LVU30
 129 0004 B0F5C07F 		cmp	r0, #384
 130 0008 16DB     		blt	.L16
  51:./fs/char_device.c **** 		for (cd = chrdevs[major_to_index(i)]; cd; cd = cd->next)
 131              		.loc 1 51 3 view .LVU31
 132              		.loc 1 51 21 is_stmt 0 view .LVU32
 133 000a 0146     		mov	r1, r0
 134              	.LVL10:
 135              	.LBB68:
 136              	.LBI68:
  33:./fs/char_device.c **** {
 137              		.loc 1 33 19 is_stmt 1 view .LVU33
 138              	.LBB69:
ARM GAS  /tmp/ccZE4dRO.s 			page 5


  35:./fs/char_device.c **** }
 139              		.loc 1 35 2 view .LVU34
  35:./fs/char_device.c **** }
 140              		.loc 1 35 15 is_stmt 0 view .LVU35
 141 000c 0C4B     		ldr	r3, .L18
 142 000e A3FB0023 		umull	r2, r3, r3, r0
 143 0012 C21A     		subs	r2, r0, r3
 144 0014 03EB5203 		add	r3, r3, r2, lsr #1
 145 0018 9B09     		lsrs	r3, r3, #6
 146 001a C3EBC313 		rsb	r3, r3, r3, lsl #7
 147 001e C31A     		subs	r3, r0, r3
 148              	.LVL11:
  35:./fs/char_device.c **** }
 149              		.loc 1 35 15 view .LVU36
 150              	.LBE69:
 151              	.LBE68:
 152              		.loc 1 51 11 discriminator 1 view .LVU37
 153 0020 084A     		ldr	r2, .L18+4
 154 0022 52F82330 		ldr	r3, [r2, r3, lsl #2]
 155              	.LVL12:
 156              	.L11:
 157              		.loc 1 51 41 is_stmt 1 discriminator 1 view .LVU38
 158 0026 23B1     		cbz	r3, .L17
  52:./fs/char_device.c **** 			if (cd->major == i)
 159              		.loc 1 52 4 view .LVU39
 160              		.loc 1 52 10 is_stmt 0 view .LVU40
 161 0028 5A68     		ldr	r2, [r3, #4]
 162              		.loc 1 52 7 view .LVU41
 163 002a 9142     		cmp	r1, r2
 164 002c 02D0     		beq	.L12
  51:./fs/char_device.c **** 			if (cd->major == i)
 165              		.loc 1 51 48 is_stmt 1 discriminator 2 view .LVU42
 166 002e 1B68     		ldr	r3, [r3]
 167              	.LVL13:
  51:./fs/char_device.c **** 			if (cd->major == i)
 168              		.loc 1 51 48 is_stmt 0 discriminator 2 view .LVU43
 169 0030 F9E7     		b	.L11
 170              	.L17:
  51:./fs/char_device.c **** 			if (cd->major == i)
 171              		.loc 1 51 48 discriminator 2 view .LVU44
 172 0032 7047     		bx	lr
 173              	.L12:
  53:./fs/char_device.c **** 				break;
  54:./fs/char_device.c **** 
  55:./fs/char_device.c **** 		if (cd == NULL)
 174              		.loc 1 55 3 is_stmt 1 view .LVU45
  50:./fs/char_device.c **** 		for (cd = chrdevs[major_to_index(i)]; cd; cd = cd->next)
 175              		.loc 1 50 39 view .LVU46
 176 0034 0138     		subs	r0, r0, #1
 177              	.LVL14:
  50:./fs/char_device.c **** 		for (cd = chrdevs[major_to_index(i)]; cd; cd = cd->next)
 178              		.loc 1 50 39 is_stmt 0 view .LVU47
 179 0036 E5E7     		b	.L10
 180              	.LVL15:
 181              	.L16:
  56:./fs/char_device.c **** 			return i;
  57:./fs/char_device.c **** 	}
ARM GAS  /tmp/ccZE4dRO.s 			page 6


  58:./fs/char_device.c **** 
  59:./fs/char_device.c **** 	return -EBUSY;
 182              		.loc 1 59 9 view .LVU48
 183 0038 6FF00F00 		mvn	r0, #15
 184              	.LVL16:
  60:./fs/char_device.c **** }
 185              		.loc 1 60 1 view .LVU49
 186 003c 7047     		bx	lr
 187              	.L19:
 188 003e 00BF     		.align	2
 189              	.L18:
 190 0040 11080402 		.word	33818641
 191 0044 00000000 		.word	chrdevs
 192              		.cfi_endproc
 193              	.LFE1036:
 195              		.section	.text.__unregister_chrdev_region,"ax",%progbits
 196              		.align	1
 197              		.syntax unified
 198              		.thumb
 199              		.thumb_func
 201              	__unregister_chrdev_region:
 202              	.LVL17:
 203              	.LFB1038:
  61:./fs/char_device.c **** 
  62:./fs/char_device.c **** 
  63:./fs/char_device.c **** 
  64:./fs/char_device.c **** static struct char_device_struct *
  65:./fs/char_device.c **** __register_chrdev_region(unsigned int major, unsigned int baseminor,
  66:./fs/char_device.c **** 			   int minorct, const char *name)
  67:./fs/char_device.c **** {
  68:./fs/char_device.c **** 	struct char_device_struct *cd, *curr, *prev = NULL;
  69:./fs/char_device.c **** 	int ret;
  70:./fs/char_device.c **** 	int i;
  71:./fs/char_device.c **** 
  72:./fs/char_device.c **** 	if (major >= CHRDEV_MAJOR_MAX) {
  73:./fs/char_device.c **** 		pr_err("CHRDEV \"%s\" major requested (%u) is greater than the maximum (%u)\n",
  74:./fs/char_device.c **** 		       name, major, CHRDEV_MAJOR_MAX-1);
  75:./fs/char_device.c **** 		return ERR_PTR(-EINVAL);
  76:./fs/char_device.c **** 	}
  77:./fs/char_device.c **** 
  78:./fs/char_device.c **** 	if (minorct > MINORMASK + 1 - baseminor) {
  79:./fs/char_device.c **** 		pr_err("CHRDEV \"%s\" minor range requested (%u-%u) is out of range of maximum range (%u-%u) for 
  80:./fs/char_device.c **** 			name, baseminor, baseminor + minorct - 1, 0, MINORMASK);
  81:./fs/char_device.c **** 		return ERR_PTR(-EINVAL);
  82:./fs/char_device.c **** 	}
  83:./fs/char_device.c **** 
  84:./fs/char_device.c **** 	cd = kzalloc(sizeof(struct char_device_struct), GFP_KERNEL);
  85:./fs/char_device.c **** 	if (cd == NULL)
  86:./fs/char_device.c **** 		return ERR_PTR(-ENOMEM);
  87:./fs/char_device.c **** 
  88:./fs/char_device.c **** 	mutex_lock(&chrdevs_lock);
  89:./fs/char_device.c **** 
  90:./fs/char_device.c **** 	if (major == 0) {
  91:./fs/char_device.c **** 		ret = find_dynamic_major();
  92:./fs/char_device.c **** 		if (ret < 0) {
  93:./fs/char_device.c **** 			pr_err("CHRDEV \"%s\" dynamic allocation region is full\n",
  94:./fs/char_device.c **** 			       name);
ARM GAS  /tmp/ccZE4dRO.s 			page 7


  95:./fs/char_device.c **** 			goto out;
  96:./fs/char_device.c **** 		}
  97:./fs/char_device.c **** 		major = ret;
  98:./fs/char_device.c **** 	}
  99:./fs/char_device.c **** 
 100:./fs/char_device.c **** 	ret = -EBUSY;
 101:./fs/char_device.c **** 	i = major_to_index(major);
 102:./fs/char_device.c **** 	for (curr = chrdevs[i]; curr; prev = curr, curr = curr->next) {
 103:./fs/char_device.c **** 		if (curr->major < major)
 104:./fs/char_device.c **** 			continue;
 105:./fs/char_device.c **** 
 106:./fs/char_device.c **** 		if (curr->major > major)
 107:./fs/char_device.c **** 			break;
 108:./fs/char_device.c **** 
 109:./fs/char_device.c **** 		if (curr->baseminor + curr->minorct <= baseminor)
 110:./fs/char_device.c **** 			continue;
 111:./fs/char_device.c **** 
 112:./fs/char_device.c **** 		if (curr->baseminor >= baseminor + minorct)
 113:./fs/char_device.c **** 			break;
 114:./fs/char_device.c **** 
 115:./fs/char_device.c **** 		goto out;
 116:./fs/char_device.c **** 	}
 117:./fs/char_device.c **** 
 118:./fs/char_device.c **** 	cd->major = major;
 119:./fs/char_device.c **** 	cd->baseminor = baseminor;
 120:./fs/char_device.c **** 	cd->minorct = minorct;
 121:./fs/char_device.c **** 	strscpy(cd->name, name, sizeof(cd->name));
 122:./fs/char_device.c **** 
 123:./fs/char_device.c **** 	if (!prev) {
 124:./fs/char_device.c **** 		cd->next = curr;
 125:./fs/char_device.c **** 		chrdevs[i] = cd;
 126:./fs/char_device.c **** 	} else {
 127:./fs/char_device.c **** 		cd->next = prev->next;
 128:./fs/char_device.c **** 		prev->next = cd;
 129:./fs/char_device.c **** 	}
 130:./fs/char_device.c **** 
 131:./fs/char_device.c **** 	mutex_unlock(&chrdevs_lock);
 132:./fs/char_device.c **** 	return cd;
 133:./fs/char_device.c **** out:
 134:./fs/char_device.c **** 	mutex_unlock(&chrdevs_lock);
 135:./fs/char_device.c **** 	kfree(cd);
 136:./fs/char_device.c **** 	return ERR_PTR(ret);
 137:./fs/char_device.c **** }
 138:./fs/char_device.c **** 
 139:./fs/char_device.c **** 
 140:./fs/char_device.c **** static struct char_device_struct *
 141:./fs/char_device.c **** __unregister_chrdev_region(unsigned major, unsigned baseminor, int minorct)
 142:./fs/char_device.c **** {
 204              		.loc 1 142 1 is_stmt 1 view -0
 205              		.cfi_startproc
 206              		@ args = 0, pretend = 0, frame = 0
 207              		@ frame_needed = 0, uses_anonymous_args = 0
 208              		@ link register save eliminated.
 209              		.loc 1 142 1 is_stmt 0 view .LVU51
 210 0000 8446     		mov	ip, r0
 143:./fs/char_device.c **** 	struct char_device_struct *cd = NULL, **cp;
 211              		.loc 1 143 2 is_stmt 1 view .LVU52
ARM GAS  /tmp/ccZE4dRO.s 			page 8


 212              	.LVL18:
 144:./fs/char_device.c **** 	int i = major_to_index(major);
 213              		.loc 1 144 2 view .LVU53
 214              	.LBB70:
 215              	.LBI70:
  33:./fs/char_device.c **** {
 216              		.loc 1 33 19 view .LVU54
 217              	.LBB71:
  35:./fs/char_device.c **** }
 218              		.loc 1 35 2 view .LVU55
  35:./fs/char_device.c **** }
 219              		.loc 1 35 15 is_stmt 0 view .LVU56
 220 0002 1548     		ldr	r0, .L33
 221              	.LVL19:
  35:./fs/char_device.c **** }
 222              		.loc 1 35 15 view .LVU57
 223 0004 A0FB0C30 		umull	r3, r0, r0, ip
 224 0008 ACEB0003 		sub	r3, ip, r0
 225 000c 00EB5300 		add	r0, r0, r3, lsr #1
 226 0010 8009     		lsrs	r0, r0, #6
 227 0012 C0EBC010 		rsb	r0, r0, r0, lsl #7
 228 0016 ACEB0000 		sub	r0, ip, r0
 229              	.LVL20:
  35:./fs/char_device.c **** }
 230              		.loc 1 35 15 view .LVU58
 231              	.LBE71:
 232              	.LBE70:
 145:./fs/char_device.c **** 
 146:./fs/char_device.c **** 	mutex_lock(&chrdevs_lock);
 233              		.loc 1 146 2 is_stmt 1 view .LVU59
 147:./fs/char_device.c **** 	for (cp = &chrdevs[i]; *cp; cp = &(*cp)->next)
 234              		.loc 1 147 2 view .LVU60
 235              		.loc 1 147 10 is_stmt 0 view .LVU61
 236 001a 104B     		ldr	r3, .L33+4
 237 001c 03EB8003 		add	r3, r3, r0, lsl #2
 238              	.LVL21:
 239              		.loc 1 147 25 is_stmt 1 discriminator 1 view .LVU62
 240 0020 1868     		ldr	r0, [r3]
 241              	.LVL22:
 242              		.loc 1 147 25 is_stmt 0 discriminator 1 view .LVU63
 243 0022 98B1     		cbz	r0, .L32
 142:./fs/char_device.c **** 	struct char_device_struct *cd = NULL, **cp;
 244              		.loc 1 142 1 view .LVU64
 245 0024 10B4     		push	{r4}
 246              	.LCFI3:
 247              		.cfi_def_cfa_offset 4
 248              		.cfi_offset 4, -4
 249 0026 02E0     		b	.L24
 250              	.L22:
 251              		.loc 1 147 33 is_stmt 1 discriminator 2 view .LVU65
 252 0028 0346     		mov	r3, r0
 253              	.LVL23:
 254              		.loc 1 147 25 discriminator 1 view .LVU66
 255 002a 0068     		ldr	r0, [r0]
 256 002c 40B1     		cbz	r0, .L23
 257              	.L24:
 148:./fs/char_device.c **** 		if ((*cp)->major == major &&
ARM GAS  /tmp/ccZE4dRO.s 			page 9


 258              		.loc 1 148 3 view .LVU67
 259              		.loc 1 148 6 is_stmt 0 view .LVU68
 260 002e 4468     		ldr	r4, [r0, #4]
 261 0030 6445     		cmp	r4, ip
 262 0032 F9D1     		bne	.L22
 263              		.loc 1 148 29 discriminator 1 view .LVU69
 264 0034 8468     		ldr	r4, [r0, #8]
 265 0036 8C42     		cmp	r4, r1
 266 0038 F6D1     		bne	.L22
 149:./fs/char_device.c **** 		    (*cp)->baseminor == baseminor &&
 267              		.loc 1 149 37 view .LVU70
 268 003a C468     		ldr	r4, [r0, #12]
 269 003c 9442     		cmp	r4, r2
 270 003e F3D1     		bne	.L22
 271              	.L23:
 150:./fs/char_device.c **** 		    (*cp)->minorct == minorct)
 151:./fs/char_device.c **** 			break;
 152:./fs/char_device.c **** 	if (*cp) {
 272              		.loc 1 152 2 is_stmt 1 view .LVU71
 273              		.loc 1 152 5 is_stmt 0 view .LVU72
 274 0040 08B1     		cbz	r0, .L20
 153:./fs/char_device.c **** 		cd = *cp;
 275              		.loc 1 153 3 is_stmt 1 view .LVU73
 276              	.LVL24:
 154:./fs/char_device.c **** 		*cp = cd->next;
 277              		.loc 1 154 3 view .LVU74
 278              		.loc 1 154 11 is_stmt 0 view .LVU75
 279 0042 0268     		ldr	r2, [r0]
 280              	.LVL25:
 281              		.loc 1 154 7 view .LVU76
 282 0044 1A60     		str	r2, [r3]
 155:./fs/char_device.c **** 	}
 156:./fs/char_device.c **** 	mutex_unlock(&chrdevs_lock);
 283              		.loc 1 156 2 is_stmt 1 view .LVU77
 157:./fs/char_device.c **** 	return cd;
 284              		.loc 1 157 2 view .LVU78
 285              	.LVL26:
 286              	.L20:
 158:./fs/char_device.c **** }
 287              		.loc 1 158 1 is_stmt 0 view .LVU79
 288 0046 5DF8044B 		ldr	r4, [sp], #4
 289              	.LCFI4:
 290              		.cfi_restore 4
 291              		.cfi_def_cfa_offset 0
 292 004a 7047     		bx	lr
 293              	.LVL27:
 294              	.L32:
 152:./fs/char_device.c **** 		cd = *cp;
 295              		.loc 1 152 2 is_stmt 1 view .LVU80
 152:./fs/char_device.c **** 		cd = *cp;
 296              		.loc 1 152 5 is_stmt 0 view .LVU81
 297 004c 10B1     		cbz	r0, .L30
 153:./fs/char_device.c **** 		*cp = cd->next;
 298              		.loc 1 153 3 is_stmt 1 view .LVU82
 299              	.LVL28:
 154:./fs/char_device.c **** 	}
 300              		.loc 1 154 3 view .LVU83
ARM GAS  /tmp/ccZE4dRO.s 			page 10


 154:./fs/char_device.c **** 	}
 301              		.loc 1 154 11 is_stmt 0 view .LVU84
 302 004e 0268     		ldr	r2, [r0]
 303              	.LVL29:
 154:./fs/char_device.c **** 	}
 304              		.loc 1 154 7 view .LVU85
 305 0050 1A60     		str	r2, [r3]
 156:./fs/char_device.c **** 	return cd;
 306              		.loc 1 156 2 is_stmt 1 view .LVU86
 157:./fs/char_device.c **** }
 307              		.loc 1 157 2 view .LVU87
 308 0052 7047     		bx	lr
 309              	.LVL30:
 310              	.L30:
 311              		.loc 1 158 1 is_stmt 0 view .LVU88
 312 0054 7047     		bx	lr
 313              	.L34:
 314 0056 00BF     		.align	2
 315              	.L33:
 316 0058 11080402 		.word	33818641
 317 005c 00000000 		.word	chrdevs
 318              		.cfi_endproc
 319              	.LFE1038:
 321              		.section	.text.cdev_add,"ax",%progbits
 322              		.align	1
 323              		.global	cdev_add
 324              		.syntax unified
 325              		.thumb
 326              		.thumb_func
 328              	cdev_add:
 329              	.LVL31:
 330              	.LFB1045:
 159:./fs/char_device.c **** 
 160:./fs/char_device.c **** 
 161:./fs/char_device.c **** /**
 162:./fs/char_device.c ****  * register_chrdev_region() - register a range of device numbers
 163:./fs/char_device.c ****  * @from: the first in the desired range of device numbers; must include
 164:./fs/char_device.c ****  *        the major number.
 165:./fs/char_device.c ****  * @count: the number of consecutive device numbers required
 166:./fs/char_device.c ****  * @name: the name of the device or driver.
 167:./fs/char_device.c ****  *
 168:./fs/char_device.c ****  * Return value is zero on success, a negative error code on failure.
 169:./fs/char_device.c ****  */
 170:./fs/char_device.c **** int register_chrdev_region(dev_t from, unsigned count, const char *name)
 171:./fs/char_device.c **** {
 172:./fs/char_device.c **** 	struct char_device_struct *cd;
 173:./fs/char_device.c **** 	dev_t to = from + count;
 174:./fs/char_device.c **** 	dev_t n, next;
 175:./fs/char_device.c **** 
 176:./fs/char_device.c **** 	for (n = from; n < to; n = next) {
 177:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 178:./fs/char_device.c **** 		if (next > to)
 179:./fs/char_device.c **** 			next = to;
 180:./fs/char_device.c **** 		cd = __register_chrdev_region(MAJOR(n), MINOR(n),
 181:./fs/char_device.c **** 			       next - n, name);
 182:./fs/char_device.c **** 		if (IS_ERR(cd))
 183:./fs/char_device.c **** 			goto fail;
ARM GAS  /tmp/ccZE4dRO.s 			page 11


 184:./fs/char_device.c **** 	}
 185:./fs/char_device.c **** 	return 0;
 186:./fs/char_device.c **** fail:
 187:./fs/char_device.c **** 	to = n;
 188:./fs/char_device.c **** 	for (n = from; n < to; n = next) {
 189:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 190:./fs/char_device.c **** 		kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));
 191:./fs/char_device.c **** 	}
 192:./fs/char_device.c **** 	return PTR_ERR(cd);
 193:./fs/char_device.c **** }
 194:./fs/char_device.c **** 
 195:./fs/char_device.c **** /**
 196:./fs/char_device.c ****  * alloc_chrdev_region() - register a range of char device numbers
 197:./fs/char_device.c ****  * @dev: output parameter for first assigned number
 198:./fs/char_device.c ****  * @baseminor: first of the requested range of minor numbers
 199:./fs/char_device.c ****  * @count: the number of minor numbers required
 200:./fs/char_device.c ****  * @name: the name of the associated device or driver
 201:./fs/char_device.c ****  *
 202:./fs/char_device.c ****  * Allocates a range of char device numbers.  The major number will be
 203:./fs/char_device.c ****  * chosen dynamically, and returned (along with the first minor number)
 204:./fs/char_device.c ****  * in @dev.  Returns zero or a negative error code.
 205:./fs/char_device.c ****  */
 206:./fs/char_device.c **** int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,
 207:./fs/char_device.c ****     const char *name)
 208:./fs/char_device.c **** {
 209:./fs/char_device.c **** struct char_device_struct *cd;
 210:./fs/char_device.c **** cd = __register_chrdev_region(0, baseminor, count, name);
 211:./fs/char_device.c **** if (IS_ERR(cd))
 212:./fs/char_device.c **** return PTR_ERR(cd);
 213:./fs/char_device.c **** *dev = MKDEV(cd->major, cd->baseminor);
 214:./fs/char_device.c **** return 0;
 215:./fs/char_device.c **** }
 216:./fs/char_device.c **** 
 217:./fs/char_device.c **** /**
 218:./fs/char_device.c ****  * __register_chrdev() - create and register a cdev occupying a range of minors
 219:./fs/char_device.c ****  * @major: major device number or 0 for dynamic allocation
 220:./fs/char_device.c ****  * @baseminor: first of the requested range of minor numbers
 221:./fs/char_device.c ****  * @count: the number of minor numbers required
 222:./fs/char_device.c ****  * @name: name of this range of devices
 223:./fs/char_device.c ****  * @fops: file operations associated with this devices
 224:./fs/char_device.c ****  *
 225:./fs/char_device.c ****  * If @major == 0 this functions will dynamically allocate a major and return
 226:./fs/char_device.c ****  * its number.
 227:./fs/char_device.c ****  *
 228:./fs/char_device.c ****  * If @major > 0 this function will attempt to reserve a device with the given
 229:./fs/char_device.c ****  * major number and will return zero on success.
 230:./fs/char_device.c ****  *
 231:./fs/char_device.c ****  * Returns a -ve errno on failure.
 232:./fs/char_device.c ****  *
 233:./fs/char_device.c ****  * The name of this device has nothing to do with the name of the device in
 234:./fs/char_device.c ****  * /dev. It only helps to keep track of the different owners of devices. If
 235:./fs/char_device.c ****  * your module name has only one type of devices it's ok to use e.g. the name
 236:./fs/char_device.c ****  * of the module here.
 237:./fs/char_device.c ****  */
 238:./fs/char_device.c **** int __register_chrdev(unsigned int major, unsigned int baseminor,
 239:./fs/char_device.c ****     unsigned int count, const char *name,
 240:./fs/char_device.c ****     const struct file_operations *fops)
ARM GAS  /tmp/ccZE4dRO.s 			page 12


 241:./fs/char_device.c **** {
 242:./fs/char_device.c ****     struct char_device_struct *cd;
 243:./fs/char_device.c ****     struct cdev *cdev;
 244:./fs/char_device.c ****     int err = -ENOMEM;
 245:./fs/char_device.c **** 
 246:./fs/char_device.c ****     cd = __register_chrdev_region(major, baseminor, count, name);
 247:./fs/char_device.c ****     if (IS_ERR(cd))
 248:./fs/char_device.c ****     return PTR_ERR(cd);
 249:./fs/char_device.c **** 
 250:./fs/char_device.c ****     cdev = cdev_alloc();
 251:./fs/char_device.c ****     if (!cdev)
 252:./fs/char_device.c ****     goto out2;
 253:./fs/char_device.c **** 
 254:./fs/char_device.c ****     cdev->owner = fops->owner;
 255:./fs/char_device.c ****     cdev->ops = fops;
 256:./fs/char_device.c ****     // kobject_set_name(&cdev->kobj, "%s", name);
 257:./fs/char_device.c **** 
 258:./fs/char_device.c **** 
 259:./fs/char_device.c ****     err = cdev_add(cdev, MKDEV(cd->major, baseminor), count);
 260:./fs/char_device.c ****     if (err)
 261:./fs/char_device.c ****     goto out;
 262:./fs/char_device.c **** 
 263:./fs/char_device.c ****     cd->cdev = cdev;
 264:./fs/char_device.c **** 
 265:./fs/char_device.c ****     return major ? 0 : cd->major;
 266:./fs/char_device.c **** out:
 267:./fs/char_device.c ****     //kobject_put(&cdev->kobj);
 268:./fs/char_device.c **** out2:
 269:./fs/char_device.c ****     kfree(__unregister_chrdev_region(cd->major, baseminor, count));
 270:./fs/char_device.c ****     return err;
 271:./fs/char_device.c **** }
 272:./fs/char_device.c **** 
 273:./fs/char_device.c **** /**
 274:./fs/char_device.c ****  * unregister_chrdev_region() - unregister a range of device numbers
 275:./fs/char_device.c ****  * @from: the first in the range of numbers to unregister
 276:./fs/char_device.c ****  * @count: the number of device numbers to unregister
 277:./fs/char_device.c ****  *
 278:./fs/char_device.c ****  * This function will unregister a range of @count device numbers,
 279:./fs/char_device.c ****  * starting with @from.  The caller should normally be the one who
 280:./fs/char_device.c ****  * allocated those numbers in the first place...
 281:./fs/char_device.c ****  */
 282:./fs/char_device.c **** void unregister_chrdev_region(dev_t from, unsigned count)
 283:./fs/char_device.c **** {
 284:./fs/char_device.c **** 	dev_t to = from + count;
 285:./fs/char_device.c **** 	dev_t n, next;
 286:./fs/char_device.c **** 
 287:./fs/char_device.c **** 	for (n = from; n < to; n = next) {
 288:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 289:./fs/char_device.c **** 		if (next > to)
 290:./fs/char_device.c **** 			next = to;
 291:./fs/char_device.c **** 		kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));
 292:./fs/char_device.c **** 	}
 293:./fs/char_device.c **** }
 294:./fs/char_device.c **** 
 295:./fs/char_device.c **** /**
 296:./fs/char_device.c ****  * __unregister_chrdev - unregister and destroy a cdev
 297:./fs/char_device.c ****  * @major: major device number
ARM GAS  /tmp/ccZE4dRO.s 			page 13


 298:./fs/char_device.c ****  * @baseminor: first of the range of minor numbers
 299:./fs/char_device.c ****  * @count: the number of minor numbers this cdev is occupying
 300:./fs/char_device.c ****  * @name: name of this range of devices
 301:./fs/char_device.c ****  *
 302:./fs/char_device.c ****  * Unregister and destroy the cdev occupying the region described by
 303:./fs/char_device.c ****  * @major, @baseminor and @count.  This function undoes what
 304:./fs/char_device.c ****  * __register_chrdev() did.
 305:./fs/char_device.c ****  */
 306:./fs/char_device.c **** void __unregister_chrdev(unsigned int major, unsigned int baseminor,
 307:./fs/char_device.c ****     unsigned int count, const char *name)
 308:./fs/char_device.c **** {
 309:./fs/char_device.c **** struct char_device_struct *cd;
 310:./fs/char_device.c **** 
 311:./fs/char_device.c **** cd = __unregister_chrdev_region(major, baseminor, count);
 312:./fs/char_device.c **** if (cd && cd->cdev)
 313:./fs/char_device.c **** cdev_del(cd->cdev);
 314:./fs/char_device.c **** kfree(cd);
 315:./fs/char_device.c **** }
 316:./fs/char_device.c **** 
 317:./fs/char_device.c **** 
 318:./fs/char_device.c **** 
 319:./fs/char_device.c **** 
 320:./fs/char_device.c **** void cdev_put(struct cdev *p)
 321:./fs/char_device.c **** {
 322:./fs/char_device.c **** 	if (p) {
 323:./fs/char_device.c **** 		struct module *owner = p->owner;
 324:./fs/char_device.c **** 		//kobject_put(&p->kobj);
 325:./fs/char_device.c **** 		//module_put(owner);
 326:./fs/char_device.c **** 	}
 327:./fs/char_device.c **** }
 328:./fs/char_device.c **** 
 329:./fs/char_device.c **** 
 330:./fs/char_device.c **** /**
 331:./fs/char_device.c ****  * cdev_add() - add a char device to the system
 332:./fs/char_device.c ****  * @p: the cdev structure for the device
 333:./fs/char_device.c ****  * @dev: the first device number for which this device is responsible
 334:./fs/char_device.c ****  * @count: the number of consecutive minor numbers corresponding to this
 335:./fs/char_device.c ****  *         device
 336:./fs/char_device.c ****  *
 337:./fs/char_device.c ****  * cdev_add() adds the device represented by @p to the system, making it
 338:./fs/char_device.c ****  * live immediately.  A negative error code is returned on failure.
 339:./fs/char_device.c ****  */
 340:./fs/char_device.c **** int cdev_add(struct cdev *p, dev_t dev, unsigned count)
 341:./fs/char_device.c **** {
 331              		.loc 1 341 1 is_stmt 1 view -0
 332              		.cfi_startproc
 333              		@ args = 0, pretend = 0, frame = 0
 334              		@ frame_needed = 0, uses_anonymous_args = 0
 335              		@ link register save eliminated.
 342:./fs/char_device.c **** 	int error;
 336              		.loc 1 342 2 view .LVU90
 343:./fs/char_device.c **** 
 344:./fs/char_device.c **** 	p->dev = dev;
 337              		.loc 1 344 2 view .LVU91
 338              		.loc 1 344 9 is_stmt 0 view .LVU92
 339 0000 0161     		str	r1, [r0, #16]
 345:./fs/char_device.c **** 	p->count = count;
ARM GAS  /tmp/ccZE4dRO.s 			page 14


 340              		.loc 1 345 2 is_stmt 1 view .LVU93
 341              		.loc 1 345 11 is_stmt 0 view .LVU94
 342 0002 4261     		str	r2, [r0, #20]
 346:./fs/char_device.c **** 
 347:./fs/char_device.c **** 	// if (WARN_ON(dev == WHITEOUT_DEV)) {
 348:./fs/char_device.c **** 	// 	error = -EBUSY;
 349:./fs/char_device.c **** 	// 	return error;
 350:./fs/char_device.c ****     //     goto err;
 351:./fs/char_device.c **** 	// }
 352:./fs/char_device.c **** 
 353:./fs/char_device.c **** 	// error = kobj_map(cdev_map, dev, count, NULL,
 354:./fs/char_device.c **** 	// 		 exact_match, exact_lock, p);
 355:./fs/char_device.c **** 	// if (error)
 356:./fs/char_device.c **** 	// 	goto err;
 357:./fs/char_device.c **** 
 358:./fs/char_device.c **** 	// kobject_get(p->kobj.parent);
 359:./fs/char_device.c **** 
 360:./fs/char_device.c **** 	return 0;
 343              		.loc 1 360 2 is_stmt 1 view .LVU95
 361:./fs/char_device.c **** 
 362:./fs/char_device.c **** // err:
 363:./fs/char_device.c **** // 	kfree_const(p->kobj.name);
 364:./fs/char_device.c **** // 	p->kobj.name = NULL;
 365:./fs/char_device.c **** // 	return error;
 366:./fs/char_device.c **** }
 344              		.loc 1 366 1 is_stmt 0 view .LVU96
 345 0004 0020     		movs	r0, #0
 346              	.LVL32:
 347              		.loc 1 366 1 view .LVU97
 348 0006 7047     		bx	lr
 349              		.cfi_endproc
 350              	.LFE1045:
 352              		.section	.text.find_chrdev,"ax",%progbits
 353              		.align	1
 354              		.global	find_chrdev
 355              		.syntax unified
 356              		.thumb
 357              		.thumb_func
 359              	find_chrdev:
 360              	.LVL33:
 361              	.LFB1049:
 367:./fs/char_device.c **** 
 368:./fs/char_device.c **** 
 369:./fs/char_device.c **** 
 370:./fs/char_device.c **** 
 371:./fs/char_device.c **** 
 372:./fs/char_device.c **** /**
 373:./fs/char_device.c ****  * cdev_alloc() - allocate a cdev structure
 374:./fs/char_device.c ****  *
 375:./fs/char_device.c ****  * Allocates and returns a cdev structure, or NULL on failure.
 376:./fs/char_device.c ****  */
 377:./fs/char_device.c **** struct cdev *cdev_alloc(void)
 378:./fs/char_device.c **** {
 379:./fs/char_device.c **** 	struct cdev *p = kzalloc(sizeof(struct cdev), GFP_KERNEL);
 380:./fs/char_device.c **** 	if (p) {
 381:./fs/char_device.c **** 		INIT_LIST_HEAD(&p->list);
 382:./fs/char_device.c **** 		// kobject_init(&p->kobj, &ktype_cdev_dynamic);
ARM GAS  /tmp/ccZE4dRO.s 			page 15


 383:./fs/char_device.c **** 	}
 384:./fs/char_device.c **** 	return p;
 385:./fs/char_device.c **** } 
 386:./fs/char_device.c **** 
 387:./fs/char_device.c **** /**
 388:./fs/char_device.c ****  * cdev_init() - initialize a cdev structure
 389:./fs/char_device.c ****  * @cdev: the structure to initialize
 390:./fs/char_device.c ****  * @fops: the file_operations for this device
 391:./fs/char_device.c ****  *
 392:./fs/char_device.c ****  * Initializes @cdev, remembering @fops, making it ready to add to the
 393:./fs/char_device.c ****  * system with cdev_add().
 394:./fs/char_device.c ****  */
 395:./fs/char_device.c **** void cdev_init(struct cdev *cdev, const struct file_operations *fops)
 396:./fs/char_device.c **** {
 397:./fs/char_device.c **** 	memset(cdev, 0, sizeof *cdev);
 398:./fs/char_device.c **** 	INIT_LIST_HEAD(&cdev->list);
 399:./fs/char_device.c **** 	// kobject_init(&cdev->kobj, &ktype_cdev_default);
 400:./fs/char_device.c **** 	cdev->ops = fops;
 401:./fs/char_device.c **** }
 402:./fs/char_device.c **** 
 403:./fs/char_device.c **** 
 404:./fs/char_device.c **** /**
 405:./fs/char_device.c ****  * cdev_del() - remove a cdev from the system
 406:./fs/char_device.c ****  * @p: the cdev structure to be removed
 407:./fs/char_device.c ****  *
 408:./fs/char_device.c ****  * cdev_del() removes @p from the system, possibly freeing the structure
 409:./fs/char_device.c ****  * itself.
 410:./fs/char_device.c ****  *
 411:./fs/char_device.c ****  * NOTE: This guarantees that cdev device will no longer be able to be
 412:./fs/char_device.c ****  * opened, however any cdevs already open will remain and their fops will
 413:./fs/char_device.c ****  * still be callable even after cdev_del returns.
 414:./fs/char_device.c ****  */
 415:./fs/char_device.c **** void cdev_del(struct cdev *p)
 416:./fs/char_device.c **** {
 417:./fs/char_device.c ****     kfree(p);
 418:./fs/char_device.c ****     // cdev_unmap(p->dev, p->count);
 419:./fs/char_device.c **** 	// kobject_put(&p->kobj);
 420:./fs/char_device.c **** }
 421:./fs/char_device.c **** 
 422:./fs/char_device.c **** 
 423:./fs/char_device.c **** 
 424:./fs/char_device.c **** 
 425:./fs/char_device.c **** 
 426:./fs/char_device.c **** struct file_operations *find_chrdev(unsigned int major, unsigned int minor)
 427:./fs/char_device.c **** {
 362              		.loc 1 427 1 is_stmt 1 view -0
 363              		.cfi_startproc
 364              		@ args = 0, pretend = 0, frame = 0
 365              		@ frame_needed = 0, uses_anonymous_args = 0
 366              		@ link register save eliminated.
 367              		.loc 1 427 1 is_stmt 0 view .LVU99
 368 0000 0246     		mov	r2, r0
 428:./fs/char_device.c **** 	int i = major_to_index(major);
 369              		.loc 1 428 2 is_stmt 1 view .LVU100
 370              	.LVL34:
 371              	.LBB72:
 372              	.LBI72:
ARM GAS  /tmp/ccZE4dRO.s 			page 16


  33:./fs/char_device.c **** {
 373              		.loc 1 33 19 view .LVU101
 374              	.LBB73:
  35:./fs/char_device.c **** }
 375              		.loc 1 35 2 view .LVU102
  35:./fs/char_device.c **** }
 376              		.loc 1 35 15 is_stmt 0 view .LVU103
 377 0002 154B     		ldr	r3, .L51
 378 0004 A3FB0203 		umull	r0, r3, r3, r2
 379              	.LVL35:
  35:./fs/char_device.c **** }
 380              		.loc 1 35 15 view .LVU104
 381 0008 D01A     		subs	r0, r2, r3
 382 000a 03EB5003 		add	r3, r3, r0, lsr #1
 383 000e 9B09     		lsrs	r3, r3, #6
 384 0010 C3EBC313 		rsb	r3, r3, r3, lsl #7
 385 0014 D31A     		subs	r3, r2, r3
 386              	.LVL36:
  35:./fs/char_device.c **** }
 387              		.loc 1 35 15 view .LVU105
 388              	.LBE73:
 389              	.LBE72:
 429:./fs/char_device.c **** 	struct char_device_struct *cd;
 390              		.loc 1 429 2 is_stmt 1 view .LVU106
 430:./fs/char_device.c **** 
 431:./fs/char_device.c **** 	mutex_lock(&chrdevs_lock);
 391              		.loc 1 431 2 view .LVU107
 432:./fs/char_device.c **** 	for (cd = chrdevs[i]; cd; cd = cd->next) {
 392              		.loc 1 432 2 view .LVU108
 393              		.loc 1 432 10 is_stmt 0 view .LVU109
 394 0016 1148     		ldr	r0, .L51+4
 395 0018 50F82300 		ldr	r0, [r0, r3, lsl #2]
 396              	.LVL37:
 397              		.loc 1 432 2 view .LVU110
 398 001c 05E0     		b	.L42
 399              	.LVL38:
 400              	.L50:
 401              	.LCFI5:
 402              		.cfi_def_cfa_offset 4
 403              		.cfi_offset 4, -4
 433:./fs/char_device.c **** 		if (cd->major != major)
 434:./fs/char_device.c **** 			continue;
 435:./fs/char_device.c **** 		if (cd->baseminor <= minor && minor < cd->baseminor + cd->minorct) {
 436:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 404              		.loc 1 436 4 is_stmt 1 view .LVU111
 437:./fs/char_device.c **** 			return cd->cdev->ops;
 405              		.loc 1 437 4 view .LVU112
 406              		.loc 1 437 13 is_stmt 0 view .LVU113
 407 001e 036D     		ldr	r3, [r0, #80]
 408              		.loc 1 437 19 view .LVU114
 409 0020 5868     		ldr	r0, [r3, #4]
 410              	.LVL39:
 411              	.L36:
 438:./fs/char_device.c **** 		}
 439:./fs/char_device.c **** 	}
 440:./fs/char_device.c **** 	mutex_unlock(&chrdevs_lock);
 441:./fs/char_device.c **** 	return NULL;
ARM GAS  /tmp/ccZE4dRO.s 			page 17


 442:./fs/char_device.c **** }
 412              		.loc 1 442 1 view .LVU115
 413 0022 5DF8044B 		ldr	r4, [sp], #4
 414              	.LCFI6:
 415              		.cfi_restore 4
 416              		.cfi_def_cfa_offset 0
 417 0026 7047     		bx	lr
 418              	.LVL40:
 419              	.L43:
 432:./fs/char_device.c **** 		if (cd->major != major)
 420              		.loc 1 432 31 is_stmt 1 discriminator 2 view .LVU116
 421 0028 0068     		ldr	r0, [r0]
 422              	.LVL41:
 423              	.L42:
 432:./fs/char_device.c **** 		if (cd->major != major)
 424              		.loc 1 432 24 discriminator 1 view .LVU117
 425 002a A0B1     		cbz	r0, .L49
 433:./fs/char_device.c **** 			continue;
 426              		.loc 1 433 3 view .LVU118
 433:./fs/char_device.c **** 			continue;
 427              		.loc 1 433 9 is_stmt 0 view .LVU119
 428 002c 4368     		ldr	r3, [r0, #4]
 433:./fs/char_device.c **** 			continue;
 429              		.loc 1 433 6 view .LVU120
 430 002e 9342     		cmp	r3, r2
 431 0030 FAD1     		bne	.L43
 435:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 432              		.loc 1 435 3 is_stmt 1 view .LVU121
 435:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 433              		.loc 1 435 9 is_stmt 0 view .LVU122
 434 0032 8368     		ldr	r3, [r0, #8]
 435:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 435              		.loc 1 435 6 view .LVU123
 436 0034 8B42     		cmp	r3, r1
 437 0036 F7D8     		bhi	.L43
 427:./fs/char_device.c **** 	int i = major_to_index(major);
 438              		.loc 1 427 1 view .LVU124
 439 0038 10B4     		push	{r4}
 440              	.LCFI7:
 441              		.cfi_def_cfa_offset 4
 442              		.cfi_offset 4, -4
 443              	.L45:
 435:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 444              		.loc 1 435 55 discriminator 1 view .LVU125
 445 003a C468     		ldr	r4, [r0, #12]
 446 003c 2344     		add	r3, r3, r4
 435:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 447              		.loc 1 435 30 discriminator 1 view .LVU126
 448 003e 8B42     		cmp	r3, r1
 449 0040 EDD8     		bhi	.L50
 450              	.L38:
 432:./fs/char_device.c **** 		if (cd->major != major)
 451              		.loc 1 432 31 is_stmt 1 discriminator 2 view .LVU127
 452 0042 0068     		ldr	r0, [r0]
 453              	.LVL42:
 432:./fs/char_device.c **** 		if (cd->major != major)
 454              		.loc 1 432 24 discriminator 1 view .LVU128
ARM GAS  /tmp/ccZE4dRO.s 			page 18


 455 0044 0028     		cmp	r0, #0
 456 0046 ECD0     		beq	.L36
 433:./fs/char_device.c **** 			continue;
 457              		.loc 1 433 3 view .LVU129
 433:./fs/char_device.c **** 			continue;
 458              		.loc 1 433 9 is_stmt 0 view .LVU130
 459 0048 4368     		ldr	r3, [r0, #4]
 433:./fs/char_device.c **** 			continue;
 460              		.loc 1 433 6 view .LVU131
 461 004a 9342     		cmp	r3, r2
 462 004c F9D1     		bne	.L38
 435:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 463              		.loc 1 435 3 is_stmt 1 view .LVU132
 435:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 464              		.loc 1 435 9 is_stmt 0 view .LVU133
 465 004e 8368     		ldr	r3, [r0, #8]
 435:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 466              		.loc 1 435 6 view .LVU134
 467 0050 8B42     		cmp	r3, r1
 468 0052 F6D8     		bhi	.L38
 469 0054 F1E7     		b	.L45
 470              	.L49:
 471              	.LCFI8:
 472              		.cfi_def_cfa_offset 0
 473              		.cfi_restore 4
 435:./fs/char_device.c **** 			mutex_unlock(&chrdevs_lock);
 474              		.loc 1 435 6 view .LVU135
 475 0056 7047     		bx	lr
 476              	.L52:
 477              		.align	2
 478              	.L51:
 479 0058 11080402 		.word	33818641
 480 005c 00000000 		.word	chrdevs
 481              		.cfi_endproc
 482              	.LFE1049:
 484              		.section	.text.kzalloc,"ax",%progbits
 485              		.align	1
 486              		.syntax unified
 487              		.thumb
 488              		.thumb_func
 490              	kzalloc:
 491              	.LVL43:
 492              	.LFB332:
 493              		.file 3 "./include/linux/slab.h"
   1:./include/linux/slab.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/slab.h **** /*
   3:./include/linux/slab.h ****  * Written by Mark Hemment, 1996 (markhe@nextd.demon.co.uk).
   4:./include/linux/slab.h ****  *
   5:./include/linux/slab.h ****  * (C) SGI 2006, Christoph Lameter
   6:./include/linux/slab.h ****  * 	Cleaned up and restructured to ease the addition of alternative
   7:./include/linux/slab.h ****  * 	implementations of SLAB allocators.
   8:./include/linux/slab.h ****  * (C) Linux Foundation 2008-2013
   9:./include/linux/slab.h ****  *      Unified interface for all slab allocators
  10:./include/linux/slab.h ****  */
  11:./include/linux/slab.h **** 
  12:./include/linux/slab.h **** #ifndef _LINUX_SLAB_H
  13:./include/linux/slab.h **** #define	_LINUX_SLAB_H
ARM GAS  /tmp/ccZE4dRO.s 			page 19


  14:./include/linux/slab.h **** 
  15:./include/linux/slab.h **** #include <linux/cache.h>
  16:./include/linux/slab.h **** #include <linux/overflow.h>
  17:./include/linux/slab.h **** #include <linux/types.h>
  18:./include/linux/slab.h **** #include <linux/raid/pq.h>
  19:./include/linux/slab.h **** #include <linux/gfp_types.h>
  20:./include/linux/slab.h **** #include <linux/numa.h>
  21:./include/linux/slab.h **** #include <linux/reciprocal_div.h>
  22:./include/linux/slab.h **** #include <linux/spinlock.h>
  23:./include/linux/slab.h **** 
  24:./include/linux/slab.h **** enum _slab_flag_bits {
  25:./include/linux/slab.h **** 	_SLAB_CONSISTENCY_CHECKS,
  26:./include/linux/slab.h **** 	_SLAB_RED_ZONE,
  27:./include/linux/slab.h **** 	_SLAB_POISON,
  28:./include/linux/slab.h **** 	_SLAB_KMALLOC,
  29:./include/linux/slab.h **** 	_SLAB_HWCACHE_ALIGN,
  30:./include/linux/slab.h **** 	_SLAB_CACHE_DMA,
  31:./include/linux/slab.h **** 	_SLAB_CACHE_DMA32,
  32:./include/linux/slab.h **** 	_SLAB_STORE_USER,
  33:./include/linux/slab.h **** 	_SLAB_PANIC,
  34:./include/linux/slab.h **** 	_SLAB_TYPESAFE_BY_RCU,
  35:./include/linux/slab.h **** 	_SLAB_TRACE,
  36:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
  37:./include/linux/slab.h **** 	_SLAB_DEBUG_OBJECTS,
  38:./include/linux/slab.h **** #endif
  39:./include/linux/slab.h **** 	_SLAB_NOLEAKTRACE,
  40:./include/linux/slab.h **** 	_SLAB_NO_MERGE,
  41:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
  42:./include/linux/slab.h **** 	_SLAB_FAILSLAB,
  43:./include/linux/slab.h **** #endif
  44:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
  45:./include/linux/slab.h **** 	_SLAB_ACCOUNT,
  46:./include/linux/slab.h **** #endif
  47:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
  48:./include/linux/slab.h **** 	_SLAB_KASAN,
  49:./include/linux/slab.h **** #endif
  50:./include/linux/slab.h **** 	_SLAB_NO_USER_FLAGS,
  51:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
  52:./include/linux/slab.h **** 	_SLAB_SKIP_KFENCE,
  53:./include/linux/slab.h **** #endif
  54:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
  55:./include/linux/slab.h **** 	_SLAB_RECLAIM_ACCOUNT,
  56:./include/linux/slab.h **** #endif
  57:./include/linux/slab.h **** 	_SLAB_OBJECT_POISON,
  58:./include/linux/slab.h **** 	_SLAB_CMPXCHG_DOUBLE,
  59:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
  60:./include/linux/slab.h **** 	_SLAB_NO_OBJ_EXT,
  61:./include/linux/slab.h **** #endif
  62:./include/linux/slab.h **** 	_SLAB_FLAGS_LAST_BIT
  63:./include/linux/slab.h **** };
  64:./include/linux/slab.h **** 
  65:./include/linux/slab.h **** 
  66:./include/linux/slab.h **** 
  67:./include/linux/slab.h **** #define __SLAB_FLAG_BIT(nr)	((slab_flags_t __force)(1U << (nr)))
  68:./include/linux/slab.h **** #define __SLAB_FLAG_UNUSED	((slab_flags_t __force)(0U))
  69:./include/linux/slab.h **** 
  70:./include/linux/slab.h **** /*
ARM GAS  /tmp/ccZE4dRO.s 			page 20


  71:./include/linux/slab.h ****  * Flags to pass to kmem_cache_create().
  72:./include/linux/slab.h ****  * The ones marked DEBUG need CONFIG_SLUB_DEBUG enabled, otherwise are no-op
  73:./include/linux/slab.h ****  */
  74:./include/linux/slab.h **** /* DEBUG: Perform (expensive) checks on alloc/free */
  75:./include/linux/slab.h **** #define SLAB_CONSISTENCY_CHECKS	__SLAB_FLAG_BIT(_SLAB_CONSISTENCY_CHECKS)
  76:./include/linux/slab.h **** /* DEBUG: Red zone objs in a cache */
  77:./include/linux/slab.h **** #define SLAB_RED_ZONE		__SLAB_FLAG_BIT(_SLAB_RED_ZONE)
  78:./include/linux/slab.h **** /* DEBUG: Poison objects */
  79:./include/linux/slab.h **** #define SLAB_POISON		__SLAB_FLAG_BIT(_SLAB_POISON)
  80:./include/linux/slab.h **** /* Indicate a kmalloc slab */
  81:./include/linux/slab.h **** #define SLAB_KMALLOC		__SLAB_FLAG_BIT(_SLAB_KMALLOC)
  82:./include/linux/slab.h **** /**
  83:./include/linux/slab.h ****  * define SLAB_HWCACHE_ALIGN - Align objects on cache line boundaries.
  84:./include/linux/slab.h ****  *
  85:./include/linux/slab.h ****  * Sufficiently large objects are aligned on cache line boundary. For object
  86:./include/linux/slab.h ****  * size smaller than a half of cache line size, the alignment is on the half of
  87:./include/linux/slab.h ****  * cache line size. In general, if object size is smaller than 1/2^n of cache
  88:./include/linux/slab.h ****  * line size, the alignment is adjusted to 1/2^n.
  89:./include/linux/slab.h ****  *
  90:./include/linux/slab.h ****  * If explicit alignment is also requested by the respective
  91:./include/linux/slab.h ****  * &struct kmem_cache_args field, the greater of both is alignments is applied.
  92:./include/linux/slab.h ****  */
  93:./include/linux/slab.h **** #define SLAB_HWCACHE_ALIGN	__SLAB_FLAG_BIT(_SLAB_HWCACHE_ALIGN)
  94:./include/linux/slab.h **** /* Use GFP_DMA memory */
  95:./include/linux/slab.h **** #define SLAB_CACHE_DMA		__SLAB_FLAG_BIT(_SLAB_CACHE_DMA)
  96:./include/linux/slab.h **** /* Use GFP_DMA32 memory */
  97:./include/linux/slab.h **** #define SLAB_CACHE_DMA32	__SLAB_FLAG_BIT(_SLAB_CACHE_DMA32)
  98:./include/linux/slab.h **** /* DEBUG: Store the last owner for bug hunting */
  99:./include/linux/slab.h **** #define SLAB_STORE_USER		__SLAB_FLAG_BIT(_SLAB_STORE_USER)
 100:./include/linux/slab.h **** /* Panic if kmem_cache_create() fails */
 101:./include/linux/slab.h **** #define SLAB_PANIC		__SLAB_FLAG_BIT(_SLAB_PANIC)
 102:./include/linux/slab.h **** /**
 103:./include/linux/slab.h ****  * define SLAB_TYPESAFE_BY_RCU - **WARNING** READ THIS!
 104:./include/linux/slab.h ****  *
 105:./include/linux/slab.h ****  * This delays freeing the SLAB page by a grace period, it does _NOT_
 106:./include/linux/slab.h ****  * delay object freeing. This means that if you do kmem_cache_free()
 107:./include/linux/slab.h ****  * that memory location is free to be reused at any time. Thus it may
 108:./include/linux/slab.h ****  * be possible to see another object there in the same RCU grace period.
 109:./include/linux/slab.h ****  *
 110:./include/linux/slab.h ****  * This feature only ensures the memory location backing the object
 111:./include/linux/slab.h ****  * stays valid, the trick to using this is relying on an independent
 112:./include/linux/slab.h ****  * object validation pass. Something like:
 113:./include/linux/slab.h ****  *
 114:./include/linux/slab.h ****  * ::
 115:./include/linux/slab.h ****  *
 116:./include/linux/slab.h ****  *  begin:
 117:./include/linux/slab.h ****  *   rcu_read_lock();
 118:./include/linux/slab.h ****  *   obj = lockless_lookup(key);
 119:./include/linux/slab.h ****  *   if (obj) {
 120:./include/linux/slab.h ****  *     if (!try_get_ref(obj)) // might fail for free objects
 121:./include/linux/slab.h ****  *       rcu_read_unlock();
 122:./include/linux/slab.h ****  *       goto begin;
 123:./include/linux/slab.h ****  *
 124:./include/linux/slab.h ****  *     if (obj->key != key) { // not the object we expected
 125:./include/linux/slab.h ****  *       put_ref(obj);
 126:./include/linux/slab.h ****  *       rcu_read_unlock();
 127:./include/linux/slab.h ****  *       goto begin;
ARM GAS  /tmp/ccZE4dRO.s 			page 21


 128:./include/linux/slab.h ****  *     }
 129:./include/linux/slab.h ****  *   }
 130:./include/linux/slab.h ****  *  rcu_read_unlock();
 131:./include/linux/slab.h ****  *
 132:./include/linux/slab.h ****  * This is useful if we need to approach a kernel structure obliquely,
 133:./include/linux/slab.h ****  * from its address obtained without the usual locking. We can lock
 134:./include/linux/slab.h ****  * the structure to stabilize it and check it's still at the given address,
 135:./include/linux/slab.h ****  * only if we can be sure that the memory has not been meanwhile reused
 136:./include/linux/slab.h ****  * for some other kind of object (which our subsystem's lock might corrupt).
 137:./include/linux/slab.h ****  *
 138:./include/linux/slab.h ****  * rcu_read_lock before reading the address, then rcu_read_unlock after
 139:./include/linux/slab.h ****  * taking the spinlock within the structure expected at that address.
 140:./include/linux/slab.h ****  *
 141:./include/linux/slab.h ****  * Note that it is not possible to acquire a lock within a structure
 142:./include/linux/slab.h ****  * allocated with SLAB_TYPESAFE_BY_RCU without first acquiring a reference
 143:./include/linux/slab.h ****  * as described above.  The reason is that SLAB_TYPESAFE_BY_RCU pages
 144:./include/linux/slab.h ****  * are not zeroed before being given to the slab, which means that any
 145:./include/linux/slab.h ****  * locks must be initialized after each and every kmem_struct_alloc().
 146:./include/linux/slab.h ****  * Alternatively, make the ctor passed to kmem_cache_create() initialize
 147:./include/linux/slab.h ****  * the locks at page-allocation time, as is done in __i915_request_ctor(),
 148:./include/linux/slab.h ****  * sighand_ctor(), and anon_vma_ctor().  Such a ctor permits readers
 149:./include/linux/slab.h ****  * to safely acquire those ctor-initialized locks under rcu_read_lock()
 150:./include/linux/slab.h ****  * protection.
 151:./include/linux/slab.h ****  *
 152:./include/linux/slab.h ****  * Note that SLAB_TYPESAFE_BY_RCU was originally named SLAB_DESTROY_BY_RCU.
 153:./include/linux/slab.h ****  */
 154:./include/linux/slab.h **** #define SLAB_TYPESAFE_BY_RCU	__SLAB_FLAG_BIT(_SLAB_TYPESAFE_BY_RCU)
 155:./include/linux/slab.h **** /* Trace allocations and frees */
 156:./include/linux/slab.h **** #define SLAB_TRACE		__SLAB_FLAG_BIT(_SLAB_TRACE)
 157:./include/linux/slab.h **** 
 158:./include/linux/slab.h **** /* Flag to prevent checks on free */
 159:./include/linux/slab.h **** #ifdef CONFIG_DEBUG_OBJECTS
 160:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_BIT(_SLAB_DEBUG_OBJECTS)
 161:./include/linux/slab.h **** #else
 162:./include/linux/slab.h **** # define SLAB_DEBUG_OBJECTS	__SLAB_FLAG_UNUSED
 163:./include/linux/slab.h **** #endif
 164:./include/linux/slab.h **** 
 165:./include/linux/slab.h **** /* Avoid kmemleak tracing */
 166:./include/linux/slab.h **** #define SLAB_NOLEAKTRACE	__SLAB_FLAG_BIT(_SLAB_NOLEAKTRACE)
 167:./include/linux/slab.h **** 
 168:./include/linux/slab.h **** /*
 169:./include/linux/slab.h ****  * Prevent merging with compatible kmem caches. This flag should be used
 170:./include/linux/slab.h ****  * cautiously. Valid use cases:
 171:./include/linux/slab.h ****  *
 172:./include/linux/slab.h ****  * - caches created for self-tests (e.g. kunit)
 173:./include/linux/slab.h ****  * - general caches created and used by a subsystem, only when a
 174:./include/linux/slab.h ****  *   (subsystem-specific) debug option is enabled
 175:./include/linux/slab.h ****  * - performance critical caches, should be very rare and consulted with slab
 176:./include/linux/slab.h ****  *   maintainers, and not used together with CONFIG_SLUB_TINY
 177:./include/linux/slab.h ****  */
 178:./include/linux/slab.h **** #define SLAB_NO_MERGE		__SLAB_FLAG_BIT(_SLAB_NO_MERGE)
 179:./include/linux/slab.h **** 
 180:./include/linux/slab.h **** /* Fault injection mark */
 181:./include/linux/slab.h **** #ifdef CONFIG_FAILSLAB
 182:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_BIT(_SLAB_FAILSLAB)
 183:./include/linux/slab.h **** #else
 184:./include/linux/slab.h **** # define SLAB_FAILSLAB		__SLAB_FLAG_UNUSED
ARM GAS  /tmp/ccZE4dRO.s 			page 22


 185:./include/linux/slab.h **** #endif
 186:./include/linux/slab.h **** /**
 187:./include/linux/slab.h ****  * define SLAB_ACCOUNT - Account allocations to memcg.
 188:./include/linux/slab.h ****  *
 189:./include/linux/slab.h ****  * All object allocations from this cache will be memcg accounted, regardless of
 190:./include/linux/slab.h ****  * __GFP_ACCOUNT being or not being passed to individual allocations.
 191:./include/linux/slab.h ****  */
 192:./include/linux/slab.h **** #ifdef CONFIG_MEMCG
 193:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_BIT(_SLAB_ACCOUNT)
 194:./include/linux/slab.h **** #else
 195:./include/linux/slab.h **** # define SLAB_ACCOUNT		__SLAB_FLAG_UNUSED
 196:./include/linux/slab.h **** #endif
 197:./include/linux/slab.h **** 
 198:./include/linux/slab.h **** #ifdef CONFIG_KASAN_GENERIC
 199:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_BIT(_SLAB_KASAN)
 200:./include/linux/slab.h **** #else
 201:./include/linux/slab.h **** #define SLAB_KASAN		__SLAB_FLAG_UNUSED
 202:./include/linux/slab.h **** #endif
 203:./include/linux/slab.h **** 
 204:./include/linux/slab.h **** /*
 205:./include/linux/slab.h ****  * Ignore user specified debugging flags.
 206:./include/linux/slab.h ****  * Intended for caches created for self-tests so they have only flags
 207:./include/linux/slab.h ****  * specified in the code and other flags are ignored.
 208:./include/linux/slab.h ****  */
 209:./include/linux/slab.h **** #define SLAB_NO_USER_FLAGS	__SLAB_FLAG_BIT(_SLAB_NO_USER_FLAGS)
 210:./include/linux/slab.h **** 
 211:./include/linux/slab.h **** #ifdef CONFIG_KFENCE
 212:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_BIT(_SLAB_SKIP_KFENCE)
 213:./include/linux/slab.h **** #else
 214:./include/linux/slab.h **** #define SLAB_SKIP_KFENCE	__SLAB_FLAG_UNUSED
 215:./include/linux/slab.h **** #endif
 216:./include/linux/slab.h **** 
 217:./include/linux/slab.h **** /* The following flags affect the page allocator grouping pages by mobility */
 218:./include/linux/slab.h **** /**
 219:./include/linux/slab.h ****  * define SLAB_RECLAIM_ACCOUNT - Objects are reclaimable.
 220:./include/linux/slab.h ****  *
 221:./include/linux/slab.h ****  * Use this flag for caches that have an associated shrinker. As a result, slab
 222:./include/linux/slab.h ****  * pages are allocated with __GFP_RECLAIMABLE, which affects grouping pages by
 223:./include/linux/slab.h ****  * mobility, and are accounted in SReclaimable counter in /proc/meminfo
 224:./include/linux/slab.h ****  */
 225:./include/linux/slab.h **** #ifndef CONFIG_SLUB_TINY
 226:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_BIT(_SLAB_RECLAIM_ACCOUNT)
 227:./include/linux/slab.h **** #else
 228:./include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	__SLAB_FLAG_UNUSED
 229:./include/linux/slab.h **** #endif
 230:./include/linux/slab.h **** #define SLAB_TEMPORARY		SLAB_RECLAIM_ACCOUNT	/* Objects are short-lived */
 231:./include/linux/slab.h **** 
 232:./include/linux/slab.h **** /* Slab created using create_boot_cache */
 233:./include/linux/slab.h **** #ifdef CONFIG_SLAB_OBJ_EXT
 234:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_BIT(_SLAB_NO_OBJ_EXT)
 235:./include/linux/slab.h **** #else
 236:./include/linux/slab.h **** #define SLAB_NO_OBJ_EXT		__SLAB_FLAG_UNUSED
 237:./include/linux/slab.h **** #endif
 238:./include/linux/slab.h **** 
 239:./include/linux/slab.h **** /*
 240:./include/linux/slab.h ****  * freeptr_t represents a SLUB freelist pointer, which might be encoded
 241:./include/linux/slab.h ****  * and not dereferenceable if CONFIG_SLAB_FREELIST_HARDENED is enabled.
ARM GAS  /tmp/ccZE4dRO.s 			page 23


 242:./include/linux/slab.h ****  */
 243:./include/linux/slab.h **** typedef struct { unsigned long v; } freeptr_t;
 244:./include/linux/slab.h **** 
 245:./include/linux/slab.h **** /*
 246:./include/linux/slab.h ****  * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.
 247:./include/linux/slab.h ****  *
 248:./include/linux/slab.h ****  * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault.
 249:./include/linux/slab.h ****  *
 250:./include/linux/slab.h ****  * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.
 251:./include/linux/slab.h ****  * Both make kfree a no-op.
 252:./include/linux/slab.h ****  */
 253:./include/linux/slab.h **** #define ZERO_SIZE_PTR ((void *)16)
 254:./include/linux/slab.h **** 
 255:./include/linux/slab.h **** #define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) <= \
 256:./include/linux/slab.h **** 				(unsigned long)ZERO_SIZE_PTR)
 257:./include/linux/slab.h **** 
 258:./include/linux/slab.h **** 
 259:./include/linux/slab.h **** 
 260:./include/linux/slab.h **** 
 261:./include/linux/slab.h **** 
 262:./include/linux/slab.h **** #ifdef CONFIG_SLUB_CPU_PARTIAL
 263:./include/linux/slab.h **** #define slub_percpu_partial(c)			((c)->partial)
 264:./include/linux/slab.h **** 
 265:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)		\
 266:./include/linux/slab.h **** ({						\
 267:./include/linux/slab.h **** 	slub_percpu_partial(c) = (p)->next;	\
 268:./include/linux/slab.h **** })
 269:./include/linux/slab.h **** 
 270:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	READ_ONCE(slub_percpu_partial(c))
 271:./include/linux/slab.h **** #else
 272:./include/linux/slab.h **** #define slub_percpu_partial(c)			NULL
 273:./include/linux/slab.h **** 
 274:./include/linux/slab.h **** #define slub_set_percpu_partial(c, p)
 275:./include/linux/slab.h **** 
 276:./include/linux/slab.h **** #define slub_percpu_partial_read_once(c)	NULL
 277:./include/linux/slab.h **** 
 278:./include/linux/slab.h **** 
 279:./include/linux/slab.h **** #endif // CONFIG_SLUB_CPU_PARTIAL
 280:./include/linux/slab.h **** 
 281:./include/linux/slab.h **** /*
 282:./include/linux/slab.h **** 	* Word size structure that can be atomically updated or read and that
 283:./include/linux/slab.h **** 	* contains both the order and the number of objects that a slab of the
 284:./include/linux/slab.h **** 	* given order would contain.
 285:./include/linux/slab.h **** 	*/				
 286:./include/linux/slab.h **** struct kmem_cache_order_objects {
 287:./include/linux/slab.h **** 	unsigned int x;
 288:./include/linux/slab.h **** };
 289:./include/linux/slab.h **** 
 290:./include/linux/slab.h **** struct kmem_cache_node {
 291:./include/linux/slab.h **** 	spinlock_t list_lock;
 292:./include/linux/slab.h **** 	unsigned long nr_partial;
 293:./include/linux/slab.h **** 	struct list_head partial;
 294:./include/linux/slab.h **** #ifdef CONFIG_SLUB_DEBUG
 295:./include/linux/slab.h **** 	atomic_long_t nr_slabs;
 296:./include/linux/slab.h **** 	atomic_long_t total_objects;
 297:./include/linux/slab.h **** 	struct list_head full;
 298:./include/linux/slab.h **** #endif
ARM GAS  /tmp/ccZE4dRO.s 			page 24


 299:./include/linux/slab.h **** };
 300:./include/linux/slab.h **** 
 301:./include/linux/slab.h **** struct kmem_cache {
 302:./include/linux/slab.h **** 	#ifndef CONFIG_SLUB_TINY
 303:./include/linux/slab.h **** 	//	struct kmem_cache_cpu __percpu *cpu_slab;
 304:./include/linux/slab.h **** 	#endif
 305:./include/linux/slab.h **** 		/* Used for retrieving partial slabs, etc. */
 306:./include/linux/slab.h **** 		slab_flags_t flags;
 307:./include/linux/slab.h **** 		unsigned long min_partial;
 308:./include/linux/slab.h **** 		unsigned int size;		/* Object size including metadata */
 309:./include/linux/slab.h **** 		unsigned int object_size;	/* Object size without metadata */
 310:./include/linux/slab.h **** 		struct reciprocal_value reciprocal_size;
 311:./include/linux/slab.h **** 		unsigned int offset;		/* Free pointer offset */
 312:./include/linux/slab.h **** 	#ifdef CONFIG_SLUB_CPU_PARTIAL
 313:./include/linux/slab.h **** 		/* Number of per cpu partial objects to keep around */
 314:./include/linux/slab.h **** 		unsigned int cpu_partial;
 315:./include/linux/slab.h **** 		/* Number of per cpu partial slabs to keep around */
 316:./include/linux/slab.h **** 		unsigned int cpu_partial_slabs;
 317:./include/linux/slab.h **** 	#endif
 318:./include/linux/slab.h **** 		struct kmem_cache_order_objects oo;
 319:./include/linux/slab.h **** 	
 320:./include/linux/slab.h **** 		/* Allocation and freeing of slabs */
 321:./include/linux/slab.h **** 		struct kmem_cache_order_objects min;
 322:./include/linux/slab.h **** 		gfp_t allocflags;		/* gfp flags to use on each alloc */
 323:./include/linux/slab.h **** 		int refcount;			/* Refcount for slab cache destroy */
 324:./include/linux/slab.h **** 		void (*ctor)(void *object);	/* Object constructor */
 325:./include/linux/slab.h **** 		unsigned int inuse;		/* Offset to metadata */
 326:./include/linux/slab.h **** 		unsigned int align;		/* Alignment */
 327:./include/linux/slab.h **** 		unsigned int red_left_pad;	/* Left redzone padding size */
 328:./include/linux/slab.h **** 		const char *name;		/* Name (only for display!) */
 329:./include/linux/slab.h **** 		struct list_head list;		/* List of slab caches */
 330:./include/linux/slab.h **** 	#ifdef CONFIG_SYSFS
 331:./include/linux/slab.h **** 		struct kobject kobj;		/* For sysfs */
 332:./include/linux/slab.h **** 	#endif
 333:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_HARDENED
 334:./include/linux/slab.h **** 		unsigned long random;
 335:./include/linux/slab.h **** 	#endif
 336:./include/linux/slab.h **** 	
 337:./include/linux/slab.h **** 	#ifdef CONFIG_NUMA
 338:./include/linux/slab.h **** 		/*
 339:./include/linux/slab.h **** 			* Defragmentation by allocating from a remote node.
 340:./include/linux/slab.h **** 			*/
 341:./include/linux/slab.h **** 		unsigned int remote_node_defrag_ratio;
 342:./include/linux/slab.h **** 	#endif
 343:./include/linux/slab.h **** 	
 344:./include/linux/slab.h **** 	#ifdef CONFIG_SLAB_FREELIST_RANDOM
 345:./include/linux/slab.h **** 		unsigned int *random_seq;
 346:./include/linux/slab.h **** 	#endif
 347:./include/linux/slab.h **** 	
 348:./include/linux/slab.h **** 	#ifdef CONFIG_KASAN_GENERIC
 349:./include/linux/slab.h **** 		struct kasan_cache kasan_info;
 350:./include/linux/slab.h **** 	#endif
 351:./include/linux/slab.h **** 	
 352:./include/linux/slab.h **** 	#ifdef CONFIG_HARDENED_USERCOPY
 353:./include/linux/slab.h **** 		unsigned int useroffset;	/* Usercopy region offset */
 354:./include/linux/slab.h **** 		unsigned int usersize;		/* Usercopy region size */
 355:./include/linux/slab.h **** 	#endif
ARM GAS  /tmp/ccZE4dRO.s 			page 25


 356:./include/linux/slab.h **** 	
 357:./include/linux/slab.h **** 		struct kmem_cache_node *node[MAX_NUMNODES];
 358:./include/linux/slab.h **** 	};
 359:./include/linux/slab.h **** 					
 360:./include/linux/slab.h **** 
 361:./include/linux/slab.h **** 
 362:./include/linux/slab.h **** 
 363:./include/linux/slab.h **** 
 364:./include/linux/slab.h **** #define KMALLOC_WAIT 1
 365:./include/linux/slab.h **** 
 366:./include/linux/slab.h **** 
 367:./include/linux/slab.h **** extern void* __smalloc__(u32 size, gfp_t flags);
 368:./include/linux/slab.h **** extern void  __sfree__(void* addr);
 369:./include/linux/slab.h **** 
 370:./include/linux/slab.h **** 
 371:./include/linux/slab.h **** static void inline *vmalloc(unsigned long size){
 372:./include/linux/slab.h **** 	return __smalloc__(size,GFP_TRANSHUGE_LIGHT);
 373:./include/linux/slab.h **** }
 374:./include/linux/slab.h **** 
 375:./include/linux/slab.h **** static void inline vfree(void *addr){
 376:./include/linux/slab.h **** 	__sfree__(addr);
 377:./include/linux/slab.h **** }
 378:./include/linux/slab.h **** 
 379:./include/linux/slab.h **** static void inline *kmalloc(size_t size, gfp_t flags){
 380:./include/linux/slab.h **** 	return __smalloc__((u32)size,flags);
 381:./include/linux/slab.h **** }
 382:./include/linux/slab.h **** 
 383:./include/linux/slab.h **** static void inline kfree(const void *ptr){
 384:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 385:./include/linux/slab.h **** }
 386:./include/linux/slab.h **** 
 387:./include/linux/slab.h **** 
 388:./include/linux/slab.h **** 
 389:./include/linux/slab.h **** static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags){
 390:./include/linux/slab.h **** 	return kmalloc(n * size, flags);
 391:./include/linux/slab.h **** }
 392:./include/linux/slab.h **** 
 393:./include/linux/slab.h **** 
 394:./include/linux/slab.h **** static void kfree_array(void **ptr,int n){
 395:./include/linux/slab.h **** 	int i;
 396:./include/linux/slab.h **** 	if (ptr) {
 397:./include/linux/slab.h **** 		for (i = 0; i < n; i++) {
 398:./include/linux/slab.h **** 			__sfree__(ptr[i]);
 399:./include/linux/slab.h **** 		}
 400:./include/linux/slab.h **** 		__sfree__(ptr);
 401:./include/linux/slab.h **** 	}
 402:./include/linux/slab.h **** }
 403:./include/linux/slab.h **** 
 404:./include/linux/slab.h **** static inline void* kmalloc_node_noprof(size_t size, gfp_t flags, int node)
 405:./include/linux/slab.h **** {
 406:./include/linux/slab.h ****     return kmalloc((u32)size,flags);
 407:./include/linux/slab.h **** }
 408:./include/linux/slab.h **** 
 409:./include/linux/slab.h **** 
 410:./include/linux/slab.h **** static void inline *kzalloc(size_t size, gfp_t flags){
 494              		.loc 3 410 54 is_stmt 1 view -0
 495              		.cfi_startproc
ARM GAS  /tmp/ccZE4dRO.s 			page 26


 496              		@ args = 0, pretend = 0, frame = 0
 497              		@ frame_needed = 0, uses_anonymous_args = 0
 498              		.loc 3 410 54 is_stmt 0 view .LVU137
 499 0000 38B5     		push	{r3, r4, r5, lr}
 500              	.LCFI9:
 501              		.cfi_def_cfa_offset 16
 502              		.cfi_offset 3, -16
 503              		.cfi_offset 4, -12
 504              		.cfi_offset 5, -8
 505              		.cfi_offset 14, -4
 506 0002 0546     		mov	r5, r0
 411:./include/linux/slab.h **** 	void* data = __smalloc__((u32)size,flags);
 507              		.loc 3 411 2 is_stmt 1 view .LVU138
 508              		.loc 3 411 15 is_stmt 0 view .LVU139
 509 0004 FFF7FEFF 		bl	__smalloc__
 510              	.LVL44:
 511              		.loc 3 411 15 view .LVU140
 512 0008 0446     		mov	r4, r0
 513              	.LVL45:
 412:./include/linux/slab.h **** 	memset(data,0,size);
 514              		.loc 3 412 2 is_stmt 1 view .LVU141
 515 000a 2A46     		mov	r2, r5
 516 000c 0021     		movs	r1, #0
 517 000e FFF7FEFF 		bl	memset
 518              	.LVL46:
 413:./include/linux/slab.h **** 	return data;
 519              		.loc 3 413 2 view .LVU142
 414:./include/linux/slab.h **** }
 520              		.loc 3 414 1 is_stmt 0 view .LVU143
 521 0012 2046     		mov	r0, r4
 522 0014 38BD     		pop	{r3, r4, r5, pc}
 523              		.loc 3 414 1 view .LVU144
 524              		.cfi_endproc
 525              	.LFE332:
 527              		.section	.text.cdev_alloc,"ax",%progbits
 528              		.align	1
 529              		.global	cdev_alloc
 530              		.syntax unified
 531              		.thumb
 532              		.thumb_func
 534              	cdev_alloc:
 535              	.LFB1046:
 378:./fs/char_device.c **** 	struct cdev *p = kzalloc(sizeof(struct cdev), GFP_KERNEL);
 536              		.loc 1 378 1 is_stmt 1 view -0
 537              		.cfi_startproc
 538              		@ args = 0, pretend = 0, frame = 0
 539              		@ frame_needed = 0, uses_anonymous_args = 0
 540 0000 08B5     		push	{r3, lr}
 541              	.LCFI10:
 542              		.cfi_def_cfa_offset 8
 543              		.cfi_offset 3, -8
 544              		.cfi_offset 14, -4
 379:./fs/char_device.c **** 	if (p) {
 545              		.loc 1 379 2 view .LVU146
 379:./fs/char_device.c **** 	if (p) {
 546              		.loc 1 379 19 is_stmt 0 view .LVU147
 547 0002 4FF44C61 		mov	r1, #3264
ARM GAS  /tmp/ccZE4dRO.s 			page 27


 548 0006 1820     		movs	r0, #24
 549 0008 FFF7FEFF 		bl	kzalloc
 550              	.LVL47:
 380:./fs/char_device.c **** 		INIT_LIST_HEAD(&p->list);
 551              		.loc 1 380 2 is_stmt 1 view .LVU148
 380:./fs/char_device.c **** 		INIT_LIST_HEAD(&p->list);
 552              		.loc 1 380 5 is_stmt 0 view .LVU149
 553 000c 0346     		mov	r3, r0
 554 000e 18B1     		cbz	r0, .L55
 381:./fs/char_device.c **** 		// kobject_init(&p->kobj, &ktype_cdev_dynamic);
 555              		.loc 1 381 3 is_stmt 1 view .LVU150
 556 0010 00F10802 		add	r2, r0, #8
 557              	.LVL48:
 558              	.LBB74:
 559              	.LBI74:
 560              		.file 4 "./include/linux/list.h"
   1:./include/linux/list.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/list.h **** #ifndef _LINUX_LIST_H
   3:./include/linux/list.h **** #define _LINUX_LIST_H
   4:./include/linux/list.h **** 
   5:./include/linux/list.h **** #include <linux/container_of.h>
   6:./include/linux/list.h **** #include <linux/types.h>
   7:./include/linux/list.h **** #include <linux/stddef.h>
   8:./include/linux/list.h **** #include <linux/poison.h>
   9:./include/linux/list.h **** #include <linux/const.h>
  10:./include/linux/list.h **** 
  11:./include/linux/list.h **** #include <asm/barrier.h>
  12:./include/linux/list.h **** #include <linux/rwonce.h>
  13:./include/linux/list.h **** /*
  14:./include/linux/list.h ****  * Circular doubly linked list implementation.
  15:./include/linux/list.h ****  *
  16:./include/linux/list.h ****  * Some of the internal functions ("__xxx") are useful when
  17:./include/linux/list.h ****  * manipulating whole lists rather than single entries, as
  18:./include/linux/list.h ****  * sometimes we already know the next/prev entries and we can
  19:./include/linux/list.h ****  * generate better code by using them directly rather than
  20:./include/linux/list.h ****  * using the generic single-entry routines.
  21:./include/linux/list.h ****  */
  22:./include/linux/list.h **** 
  23:./include/linux/list.h **** #define LIST_HEAD_INIT(name) { &(name), &(name) }
  24:./include/linux/list.h **** 
  25:./include/linux/list.h **** #define LIST_HEAD(name) \
  26:./include/linux/list.h **** 	struct list_head name = LIST_HEAD_INIT(name)
  27:./include/linux/list.h **** 
  28:./include/linux/list.h **** /**
  29:./include/linux/list.h ****  * INIT_LIST_HEAD - Initialize a list_head structure
  30:./include/linux/list.h ****  * @list: list_head structure to be initialized.
  31:./include/linux/list.h ****  *
  32:./include/linux/list.h ****  * Initializes the list_head to point to itself.  If it is a list header,
  33:./include/linux/list.h ****  * the result is an empty list.
  34:./include/linux/list.h ****  */
  35:./include/linux/list.h **** static inline void INIT_LIST_HEAD(struct list_head *list)
 561              		.loc 4 35 20 view .LVU151
 562              	.LBB75:
  36:./include/linux/list.h **** {
  37:./include/linux/list.h **** 	WRITE_ONCE(list->next, list);
 563              		.loc 4 37 2 view .LVU152
 564              		.loc 4 37 2 view .LVU153
ARM GAS  /tmp/ccZE4dRO.s 			page 28


 565              	.LBB76:
 566              		.loc 4 37 2 view .LVU154
 567              		.loc 4 37 2 view .LVU155
 568              	.LBE76:
 569              		.loc 4 37 2 discriminator 2 view .LVU156
 570              		.loc 4 37 2 discriminator 2 view .LVU157
 571              		.loc 4 37 2 discriminator 2 view .LVU158
 572 0014 8260     		str	r2, [r0, #8]
 573              		.loc 4 37 2 discriminator 2 view .LVU159
 574              		.loc 4 37 2 discriminator 2 view .LVU160
  38:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 575              		.loc 4 38 2 view .LVU161
 576              		.loc 4 38 2 view .LVU162
 577              	.LBB77:
 578              		.loc 4 38 2 view .LVU163
 579              		.loc 4 38 2 view .LVU164
 580              	.LBE77:
 581              		.loc 4 38 2 discriminator 2 view .LVU165
 582              		.loc 4 38 2 discriminator 2 view .LVU166
 583              		.loc 4 38 2 discriminator 2 view .LVU167
 584 0016 C260     		str	r2, [r0, #12]
 585              		.loc 4 38 2 discriminator 2 view .LVU168
 586              		.loc 4 38 2 discriminator 2 view .LVU169
 587              	.LVL49:
 588              		.loc 4 38 2 is_stmt 0 discriminator 2 view .LVU170
 589              	.LBE75:
 590              	.LBE74:
 384:./fs/char_device.c **** } 
 591              		.loc 1 384 2 is_stmt 1 view .LVU171
 592              	.L55:
 385:./fs/char_device.c **** 
 593              		.loc 1 385 1 is_stmt 0 view .LVU172
 594 0018 1846     		mov	r0, r3
 595              	.LVL50:
 385:./fs/char_device.c **** 
 596              		.loc 1 385 1 view .LVU173
 597 001a 08BD     		pop	{r3, pc}
 385:./fs/char_device.c **** 
 598              		.loc 1 385 1 view .LVU174
 599              		.cfi_endproc
 600              	.LFE1046:
 602              		.section	.text.cdev_init,"ax",%progbits
 603              		.align	1
 604              		.global	cdev_init
 605              		.syntax unified
 606              		.thumb
 607              		.thumb_func
 609              	cdev_init:
 610              	.LVL51:
 611              	.LFB1047:
 396:./fs/char_device.c **** 	memset(cdev, 0, sizeof *cdev);
 612              		.loc 1 396 1 is_stmt 1 view -0
 613              		.cfi_startproc
 614              		@ args = 0, pretend = 0, frame = 0
 615              		@ frame_needed = 0, uses_anonymous_args = 0
 616              		@ link register save eliminated.
 397:./fs/char_device.c **** 	INIT_LIST_HEAD(&cdev->list);
ARM GAS  /tmp/ccZE4dRO.s 			page 29


 617              		.loc 1 397 2 view .LVU176
 618 0000 0023     		movs	r3, #0
 619 0002 0360     		str	r3, [r0]	@ unaligned
 620 0004 4360     		str	r3, [r0, #4]	@ unaligned
 621 0006 8360     		str	r3, [r0, #8]	@ unaligned
 622 0008 C360     		str	r3, [r0, #12]	@ unaligned
 623 000a 0361     		str	r3, [r0, #16]	@ unaligned
 624 000c 4361     		str	r3, [r0, #20]	@ unaligned
 398:./fs/char_device.c **** 	// kobject_init(&cdev->kobj, &ktype_cdev_default);
 625              		.loc 1 398 2 view .LVU177
 626 000e 00F10803 		add	r3, r0, #8
 627              	.LVL52:
 628              	.LBB78:
 629              	.LBI78:
  35:./include/linux/list.h **** {
 630              		.loc 4 35 20 view .LVU178
 631              	.LBB79:
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 632              		.loc 4 37 2 view .LVU179
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 633              		.loc 4 37 2 view .LVU180
 634              	.LBB80:
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 635              		.loc 4 37 2 view .LVU181
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 636              		.loc 4 37 2 view .LVU182
 637              	.LBE80:
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 638              		.loc 4 37 2 discriminator 2 view .LVU183
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 639              		.loc 4 37 2 discriminator 2 view .LVU184
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 640              		.loc 4 37 2 discriminator 2 view .LVU185
 641 0012 8360     		str	r3, [r0, #8]
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 642              		.loc 4 37 2 discriminator 2 view .LVU186
  37:./include/linux/list.h **** 	WRITE_ONCE(list->prev, list);
 643              		.loc 4 37 2 discriminator 2 view .LVU187
 644              		.loc 4 38 2 view .LVU188
 645              		.loc 4 38 2 view .LVU189
 646              	.LBB81:
 647              		.loc 4 38 2 view .LVU190
 648              		.loc 4 38 2 view .LVU191
 649              	.LBE81:
 650              		.loc 4 38 2 discriminator 2 view .LVU192
 651              		.loc 4 38 2 discriminator 2 view .LVU193
 652              		.loc 4 38 2 discriminator 2 view .LVU194
 653 0014 C360     		str	r3, [r0, #12]
 654              		.loc 4 38 2 discriminator 2 view .LVU195
 655              		.loc 4 38 2 discriminator 2 view .LVU196
 656              	.LVL53:
 657              		.loc 4 38 2 is_stmt 0 discriminator 2 view .LVU197
 658              	.LBE79:
 659              	.LBE78:
 400:./fs/char_device.c **** }
 660              		.loc 1 400 2 is_stmt 1 view .LVU198
 400:./fs/char_device.c **** }
ARM GAS  /tmp/ccZE4dRO.s 			page 30


 661              		.loc 1 400 12 is_stmt 0 view .LVU199
 662 0016 4160     		str	r1, [r0, #4]
 401:./fs/char_device.c **** 
 663              		.loc 1 401 1 view .LVU200
 664 0018 7047     		bx	lr
 665              		.cfi_endproc
 666              	.LFE1047:
 668              		.section	.rodata.__register_chrdev_region.str1.4,"aMS",%progbits,1
 669              		.align	2
 670              	.LC0:
 671 0000 43485244 		.ascii	"CHRDEV \"%s\" major requested (%u) is greater than "
 671      45562022 
 671      25732220 
 671      6D616A6F 
 671      72207265 
 672 0031 74686520 		.ascii	"the maximum (%u)\012\000"
 672      6D617869 
 672      6D756D20 
 672      28257529 
 672      0A00
 673 0043 00       		.align	2
 674              	.LC1:
 675 0044 43485244 		.ascii	"CHRDEV \"%s\" minor range requested (%u-%u) is out "
 675      45562022 
 675      25732220 
 675      6D696E6F 
 675      72207261 
 676 0075 6F662072 		.ascii	"of range of maximum range (%u-%u) for a single majo"
 676      616E6765 
 676      206F6620 
 676      6D617869 
 676      6D756D20 
 677 00a8 720A00   		.ascii	"r\012\000"
 678 00ab 00       		.align	2
 679              	.LC2:
 680 00ac 43485244 		.ascii	"CHRDEV \"%s\" dynamic allocation region is full\012"
 680      45562022 
 680      25732220 
 680      64796E61 
 680      6D696320 
 681 00da 00       		.ascii	"\000"
 682              		.section	.text.__register_chrdev_region,"ax",%progbits
 683              		.align	1
 684              		.syntax unified
 685              		.thumb
 686              		.thumb_func
 688              	__register_chrdev_region:
 689              	.LVL54:
 690              	.LFB1037:
  67:./fs/char_device.c **** 	struct char_device_struct *cd, *curr, *prev = NULL;
 691              		.loc 1 67 1 is_stmt 1 view -0
 692              		.cfi_startproc
 693              		@ args = 0, pretend = 0, frame = 0
 694              		@ frame_needed = 0, uses_anonymous_args = 0
  67:./fs/char_device.c **** 	struct char_device_struct *cd, *curr, *prev = NULL;
 695              		.loc 1 67 1 is_stmt 0 view .LVU202
 696 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
ARM GAS  /tmp/ccZE4dRO.s 			page 31


 697              	.LCFI11:
 698              		.cfi_def_cfa_offset 36
 699              		.cfi_offset 4, -36
 700              		.cfi_offset 5, -32
 701              		.cfi_offset 6, -28
 702              		.cfi_offset 7, -24
 703              		.cfi_offset 8, -20
 704              		.cfi_offset 9, -16
 705              		.cfi_offset 10, -12
 706              		.cfi_offset 11, -8
 707              		.cfi_offset 14, -4
 708 0004 83B0     		sub	sp, sp, #12
 709              	.LCFI12:
 710              		.cfi_def_cfa_offset 48
 711 0006 0446     		mov	r4, r0
 712 0008 9946     		mov	r9, r3
  68:./fs/char_device.c **** 	int ret;
 713              		.loc 1 68 2 is_stmt 1 view .LVU203
 714              	.LVL55:
  69:./fs/char_device.c **** 	int i;
 715              		.loc 1 69 2 view .LVU204
  70:./fs/char_device.c **** 
 716              		.loc 1 70 2 view .LVU205
  72:./fs/char_device.c **** 		pr_err("CHRDEV \"%s\" major requested (%u) is greater than the maximum (%u)\n",
 717              		.loc 1 72 2 view .LVU206
  72:./fs/char_device.c **** 		pr_err("CHRDEV \"%s\" major requested (%u) is greater than the maximum (%u)\n",
 718              		.loc 1 72 5 is_stmt 0 view .LVU207
 719 000a B0F5007F 		cmp	r0, #512
 720 000e 1ED2     		bcs	.L73
 721 0010 0E46     		mov	r6, r1
 722 0012 1746     		mov	r7, r2
  78:./fs/char_device.c **** 		pr_err("CHRDEV \"%s\" minor range requested (%u-%u) is out of range of maximum range (%u-%u) for 
 723              		.loc 1 78 2 is_stmt 1 view .LVU208
  78:./fs/char_device.c **** 		pr_err("CHRDEV \"%s\" minor range requested (%u-%u) is out of range of maximum range (%u-%u) for 
 724              		.loc 1 78 30 is_stmt 0 view .LVU209
 725 0014 C1F58013 		rsb	r3, r1, #1048576
 726              	.LVL56:
  78:./fs/char_device.c **** 		pr_err("CHRDEV \"%s\" minor range requested (%u-%u) is out of range of maximum range (%u-%u) for 
 727              		.loc 1 78 5 view .LVU210
 728 0018 9342     		cmp	r3, r2
 729 001a 22D3     		bcc	.L74
  84:./fs/char_device.c **** 	if (cd == NULL)
 730              		.loc 1 84 2 is_stmt 1 view .LVU211
  84:./fs/char_device.c **** 	if (cd == NULL)
 731              		.loc 1 84 7 is_stmt 0 view .LVU212
 732 001c 4FF44C61 		mov	r1, #3264
 733              	.LVL57:
  84:./fs/char_device.c **** 	if (cd == NULL)
 734              		.loc 1 84 7 view .LVU213
 735 0020 5420     		movs	r0, #84
 736              	.LVL58:
  84:./fs/char_device.c **** 	if (cd == NULL)
 737              		.loc 1 84 7 view .LVU214
 738 0022 FFF7FEFF 		bl	kzalloc
 739              	.LVL59:
  85:./fs/char_device.c **** 		return ERR_PTR(-ENOMEM);
 740              		.loc 1 85 2 is_stmt 1 view .LVU215
ARM GAS  /tmp/ccZE4dRO.s 			page 32


  85:./fs/char_device.c **** 		return ERR_PTR(-ENOMEM);
 741              		.loc 1 85 5 is_stmt 0 view .LVU216
 742 0026 8046     		mov	r8, r0
 743 0028 0028     		cmp	r0, #0
 744 002a 6CD0     		beq	.L71
  88:./fs/char_device.c **** 
 745              		.loc 1 88 2 is_stmt 1 view .LVU217
  90:./fs/char_device.c **** 		ret = find_dynamic_major();
 746              		.loc 1 90 2 view .LVU218
  90:./fs/char_device.c **** 		ret = find_dynamic_major();
 747              		.loc 1 90 5 is_stmt 0 view .LVU219
 748 002c 54B3     		cbz	r4, .L75
 749              	.LVL60:
 750              	.L63:
 100:./fs/char_device.c **** 	i = major_to_index(major);
 751              		.loc 1 100 2 is_stmt 1 view .LVU220
 101:./fs/char_device.c **** 	for (curr = chrdevs[i]; curr; prev = curr, curr = curr->next) {
 752              		.loc 1 101 2 view .LVU221
 753              	.LBB82:
 754              	.LBI82:
  33:./fs/char_device.c **** {
 755              		.loc 1 33 19 view .LVU222
 756              	.LBB83:
  35:./fs/char_device.c **** }
 757              		.loc 1 35 2 view .LVU223
  35:./fs/char_device.c **** }
 758              		.loc 1 35 15 is_stmt 0 view .LVU224
 759 002e 374D     		ldr	r5, .L78
 760 0030 A5FB0435 		umull	r3, r5, r5, r4
 761 0034 631B     		subs	r3, r4, r5
 762 0036 05EB5305 		add	r5, r5, r3, lsr #1
 763 003a AD09     		lsrs	r5, r5, #6
 764 003c C5EBC515 		rsb	r5, r5, r5, lsl #7
 765 0040 651B     		subs	r5, r4, r5
 766              	.LVL61:
  35:./fs/char_device.c **** }
 767              		.loc 1 35 15 view .LVU225
 768              	.LBE83:
 769              	.LBE82:
 102:./fs/char_device.c **** 		if (curr->major < major)
 770              		.loc 1 102 2 is_stmt 1 view .LVU226
 102:./fs/char_device.c **** 		if (curr->major < major)
 771              		.loc 1 102 12 is_stmt 0 view .LVU227
 772 0042 334B     		ldr	r3, .L78+4
 773 0044 53F825A0 		ldr	r10, [r3, r5, lsl #2]
 774              	.LVL62:
  68:./fs/char_device.c **** 	int ret;
 775              		.loc 1 68 41 view .LVU228
 776 0048 4FF0000B 		mov	fp, #0
 102:./fs/char_device.c **** 		if (curr->major < major)
 777              		.loc 1 102 2 view .LVU229
 778 004c 2DE0     		b	.L66
 779              	.LVL63:
 780              	.L73:
  73:./fs/char_device.c **** 		       name, major, CHRDEV_MAJOR_MAX-1);
 781              		.loc 1 73 3 is_stmt 1 view .LVU230
 782 004e 40F2FF13 		movw	r3, #511
ARM GAS  /tmp/ccZE4dRO.s 			page 33


 783              	.LVL64:
  73:./fs/char_device.c **** 		       name, major, CHRDEV_MAJOR_MAX-1);
 784              		.loc 1 73 3 is_stmt 0 view .LVU231
 785 0052 0246     		mov	r2, r0
 786              	.LVL65:
  73:./fs/char_device.c **** 		       name, major, CHRDEV_MAJOR_MAX-1);
 787              		.loc 1 73 3 view .LVU232
 788 0054 4946     		mov	r1, r9
 789              	.LVL66:
  73:./fs/char_device.c **** 		       name, major, CHRDEV_MAJOR_MAX-1);
 790              		.loc 1 73 3 view .LVU233
 791 0056 2F48     		ldr	r0, .L78+8
 792              	.LVL67:
  73:./fs/char_device.c **** 		       name, major, CHRDEV_MAJOR_MAX-1);
 793              		.loc 1 73 3 view .LVU234
 794 0058 FFF7FEFF 		bl	printk
 795              	.LVL68:
  75:./fs/char_device.c **** 	}
 796              		.loc 1 75 3 is_stmt 1 view .LVU235
  75:./fs/char_device.c **** 	}
 797              		.loc 1 75 10 is_stmt 0 view .LVU236
 798 005c 6FF01508 		mvn	r8, #21
 799 0060 0CE0     		b	.L59
 800              	.LVL69:
 801              	.L74:
  79:./fs/char_device.c **** 			name, baseminor, baseminor + minorct - 1, 0, MINORMASK);
 802              		.loc 1 79 3 is_stmt 1 view .LVU237
 803 0062 5318     		adds	r3, r2, r1
 804 0064 2C4A     		ldr	r2, .L78+12
 805              	.LVL70:
  79:./fs/char_device.c **** 			name, baseminor, baseminor + minorct - 1, 0, MINORMASK);
 806              		.loc 1 79 3 is_stmt 0 view .LVU238
 807 0066 0192     		str	r2, [sp, #4]
 808 0068 0022     		movs	r2, #0
 809 006a 0092     		str	r2, [sp]
 810 006c 013B     		subs	r3, r3, #1
 811 006e 0A46     		mov	r2, r1
 812 0070 4946     		mov	r1, r9
 813              	.LVL71:
  79:./fs/char_device.c **** 			name, baseminor, baseminor + minorct - 1, 0, MINORMASK);
 814              		.loc 1 79 3 view .LVU239
 815 0072 2A48     		ldr	r0, .L78+16
 816              	.LVL72:
  79:./fs/char_device.c **** 			name, baseminor, baseminor + minorct - 1, 0, MINORMASK);
 817              		.loc 1 79 3 view .LVU240
 818 0074 FFF7FEFF 		bl	printk
 819              	.LVL73:
  81:./fs/char_device.c **** 	}
 820              		.loc 1 81 3 is_stmt 1 view .LVU241
  81:./fs/char_device.c **** 	}
 821              		.loc 1 81 10 is_stmt 0 view .LVU242
 822 0078 6FF01508 		mvn	r8, #21
 823              	.LVL74:
 824              	.L59:
 137:./fs/char_device.c **** 
 825              		.loc 1 137 1 view .LVU243
 826 007c 4046     		mov	r0, r8
ARM GAS  /tmp/ccZE4dRO.s 			page 34


 827 007e 03B0     		add	sp, sp, #12
 828              	.LCFI13:
 829              		.cfi_remember_state
 830              		.cfi_def_cfa_offset 36
 831              		@ sp needed
 832 0080 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 833              	.LVL75:
 834              	.L75:
 835              	.LCFI14:
 836              		.cfi_restore_state
  91:./fs/char_device.c **** 		if (ret < 0) {
 837              		.loc 1 91 3 is_stmt 1 view .LVU244
  91:./fs/char_device.c **** 		if (ret < 0) {
 838              		.loc 1 91 9 is_stmt 0 view .LVU245
 839 0084 FFF7FEFF 		bl	find_dynamic_major
 840              	.LVL76:
  92:./fs/char_device.c **** 			pr_err("CHRDEV \"%s\" dynamic allocation region is full\n",
 841              		.loc 1 92 3 is_stmt 1 view .LVU246
  92:./fs/char_device.c **** 			pr_err("CHRDEV \"%s\" dynamic allocation region is full\n",
 842              		.loc 1 92 6 is_stmt 0 view .LVU247
 843 0088 041E     		subs	r4, r0, #0
 844              	.LVL77:
  92:./fs/char_device.c **** 			pr_err("CHRDEV \"%s\" dynamic allocation region is full\n",
 845              		.loc 1 92 6 view .LVU248
 846 008a D0DA     		bge	.L63
  93:./fs/char_device.c **** 			       name);
 847              		.loc 1 93 4 is_stmt 1 view .LVU249
 848 008c 4946     		mov	r1, r9
 849 008e 2448     		ldr	r0, .L78+20
 850              	.LVL78:
  93:./fs/char_device.c **** 			       name);
 851              		.loc 1 93 4 is_stmt 0 view .LVU250
 852 0090 FFF7FEFF 		bl	printk
 853              	.LVL79:
  95:./fs/char_device.c **** 		}
 854              		.loc 1 95 4 is_stmt 1 view .LVU251
 855 0094 01E0     		b	.L65
 856              	.LVL80:
 857              	.L76:
 100:./fs/char_device.c **** 	i = major_to_index(major);
 858              		.loc 1 100 6 is_stmt 0 view .LVU252
 859 0096 6FF00F04 		mvn	r4, #15
 860              	.LVL81:
 861              	.L65:
 134:./fs/char_device.c **** 	kfree(cd);
 862              		.loc 1 134 2 is_stmt 1 view .LVU253
 135:./fs/char_device.c **** 	return ERR_PTR(ret);
 863              		.loc 1 135 2 view .LVU254
 864              	.LBB84:
 865              	.LBI84:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 866              		.loc 3 383 20 view .LVU255
 867              	.LBB85:
 384:./include/linux/slab.h **** }
 868              		.loc 3 384 2 view .LVU256
 869 009a 4046     		mov	r0, r8
 870 009c FFF7FEFF 		bl	__sfree__
ARM GAS  /tmp/ccZE4dRO.s 			page 35


 871              	.LVL82:
 384:./include/linux/slab.h **** }
 872              		.loc 3 384 2 is_stmt 0 view .LVU257
 873              	.LBE85:
 874              	.LBE84:
 136:./fs/char_device.c **** }
 875              		.loc 1 136 2 is_stmt 1 view .LVU258
 876              	.LBB86:
 877              	.LBI86:
 878              		.file 5 "./include/linux/err.h"
   1:./include/linux/err.h **** /* SPDX-License-Identifier: GPL-2.0 */
   2:./include/linux/err.h **** #ifndef _LINUX_ERR_H
   3:./include/linux/err.h **** #define _LINUX_ERR_H
   4:./include/linux/err.h **** 
   5:./include/linux/err.h **** #include <linux/compiler_attributes.h>
   6:./include/linux/err.h **** #include <linux/compiler.h>
   7:./include/linux/err.h **** #include <linux/types.h>
   8:./include/linux/err.h **** 
   9:./include/linux/err.h **** #include <asm/errno.h>
  10:./include/linux/err.h **** 
  11:./include/linux/err.h **** /*
  12:./include/linux/err.h ****  * Kernel pointers have redundant information, so we can use a
  13:./include/linux/err.h ****  * scheme where we can return either an error code or a normal
  14:./include/linux/err.h ****  * pointer with the same return value.
  15:./include/linux/err.h ****  *
  16:./include/linux/err.h ****  * This should be a per-architecture thing, to allow different
  17:./include/linux/err.h ****  * error and pointer decisions.
  18:./include/linux/err.h ****  */
  19:./include/linux/err.h **** #define MAX_ERRNO	4095
  20:./include/linux/err.h **** 
  21:./include/linux/err.h **** #ifndef __ASSEMBLY__
  22:./include/linux/err.h **** 
  23:./include/linux/err.h **** /**
  24:./include/linux/err.h ****  * IS_ERR_VALUE - Detect an error pointer.
  25:./include/linux/err.h ****  * @x: The pointer to check.
  26:./include/linux/err.h ****  *
  27:./include/linux/err.h ****  * Like IS_ERR(), but does not generate a compiler warning if result is unused.
  28:./include/linux/err.h ****  */
  29:./include/linux/err.h **** 
  30:./include/linux/err.h **** #ifndef unlikely
  31:./include/linux/err.h **** #  define unlikely(x) __builtin_expect(!!(x), 0)
  32:./include/linux/err.h **** #endif
  33:./include/linux/err.h **** 
  34:./include/linux/err.h **** #ifndef likely
  35:./include/linux/err.h **** #  define likely(x) __builtin_expect(!!(x), 1)
  36:./include/linux/err.h **** #endif
  37:./include/linux/err.h **** 
  38:./include/linux/err.h **** #define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)
  39:./include/linux/err.h **** 
  40:./include/linux/err.h **** /**
  41:./include/linux/err.h ****  * ERR_PTR - Create an error pointer.
  42:./include/linux/err.h ****  * @error: A negative error code.
  43:./include/linux/err.h ****  *
  44:./include/linux/err.h ****  * Encodes @error into a pointer value. Users should consider the result
  45:./include/linux/err.h ****  * opaque and not assume anything about how the error is encoded.
  46:./include/linux/err.h ****  *
  47:./include/linux/err.h ****  * Return: A pointer with @error encoded within its value.
ARM GAS  /tmp/ccZE4dRO.s 			page 36


  48:./include/linux/err.h ****  */
  49:./include/linux/err.h **** static inline void * __must_check ERR_PTR(long error)
 879              		.loc 5 49 35 view .LVU259
 880              	.LBB87:
  50:./include/linux/err.h **** {
  51:./include/linux/err.h **** 	return (void *) error;
 881              		.loc 5 51 2 view .LVU260
 882              		.loc 5 51 9 is_stmt 0 view .LVU261
 883 00a0 A046     		mov	r8, r4
 884              	.LVL83:
 885              		.loc 5 51 9 view .LVU262
 886              	.LBE87:
 887              	.LBE86:
 136:./fs/char_device.c **** }
 888              		.loc 1 136 9 view .LVU263
 889 00a2 EBE7     		b	.L59
 890              	.LVL84:
 891              	.L67:
 102:./fs/char_device.c **** 		if (curr->major < major)
 892              		.loc 1 102 43 is_stmt 1 discriminator 2 view .LVU264
 102:./fs/char_device.c **** 		if (curr->major < major)
 893              		.loc 1 102 37 is_stmt 0 discriminator 2 view .LVU265
 894 00a4 D346     		mov	fp, r10
 102:./fs/char_device.c **** 		if (curr->major < major)
 895              		.loc 1 102 50 discriminator 2 view .LVU266
 896 00a6 DAF800A0 		ldr	r10, [r10]
 897              	.LVL85:
 898              	.L66:
 102:./fs/char_device.c **** 		if (curr->major < major)
 899              		.loc 1 102 26 is_stmt 1 discriminator 1 view .LVU267
 900 00aa BAF1000F 		cmp	r10, #0
 901 00ae 0ED0     		beq	.L68
 103:./fs/char_device.c **** 			continue;
 902              		.loc 1 103 3 view .LVU268
 103:./fs/char_device.c **** 			continue;
 903              		.loc 1 103 11 is_stmt 0 view .LVU269
 904 00b0 DAF80430 		ldr	r3, [r10, #4]
 103:./fs/char_device.c **** 			continue;
 905              		.loc 1 103 6 view .LVU270
 906 00b4 A342     		cmp	r3, r4
 907 00b6 F5D3     		bcc	.L67
 106:./fs/char_device.c **** 			break;
 908              		.loc 1 106 3 is_stmt 1 view .LVU271
 106:./fs/char_device.c **** 			break;
 909              		.loc 1 106 6 is_stmt 0 view .LVU272
 910 00b8 09D8     		bhi	.L68
 109:./fs/char_device.c **** 			continue;
 911              		.loc 1 109 3 is_stmt 1 view .LVU273
 109:./fs/char_device.c **** 			continue;
 912              		.loc 1 109 11 is_stmt 0 view .LVU274
 913 00ba DAF80820 		ldr	r2, [r10, #8]
 109:./fs/char_device.c **** 			continue;
 914              		.loc 1 109 29 view .LVU275
 915 00be DAF80C30 		ldr	r3, [r10, #12]
 109:./fs/char_device.c **** 			continue;
 916              		.loc 1 109 23 view .LVU276
 917 00c2 1344     		add	r3, r3, r2
ARM GAS  /tmp/ccZE4dRO.s 			page 37


 109:./fs/char_device.c **** 			continue;
 918              		.loc 1 109 6 view .LVU277
 919 00c4 B342     		cmp	r3, r6
 920 00c6 EDD9     		bls	.L67
 112:./fs/char_device.c **** 			break;
 921              		.loc 1 112 3 is_stmt 1 view .LVU278
 112:./fs/char_device.c **** 			break;
 922              		.loc 1 112 36 is_stmt 0 view .LVU279
 923 00c8 BB19     		adds	r3, r7, r6
 112:./fs/char_device.c **** 			break;
 924              		.loc 1 112 6 view .LVU280
 925 00ca 9A42     		cmp	r2, r3
 926 00cc E3D3     		bcc	.L76
 927              	.L68:
 118:./fs/char_device.c **** 	cd->baseminor = baseminor;
 928              		.loc 1 118 2 is_stmt 1 view .LVU281
 118:./fs/char_device.c **** 	cd->baseminor = baseminor;
 929              		.loc 1 118 12 is_stmt 0 view .LVU282
 930 00ce C8F80440 		str	r4, [r8, #4]
 119:./fs/char_device.c **** 	cd->minorct = minorct;
 931              		.loc 1 119 2 is_stmt 1 view .LVU283
 119:./fs/char_device.c **** 	cd->minorct = minorct;
 932              		.loc 1 119 16 is_stmt 0 view .LVU284
 933 00d2 C8F80860 		str	r6, [r8, #8]
 120:./fs/char_device.c **** 	strscpy(cd->name, name, sizeof(cd->name));
 934              		.loc 1 120 2 is_stmt 1 view .LVU285
 120:./fs/char_device.c **** 	strscpy(cd->name, name, sizeof(cd->name));
 935              		.loc 1 120 14 is_stmt 0 view .LVU286
 936 00d6 C8F80C70 		str	r7, [r8, #12]
 121:./fs/char_device.c **** 
 937              		.loc 1 121 2 is_stmt 1 view .LVU287
 938 00da 4022     		movs	r2, #64
 939 00dc 4946     		mov	r1, r9
 940 00de 08F11000 		add	r0, r8, #16
 941 00e2 FFF7FEFF 		bl	sized_strscpy
 942              	.LVL86:
 123:./fs/char_device.c **** 		cd->next = curr;
 943              		.loc 1 123 2 view .LVU288
 123:./fs/char_device.c **** 		cd->next = curr;
 944              		.loc 1 123 5 is_stmt 0 view .LVU289
 945 00e6 BBF1000F 		cmp	fp, #0
 946 00ea 06D0     		beq	.L77
 127:./fs/char_device.c **** 		prev->next = cd;
 947              		.loc 1 127 3 is_stmt 1 view .LVU290
 127:./fs/char_device.c **** 		prev->next = cd;
 948              		.loc 1 127 18 is_stmt 0 view .LVU291
 949 00ec DBF80030 		ldr	r3, [fp]
 127:./fs/char_device.c **** 		prev->next = cd;
 950              		.loc 1 127 12 view .LVU292
 951 00f0 C8F80030 		str	r3, [r8]
 128:./fs/char_device.c **** 	}
 952              		.loc 1 128 3 is_stmt 1 view .LVU293
 128:./fs/char_device.c **** 	}
 953              		.loc 1 128 14 is_stmt 0 view .LVU294
 954 00f4 CBF80080 		str	r8, [fp]
 955 00f8 C0E7     		b	.L59
 956              	.L77:
ARM GAS  /tmp/ccZE4dRO.s 			page 38


 124:./fs/char_device.c **** 		chrdevs[i] = cd;
 957              		.loc 1 124 3 is_stmt 1 view .LVU295
 124:./fs/char_device.c **** 		chrdevs[i] = cd;
 958              		.loc 1 124 12 is_stmt 0 view .LVU296
 959 00fa C8F800A0 		str	r10, [r8]
 125:./fs/char_device.c **** 	} else {
 960              		.loc 1 125 3 is_stmt 1 view .LVU297
 125:./fs/char_device.c **** 	} else {
 961              		.loc 1 125 14 is_stmt 0 view .LVU298
 962 00fe 044B     		ldr	r3, .L78+4
 963 0100 43F82580 		str	r8, [r3, r5, lsl #2]
 964 0104 BAE7     		b	.L59
 965              	.LVL87:
 966              	.L71:
  86:./fs/char_device.c **** 
 967              		.loc 1 86 10 view .LVU299
 968 0106 6FF00B08 		mvn	r8, #11
 969 010a B7E7     		b	.L59
 970              	.L79:
 971              		.align	2
 972              	.L78:
 973 010c 11080402 		.word	33818641
 974 0110 00000000 		.word	chrdevs
 975 0114 00000000 		.word	.LC0
 976 0118 FFFF0F00 		.word	1048575
 977 011c 44000000 		.word	.LC1
 978 0120 AC000000 		.word	.LC2
 979              		.cfi_endproc
 980              	.LFE1037:
 982              		.section	.text.alloc_chrdev_region,"ax",%progbits
 983              		.align	1
 984              		.global	alloc_chrdev_region
 985              		.syntax unified
 986              		.thumb
 987              		.thumb_func
 989              	alloc_chrdev_region:
 990              	.LVL88:
 991              	.LFB1040:
 208:./fs/char_device.c **** struct char_device_struct *cd;
 992              		.loc 1 208 1 is_stmt 1 view -0
 993              		.cfi_startproc
 994              		@ args = 0, pretend = 0, frame = 0
 995              		@ frame_needed = 0, uses_anonymous_args = 0
 208:./fs/char_device.c **** struct char_device_struct *cd;
 996              		.loc 1 208 1 is_stmt 0 view .LVU301
 997 0000 10B5     		push	{r4, lr}
 998              	.LCFI15:
 999              		.cfi_def_cfa_offset 8
 1000              		.cfi_offset 4, -8
 1001              		.cfi_offset 14, -4
 1002 0002 0446     		mov	r4, r0
 209:./fs/char_device.c **** cd = __register_chrdev_region(0, baseminor, count, name);
 1003              		.loc 1 209 1 is_stmt 1 view .LVU302
 210:./fs/char_device.c **** if (IS_ERR(cd))
 1004              		.loc 1 210 1 view .LVU303
 210:./fs/char_device.c **** if (IS_ERR(cd))
 1005              		.loc 1 210 6 is_stmt 0 view .LVU304
ARM GAS  /tmp/ccZE4dRO.s 			page 39


 1006 0004 0020     		movs	r0, #0
 1007              	.LVL89:
 210:./fs/char_device.c **** if (IS_ERR(cd))
 1008              		.loc 1 210 6 view .LVU305
 1009 0006 FFF7FEFF 		bl	__register_chrdev_region
 1010              	.LVL90:
 210:./fs/char_device.c **** if (IS_ERR(cd))
 1011              		.loc 1 210 6 view .LVU306
 1012 000a 0346     		mov	r3, r0
 1013              	.LVL91:
 211:./fs/char_device.c **** return PTR_ERR(cd);
 1014              		.loc 1 211 1 is_stmt 1 view .LVU307
 1015              	.LBB88:
 1016              	.LBI88:
  52:./include/linux/err.h **** }
  53:./include/linux/err.h **** 
  54:./include/linux/err.h **** /* Return the pointer in the percpu address space. */
  55:./include/linux/err.h **** #define ERR_PTR_PCPU(error) ((void __percpu *)(unsigned long)ERR_PTR(error))
  56:./include/linux/err.h **** 
  57:./include/linux/err.h **** /**
  58:./include/linux/err.h ****  * PTR_ERR - Extract the error code from an error pointer.
  59:./include/linux/err.h ****  * @ptr: An error pointer.
  60:./include/linux/err.h ****  * Return: The error code within @ptr.
  61:./include/linux/err.h ****  */
  62:./include/linux/err.h **** static inline long __must_check PTR_ERR(__force const void *ptr)
  63:./include/linux/err.h **** {
  64:./include/linux/err.h **** 	return (long) ptr;
  65:./include/linux/err.h **** }
  66:./include/linux/err.h **** 
  67:./include/linux/err.h **** /* Read an error pointer from the percpu address space. */
  68:./include/linux/err.h **** #define PTR_ERR_PCPU(ptr) (PTR_ERR((const void *)(__force const unsigned long)(ptr)))
  69:./include/linux/err.h **** 
  70:./include/linux/err.h **** /**
  71:./include/linux/err.h ****  * IS_ERR - Detect an error pointer.
  72:./include/linux/err.h ****  * @ptr: The pointer to check.
  73:./include/linux/err.h ****  * Return: true if @ptr is an error pointer, false otherwise.
  74:./include/linux/err.h ****  */
  75:./include/linux/err.h **** static inline bool __must_check IS_ERR(__force const void *ptr)
 1017              		.loc 5 75 33 view .LVU308
 1018              	.LBB89:
  76:./include/linux/err.h **** {
  77:./include/linux/err.h **** 	return IS_ERR_VALUE((unsigned long)ptr);
 1019              		.loc 5 77 2 view .LVU309
 1020              		.loc 5 77 9 is_stmt 0 view .LVU310
 1021 000c 10F5805F 		cmn	r0, #4096
 1022 0010 94BF     		ite	ls
 1023 0012 0020     		movls	r0, #0
 1024              	.LVL92:
 1025              		.loc 5 77 9 view .LVU311
 1026 0014 0120     		movhi	r0, #1
 1027              	.LVL93:
 1028              		.loc 5 77 9 view .LVU312
 1029              	.LBE89:
 1030              	.LBE88:
 211:./fs/char_device.c **** return PTR_ERR(cd);
 1031              		.loc 1 211 4 discriminator 1 view .LVU313
 1032 0016 28B9     		cbnz	r0, .L84
ARM GAS  /tmp/ccZE4dRO.s 			page 40


 213:./fs/char_device.c **** return 0;
 1033              		.loc 1 213 1 is_stmt 1 view .LVU314
 213:./fs/char_device.c **** return 0;
 1034              		.loc 1 213 8 is_stmt 0 view .LVU315
 1035 0018 5A68     		ldr	r2, [r3, #4]
 1036 001a 9B68     		ldr	r3, [r3, #8]
 1037              	.LVL94:
 213:./fs/char_device.c **** return 0;
 1038              		.loc 1 213 8 view .LVU316
 1039 001c 43EA0253 		orr	r3, r3, r2, lsl #20
 213:./fs/char_device.c **** return 0;
 1040              		.loc 1 213 6 view .LVU317
 1041 0020 2360     		str	r3, [r4]
 214:./fs/char_device.c **** }
 1042              		.loc 1 214 1 is_stmt 1 view .LVU318
 1043              	.L80:
 215:./fs/char_device.c **** 
 1044              		.loc 1 215 1 is_stmt 0 view .LVU319
 1045 0022 10BD     		pop	{r4, pc}
 1046              	.LVL95:
 1047              	.L84:
 212:./fs/char_device.c **** *dev = MKDEV(cd->major, cd->baseminor);
 1048              		.loc 1 212 1 is_stmt 1 view .LVU320
 1049              	.LBB90:
 1050              	.LBI90:
  62:./include/linux/err.h **** {
 1051              		.loc 5 62 33 view .LVU321
 1052              	.LBB91:
  64:./include/linux/err.h **** }
 1053              		.loc 5 64 2 view .LVU322
  64:./include/linux/err.h **** }
 1054              		.loc 5 64 9 is_stmt 0 view .LVU323
 1055 0024 1846     		mov	r0, r3
 1056              	.LVL96:
  64:./include/linux/err.h **** }
 1057              		.loc 5 64 9 view .LVU324
 1058              	.LBE91:
 1059              	.LBE90:
 212:./fs/char_device.c **** *dev = MKDEV(cd->major, cd->baseminor);
 1060              		.loc 1 212 8 view .LVU325
 1061 0026 FCE7     		b	.L80
 1062              		.cfi_endproc
 1063              	.LFE1040:
 1065              		.section	.text.register_chrdev_region,"ax",%progbits
 1066              		.align	1
 1067              		.global	register_chrdev_region
 1068              		.syntax unified
 1069              		.thumb
 1070              		.thumb_func
 1072              	register_chrdev_region:
 1073              	.LVL97:
 1074              	.LFB1039:
 171:./fs/char_device.c **** 	struct char_device_struct *cd;
 1075              		.loc 1 171 1 is_stmt 1 view -0
 1076              		.cfi_startproc
 1077              		@ args = 0, pretend = 0, frame = 0
 1078              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccZE4dRO.s 			page 41


 171:./fs/char_device.c **** 	struct char_device_struct *cd;
 1079              		.loc 1 171 1 is_stmt 0 view .LVU327
 1080 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1081              	.LCFI16:
 1082              		.cfi_def_cfa_offset 32
 1083              		.cfi_offset 3, -32
 1084              		.cfi_offset 4, -28
 1085              		.cfi_offset 5, -24
 1086              		.cfi_offset 6, -20
 1087              		.cfi_offset 7, -16
 1088              		.cfi_offset 8, -12
 1089              		.cfi_offset 9, -8
 1090              		.cfi_offset 14, -4
 1091 0004 0546     		mov	r5, r0
 1092 0006 9146     		mov	r9, r2
 172:./fs/char_device.c **** 	dev_t to = from + count;
 1093              		.loc 1 172 2 is_stmt 1 view .LVU328
 173:./fs/char_device.c **** 	dev_t n, next;
 1094              		.loc 1 173 2 view .LVU329
 173:./fs/char_device.c **** 	dev_t n, next;
 1095              		.loc 1 173 8 is_stmt 0 view .LVU330
 1096 0008 00EB0108 		add	r8, r0, r1
 1097              	.LVL98:
 174:./fs/char_device.c **** 
 1098              		.loc 1 174 2 is_stmt 1 view .LVU331
 176:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1099              		.loc 1 176 2 view .LVU332
 176:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1100              		.loc 1 176 9 is_stmt 0 view .LVU333
 1101 000c 0446     		mov	r4, r0
 176:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1102              		.loc 1 176 2 view .LVU334
 1103 000e 0AE0     		b	.L86
 1104              	.LVL99:
 1105              	.L87:
 180:./fs/char_device.c **** 			       next - n, name);
 1106              		.loc 1 180 3 is_stmt 1 view .LVU335
 180:./fs/char_device.c **** 			       next - n, name);
 1107              		.loc 1 180 8 is_stmt 0 view .LVU336
 1108 0010 4B46     		mov	r3, r9
 1109 0012 3A1B     		subs	r2, r7, r4
 1110 0014 C4F31301 		ubfx	r1, r4, #0, #20
 1111 0018 FFF7FEFF 		bl	__register_chrdev_region
 1112              	.LVL100:
 1113 001c 0646     		mov	r6, r0
 1114              	.LVL101:
 182:./fs/char_device.c **** 			goto fail;
 1115              		.loc 1 182 3 is_stmt 1 view .LVU337
 1116              	.LBB92:
 1117              	.LBI92:
  75:./include/linux/err.h **** {
 1118              		.loc 5 75 33 view .LVU338
 1119              	.LBB93:
 1120              		.loc 5 77 2 view .LVU339
 1121              		.loc 5 77 2 is_stmt 0 view .LVU340
 1122              	.LBE93:
 1123              	.LBE92:
ARM GAS  /tmp/ccZE4dRO.s 			page 42


 182:./fs/char_device.c **** 			goto fail;
 1124              		.loc 1 182 6 discriminator 1 view .LVU341
 1125 001e 10F5805F 		cmn	r0, #4096
 1126 0022 18D8     		bhi	.L88
 176:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1127              		.loc 1 176 27 discriminator 2 view .LVU342
 1128 0024 3C46     		mov	r4, r7
 1129              	.LVL102:
 1130              	.L86:
 176:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1131              		.loc 1 176 19 is_stmt 1 discriminator 1 view .LVU343
 1132 0026 4445     		cmp	r4, r8
 1133 0028 07D2     		bcs	.L94
 177:./fs/char_device.c **** 		if (next > to)
 1134              		.loc 1 177 3 view .LVU344
 177:./fs/char_device.c **** 		if (next > to)
 1135              		.loc 1 177 10 is_stmt 0 view .LVU345
 1136 002a 200D     		lsrs	r0, r4, #20
 1137 002c 461C     		adds	r6, r0, #1
 177:./fs/char_device.c **** 		if (next > to)
 1138              		.loc 1 177 8 view .LVU346
 1139 002e 3705     		lsls	r7, r6, #20
 1140              	.LVL103:
 178:./fs/char_device.c **** 			next = to;
 1141              		.loc 1 178 3 is_stmt 1 view .LVU347
 178:./fs/char_device.c **** 			next = to;
 1142              		.loc 1 178 6 is_stmt 0 view .LVU348
 1143 0030 B8EB065F 		cmp	r8, r6, lsl #20
 1144 0034 ECD2     		bcs	.L87
 179:./fs/char_device.c **** 		cd = __register_chrdev_region(MAJOR(n), MINOR(n),
 1145              		.loc 1 179 9 view .LVU349
 1146 0036 4746     		mov	r7, r8
 1147              	.LVL104:
 179:./fs/char_device.c **** 		cd = __register_chrdev_region(MAJOR(n), MINOR(n),
 1148              		.loc 1 179 9 view .LVU350
 1149 0038 EAE7     		b	.L87
 1150              	.LVL105:
 1151              	.L94:
 185:./fs/char_device.c **** fail:
 1152              		.loc 1 185 9 view .LVU351
 1153 003a 0020     		movs	r0, #0
 1154 003c 0EE0     		b	.L85
 1155              	.LVL106:
 1156              	.L91:
 189:./fs/char_device.c **** 		kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));
 1157              		.loc 1 189 3 is_stmt 1 view .LVU352
 189:./fs/char_device.c **** 		kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));
 1158              		.loc 1 189 10 is_stmt 0 view .LVU353
 1159 003e 280D     		lsrs	r0, r5, #20
 1160 0040 421C     		adds	r2, r0, #1
 189:./fs/char_device.c **** 		kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));
 1161              		.loc 1 189 8 view .LVU354
 1162 0042 1705     		lsls	r7, r2, #20
 1163              	.LVL107:
 190:./fs/char_device.c **** 	}
 1164              		.loc 1 190 3 is_stmt 1 view .LVU355
 190:./fs/char_device.c **** 	}
ARM GAS  /tmp/ccZE4dRO.s 			page 43


 1165              		.loc 1 190 9 is_stmt 0 view .LVU356
 1166 0044 C5EB0252 		rsb	r2, r5, r2, lsl #20
 1167 0048 C5F31301 		ubfx	r1, r5, #0, #20
 1168 004c FFF7FEFF 		bl	__unregister_chrdev_region
 1169              	.LVL108:
 1170              	.LBB94:
 1171              	.LBI94:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 1172              		.loc 3 383 20 is_stmt 1 view .LVU357
 1173              	.LBB95:
 384:./include/linux/slab.h **** }
 1174              		.loc 3 384 2 view .LVU358
 1175 0050 FFF7FEFF 		bl	__sfree__
 1176              	.LVL109:
 384:./include/linux/slab.h **** }
 1177              		.loc 3 384 2 is_stmt 0 view .LVU359
 1178              	.LBE95:
 1179              	.LBE94:
 188:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1180              		.loc 1 188 27 is_stmt 1 discriminator 3 view .LVU360
 188:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1181              		.loc 1 188 27 is_stmt 0 discriminator 3 view .LVU361
 1182 0054 3D46     		mov	r5, r7
 1183              	.LVL110:
 1184              	.L88:
 1185              	.LDL1:
 188:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1186              		.loc 1 188 19 is_stmt 1 discriminator 1 view .LVU362
 1187 0056 AC42     		cmp	r4, r5
 1188 0058 F1D8     		bhi	.L91
 192:./fs/char_device.c **** }
 1189              		.loc 1 192 2 view .LVU363
 1190              	.LVL111:
 1191              	.LBB96:
 1192              	.LBI96:
  62:./include/linux/err.h **** {
 1193              		.loc 5 62 33 view .LVU364
 1194              	.LBB97:
  64:./include/linux/err.h **** }
 1195              		.loc 5 64 2 view .LVU365
  64:./include/linux/err.h **** }
 1196              		.loc 5 64 9 is_stmt 0 view .LVU366
 1197 005a 3046     		mov	r0, r6
 1198              	.LVL112:
 1199              	.L85:
  64:./include/linux/err.h **** }
 1200              		.loc 5 64 9 view .LVU367
 1201              	.LBE97:
 1202              	.LBE96:
 193:./fs/char_device.c **** 
 1203              		.loc 1 193 1 view .LVU368
 1204 005c BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 193:./fs/char_device.c **** 
 1205              		.loc 1 193 1 view .LVU369
 1206              		.cfi_endproc
 1207              	.LFE1039:
 1209              		.section	.text.__register_chrdev,"ax",%progbits
ARM GAS  /tmp/ccZE4dRO.s 			page 44


 1210              		.align	1
 1211              		.global	__register_chrdev
 1212              		.syntax unified
 1213              		.thumb
 1214              		.thumb_func
 1216              	__register_chrdev:
 1217              	.LVL113:
 1218              	.LFB1041:
 241:./fs/char_device.c ****     struct char_device_struct *cd;
 1219              		.loc 1 241 1 is_stmt 1 view -0
 1220              		.cfi_startproc
 1221              		@ args = 4, pretend = 0, frame = 0
 1222              		@ frame_needed = 0, uses_anonymous_args = 0
 241:./fs/char_device.c ****     struct char_device_struct *cd;
 1223              		.loc 1 241 1 is_stmt 0 view .LVU371
 1224 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1225              	.LCFI17:
 1226              		.cfi_def_cfa_offset 32
 1227              		.cfi_offset 3, -32
 1228              		.cfi_offset 4, -28
 1229              		.cfi_offset 5, -24
 1230              		.cfi_offset 6, -20
 1231              		.cfi_offset 7, -16
 1232              		.cfi_offset 8, -12
 1233              		.cfi_offset 9, -8
 1234              		.cfi_offset 14, -4
 1235 0004 8046     		mov	r8, r0
 1236 0006 0E46     		mov	r6, r1
 1237 0008 1746     		mov	r7, r2
 1238 000a 089D     		ldr	r5, [sp, #32]
 242:./fs/char_device.c ****     struct cdev *cdev;
 1239              		.loc 1 242 5 is_stmt 1 view .LVU372
 243:./fs/char_device.c ****     int err = -ENOMEM;
 1240              		.loc 1 243 5 view .LVU373
 244:./fs/char_device.c **** 
 1241              		.loc 1 244 5 view .LVU374
 1242              	.LVL114:
 246:./fs/char_device.c ****     if (IS_ERR(cd))
 1243              		.loc 1 246 5 view .LVU375
 246:./fs/char_device.c ****     if (IS_ERR(cd))
 1244              		.loc 1 246 10 is_stmt 0 view .LVU376
 1245 000c FFF7FEFF 		bl	__register_chrdev_region
 1246              	.LVL115:
 246:./fs/char_device.c ****     if (IS_ERR(cd))
 1247              		.loc 1 246 10 view .LVU377
 1248 0010 0446     		mov	r4, r0
 1249              	.LVL116:
 247:./fs/char_device.c ****     return PTR_ERR(cd);
 1250              		.loc 1 247 5 is_stmt 1 view .LVU378
 1251              	.LBB98:
 1252              	.LBI98:
  75:./include/linux/err.h **** {
 1253              		.loc 5 75 33 view .LVU379
 1254              	.LBB99:
 1255              		.loc 5 77 2 view .LVU380
 1256              		.loc 5 77 2 is_stmt 0 view .LVU381
 1257              	.LBE99:
ARM GAS  /tmp/ccZE4dRO.s 			page 45


 1258              	.LBE98:
 247:./fs/char_device.c ****     return PTR_ERR(cd);
 1259              		.loc 1 247 8 discriminator 1 view .LVU382
 1260 0012 10F5805F 		cmn	r0, #4096
 1261 0016 15D8     		bhi	.L101
 250:./fs/char_device.c ****     if (!cdev)
 1262              		.loc 1 250 5 is_stmt 1 view .LVU383
 250:./fs/char_device.c ****     if (!cdev)
 1263              		.loc 1 250 12 is_stmt 0 view .LVU384
 1264 0018 FFF7FEFF 		bl	cdev_alloc
 1265              	.LVL117:
 251:./fs/char_device.c ****     goto out2;
 1266              		.loc 1 251 5 is_stmt 1 view .LVU385
 251:./fs/char_device.c ****     goto out2;
 1267              		.loc 1 251 8 is_stmt 0 view .LVU386
 1268 001c 8146     		mov	r9, r0
 1269 001e 98B1     		cbz	r0, .L99
 254:./fs/char_device.c ****     cdev->ops = fops;
 1270              		.loc 1 254 5 is_stmt 1 view .LVU387
 254:./fs/char_device.c ****     cdev->ops = fops;
 1271              		.loc 1 254 23 is_stmt 0 view .LVU388
 1272 0020 2B68     		ldr	r3, [r5]
 254:./fs/char_device.c ****     cdev->ops = fops;
 1273              		.loc 1 254 17 view .LVU389
 1274 0022 0360     		str	r3, [r0]
 255:./fs/char_device.c ****     // kobject_set_name(&cdev->kobj, "%s", name);
 1275              		.loc 1 255 5 is_stmt 1 view .LVU390
 255:./fs/char_device.c ****     // kobject_set_name(&cdev->kobj, "%s", name);
 1276              		.loc 1 255 15 is_stmt 0 view .LVU391
 1277 0024 4560     		str	r5, [r0, #4]
 259:./fs/char_device.c ****     if (err)
 1278              		.loc 1 259 5 is_stmt 1 view .LVU392
 259:./fs/char_device.c ****     if (err)
 1279              		.loc 1 259 26 is_stmt 0 view .LVU393
 1280 0026 6168     		ldr	r1, [r4, #4]
 259:./fs/char_device.c ****     if (err)
 1281              		.loc 1 259 11 view .LVU394
 1282 0028 3A46     		mov	r2, r7
 1283 002a 46EA0151 		orr	r1, r6, r1, lsl #20
 1284 002e FFF7FEFF 		bl	cdev_add
 1285              	.LVL118:
 260:./fs/char_device.c ****     goto out;
 1286              		.loc 1 260 5 is_stmt 1 view .LVU395
 260:./fs/char_device.c ****     goto out;
 1287              		.loc 1 260 8 is_stmt 0 view .LVU396
 1288 0032 0546     		mov	r5, r0
 1289 0034 50B9     		cbnz	r0, .L98
 263:./fs/char_device.c **** 
 1290              		.loc 1 263 5 is_stmt 1 view .LVU397
 263:./fs/char_device.c **** 
 1291              		.loc 1 263 14 is_stmt 0 view .LVU398
 1292 0036 C4F85090 		str	r9, [r4, #80]
 265:./fs/char_device.c **** out:
 1293              		.loc 1 265 5 is_stmt 1 view .LVU399
 265:./fs/char_device.c **** out:
 1294              		.loc 1 265 22 is_stmt 0 view .LVU400
 1295 003a B8F1000F 		cmp	r8, #0
ARM GAS  /tmp/ccZE4dRO.s 			page 46


 1296 003e 0CD1     		bne	.L95
 265:./fs/char_device.c **** out:
 1297              		.loc 1 265 26 discriminator 1 view .LVU401
 1298 0040 6568     		ldr	r5, [r4, #4]
 1299 0042 0AE0     		b	.L95
 1300              	.LVL119:
 1301              	.L101:
 248:./fs/char_device.c **** 
 1302              		.loc 1 248 5 is_stmt 1 view .LVU402
 1303              	.LBB100:
 1304              	.LBI100:
  62:./include/linux/err.h **** {
 1305              		.loc 5 62 33 view .LVU403
 1306              	.LBB101:
  64:./include/linux/err.h **** }
 1307              		.loc 5 64 2 view .LVU404
  64:./include/linux/err.h **** }
 1308              		.loc 5 64 9 is_stmt 0 view .LVU405
 1309 0044 0546     		mov	r5, r0
 1310              	.LVL120:
  64:./include/linux/err.h **** }
 1311              		.loc 5 64 9 view .LVU406
 1312              	.LBE101:
 1313              	.LBE100:
 248:./fs/char_device.c **** 
 1314              		.loc 1 248 12 view .LVU407
 1315 0046 08E0     		b	.L95
 1316              	.LVL121:
 1317              	.L99:
 244:./fs/char_device.c **** 
 1318              		.loc 1 244 9 view .LVU408
 1319 0048 6FF00B05 		mvn	r5, #11
 1320              	.LVL122:
 1321              	.L98:
 1322              	.LDL2:
 269:./fs/char_device.c ****     return err;
 1323              		.loc 1 269 5 is_stmt 1 view .LVU409
 269:./fs/char_device.c ****     return err;
 1324              		.loc 1 269 11 is_stmt 0 view .LVU410
 1325 004c 3A46     		mov	r2, r7
 1326 004e 3146     		mov	r1, r6
 1327 0050 6068     		ldr	r0, [r4, #4]
 1328 0052 FFF7FEFF 		bl	__unregister_chrdev_region
 1329              	.LVL123:
 1330              	.LBB102:
 1331              	.LBI102:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 1332              		.loc 3 383 20 is_stmt 1 view .LVU411
 1333              	.LBB103:
 384:./include/linux/slab.h **** }
 1334              		.loc 3 384 2 view .LVU412
 1335 0056 FFF7FEFF 		bl	__sfree__
 1336              	.LVL124:
 384:./include/linux/slab.h **** }
 1337              		.loc 3 384 2 is_stmt 0 view .LVU413
 1338              	.LBE103:
 1339              	.LBE102:
ARM GAS  /tmp/ccZE4dRO.s 			page 47


 270:./fs/char_device.c **** }
 1340              		.loc 1 270 5 is_stmt 1 view .LVU414
 1341              	.L95:
 271:./fs/char_device.c **** 
 1342              		.loc 1 271 1 is_stmt 0 view .LVU415
 1343 005a 2846     		mov	r0, r5
 1344 005c BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 271:./fs/char_device.c **** 
 1345              		.loc 1 271 1 view .LVU416
 1346              		.cfi_endproc
 1347              	.LFE1041:
 1349              		.section	.text.unregister_chrdev_region,"ax",%progbits
 1350              		.align	1
 1351              		.global	unregister_chrdev_region
 1352              		.syntax unified
 1353              		.thumb
 1354              		.thumb_func
 1356              	unregister_chrdev_region:
 1357              	.LVL125:
 1358              	.LFB1042:
 283:./fs/char_device.c **** 	dev_t to = from + count;
 1359              		.loc 1 283 1 is_stmt 1 view -0
 1360              		.cfi_startproc
 1361              		@ args = 0, pretend = 0, frame = 0
 1362              		@ frame_needed = 0, uses_anonymous_args = 0
 283:./fs/char_device.c **** 	dev_t to = from + count;
 1363              		.loc 1 283 1 is_stmt 0 view .LVU418
 1364 0000 38B5     		push	{r3, r4, r5, lr}
 1365              	.LCFI18:
 1366              		.cfi_def_cfa_offset 16
 1367              		.cfi_offset 3, -16
 1368              		.cfi_offset 4, -12
 1369              		.cfi_offset 5, -8
 1370              		.cfi_offset 14, -4
 1371 0002 0346     		mov	r3, r0
 284:./fs/char_device.c **** 	dev_t n, next;
 1372              		.loc 1 284 2 is_stmt 1 view .LVU419
 284:./fs/char_device.c **** 	dev_t n, next;
 1373              		.loc 1 284 8 is_stmt 0 view .LVU420
 1374 0004 4518     		adds	r5, r0, r1
 1375              	.LVL126:
 285:./fs/char_device.c **** 
 1376              		.loc 1 285 2 is_stmt 1 view .LVU421
 287:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1377              		.loc 1 287 2 view .LVU422
 287:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1378              		.loc 1 287 2 is_stmt 0 view .LVU423
 1379 0006 07E0     		b	.L103
 1380              	.LVL127:
 1381              	.L104:
 291:./fs/char_device.c **** 	}
 1382              		.loc 1 291 3 is_stmt 1 view .LVU424
 291:./fs/char_device.c **** 	}
 1383              		.loc 1 291 9 is_stmt 0 view .LVU425
 1384 0008 E21A     		subs	r2, r4, r3
 1385 000a C3F31301 		ubfx	r1, r3, #0, #20
 1386 000e FFF7FEFF 		bl	__unregister_chrdev_region
ARM GAS  /tmp/ccZE4dRO.s 			page 48


 1387              	.LVL128:
 1388              	.LBB104:
 1389              	.LBI104:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 1390              		.loc 3 383 20 is_stmt 1 view .LVU426
 1391              	.LBB105:
 384:./include/linux/slab.h **** }
 1392              		.loc 3 384 2 view .LVU427
 1393 0012 FFF7FEFF 		bl	__sfree__
 1394              	.LVL129:
 384:./include/linux/slab.h **** }
 1395              		.loc 3 384 2 is_stmt 0 view .LVU428
 1396              	.LBE105:
 1397              	.LBE104:
 287:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1398              		.loc 1 287 27 is_stmt 1 discriminator 2 view .LVU429
 287:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1399              		.loc 1 287 27 is_stmt 0 discriminator 2 view .LVU430
 1400 0016 2346     		mov	r3, r4
 1401              	.LVL130:
 1402              	.L103:
 287:./fs/char_device.c **** 		next = MKDEV(MAJOR(n)+1, 0);
 1403              		.loc 1 287 19 is_stmt 1 discriminator 1 view .LVU431
 1404 0018 AB42     		cmp	r3, r5
 1405 001a 07D2     		bcs	.L108
 288:./fs/char_device.c **** 		if (next > to)
 1406              		.loc 1 288 3 view .LVU432
 288:./fs/char_device.c **** 		if (next > to)
 1407              		.loc 1 288 10 is_stmt 0 view .LVU433
 1408 001c 180D     		lsrs	r0, r3, #20
 1409 001e 421C     		adds	r2, r0, #1
 288:./fs/char_device.c **** 		if (next > to)
 1410              		.loc 1 288 8 view .LVU434
 1411 0020 1405     		lsls	r4, r2, #20
 1412              	.LVL131:
 289:./fs/char_device.c **** 			next = to;
 1413              		.loc 1 289 3 is_stmt 1 view .LVU435
 289:./fs/char_device.c **** 			next = to;
 1414              		.loc 1 289 6 is_stmt 0 view .LVU436
 1415 0022 B5EB025F 		cmp	r5, r2, lsl #20
 1416 0026 EFD2     		bcs	.L104
 290:./fs/char_device.c **** 		kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));
 1417              		.loc 1 290 9 view .LVU437
 1418 0028 2C46     		mov	r4, r5
 1419              	.LVL132:
 290:./fs/char_device.c **** 		kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));
 1420              		.loc 1 290 9 view .LVU438
 1421 002a EDE7     		b	.L104
 1422              	.LVL133:
 1423              	.L108:
 293:./fs/char_device.c **** 
 1424              		.loc 1 293 1 view .LVU439
 1425 002c 38BD     		pop	{r3, r4, r5, pc}
 293:./fs/char_device.c **** 
 1426              		.loc 1 293 1 view .LVU440
 1427              		.cfi_endproc
 1428              	.LFE1042:
ARM GAS  /tmp/ccZE4dRO.s 			page 49


 1430              		.section	.text.cdev_del,"ax",%progbits
 1431              		.align	1
 1432              		.global	cdev_del
 1433              		.syntax unified
 1434              		.thumb
 1435              		.thumb_func
 1437              	cdev_del:
 1438              	.LVL134:
 1439              	.LFB1048:
 416:./fs/char_device.c ****     kfree(p);
 1440              		.loc 1 416 1 is_stmt 1 view -0
 1441              		.cfi_startproc
 1442              		@ args = 0, pretend = 0, frame = 0
 1443              		@ frame_needed = 0, uses_anonymous_args = 0
 416:./fs/char_device.c ****     kfree(p);
 1444              		.loc 1 416 1 is_stmt 0 view .LVU442
 1445 0000 08B5     		push	{r3, lr}
 1446              	.LCFI19:
 1447              		.cfi_def_cfa_offset 8
 1448              		.cfi_offset 3, -8
 1449              		.cfi_offset 14, -4
 417:./fs/char_device.c ****     // cdev_unmap(p->dev, p->count);
 1450              		.loc 1 417 5 is_stmt 1 view .LVU443
 1451              	.LVL135:
 1452              	.LBB106:
 1453              	.LBI106:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 1454              		.loc 3 383 20 view .LVU444
 1455              	.LBB107:
 384:./include/linux/slab.h **** }
 1456              		.loc 3 384 2 view .LVU445
 1457 0002 FFF7FEFF 		bl	__sfree__
 1458              	.LVL136:
 384:./include/linux/slab.h **** }
 1459              		.loc 3 384 2 is_stmt 0 view .LVU446
 1460              	.LBE107:
 1461              	.LBE106:
 420:./fs/char_device.c **** 
 1462              		.loc 1 420 1 view .LVU447
 1463 0006 08BD     		pop	{r3, pc}
 1464              		.cfi_endproc
 1465              	.LFE1048:
 1467              		.section	.text.__unregister_chrdev,"ax",%progbits
 1468              		.align	1
 1469              		.global	__unregister_chrdev
 1470              		.syntax unified
 1471              		.thumb
 1472              		.thumb_func
 1474              	__unregister_chrdev:
 1475              	.LVL137:
 1476              	.LFB1043:
 308:./fs/char_device.c **** struct char_device_struct *cd;
 1477              		.loc 1 308 1 is_stmt 1 view -0
 1478              		.cfi_startproc
 1479              		@ args = 0, pretend = 0, frame = 0
 1480              		@ frame_needed = 0, uses_anonymous_args = 0
 308:./fs/char_device.c **** struct char_device_struct *cd;
ARM GAS  /tmp/ccZE4dRO.s 			page 50


 1481              		.loc 1 308 1 is_stmt 0 view .LVU449
 1482 0000 10B5     		push	{r4, lr}
 1483              	.LCFI20:
 1484              		.cfi_def_cfa_offset 8
 1485              		.cfi_offset 4, -8
 1486              		.cfi_offset 14, -4
 309:./fs/char_device.c **** 
 1487              		.loc 1 309 1 is_stmt 1 view .LVU450
 311:./fs/char_device.c **** if (cd && cd->cdev)
 1488              		.loc 1 311 1 view .LVU451
 311:./fs/char_device.c **** if (cd && cd->cdev)
 1489              		.loc 1 311 6 is_stmt 0 view .LVU452
 1490 0002 FFF7FEFF 		bl	__unregister_chrdev_region
 1491              	.LVL138:
 312:./fs/char_device.c **** cdev_del(cd->cdev);
 1492              		.loc 1 312 1 is_stmt 1 view .LVU453
 312:./fs/char_device.c **** cdev_del(cd->cdev);
 1493              		.loc 1 312 4 is_stmt 0 view .LVU454
 1494 0006 0446     		mov	r4, r0
 1495 0008 18B1     		cbz	r0, .L112
 312:./fs/char_device.c **** cdev_del(cd->cdev);
 1496              		.loc 1 312 13 discriminator 1 view .LVU455
 1497 000a 006D     		ldr	r0, [r0, #80]
 1498              	.LVL139:
 312:./fs/char_device.c **** cdev_del(cd->cdev);
 1499              		.loc 1 312 8 discriminator 1 view .LVU456
 1500 000c 08B1     		cbz	r0, .L112
 313:./fs/char_device.c **** kfree(cd);
 1501              		.loc 1 313 1 is_stmt 1 view .LVU457
 1502 000e FFF7FEFF 		bl	cdev_del
 1503              	.LVL140:
 1504              	.L112:
 314:./fs/char_device.c **** }
 1505              		.loc 1 314 1 view .LVU458
 1506              	.LBB108:
 1507              	.LBI108:
 383:./include/linux/slab.h **** 	__sfree__((void*)ptr);
 1508              		.loc 3 383 20 view .LVU459
 1509              	.LBB109:
 384:./include/linux/slab.h **** }
 1510              		.loc 3 384 2 view .LVU460
 1511 0012 2046     		mov	r0, r4
 1512 0014 FFF7FEFF 		bl	__sfree__
 1513              	.LVL141:
 384:./include/linux/slab.h **** }
 1514              		.loc 3 384 2 is_stmt 0 view .LVU461
 1515              	.LBE109:
 1516              	.LBE108:
 315:./fs/char_device.c **** 
 1517              		.loc 1 315 1 view .LVU462
 1518 0018 10BD     		pop	{r4, pc}
 315:./fs/char_device.c **** 
 1519              		.loc 1 315 1 view .LVU463
 1520              		.cfi_endproc
 1521              	.LFE1043:
 1523              		.section	.text.cdev_put,"ax",%progbits
 1524              		.align	1
ARM GAS  /tmp/ccZE4dRO.s 			page 51


 1525              		.global	cdev_put
 1526              		.syntax unified
 1527              		.thumb
 1528              		.thumb_func
 1530              	cdev_put:
 1531              	.LVL142:
 1532              	.LFB1044:
 321:./fs/char_device.c **** 	if (p) {
 1533              		.loc 1 321 1 is_stmt 1 view -0
 1534              		.cfi_startproc
 1535              		@ args = 0, pretend = 0, frame = 0
 1536              		@ frame_needed = 0, uses_anonymous_args = 0
 1537              		@ link register save eliminated.
 322:./fs/char_device.c **** 		struct module *owner = p->owner;
 1538              		.loc 1 322 2 view .LVU465
 323:./fs/char_device.c **** 		//kobject_put(&p->kobj);
 1539              		.loc 1 323 3 view .LVU466
 327:./fs/char_device.c **** 
 1540              		.loc 1 327 1 is_stmt 0 view .LVU467
 1541 0000 7047     		bx	lr
 1542              		.cfi_endproc
 1543              	.LFE1044:
 1545              		.section	.rodata.str1.4,"aMS",%progbits,1
 1546              		.align	2
 1547              	.LC3:
 1548 0000 5F5F756E 		.ascii	"__unregister_chrdev\000"
 1548      72656769 
 1548      73746572 
 1548      5F636872 
 1548      64657600 
 1549              		.align	2
 1550              	.LC4:
 1551 0014 00       		.ascii	"\000"
 1552              		.section	.export_table,"aw"
 1553              		.align	2
 1556              	__unregister_chrdev_export_struct:
 1557 0000 00000000 		.word	.LC3
 1558 0004 14000000 		.word	.LC4
 1559 0008 00000000 		.word	__unregister_chrdev
 1560              		.section	.rodata.str1.4
 1561 0015 000000   		.align	2
 1562              	.LC5:
 1563 0018 5F5F7265 		.ascii	"__register_chrdev\000"
 1563      67697374 
 1563      65725F63 
 1563      68726465 
 1563      7600
 1564              		.section	.export_table
 1565              		.align	2
 1568              	__register_chrdev_export_struct:
 1569 000c 18000000 		.word	.LC5
 1570 0010 14000000 		.word	.LC4
 1571 0014 00000000 		.word	__register_chrdev
 1572              		.section	.rodata.str1.4
 1573 002a 0000     		.align	2
 1574              	.LC6:
 1575 002c 63646576 		.ascii	"cdev_add\000"
ARM GAS  /tmp/ccZE4dRO.s 			page 52


 1575      5F616464 
 1575      00
 1576              		.section	.export_table
 1577              		.align	2
 1580              	cdev_add_export_struct:
 1581 0018 2C000000 		.word	.LC6
 1582 001c 14000000 		.word	.LC4
 1583 0020 00000000 		.word	cdev_add
 1584              		.section	.rodata.str1.4
 1585 0035 000000   		.align	2
 1586              	.LC7:
 1587 0038 63646576 		.ascii	"cdev_del\000"
 1587      5F64656C 
 1587      00
 1588              		.section	.export_table
 1589              		.align	2
 1592              	cdev_del_export_struct:
 1593 0024 38000000 		.word	.LC7
 1594 0028 14000000 		.word	.LC4
 1595 002c 00000000 		.word	cdev_del
 1596              		.section	.rodata.str1.4
 1597 0041 000000   		.align	2
 1598              	.LC8:
 1599 0044 63646576 		.ascii	"cdev_alloc\000"
 1599      5F616C6C 
 1599      6F6300
 1600              		.section	.export_table
 1601              		.align	2
 1604              	cdev_alloc_export_struct:
 1605 0030 44000000 		.word	.LC8
 1606 0034 14000000 		.word	.LC4
 1607 0038 00000000 		.word	cdev_alloc
 1608              		.section	.rodata.str1.4
 1609 004f 00       		.align	2
 1610              	.LC9:
 1611 0050 63646576 		.ascii	"cdev_init\000"
 1611      5F696E69 
 1611      7400
 1612              		.section	.export_table
 1613              		.align	2
 1616              	cdev_init_export_struct:
 1617 003c 50000000 		.word	.LC9
 1618 0040 14000000 		.word	.LC4
 1619 0044 00000000 		.word	cdev_init
 1620              		.section	.rodata.str1.4
 1621 005a 0000     		.align	2
 1622              	.LC10:
 1623 005c 616C6C6F 		.ascii	"alloc_chrdev_region\000"
 1623      635F6368 
 1623      72646576 
 1623      5F726567 
 1623      696F6E00 
 1624              		.section	.export_table
 1625              		.align	2
 1628              	alloc_chrdev_region_export_struct:
 1629 0048 5C000000 		.word	.LC10
 1630 004c 14000000 		.word	.LC4
ARM GAS  /tmp/ccZE4dRO.s 			page 53


 1631 0050 00000000 		.word	alloc_chrdev_region
 1632              		.section	.rodata.str1.4
 1633              		.align	2
 1634              	.LC11:
 1635 0070 756E7265 		.ascii	"unregister_chrdev_region\000"
 1635      67697374 
 1635      65725F63 
 1635      68726465 
 1635      765F7265 
 1636              		.section	.export_table
 1637              		.align	2
 1640              	unregister_chrdev_region_export_struct:
 1641 0054 70000000 		.word	.LC11
 1642 0058 14000000 		.word	.LC4
 1643 005c 00000000 		.word	unregister_chrdev_region
 1644              		.section	.rodata.str1.4
 1645 0089 000000   		.align	2
 1646              	.LC12:
 1647 008c 72656769 		.ascii	"register_chrdev_region\000"
 1647      73746572 
 1647      5F636872 
 1647      6465765F 
 1647      72656769 
 1648              		.section	.export_table
 1649              		.align	2
 1652              	register_chrdev_region_export_struct:
 1653 0060 8C000000 		.word	.LC12
 1654 0064 14000000 		.word	.LC4
 1655 0068 00000000 		.word	register_chrdev_region
 1656              		.section	.rodata.str1.4
 1657 00a3 00       		.align	2
 1658              	.LC13:
 1659 00a4 66696E64 		.ascii	"find_chrdev\000"
 1659      5F636872 
 1659      64657600 
 1660              		.section	.export_table
 1661              		.align	2
 1664              	find_chrdev_export_struct:
 1665 006c A4000000 		.word	.LC13
 1666 0070 14000000 		.word	.LC4
 1667 0074 00000000 		.word	find_chrdev
 1668              		.section	.bss.chrdevs,"aw",%nobits
 1669              		.align	2
 1672              	chrdevs:
 1673 0000 00000000 		.space	508
 1673      00000000 
 1673      00000000 
 1673      00000000 
 1673      00000000 
 1674              		.text
 1675              	.Letext0:
 1676              		.file 6 "./include/asm-generic/int-l64.h"
 1677              		.file 7 "./include/asm-generic/posix_types.h"
 1678              		.file 8 "./include/uapi/linux/types.h"
 1679              		.file 9 "./include/linux/types.h"
 1680              		.file 10 "./include/linux/export.h"
 1681              		.file 11 "./include/linux/errseq.h"
ARM GAS  /tmp/ccZE4dRO.s 			page 54


 1682              		.file 12 "./include/linux/time64.h"
 1683              		.file 13 "./arch/arm_m/include/asm/spinlock.h"
 1684              		.file 14 "./include/linux/spinlock_types_raw.h"
 1685              		.file 15 "./include/linux/spinlock_types.h"
 1686              		.file 16 "./include/linux/rbtree_types.h"
 1687              		.file 17 "./include/linux/uidgid_types.h"
 1688              		.file 18 "./include/linux/projid.h"
 1689              		.file 19 "./include/linux/fs.h"
 1690              		.file 20 "./include/linux/mnt_idmapping.h"
 1691              		.file 21 "./include/linux/mutex.h"
 1692              		.file 22 "./include/linux/uio.h"
 1693              		.file 23 "./include/linux/wait.h"
 1694              		.file 24 "./include/linux/xarray.h"
 1695              		.file 25 "./include/linux/migrate_mode.h"
 1696              		.file 26 "./include/linux/rw_hint.h"
 1697              		.file 27 "./include/linux/reciprocal_div.h"
 1698              		.file 28 "./include/linux/mm_type.h"
 1699              		.file 29 "./include/linux/bvec.h"
 1700              		.file 30 "./include/linux/blk_types.h"
 1701              		.file 31 "./include/linux/blkdev.h"
 1702              		.file 32 "./include/linux/bio.h"
 1703              		.file 33 "./include/linux/mempool_super_haper.h"
 1704              		.file 34 "./include/linux/mempool.h"
 1705              		.file 35 "./include/linux/lockdep_types.h"
 1706              		.file 36 "./include/linux/workqueue_types.h"
 1707              		.file 37 "./include/linux/blk-mq.h"
 1708              		.file 38 "./include/linux/dcache.h"
 1709              		.file 39 "./include/uapi/linux/pr.h"
 1710              		.file 40 "./include/linux/pr.h"
 1711              		.file 41 "./include/linux/hdreg.h"
 1712              		.file 42 "./include/linux/lockref.h"
 1713              		.file 43 "./include/linux/path.h"
 1714              		.file 44 "./include/linux/statfs.h"
 1715              		.file 45 "./include/linux/stat.h"
 1716              		.file 46 "./include/linux/gfp_types.h"
 1717              		.file 47 "./include/linux/cdev.h"
 1718              		.file 48 "./arch/arm_m/include/asm/string.h"
 1719              		.file 49 "./include/linux/printk.h"
 1720              		.file 50 "<built-in>"
ARM GAS  /tmp/ccZE4dRO.s 			page 55


DEFINED SYMBOLS
                            *ABS*:00000000 char_device.c
     /tmp/ccZE4dRO.s:21     .text.sized_strscpy:00000000 $t
     /tmp/ccZE4dRO.s:26     .text.sized_strscpy:00000000 sized_strscpy
     /tmp/ccZE4dRO.s:104    .text.find_dynamic_major:00000000 $t
     /tmp/ccZE4dRO.s:109    .text.find_dynamic_major:00000000 find_dynamic_major
     /tmp/ccZE4dRO.s:190    .text.find_dynamic_major:00000040 $d
     /tmp/ccZE4dRO.s:1672   .bss.chrdevs:00000000 chrdevs
     /tmp/ccZE4dRO.s:196    .text.__unregister_chrdev_region:00000000 $t
     /tmp/ccZE4dRO.s:201    .text.__unregister_chrdev_region:00000000 __unregister_chrdev_region
     /tmp/ccZE4dRO.s:316    .text.__unregister_chrdev_region:00000058 $d
     /tmp/ccZE4dRO.s:322    .text.cdev_add:00000000 $t
     /tmp/ccZE4dRO.s:328    .text.cdev_add:00000000 cdev_add
     /tmp/ccZE4dRO.s:353    .text.find_chrdev:00000000 $t
     /tmp/ccZE4dRO.s:359    .text.find_chrdev:00000000 find_chrdev
     /tmp/ccZE4dRO.s:479    .text.find_chrdev:00000058 $d
     /tmp/ccZE4dRO.s:485    .text.kzalloc:00000000 $t
     /tmp/ccZE4dRO.s:490    .text.kzalloc:00000000 kzalloc
     /tmp/ccZE4dRO.s:528    .text.cdev_alloc:00000000 $t
     /tmp/ccZE4dRO.s:534    .text.cdev_alloc:00000000 cdev_alloc
     /tmp/ccZE4dRO.s:603    .text.cdev_init:00000000 $t
     /tmp/ccZE4dRO.s:609    .text.cdev_init:00000000 cdev_init
     /tmp/ccZE4dRO.s:669    .rodata.__register_chrdev_region.str1.4:00000000 $d
     /tmp/ccZE4dRO.s:683    .text.__register_chrdev_region:00000000 $t
     /tmp/ccZE4dRO.s:688    .text.__register_chrdev_region:00000000 __register_chrdev_region
     /tmp/ccZE4dRO.s:973    .text.__register_chrdev_region:0000010c $d
     /tmp/ccZE4dRO.s:983    .text.alloc_chrdev_region:00000000 $t
     /tmp/ccZE4dRO.s:989    .text.alloc_chrdev_region:00000000 alloc_chrdev_region
     /tmp/ccZE4dRO.s:1066   .text.register_chrdev_region:00000000 $t
     /tmp/ccZE4dRO.s:1072   .text.register_chrdev_region:00000000 register_chrdev_region
     /tmp/ccZE4dRO.s:1210   .text.__register_chrdev:00000000 $t
     /tmp/ccZE4dRO.s:1216   .text.__register_chrdev:00000000 __register_chrdev
     /tmp/ccZE4dRO.s:1350   .text.unregister_chrdev_region:00000000 $t
     /tmp/ccZE4dRO.s:1356   .text.unregister_chrdev_region:00000000 unregister_chrdev_region
     /tmp/ccZE4dRO.s:1431   .text.cdev_del:00000000 $t
     /tmp/ccZE4dRO.s:1437   .text.cdev_del:00000000 cdev_del
     /tmp/ccZE4dRO.s:1468   .text.__unregister_chrdev:00000000 $t
     /tmp/ccZE4dRO.s:1474   .text.__unregister_chrdev:00000000 __unregister_chrdev
     /tmp/ccZE4dRO.s:1524   .text.cdev_put:00000000 $t
     /tmp/ccZE4dRO.s:1530   .text.cdev_put:00000000 cdev_put
     /tmp/ccZE4dRO.s:1546   .rodata.str1.4:00000000 $d
     /tmp/ccZE4dRO.s:1553   .export_table:00000000 $d
     /tmp/ccZE4dRO.s:1556   .export_table:00000000 __unregister_chrdev_export_struct
     /tmp/ccZE4dRO.s:1568   .export_table:0000000c __register_chrdev_export_struct
     /tmp/ccZE4dRO.s:1580   .export_table:00000018 cdev_add_export_struct
     /tmp/ccZE4dRO.s:1592   .export_table:00000024 cdev_del_export_struct
     /tmp/ccZE4dRO.s:1604   .export_table:00000030 cdev_alloc_export_struct
     /tmp/ccZE4dRO.s:1616   .export_table:0000003c cdev_init_export_struct
     /tmp/ccZE4dRO.s:1628   .export_table:00000048 alloc_chrdev_region_export_struct
     /tmp/ccZE4dRO.s:1640   .export_table:00000054 unregister_chrdev_region_export_struct
     /tmp/ccZE4dRO.s:1652   .export_table:00000060 register_chrdev_region_export_struct
     /tmp/ccZE4dRO.s:1664   .export_table:0000006c find_chrdev_export_struct
     /tmp/ccZE4dRO.s:1669   .bss.chrdevs:00000000 $d

UNDEFINED SYMBOLS
__smalloc__
memset
ARM GAS  /tmp/ccZE4dRO.s 			page 56


printk
__sfree__
